%%
%% Copyright 1994-2023 The MathWorks, Inc.
%%
%% Abstract:
%%   This TLC library file contains the general purpose utility functions
%%   for accessing data type information.
%%

%if EXISTS(::_DTYPELIB_) == 0
%assign ::_DTYPELIB_ = 1

%include "autosarsup.tlc"
%include "utillib.tlc"
%include "blkio_api.tlc"
%include "dtype_api.tlc"
%include "records_api.tlc"

%if EXISTS(DSP32)
    %assign SizeOfDouble = 4
%else
    %assign SizeOfDouble = 8
%endif

%assign int32MaxValue = 2147483647
%assign int32MinValue = -int32MaxValue - 1

%<LibAddToCompiledModel("SizeOfDouble", SizeOfDouble)>

%% populate the empty SymbolicWidth and SymbolicDimension fields
%% using the fcns generated in file CGTypes_SymbolicWidth.tlc
%if ::CompiledModel.CGTypes.IncludeSymbolicWidth
    %%
    %include "CGTypes_SymbolicWidth.tlc"
%endif
%% done populating the SymbolicWidth and SymbolicDimension

%function SLibCoderTypesBaseName() void
    %return ::CompiledModel.CoderTypesInfo.BaseName
%endfunction

%function SLibCoderModelReferenceTypesBaseName() void
    %return ::CompiledModel.CoderTypesInfo.ModelReferenceTypesBaseName
%endfunction

%function SLibCoderBuiltinTypeidTypesBaseName() void
    %return ::CompiledModel.CoderTypesInfo.BuiltinTypeidTypesBaseName
%endfunction

%function SLibCoderMultiwordTypesBaseName() void
    %return ::CompiledModel.CoderTypesInfo.MultiwordTypesBaseName
%endfunction

%function SLibCoderZerocrossingTypesBaseName() void
    %return ::CompiledModel.CoderTypesInfo.ZerocrossingTypesBaseName
%endfunction

%function SLibCoderHalfTypeHdrBaseName() void
    %return ::CompiledModel.CoderTypesInfo.HalfTypeHdrBaseName
%endfunction

%function SLibCoderHalfTypeSrcBaseName() void
    %return ::CompiledModel.CoderTypesInfo.HalfTypeSrcBaseName
%endfunction

%function SLibCoderImageTypeHdrBaseName() void
    %return ::CompiledModel.CoderTypesInfo.ImageTypeHdrBaseName
%endfunction

%function SLibCoderImageTypeSrcBaseName() void
    %return ::CompiledModel.CoderTypesInfo.ImageTypeSrcBaseName
%endfunction

%function SLibCoderBasicTypesFilenames() void
    %return CGMODEL_ACCESS("FileRepository.getHeadersForBasicTypes")
%endfunction

%function SLibCoderModelReferenceTypesFilename() void
    %return ::CompiledModel.CoderTypesInfo.ModelReferenceTypesFileName
%endfunction

%function SLibCoderBuiltinTypeidTypesFilename() void
    %return ::CompiledModel.CoderTypesInfo.BuiltinTypeidTypesFileName
%endfunction

%function SLibCoderMultiwordTypesFilename() void
    %return ::CompiledModel.CoderTypesInfo.MultiwordTypesFileName
%endfunction

%function SLibCoderReplacementIntTypesFilename() void
    %return ::CompiledModel.CoderTypesInfo.ReplacementIntTypesFileName
%endfunction

%function SLibCoderReplacementBoolTypeFilename() void
    %return ::CompiledModel.CoderTypesInfo.ReplacementBoolTypeFileName
%endfunction

%function SLibCoderReplacementOtherTypesFilename() void
    %return ::CompiledModel.CoderTypesInfo.ReplacementOtherTypesFileName
%endfunction

%function SLibCoderZerocrossingTypesFilename() void
    %return ::CompiledModel.CoderTypesInfo.ZerocrossingTypesFileName
%endfunction

%function SLibCoderComplexTypesFilename() void
    %return ::CompiledModel.CoderTypesInfo.ComplexTypesFileName
%endfunction

%function SLibCoderHalfTypeHdrFilename() void
    %return ::CompiledModel.CoderTypesInfo.HalfTypeHdrFileName
%endfunction

%function SLibCoderImageTypeHdrFilename() void
    %return ::CompiledModel.CoderTypesInfo.ImageTypeHdrFileName
%endfunction

%function SLibCoderImageTypeSrcFilename() void
    %return ::CompiledModel.CoderTypesInfo.ImageTypeSrcFileName
%endfunction

%function SLibCoderRtwtypesFilePath() void
    %return ::CompiledModel.CoderTypesInfo.RtwtypesFilePath
%endfunction

%function SLibCoderModelReferenceTypesFilePath() void
    %return ::CompiledModel.CoderTypesInfo.ModelReferenceTypesFilePath
%endfunction

%function SLibCoderBuiltinTypeidTypesFilePath() void
    %return ::CompiledModel.CoderTypesInfo.BuiltinTypeidTypesFilePath
%endfunction

%function SLibCoderMultiwordTypesFilePath() void
    %return ::CompiledModel.CoderTypesInfo.MultiwordTypesFilePath
%endfunction

%function SLibCoderReplacementIntTypesFilePath() void
    %return ::CompiledModel.CoderTypesInfo.ReplacementIntTypesFilePath
%endfunction

%function SLibCoderReplacementBoolTypeFilePath() void
    %return ::CompiledModel.CoderTypesInfo.ReplacementBoolTypeFilePath
%endfunction

%function SLibCoderReplacementOtherTypesFilePath() void
    %return ::CompiledModel.CoderTypesInfo.ReplacementOtherTypesFilePath
%endfunction

%function SLibCoderZerocrossingTypesFilePath() void
    %return ::CompiledModel.CoderTypesInfo.ZerocrossingTypesFilePath
%endfunction

%function SLibCoderComplexTypesFilePath() void
    %return ::CompiledModel.CoderTypesInfo.ComplexTypesFilePath
%endfunction

%function SLibCoderHalfTypeHdrFilePath() void
    %return ::CompiledModel.CoderTypesInfo.HalfTypeHdrFilePath
%endfunction

%function SLibCoderHalfTypeSrcFilePath() void
    %return ::CompiledModel.CoderTypesInfo.HalfTypeSrcFilePath
%endfunction

%function SLibCoderImageTypeHdrFilePath() void
    %return ::CompiledModel.CoderTypesInfo.ImageTypeHdrFilePath
%endfunction

%function SLibCoderImageTypeSrcFilePath() void
    %return ::CompiledModel.CoderTypesInfo.ImageTypeSrcFilePath
%endfunction

%function SLibPotentialCoderTypesBaseNames() void
    %return ::CompiledModel.CoderTypesInfo.PotentialBaseNames
%endfunction

%function FcnUsedCoderTypes(coderTypesFile) void
    %assign usedCoderTypesFiles = SLibUsedCoderTypesFileNames()
    %foreach fIdx = SIZE(usedCoderTypesFiles, 1)
        %assign usedCoderTypesFile = usedCoderTypesFiles[fIdx]
        %if usedCoderTypesFile == coderTypesFile
            %return TLC_TRUE
        %endif
    %endforeach
    %return TLC_FALSE
%endfunction

%function SLibUsedMultiwordTypes() void
    %return FcnUsedCoderTypes(SLibCoderMultiwordTypesFilename())
%endfunction

%function SLibUsedReplacementIntTypes() void
    %return FcnUsedCoderTypes(SLibCoderReplacementIntTypesFilename())
%endfunction

%function SLibUsedReplacementBoolType() void
    %return FcnUsedCoderTypes(SLibCoderReplacementBoolTypeFilename())
%endfunction

%function SLibUsedReplacementOtherTypes() void
    %return FcnUsedCoderTypes(SLibCoderReplacementOtherTypesFilename())
%endfunction

%function SLibUsedZerocrossingTypes() void
    %return FcnUsedCoderTypes(SLibCoderZerocrossingTypesFilename())
%endfunction

%function SLibUsedHalfPrecisionTypes() void
    %return FcnUsedCoderTypes(SLibCoderHalfTypeHdrFilename())
%endfunction

%function SLibUsedBuiltinTypeidTypes() void
    %return FcnUsedCoderTypes(SLibCoderBuiltinTypeidTypesFilename())
%endfunction

%function SLibUsedImageTypes() void
    %return FcnUsedCoderTypes(SLibCoderImageTypeHdrFilename())
%endfunction

%function SLibUsedModelReferenceTypes() void
    %return FcnUsedCoderTypes(SLibCoderModelReferenceTypesFilename())
%endfunction

%function SLibUsedCoderTypesFileNames() void
    %return ::CompiledModel.CoderTypesInfo.UsedFilenames
%endfunction

%function SLibUsedNumericCoderTypesFilenames() void
    %return ::CompiledModel.CoderTypesInfo.UsedNumericFilenames
%endfunction

%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%%
%function SLibIncludeUsedCoderTypesFilenames() void
    %assign coderTypesFiles = SLibUsedCoderTypesFileNames()
    %openfile buffer
    %foreach fIdx = SIZE(coderTypesFiles,1)
        %assign incFileName = "%<coderTypesFiles[fIdx]>"
        %if incFileName[0] == "<"
            #include %<incFileName>
        %else
            #include "%<incFileName>"
        %endif
    %endforeach
    %closefile buffer
    %return buffer
%endfunction

%function SLibIncludeUsedNumericCoderTypesFilenames() void
    %assign coderTypesFiles = SLibUsedNumericCoderTypesFilenames()
    %openfile buffer
    %foreach fIdx = SIZE(coderTypesFiles,1)
        #include "%<coderTypesFiles[fIdx]>"
    %endforeach
    %closefile buffer
    %return buffer
%endfunction

%% Function: FcnGenerateStructElementOffsetString ==================================================
%% Abstract:
%%   Utility function for constructing the string corresponding to the
%%   element's offset (struct/bus)
%%
%function FcnGenerateStructElementOffsetString(offsetList) void
    %% Initialize the output string
    %assign fullOffset = ""

    %% The first element in the list is a numeric value, the others are strings
    %% like "value*loopcounter"
    %assign sep = ""
    %foreach idxOffset = SIZE(offsetList,0)-1
        %assign fullOffset =  fullOffset + sep + offsetList[idxOffset+1][0]
        %assign sep = " + "
    %endforeach

    %% Convert the first element to a string
    %assign optOffset = ISEQUAL(offsetList[0][0],0) ? "" : "%<offsetList[0][0]>"

    %% Construct the full offset string (value1*loopcounter1 +...+ valueN*loopcounterN + constant)
    %if WHITE_SPACE(fullOffset)
        %assign fullOffset = WHITE_SPACE(optOffset) ? "" : "%<optOffset>"
    %else
        %assign fullOffset = WHITE_SPACE(optOffset) ? "%<fullOffset>" : "%<fullOffset> + %<optOffset>"
    %endif

    %return fullOffset
%endfunction

%% Function: SLibAssignSLStructToUserStructND ======================================================
%% Abstract:
%%   Marshall a Simulink's array of structures to an user's array of structures.
%%
%function SLibAssignSLStructToUserStructND(dTypeId, width, dst, srcAddr, offsetList, level, isCplx) Output
    %assign intType = LibGetDataTypeNameFromId(::CompiledModel.tSS_INTEGER)
    %assign dataTypeSize = LibGetDataTypeSLSizeFromId(dTypeId)
    %assign isWidthAnExpression = TYPE(width)=="String"
    %%
    %if isCplx
        %% Lists for holding real&imag offsets
        %assign reOffsetList = Matrix(1,1) [0]
        %assign imOffsetList = Matrix(1,1) [0]
    %endif
    %%
    %% Add a loop and correct offset for non-scalar struct
    %if isWidthAnExpression || ISEQUAL(width,1)==TLC_FALSE
        %assign loopCounter = "i%<level>"
        %assign dtName = isCplx ? LibGetDataTypeComplexNameFromId(dTypeId) : LibGetDataTypeNameFromId(dTypeId)
        %assign dst = "((" + dtName + "*)" + dst + ")[%<loopCounter>]"
        %if isCplx
            %% Real part read every 2*i
            %assign loopOffset = ISEQUAL(dataTypeSize,1) ? "2*%<loopCounter>" : "%<dataTypeSize>*(2*%<loopCounter>)"
            %assign reOffsetList = offsetList + ["%<loopOffset>"]
            %% Imag part read every 2*i+1
            %assign loopOffset = ISEQUAL(dataTypeSize,1) ? "2*%<loopCounter> + 1" : "%<dataTypeSize>*(2*%<loopCounter> + 1)"
            %assign imOffsetList = offsetList + ["%<loopOffset>"]
        %else
            %assign loopOffset = ISEQUAL(dataTypeSize,1) ? "%<loopCounter>" : "%<dataTypeSize>*%<loopCounter>"
            %assign offsetList = offsetList + ["%<loopOffset>"]
        %endif
        {
            %% TopTester: test/toolbox/rtw/targets/ert/ndindexing/bus/tInlinedSFcn.m
            %<intType> %<loopCounter>;
            for (%<loopCounter> = 0; %<loopCounter> < %<width>; %<loopCounter>++) {
                %assign level = level + 1
    %else
        %if isCplx
            %assign reOffsetList = offsetList
            %assign imOffsetList = offsetList + ["%<dataTypeSize>"]
        %endif
    %endif
    %%
    %foreach idxE = LibDataTypeNumElements(dTypeId)
        %assign eName = LibDataTypeElementName(dTypeId, idxE)
        %assign eDTypeId = LibGetDataTypeIdAliasedThruToFromId(LibDataTypeElementDataTypeId(dTypeId, idxE))
        %assign eWidth = LibDataTypeElementWidth(dTypeId, idxE)
        %assign eOffset = LibDataTypeElementOffset(dTypeId, idxE)
        %if !isCplx
            %% Update the offset list for reading this element
            %assign eOffsetList = offsetList
            %assign eOffsetList[0][0] = eOffsetList[0][0] + eOffset
        %else
            %% Update the offset list for reading the real part of this element
            %assign eReOffsetList = reOffsetList
            %assign eReOffsetList[0][0] = eReOffsetList[0][0] + eOffset
            %% Update the offset list for reading the imag part of this element
            %assign eImOffsetList = imOffsetList
            %assign eImOffsetList[0][0] = eImOffsetList[0][0] + eOffset
        %endif
        %%
        %% This element can be an array of complex structures only if it
        %% corresponds to a multi-word fixed-point array. Complex Simulink.Bus
        %% are not yet supported.
        %assign eIsCplx = LibDataTypeElementIsComplex(dTypeId, idxE)

        %% there is no nested complex data type.
        %assert !(isCplx && eIsCplx)

        %if !isCplx
            %assign eDst = dst+"."+eName
        %else
            %assign eDstReal = dst+"."+tRealPart+"."+eName
            %assign eDstImag = dst+"."+tImagPart+"."+eName
        %endif
        %%
        %if LibIsStructDataType(eDTypeId)
            %if !isCplx
                %% Recurse for marshalling sub-structure element
                %<SLibAssignSLStructToUserStructND(eDTypeId, eWidth, ...
                    eDst, srcAddr, eOffsetList, level, eIsCplx)>\
            %else
                %% Recurse for marshalling sub-structure element for the real part
                %% of the root structure
                %<SLibAssignSLStructToUserStructND(eDTypeId, eWidth,...
                    eDstReal, srcAddr, eReOffsetList, level, eIsCplx)>\
                %% Recurse for marshalling sub-structure element for the imag part
                %% of the root structure
                %<SLibAssignSLStructToUserStructND(eDTypeId, eWidth, ...
                    eDstImag, srcAddr, eImOffsetList, level, eIsCplx)>\
            %endif
        %else
            %assign eDTypeSize = LibGetDataTypeSLSizeFromId(eDTypeId)
            %assign optAddr = ISEQUAL(eWidth,1) ? "&" : ""
            %if eIsCplx
                %assign eWidth = eWidth*2
            %endif
            %if !isCplx
                %% Generate the full string corresponding to the element's offset
                %% and add the string to the the Src address
                %assign eOffsetStr = FcnGenerateStructElementOffsetString(eOffsetList)
                %assign eSrc = WHITE_SPACE(eOffsetStr) ? srcAddr : srcAddr +" + %<eOffsetStr>"
            %else
                %% Generate the full string corresponding to the element's offset
                %% for the real part of the root structure and add the string to
                %% the real part of the root structure
                %assign eOffsetStr = FcnGenerateStructElementOffsetString(eReOffsetList)
                %assign eSrcReal = WHITE_SPACE(eOffsetStr) ? srcAddr : srcAddr +" + %<eOffsetStr>"
                %% Do the same as previously but for the imag part
                %assign eOffsetStr = FcnGenerateStructElementOffsetString(eImOffsetList)
                %assign eSrcImag = WHITE_SPACE(eOffsetStr) ? srcAddr : srcAddr +" + %<eOffsetStr>"
            %endif
            %if ISEQUAL(eWidth,1)
                %% Scalar structure element
                %if !isCplx
                    %% Simple assignment
                    %<eDst> = *((%<LibGetDataTypeNameFromId(eDTypeId)>*)(%<eSrc>));
                %else
                    %% Real part assignment
                    %<eDstReal> = *((%<LibGetDataTypeNameFromId(eDTypeId)>*)(%<eSrcReal>));
                    %% Imag part assignment
                    %<eDstImag> = *((%<LibGetDataTypeNameFromId(eDTypeId)>*)(%<eSrcImag>));
                %endif
            %else
                %% Wide structure element
                %if !isCplx
                    (void) %<LibGenMemFcnCall("memcpy", "%<optAddr>%<eDst>", ...
                        "%<eSrc>", "%<eWidth*eDTypeSize>")>;
                %else
                    (void) %<LibGenMemFcnCall("memcpy", "%<optAddr>%<eDstReal>",...
                        "%<eSrcReal>", "%<eWidth*eDTypeSize>")>;
                    (void) %<LibGenMemFcnCall("memcpy", "%<optAddr>%<eDstImag>", ...
                        "%<eSrcImag>", "%<eWidth*eDTypeSize>")>;
                %endif
            %endif
        %endif
    %endforeach
    %if isWidthAnExpression || ISEQUAL(width,1)==TLC_FALSE
        %% Close the block and foor-loop statements
    }
}
    %endif

%endfunction


%% Function: SLibAssignUserStructToSLStructND ======================================================
%% Abstract:
%%   Marshall an user's array of structures to a Simulink's array of structures.
%%
%function SLibAssignUserStructToSLStructND(dTypeId, width, dstAddr, src, offsetList, level, isCplx) Output
    %assign intType = LibGetDataTypeNameFromId(::CompiledModel.tSS_INTEGER)
    %assign dataTypeSize = LibGetDataTypeSLSizeFromId(dTypeId)
    %assign isWidthAnExpression = TYPE(width)=="String"
    %%
    %if isCplx
        %% Lists for holding real&imag offsets
        %assign reOffsetList = Matrix(1,1) [0]
        %assign imOffsetList = Matrix(1,1) [0]
    %endif
    %%
    %% Add a loop and correct offset for non-scalar struct
    %if isWidthAnExpression || ISEQUAL(width,1)==TLC_FALSE
        %assign loopCounter = "i%<level>"
        %assign dtName = isCplx ? LibGetDataTypeComplexNameFromId(dTypeId) : LibGetDataTypeNameFromId(dTypeId)
        %assign src = "((" + dtName + "*)" + src + ")[%<loopCounter>]"
        %if isCplx
            %% Real part read every 2*i
            %assign loopOffset = ISEQUAL(dataTypeSize,1) ? "2*%<loopCounter>" : "%<dataTypeSize>*(2*%<loopCounter>)"
            %assign reOffsetList = offsetList + ["%<loopOffset>"]
            %% Imag part read every 2*i+1
            %assign loopOffset = ISEQUAL(dataTypeSize,1) ? "2*%<loopCounter> + 1" : "%<dataTypeSize>*(2*%<loopCounter> + 1)"
            %assign imOffsetList = offsetList + ["%<loopOffset>"]
        %else
            %assign loopOffset = ISEQUAL(dataTypeSize,1) ? "%<loopCounter>" : "%<dataTypeSize>*%<loopCounter>"
            %assign offsetList = offsetList + ["%<loopOffset>"]
        %endif
        {
            %<intType> %<loopCounter>;
            for (%<loopCounter> = 0; %<loopCounter> < %<width>; %<loopCounter>++) {
                %assign level = level + 1
    %else
        %if isCplx
            %assign reOffsetList = offsetList
            %assign imOffsetList = offsetList + ["%<dataTypeSize>"]
        %endif
    %endif
    %%
    %foreach idxE = LibDataTypeNumElements(dTypeId)
        %assign eName = LibDataTypeElementName(dTypeId, idxE)
        %assign eDTypeId = LibGetDataTypeIdAliasedThruToFromId(LibDataTypeElementDataTypeId(dTypeId, idxE))
        %assign eWidth = LibDataTypeElementWidth(dTypeId, idxE)
        %assign eOffset = LibDataTypeElementOffset(dTypeId, idxE)
        %if !isCplx
            %% Update the offset list for reading this element
            %assign eOffsetList = offsetList
            %assign eOffsetList[0][0] = eOffsetList[0][0] + eOffset
        %else
            %% Update the offset list for reading the real part of this element
            %assign eReOffsetList = reOffsetList
            %assign eReOffsetList[0][0] = eReOffsetList[0][0] + eOffset
            %% Update the offset list for reading the imag part of this element
            %assign eImOffsetList = imOffsetList
            %assign eImOffsetList[0][0] = eImOffsetList[0][0] + eOffset
        %endif
        %%
        %% This element can be an array of complex structures only if it
        %% corresponds to a multi-word fixed-point array.Complex Simulink.Bus
        %% are not yet supported.
        %assign eIsCplx = LibDataTypeElementIsComplex(dTypeId, idxE)
        %if !isCplx
            %assign eSrc = src+"."+eName
        %else
            %assign eSrcReal = src+"."+tRealPart+"."+eName
            %assign eSrcImag = src+"."+tImagPart+"."+eName
        %endif
        %%
        %if LibIsStructDataType(eDTypeId)
            %if !isCplx
                %% Recurse for marshalling sub-structure element
                %<SLibAssignUserStructToSLStructND(eDTypeId, eWidth, dstAddr, ...
                    eSrc, eOffsetList, level, eIsCplx)>\
            %else
                %% Recurse for marshalling sub-structure element for the real part
                %% of the root structure
                %<SLibAssignUserStructToSLStructND(eDTypeId, eWidth, dstAddr, ...
                    eSrcReal, eReOffsetList, level, eIsCplx)>\
                %% Recurse for marshalling sub-structure element for the imag part
                %% of the root structure
                %<SLibAssignUserStructToSLStructND(eDTypeId, eWidth, dstAddr, ...
                    eSrcImag, eImOffsetList, level, eIsCplx)>\
            %endif
        %else
            %assign eDTypeSize = LibGetDataTypeSLSizeFromId(eDTypeId)
            %assign optAddr = ISEQUAL(eWidth,1) ? "&" : ""
            %if eIsCplx
                %assign eWidth = eWidth*2
            %endif
            %if !isCplx
                %% Generate the full string corresponding to the element's offset
                %% and add the string to the the Dst address
                %assign eOffsetStr = FcnGenerateStructElementOffsetString(eOffsetList)
                %assign eDst = WHITE_SPACE(eOffsetStr) ? dstAddr : dstAddr+ " + %<eOffsetStr>"
            %else
                %% Generate the full string corresponding to the element's offset
                %% for the real part of the root structure and add the string to
                %% the real part of the root structure
                %assign eOffsetStr = FcnGenerateStructElementOffsetString(eReOffsetList)
                %assign eDstReal = WHITE_SPACE(eOffsetStr) ? dstAddr : dstAddr +" + %<eOffsetStr>"
                %% Do the same as previously but for the imag part
                %assign eOffsetStr = FcnGenerateStructElementOffsetString(eImOffsetList)
                %assign eDstImag = WHITE_SPACE(eOffsetStr) ? dstAddr : dstAddr +" + %<eOffsetStr>"
            %endif
            %if ISEQUAL(eWidth,1)
                %% Scalar structure element
                %if !isCplx
                    %% Simple assignment
                    *((%<LibGetDataTypeNameFromId(eDTypeId)>*)(%<eDst>)) = %<eSrc>;
                %else
                    %% Real part assignment
                    *((%<LibGetDataTypeNameFromId(eDTypeId)>*)(%<eDstReal>)) = %<eSrcReal>;
                    %% Imag part assignment
                    *((%<LibGetDataTypeNameFromId(eDTypeId)>*)(%<eDstImag>)) = %<eSrcImag>;
                %endif
            %else
                %% Wide structure element
                %if !isCplx
                    (void) %<LibGenMemFcnCall("memcpy", "%<eDst>", ...
                        "%<optAddr>%<eSrc>", "%<eWidth*eDTypeSize>")>;
                %else
                    (void) %<LibGenMemFcnCall("memcpy", "%<eDstReal>",...
                        "%<optAddr>%<eSrcReal>", "%<eWidth*eDTypeSize>")>;
                    (void) %<LibGenMemFcnCall("memcpy", "%<eDstImag>", ...
                        "%<optAddr>%<eSrcImag>", "%<eWidth*eDTypeSize>")>;
                %endif
                %%
            %endif
        %endif
    %endforeach
    %if isWidthAnExpression || ISEQUAL(width,1)==TLC_FALSE
        %% Close the block and foor-loop statements
    }
}
    %endif
%endfunction


%% Function: SLibAssignSLStructToUserStruct ========================================================
%% Abstract:
%%   Marshall Simulink.Bus => user structure representation
%%
%function SLibAssignSLStructToUserStruct(dTypeId, dst, srcAddr, startOffset) Output
    %% Redirect the call to the more generic function by setting the width=1, the level
    %% of recursion to 0 and the complexity=TLC_FALSE.
    %<SLibAssignSLStructToUserStructND(dTypeId, 1, dst, srcAddr, Matrix(1,1) [0], 0, TLC_FALSE)>\
%endfunction


%% Function: SLibAssignUserStructToSLStruct ========================================================
%% Abstract:
%%   Marshall user structure => Simulink.Bus representation
%%
%function SLibAssignUserStructToSLStruct(dTypeId, dstAddr, src, startOffset) Output
    %% Redirect the call to the more generic function by setting the width=1, the level
    %% of recursion to 0 and the complexity=TLC_FALSE
    %<SLibAssignUserStructToSLStructND(dTypeId, 1, dstAddr, src, Matrix(1,1) [0], 0, TLC_FALSE)>\
%endfunction

%% Function: SLibValueIsAllZeros ===================================================================
%% Abstract:
%%   Return true if we can tell a given value of a data type is of
%%   zero-representation, considering float initialization options.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%% TopTester: test/toolbox/simulink/blocks/lib_Sources/Ground/rtw/tStringSupport.m
%% TopTester: test/toolbox/rtw/targets/AUTOSAR/Variants/inlineVariants/tInlineVariants8.m
%%
%function SLibValueIsAllZeros(dTypeId, valueToSet, bSetFltsAndDblsToZero) void
    %%
    %if ISEQUAL(valueToSet,0)
        %return 1
    %endif
    %%
    %if TYPE(valueToSet) == "String"
        %if CGMODEL_ACCESS("DataTypes.IsStringValueZero", valueToSet)
            %return 1
        %endif

        %%
        %% Handle boolean data type
        %%
        %assign upperValueToSet = FEVAL("upper", valueToSet)
        %if upperValueToSet == "FALSE"
            %assign dThruId = LibGetDataTypeIdAliasedThruToFromId(dTypeId)
            %if dThruId == tSS_BOOLEAN
                %return 1
            %endif
        %endif
        %%
        %% Handle struct data type
        %%
        %if LibIsStructDataType(dTypeId) || LibIsEnumDataType(dTypeId)
            %%
            %assign gndValue = SLibGetIRorTLCGround(dTypeId,TLC_TRUE,TLC_FALSE,TLC_FALSE)
            %if ISEQUAL(valueToSet, gndValue)  %% be conservative
                %return !(::CompiledModel.DataTypes.DataType[dTypeId].GroundHasNonZero || ...
                    (bSetFltsAndDblsToZero && ...
                    ::CompiledModel.DataTypes.DataType[dTypeId].GroundHasFloats))
            %endif
        %endif
        %%
    %endif
    %%
    %return 0
    %%
%endfunction

%% Function: SLibValueIsAllZeroBitsCrudeCheck ======================================================
%% Abstract:
%%   Return true if we can tell a given value of a data type is of
%%   zero-representation.
%% TopTester: test/toolbox/rtw/targets/AUTOSAR/Variants/tValueVariants.m
%%
%function SLibValueIsAllZeroBitsCrudeCheck(dTypeId, valueToSet) void
    %if LibDoesDataTypeNeedConstructor(dTypeId)
        %return TLC_FALSE
    %else
        %%Check if the valueToSet is a vector
        %if TYPE(valueToSet) == "Vector"
            %assign sze = SIZE(valueToSet)
            %assign retVal = TLC_TRUE
            %foreach idx = sze[1]
                %assign val = SLibValueIsAllZeros(dTypeId, valueToSet[idx], InitFltsAndDblsToZero)
                %if ISEQUAL(val,TLC_FALSE)
                    %return TLC_FALSE
                %endif
            %endforeach
            %return retVal
        %else
            %return SLibValueIsAllZeros(dTypeId, valueToSet, InitFltsAndDblsToZero)
        %endif
    %endif
%endfunction

%% Function: SLibDataTypeRequiresZeroInit ==========================================================
%% Abstract:
%%   This function returns true if a data-element of a given requires a logical
%%   zero intialization.
%% TopTester: test/toolbox/simulink/blocks/lib_Sources/Ground/rtw/-tStringSupport.m
%%
%function SLibDataTypeRequiresZeroInit(dTypeId, bSetFltsAndDblsToZero) void
    %%
    %if LibDoesDataTypeNeedConstructor(dTypeId)
        %return TLC_FALSE
    %elseif LibIsStructDataType(dTypeId)
        %if ::CompiledModel.DataTypes.DataType[dTypeId].GroundHasNonZero
            %return TLC_FALSE
        %elseif bSetFltsAndDblsToZero && ::CompiledModel.DataTypes.DataType[dTypeId].GroundHasFloats
            %return TLC_FALSE
        %else
            %return TLC_TRUE
        %endif
    %else
        %assign gndValue = SLibGetGroundValueFromIdStrictOpt(dTypeId,0)
        %return SLibValueIsAllZeros(dTypeId, gndValue, bSetFltsAndDblsToZero)
    %endif
    %%
%endfunction


%% Function: SLibGroundIsZero ======================================================================
%% Note:
%%
%function SLibGroundIsZero(dTypeId) void
    %return SLibDataTypeRequiresZeroInit(dTypeId, InitFltsAndDblsToZero)
%endfunction

%% Function: SLibDefaultInitialValueIsAllZeroBits ==================================================
%% Note:
%%   Just a wrapper of SLibGroundIsZero for now.  See comments in
%%   SLibGetDefaultInitialValueFromId also.
%%
%%   Note that future change to SLibGetDefaultInitialValueFromId means
%%   change to this function needed as well.
%%
%%
%function SLibDefaultInitialValueIsAllZeroBits(dTypeId) void
    %return SLibDataTypeRequiresZeroInit(dTypeId, InitFltsAndDblsToZero)
%endfunction

%% Function: SLibAllValuesMatch ====================================================================
%% Abstract:
%%   Returns true if all elements of a values vector match.
%% TopTester: test/toolbox/simulink/blocks/buses/tbus.m
%%
%function SLibAllValuesMatch(aValueVector) void
    %if TYPE(aValueVector) == "Vector"
        %assign vectSize = SIZE(aValueVector)
        %assign retVal = TLC_TRUE
        %assign firstEl = aValueVector[0]
        %foreach idx = vectSize[1]
            %if !ISEQUAL(aValueVector[idx], firstEl)
                %return TLC_FALSE
            %endif
        %endforeach
    %endif
    %return TLC_TRUE
%endfunction

%% Function: SLibCGTypeIsComplexStrict =============================================================
%% Abstract:
%%   Strict version of LibCGTypeIsComplex. Returns false for complex
%%   matrices, aliases to complex types, and pointers to complex types
%%
%function SLibCGTypeIsComplexStrict(cgTypeIdx) void
    %return CGMODEL_ACCESS("CGType.Constructor", cgTypeIdx) == "complex"
%endfunction

%% Function: LibCGTypeIsPointer ====================================================================
%% Abstract:
%%   Return whether or not this is a pointer type
%%
%function LibCGTypeIsPointer(cgTypeIdx) void
    %return CGMODEL_ACCESS("CGType.Constructor", cgTypeIdx) == "pointer"
%endfunction

%% Function: LibCGTypeIsReference ==================================================================
%% Abstract:
%%   Return whether or not this is a pointer type
%%
%function LibCGTypeIsReference(cgTypeIdx) void
    %return CGMODEL_ACCESS("CGType.Constructor", cgTypeIdx) == "reference"
%endfunction

%% Function: LibCGTypeIsRenamed ====================================================================
%% Abstract:
%%   Return whether or not this is a renamed type
%%
%function LibCGTypeIsRenamed(cgTypeIdx) void
    %return CGMODEL_ACCESS("CGType.Constructor", cgTypeIdx) == "renamed"
%endfunction

%% Function: LibCGTypeIsVoid =======================================================================
%% Abstract:
%%   Return whether or not this is a void type
%%
%function LibCGTypeIsVoid(cgTypeIdx) void
    %return CGMODEL_ACCESS("CGType.Constructor", cgTypeIdx) == "void"
%endfunction

%% Function: LibCGTypeIsFixed ======================================================================
%% Abstract:
%%   Return whether or not this is a fixed point type
%%
%function LibCGTypeIsFixed(cgTypeIdx) void
    %return CGMODEL_ACCESS("CGType.Constructor", cgTypeIdx) == "fixed"
%endfunction

%% Function: LibCGTypeIsChar =======================================================================
%% Abstract:
%%   Return whether or not this is a char type
%%
%function LibCGTypeIsChar(cgTypeIdx) void
    %return CGMODEL_ACCESS("CGType.Constructor", cgTypeIdx) == "char" %% sbcheck:ok:tlctypes
%endfunction

%% Function: LibCGTypeIsString =====================================================================
%% Abstract:
%%   Return whether or not this is a string type
%%
%function LibCGTypeIsString(cgTypeIdx) void
    %return CGMODEL_ACCESS("CGType.Constructor", cgTypeIdx) == "string"
%endfunction

%% Function: LibCGTypeIsUnkonwn ====================================================================
%% Abstract:
%%   Return whether or not this is an unknown type
%%
%function LibCGTypeIsUnknown(cgTypeIdx) void
    %return CGMODEL_ACCESS("CGType.Constructor", cgTypeIdx) == "unknown"
%endfunction


%% Function: LibCGTypeIsCoderArray =================================================================
%% Abstract:
%%   Return whether or not this is an coder array type.
%%   coder::arrays are generated from dynamic matrix types when the code generator
%%   does not know the size of a matrix and does not or cannot determine an
%%   upper bound on its size.
%%
%%
%function LibCGTypeIsCoderArray(cgTypeIdx) void
    %return CGMODEL_ACCESS("CGType.GetIsCoderArray", cgTypeIdx)
%endfunction

%% Function: LibCGTypeIsEnum =======================================================================
%% Abstract:
%%   Return whether or not this is an enumerated type. Returns true for matrices
%%   of enums, aliases to enums, and pointers to enums
%%
%function LibCGTypeIsEnum(cgTypeIdx) void
    %return CGMODEL_ACCESS("CGType.GetIsEnum", cgTypeIdx)
%endfunction

%% Function: LibCGTypeIsImage ======================================================================
%% Abstract:
%%   Return whether or not this is an image type. Returns true for matrices
%%   of images and pointers to images
%%
%function LibCGTypeIsImage(cgTypeIdx) void
    %return CGMODEL_ACCESS("CGType.GetIsImage", cgTypeIdx)
%endfunction

%% Function: SLibCGTypeIsEnumStrict ================================================================
%% Abstract:
%%   Strict version of LibCGTypeIsEnum. Returns false for matrices
%%   of enums, aliases to enums, and pointers to enums
%%
%function SLibCGTypeIsEnumStrict(cgTypeIdx) void
    %return CGMODEL_ACCESS("CGType.Constructor", cgTypeIdx) == "enum"
%endfunction

%% Function: LibCGTypeScalarBaseType ===============================================================
%% Abstract:
%%   Returns the scalar (or primitive) base type of a CG type.
%%
%function LibCGTypeScalarBaseType(cgTypeIdx) void
    %return CGMODEL_ACCESS("CGType.GetScalarBaseType", cgTypeIdx)
%endfunction %% end of LibCGTypeScalarBaseType

%% Function: LibCGTypeFixedPointBaseType ===========================================================
%% Abstract:
%%   Returns the scalar (or primitive) base type of a CG type.  Calls
%%   LibCGTypeScalarBaseType internally.  Will not return complex types.
%%
%function LibCGTypeFixedPointBaseType(cgTypeIdx) void
    %return CGMODEL_ACCESS("CGType.GetFixedPointBaseType", cgTypeIdx)
%endfunction %% end of LibCGTypeFixedPointBaseType

%% Function: LibCGTypeNamespace ====================================================================
%% Abstract:
%%   Returns the namespace of the CG type.
%%
%function LibCGTypeNamespace(cgTypeIdx) void
    %return CGMODEL_ACCESS("CGType.GetNamespace", cgTypeIdx)
%endfunction %% end of LibCGTypeNamespace

%% Function: LibAddNamespaceToTypeName =============================================================
%% Abstract:
%%   Adds the namespace to the type name.
%%
%function LibAddNamespaceToTypeName(typeName, typeNamespace) void
    %if ISEMPTY(typeName) || ISEMPTY(typeNamespace)
        %return typeName
    %endif
    %return typeNamespace + "::" + typeName
%endfunction %% end of LibAddNamespaceToTypeName

%% Function: LibCGTypeTag ==========================================================================
%% Abstract:
%%   Returns the tag for a CG type.
%%
%function LibCGTypeTag(cgTypeIdx) void
    %return CGMODEL_ACCESS("CGType.Tag", cgTypeIdx)
%endfunction %% end of LibCGTypeTag

%% Function: LibCGTypeIsOpaqueStruct ===============================================================
%% Abstract:
%%   Returns whether a CG type is an opaque struct
%%
%function LibCGTypeIsOpaqueStruct(cgTypeIdx) void
    %return CGMODEL_ACCESS("CGType.IsOpaque", cgTypeIdx)
%endfunction %% end of LibCGTypeIsOpaqueStruct

%% Function: LibCGTypeBias =========================================================================
%% Abstract:
%%   Returns the bias of a CGType
%%
%function LibCGTypeBias(cgTypeIdx) void
    %return CGMODEL_ACCESS("CGType.Bias", cgTypeIdx)
%endfunction

%% Function: LibCGTypeSlope ========================================================================
%% Abstract:
%%   Returns the slope of a CGType
%%
%function LibCGTypeSlope(cgTypeIdx) void
    %return CGMODEL_ACCESS("CGType.Slope", cgTypeIdx)
%endfunction

%% Function: LibCGTypeNBits ========================================================================
%% Abstract:
%%   Returns the NBits of a CGType
%%
%function LibCGTypeNBits(cgTypeIdx) void
    %return CGMODEL_ACCESS("CGType.NBits", cgTypeIdx)
%endfunction

%% Function: LibCGTypeIsSigned =====================================================================
%% Abstract:
%%   Returns whether a fixed point CGType is signed
%%
%function LibCGTypeIsSigned(cgTypeIdx) void
    %return CGMODEL_ACCESS("CGType.IsSigned", cgTypeIdx)
%endfunction

%% Function: LibCGTypeExponent =====================================================================
%% Abstract:
%%   Returns whether the exponent of a fixed point CGType
%%
%function LibCGTypeExponent(cgTypeIdx) void
    %return CGMODEL_ACCESS("CGType.Exponent", cgTypeIdx)
%endfunction

%% Function: LibCGTypeIsLoweredMultiword ===========================================================
%% Abstract:
%%   Returns whether a struct CGType a lowered multi-word type
%%
%function LibCGTypeIsLoweredMultiword(cgTypeIdx) void
    %return CGMODEL_ACCESS("CGType.IsLoweredMultiword", cgTypeIdx)
%endfunction

%% Function: LibCGTypeStructAlignment ==============================================================
%% Abstract:
%%   Returns the alignment of a struct CGType
%%
%function LibCGTypeStructAlignment(cgTypeIdx) void
    %return CGMODEL_ACCESS("CGType.StructAlignment", cgTypeIdx)
%endfunction

%% Function: LibCGTypeNumMembers ===================================================================
%% Abstract:
%%   Returns the number of members of a struct CGType
%%
%function LibCGTypeNumMembers(cgTypeIdx) void
    %return CGMODEL_ACCESS("CGType.NumMembers", cgTypeIdx)
%endfunction

%% Function: LibCGTypeMemberName ===================================================================
%% Abstract:
%%   Returns the name of a member of a struct CGType
%%
%function LibCGTypeMemberName(cgTypeIdx, memberIdx) void
    %return CGMODEL_ACCESS("CGType.Member.Name", cgTypeIdx, memberIdx)
%endfunction

%% Function: LibCGTypeMemberCGTypeIdx ==============================================================
%% Abstract:
%%   Returns the CGType index of a member of a struct CGType
%%
%function LibCGTypeMemberCGTypeIdx(cgTypeIdx, memberIdx) void
    %return CGMODEL_ACCESS("CGType.Member.CGTypeIdx", cgTypeIdx, memberIdx)
%endfunction

%% Function: LibCGTypeMemberCGTypeIdx ==============================================================
%% Abstract:
%%   Returns the alignment of a member of a struct CGType
%%
%function LibCGTypeMemberAlignment(cgTypeIdx, memberIdx) void
    %return CGMODEL_ACCESS("CGType.Member.Alignment", cgTypeIdx, memberIdx)
%endfunction

%function LibGetRecordCGTypeIdx(record) void
    %if ISFIELD(record, "CGTypeIdx")
        %return record.CGTypeIdx
    %elseif ISFIELD(record, "VarGroupIdx")
        %assign varGroupIdx = record.VarGroupIdx
        %return SLibVarGroupElementType(varGroupIdx[0], varGroupIdx[1])
    %else
        %assign errMsg = "Should not get here"
        %<LibReportFatalError(errMsg)>
    %endif
%endfunction

%% Function: LibGetRecordIsMatrix ==================================================================
%% Abstract:
%%   Returns true if a given data record has a matrix type
%%
%function LibGetRecordIsMatrix(record) void
    %return SLibCGTypeIsMatrix(SLibGetRecordContainerCGTypeIdx(record))
%endfunction

%% Function: SLibCGTypeIsMatrixStrict ==============================================================
%% Abstract:
%%   Strict version of LibCGTypeIsMatrix. Returns false for aliases to matrix types.
%%
%function SLibCGTypeIsMatrixStrict(cgTypeIdx) void
    %return CGMODEL_ACCESS("CGType.Constructor", cgTypeIdx) == "matrix"
%endfunction

%% Function: LibCGTypeIsStruct =====================================================================
%% Abstract:
%%   Return true if this type is a struct type (or an alias of or pointer to a struct type)
%%
%function LibCGTypeIsStruct(cgTypeIdx) void
    %return CGMODEL_ACCESS("CGType.GetIsStruct", cgTypeIdx)
%endfunction

%% Function: LibCGTypeIsClass ======================================================================
%% Abstract:
%%   Return true if this type is a struct type (or an alias of or pointer to a struct type)
%%
%function LibCGTypeIsClass(cgTypeIdx) void
    %return CGMODEL_ACCESS("CGType.GetIsClass", cgTypeIdx)
%endfunction

%% Function: SLibCGTypeIsStructStrict ==============================================================
%% Abstract:
%%   Strict version of LibCGTypeIsStruct. Will return false for pointers to or
%%   aliases of struct types
%%
%function SLibCGTypeIsStructStrict(cgTypeIdx) void
    %return CGMODEL_ACCESS("CGType.Constructor", cgTypeIdx) == "struct"
%endfunction

%% Function: LibCGTypeIsArrayOfStructs =============================================================
%% Abstract:
%%   Return true if we have an array of structures
%%
%function LibCGTypeIsArrayOfStructs(cgTypeIdx) void
    %assign arrayOfStructs = TLC_FALSE
    %if LibCGTypeIsMatrix(cgTypeIdx)
        %assign arrayOfStructs = LibCGTypeIsStruct(LibCGTypeBaseIndex(cgTypeIdx))
    %endif
    %return arrayOfStructs
%endfunction

%% Function: LibCGTypeWidth ========================================================================
%% Abstract:
%%   Return width in elements
%%
%function LibCGTypeWidth(cgTypeIdx) void
    %return CGMODEL_ACCESS("CGType.Width", cgTypeIdx)
%endfunction

%% Function: SLibEvalSymbolicWidth =================================================================
%% Abstract:
%%   Returns the symbolic width for a given CGType index. It will use the
%%   custom storage object identifier, if aUseParamIdentifier is false.
%%   Otherwise it will use the Simulink parameter identifier.
%%
%function SLibEvalSymbolicWidth(aCGTypeIdx, aUseParamIdentifier) void
    %assign prevVal = ::UseParamIdentifierForSymbolicDim
    %assign ::UseParamIdentifierForSymbolicDim = aUseParamIdentifier
    %assign fcnName = "SLibCGType" + "%<aCGTypeIdx>" + "SymbolicWidth"
    %assign symDims = %<fcnName>()
    %assign ::UseParamIdentifierForSymbolicDim = prevVal
    %return symDims
%endfunction

%% Function: LibCGTypeSymbolicWidth ================================================================
%% Abstract:
%%   Return the symbolic width of a CGType
%% TopTester: test/toolbox/simulink/variants/var-inline-general/tCSCDefine.m
%%
%function LibCGTypeSymbolicWidth(cgTypeIdx) void
    %assign cgType = ::CompiledModel.CGTypes.CGType[cgTypeIdx]
    %if ISFIELD(cgType, "SymbolicWidth")
        %if ISEMPTY(cgType.SymbolicWidth)
            %assign cgType.SymbolicWidth = SLibEvalSymbolicWidth(cgTypeIdx, TLC_FALSE)
            %addtorecord ::CompiledModel.CGTypes.CGType[cgTypeIdx] ...
                SLSymbolicWidth SLibEvalSymbolicWidth(cgTypeIdx, TLC_TRUE)
        %endif
        %return cgType.SymbolicWidth
    %else
        %return "%<LibCGTypeWidth(cgTypeIdx)>"
    %endif
%endfunction

%function SLibCGTypeSymbolicVectorDims(cgTypeIdx) void
    %assign width = LibCGTypeSymbolicWidth(cgTypeIdx)
    %if "1" == width && !LibCGTypeIsMatrix(cgTypeIdx)
        %return ""
    %elseif LibCGTypeIsStdContainer(cgTypeIdx) || ...
        LibCGTypeIsCoderArray(cgTypeIdx)
        %return ""
    %else
        %assign dims = LibCGTypeSymbolicDimensions(cgTypeIdx)
        %assign isScalar = TLC_TRUE
        %assign nonSingletonDimsCount = 0
        %assign retDims = ""
        %foreach dimIdx = SIZE(dims, 1)
            %if dims[dimIdx] != "1"
                %assign isScalar = TLC_FALSE
                %assign nonSingletonDimsCount = nonSingletonDimsCount + 1
            %endif
            %assign retDims = retDims + "[%<dims[dimIdx]>]"
        %endforeach
        %if isScalar && !LibCGTypeIsMatrix(cgTypeIdx)
            %return ""
        %elseif nonSingletonDimsCount == 1
            %% Vector case
            %return "[" + width + "]"
        %else
            %return retDims
        %endif
    %endif
%endfunction

%% Function: LibCGTypeSymbolicVectorDims ===========================================================
%% Abstract:
%%   Returns the symbolic dimensions index specification (as a string) of a
%% CGType; e.g., [3, 7] => "[3][7]", [3] => "[3]", [1] => "".
%% TopTester: test/toolbox/simulink/blocks/tenable.m
%%
%function LibCGTypeSymbolicVectorDims(cgTypeIdx) void
    %assign cgType = ::CompiledModel.CGTypes.CGType[cgTypeIdx]
    %if cgType.SymbolicVectorDims == "-1"
        %assign cgType.SymbolicVectorDims = SLibCGTypeSymbolicVectorDims(cgTypeIdx)
    %endif
    %return cgType.SymbolicVectorDims
%endfunction

%% Function: LibCGTypeDimensions ===================================================================
%% Abstract:
%%   Return dimensions
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function LibCGTypeDimensions(idx) void
    %if idx < LibGetNumBuiltInDataTypesInModel()
        %return 1
    %endif
    %if LibCGTypeIsMatrix(idx)
        %return ::CompiledModel.CGTypes.CGType[idx].Dimensions
    %elseif LibCGTypeIsPointer(idx) || LibCGTypeIsRenamed(idx)
        %return LibCGTypeDimensions(LibCGTypeBaseIndex(idx))
    %elseif LibCGTypeIsSLString(idx)
        %% String type can have dimension 1 or [1 1], see g2673660
        %assign ndims = LibCGTypeNumDimensions(idx)
        %assign dims = Vector(%<ndims>) [1@%<ndims>]
        %return dims
    %else
        %return 1
    %endif
%endfunction

%% Function: SLibEvalSymbolicDimensions ============================================================
%% Abstract:
%%   Returns the symbolic dimensions for a given CGType index. It will use the
%%   custom storage object identifier, if aUseParamIdentifier is false.
%%   Otherwise it will use the Simulink parameter identifier.
%%
%function SLibEvalSymbolicDimensions(aCGTypeIdx, aUseParamIdentifier) void
    %assign prevVal = ::UseParamIdentifierForSymbolicDim
    %assign ::UseParamIdentifierForSymbolicDim = aUseParamIdentifier
    %assign fcnName = "SLibCGType" + "%<aCGTypeIdx>" + "SymbolicDimensions"
    %assign symDims = %<fcnName>()
    %assign ::UseParamIdentifierForSymbolicDim = prevVal
    %return symDims
%endfunction

%% Function: LibCGTypeSymbolicDimensions ===========================================================
%% Abstract:
%%   Returns symbolic dimensions. The return type is array of strings.
%% TopTester: test/toolbox/rtw/targets/AUTOSAR/Variants/dimensionVariants/tDimensionVariants5.m
%%
%function LibCGTypeSymbolicDimensions(idx) void
    %if idx < LibGetNumBuiltInDataTypesInModel()
        %return ["1"]
    %endif
    %% When we fall into this case, the idx is the CGType index of a dynamic
    %% matrix.  Such a matrix is assumed by certain parts of code generation
    %% infrastructure to be a symbolic dimension, and will look something like:
    %% { Dimensions [-1, -1]; SymbolicDimensions ["", ""]; SymbolicWidth "" }
    %% Note the absence of names in SymbolicDimensions field, which would
    %% normally be an expression.  The empty names in SymbolicDimensions field is
    %% normally considered an error. Will probably need to revisit this if we
    %% come up with a case where we get an symbolic-sized array of emxArray
    %% pointers.
    %%
    %% At the moment I believe we can only get a single emxArray pointer here,
    %% and we just return that it has width 1.
    %%
    %if LibCGTypeIsCoderArray(idx)
        %return ["1"]
    %endif

    %if LibCGTypeIsMatrix(idx) && ...
        ISFIELD(::CompiledModel.CGTypes.CGType[idx], "SymbolicDimensions")
        %if ISEMPTY(::CompiledModel.CGTypes.CGType[idx].SymbolicDimensions)
            %assign ::CompiledModel.CGTypes.CGType[idx].SymbolicDimensions = ...
                SLibEvalSymbolicDimensions(idx, TLC_FALSE)
            %addtorecord ::CompiledModel.CGTypes.CGType[idx] ...
                SLSymbolicDimensions SLibEvalSymbolicDimensions(idx, TLC_TRUE)
        %endif
        %return ::CompiledModel.CGTypes.CGType[idx].SymbolicDimensions
    %else
        %assign dims = LibCGTypeDimensions(idx)
        %assign ndims = SIZE(dims, 1)
        %assign symbolicDims = Vector(%<ndims>) [""@%<ndims>]
        %foreach dim = ndims
            %assign symbolicDims[%<dim>] = "%<dims[dim]>"
        %endforeach
    %endif
    %return symbolicDims
%endfunction

%% Function: LibCGTypeBaseIndex ====================================================================
%% Abstract:
%%   Return base index
%%
%function LibCGTypeBaseIndex(cgTypeIdx) void
    %return CGMODEL_ACCESS("CGType.BaseIdx", cgTypeIdx)
%endfunction

%% Function: SLibCGTypeToSLType ====================================================================
%% Abstract:
%%   Returns the SLType index for a given CGType index. It returns -1 if
%%   no SLType exists or optionally reports an error
%% TopTester: test/toolbox/simulink/variants/var-vss-sigobj/tVSSSigObj.m
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortFcnCall3.m
%%
%function SLibCGTypeToSLType(aCGTypeIdx, aReportError) void
    %assign slTypeIdx = CGMODEL_ACCESS("CGType.GetSLTypeIdxForCGType", aCGTypeIdx)
    %if ((slTypeIdx == -1) && aReportError)
        %assign constructor = CGMODEL_ACCESS("CGType.Constructor", aCGTypeIdx)
        %assign errMsg = "invalid SLTypeIdx %<slTypeIdx> for %<constructor>"
        %<LibReportFatalError(errMsg)>
    %endif
    %return slTypeIdx
%endfunction

%% Function: LibCGTypeToSLType =====================================================================
%% Abstract:
%%   Returns the SLType index for a given CGType index and reports an error if
%%   no SLType exists.
%%
%function LibCGTypeToSLType(aCGTypeIdx) void
    %return SLibCGTypeToSLType(aCGTypeIdx, TLC_TRUE)
%endfunction

%% Function: LibCGTypeSLBaseType ===================================================================
%% Abstract:
%%   Returns the Simulink base type of a CG type.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/simulink/variants/var-inline-general/tCSCDefine.m
%%
%function LibCGTypeSLBaseType(cgTypeIdx) void
    %foreach i = cgTypeIdx
        %if ::CompiledModel.CGTypes.CGType[cgTypeIdx].SLTypeIdx > -1
            %return ::CompiledModel.CGTypes.CGType[cgTypeIdx].SLTypeIdx
        %elseif LibCGTypeIsCoderArray(cgTypeIdx)
            %% When we enter here cgTypeIdx corresponds to emxArray*.  We are looking
            %% for the base simulink type.  This first call to LibCGTypeBaseIndex
            %% strips off the pointer to give the structure type.
            %assign cgTypeIdx = LibCGTypeBaseIndex(cgTypeIdx)
            %% Now we go from the struct type to the base simulink type.
            %assign cgTypeIdx = LibCGTypeBaseIndex(cgTypeIdx)
        %else
            %if LibCGTypeIsMatrix(cgTypeIdx) || LibCGTypeIsComplex(cgTypeIdx) || ...
                LibCGTypeIsPointer(cgTypeIdx) || LibCGTypeIsRenamed(cgTypeIdx)
                %assign cgTypeIdx = LibCGTypeBaseIndex(cgTypeIdx)
            %else
                %%        %assign constructor = CGMODEL_ACCESS("CGType.Constructor", cgTypeIdx)
                %%        %assign errMsg = "invalid SLTypeIdx -1 for %<constructor>"
                %%        %<LibReportFatalError(errMsg)>
                %return -1
            %endif
        %endif
    %endforeach
    %return cgTypeIdx
%endfunction

%% Function: LibCGTypeName =========================================================================
%% Abstract:
%%   Returns the CGType name
%% TopTester: test/toolbox/simulink/variants/var-vss-sigobj/tVSSSigObj.m
%%
%function LibCGTypeName(cgTypeIdx) void
    %return LibOptStdCGTypeName(cgTypeIdx, TLC_FALSE)
%endfunction

%% Function: LibAliasedThruCGTypeName ==============================================================
%% Abstract:
%%   Returns the CGType name stripping off aliases
%% TopTester: test/toolbox/simulink/variants/var-inline-general/twipervariant.m
%% TopTester: test/toolbox/simulink/variants/var-inline-general/tRootOutportStorageClass.m
%%
%function LibAliasedThruCGTypeName(cgTypeIdx) void
    %foreach i = cgTypeIdx+1
        %assign cgTypeRec = ::CompiledModel.CGTypes.CGType[cgTypeIdx]
        %assign isComplex = TLC_FALSE
        %if LibCGTypeIsMatrix(cgTypeIdx)
            %assign cgTypeIdx = LibCGTypeBaseIndex(cgTypeIdx)
        %elseif LibCGTypeIsComplex(cgTypeIdx)
            %assign isComplex = TLC_TRUE
            %assign cgTypeRec = ::CompiledModel.CGTypes.CGType[LibCGTypeBaseIndex(cgTypeIdx)]
        %elseif LibCGTypeIsRenamed(cgTypeIdx)
            %return LibCGTypeName(LibCGTypeBaseIndex(cgTypeIdx))
        %else
            %assign slTypeIdx = cgTypeRec.SLTypeIdx
            %if slTypeIdx < 0 || slTypeIdx >= ::CompiledModel.DataTypes.NumDataTypes
                %assign constructor = CGMODEL_ACCESS("CGType.Constructor", cgTypeIdx)
                %assign errMsg = "invalid SLTypeIdx %<slTypeIdx> for %<constructor>"
                %<LibReportFatalError(errMsg)>
            %endif
            %if (isComplex)
                %return LibGetDataTypeComplexNameFromId(slTypeIdx)
            %else
                %return LibGetDataTypeNameFromId(slTypeIdx)
            %endif
        %endif
    %endforeach
    %return "#error"
%endfunction

%% Function: SLibGetRecordOriginalCGTypeIdx ========================================================
%% Abstract:
%%   Returns the original (not storage) CG type index for a given data record
%%
%function SLibGetRecordOriginalCGTypeIdx(rec) void
    %return ISFIELD(rec, "OriginalCGTypeIdx") ? ...
        rec.OriginalCGTypeIdx : rec.CGTypeIdx
%endfunction

%% Function: SLibGetRecordContainerCGTypeIdx =======================================================
%% Abstract:
%%   Returns the container or implementation CG type index for a given
%%   data record.
%%
%%   For optimization reasons if ContainerCGTypeIdx is the same as
%%   CGTypeIdx the former gets optimized away. For this reason
%%   if the former is not found the later is used.
%% TopTester: test/toolbox/simulink/variants/var-vss-sigobj/tVSSSigObj.m
%%
%function SLibGetRecordContainerCGTypeIdx(rec) void
    %if ISFIELD(rec, "ContainerCGTypeIdx") && ...
        rec.ContainerCGTypeIdx >= 0
        %return rec.ContainerCGTypeIdx
    %elseif (ISFIELD(rec, "RecordType") && rec.RecordType == "ZcSignalInfo")
        %% There is no CGType on ZcSignalInfo. Go to the VarGroup to get the type.
        %return SLibVarGroupElementType(rec.VarGroupIdx[0], rec.VarGroupIdx[1])
    %else
        %return rec.CGTypeIdx
    %endif
%endfunction

%% Function: SLibGetRecordContainerCGType ==========================================================
%% Abstract:
%%   Returns the container or implementation CG type record for a given
%%   data record.
%%
%function SLibGetRecordContainerCGType(rec) void
    %return ::CompiledModel.CGTypes.CGType[SLibGetRecordContainerCGTypeIdx(rec)]
%endfunction

%% Function: SLibGetRecordContainerTypeName ========================================================
%% Abstract:
%%   Returns the container or implementation type name for a given
%%   data record.
%%
%function SLibGetRecordContainerTypeName(rec) void
    %return SLibGetRecordContainerOptStdTypeName(rec, TLC_FALSE)
%endfunction

%% Function: SLibGetRecordContainerOptStdTypeName
%% Abstract:
%%   Returns the container or implementation type name for a given
%%   data record.
%%
%%   Specify the useStdContainerName argument as whether to return std container name
%%   if the type is a pre-lowering std container type.
%%
%function SLibGetRecordContainerOptStdTypeName(rec, useStdContainerName) void
    %assign containerCgTypeIdx = SLibGetRecordContainerCGTypeIdx(rec)
    %if LibCGTypeIsEnum(SLibGetRecordOriginalCGTypeIdx(rec)) && ...
        !(useStdContainerName && LibCGTypeIsStdContainer(containerCgTypeIdx))
        %return LibOptStdCGTypeName(SLibGetRecordOriginalCGTypeIdx(rec), useStdContainerName)
    %else
        %return LibOptStdCGTypeName(containerCgTypeIdx, useStdContainerName)
    %endif
%endfunction

%% Function: SLibGetRecordContainerBaseTypeName ====================================================
%% Abstract:
%%   Returns the container or implementation base type name for a given
%%   data record.
%%
%function SLibGetRecordContainerBaseTypeName(rec) void
    %return LibCGTypeName(LibCGTypeScalarBaseType(SLibGetRecordContainerCGTypeIdx(rec)))
%endfunction

%% Function: LibIsDataTypeLogSupported=========================================
%% Abstract:
%%   Is signal logging supported for this data type
%% TopTester: test/toolbox/simulink/variants/var-general/tStringSupport.m
%% TopTester: test/toolbox/simulink/blocks/lib_Sources/Ground/rtw/tStringSupport.m
%%
%function LibIsDataTypeLogSupported(dTypeId, logIfConvertTLCFcnExists) void
    %if LibIsHalfDataType(dTypeId)
        %return 0
    %elseif LibIsDataTypeBuiltinOrFixpt(dTypeId)
        %return 1
    %elseif LibIsEnumDataType(dTypeId)
        %return 0
    %elseif logIfConvertTLCFcnExists
        %return (LibConvertBetweenTLCFcnName(dTypeId) != "")
    %else
        %return 0
    %endif
%endfunction

%% Function: LibIsDataTypeFixpt================================================
%% Abstract:
%%   Is fixpt data type
%%
%function LibIsDataTypeFixpt(dTypeId) void
    %assign curDT = FixPt_GetDataTypeFromIndex(dTypeId)
    %%
    %if curDT.IsFixedPoint
        %return 1
    %else
        %return 0
    %endif
%endfunction

%% Function: LibIsDataTypeBuiltinOrFixpt=======================================
%% Abstract:
%%   Is builtin or fixpt data type
%%
%function LibIsDataTypeBuiltinOrFixpt(dTypeId) void
    %if LibIsBuiltInDataType(dTypeId)
        %return 1
    %else
        %return LibIsDataTypeFixpt(dTypeId)
    %endif
%endfunction


%% Function: LibIsMultiWordValue(in) =======================================
%% Abstract:
%% "in" is a string, which could be a variable or value, including
%% signal word value and multiword value, i.e., { { xUL, xUL } }.
%% return true if in is a multiword value.
%function LibIsMultiWordValue(in)
    %%simply looking for "{". Since varaible could not have "{" as a name.
    %return (TYPE(in) == "String") && ISSUBSTRING(in, "{")
%endfunction %%LibIsMultiWordValue




%% Function: LibDataTypeIsAnonymousStruct ==========================================================
%% Abstract:
%%   Is the data type a anonymous struct type?
%%
%function LibDataTypeIsAnonymousStruct(id) void
    %return LibIsStructDataType(id) && !LibIsDataTypeFixpt(id) \
    && !SLibDataTypeHasObject(id)
%endfunction

%% Function: SLibDataTypeHasObject =================================================================
%% Abstract:
%%   Does this datatype have a workspace object?
%%
%function SLibDataTypeHasObject(id) void
    %return ::CompiledModel.DataTypes.DataType[id].HasObject != 0
%endfunction


%% Function: LibDataTypeElementDescription =========================================================
%% Abstract:
%%   Return the Description of the idx'th element of datatype
%function LibDataTypeElementDescription(id, idx) void
    %return ::CompiledModel.DataTypes.DataType[id].Elements[idx].Description
%endfunction

%% Function: LibDataTypeElementUnit ================================================================
%% Abstract:
%%   Return the Units of the idx'th element of datatype
%function LibDataTypeElementUnit(id, idx) void
    %return LibGetRecordUnitExpr(::CompiledModel.DataTypes.DataType[id].Elements[idx])
%endfunction

%% Function: LibDataTypeElementASCIIEscapedUnits ===================================================
%% Abstract:
%%   Return the Escaped Units of the idx'th element of datatype
%%   Note that these units have been escaped to support unicode strings
%%   in generated code.  They must be unescaped when passed back to c++ code.
%function LibDataTypeElementASCIIEscapedUnits(id, idx) void
    %return SLibGetRecordASCIIEscapedUnitExpr(::CompiledModel.DataTypes.DataType[id].Elements[idx])
%endfunction

%% Function: LibDataTypeElementDocUnits ============================================================
%% Abstract:
%%   Return the DocUnits of the idx'th element of datatype
%function LibDataTypeElementDocUnits(id, idx) void
    %return ::CompiledModel.DataTypes.DataType[id].Elements[idx].DocUnits
%endfunction

%% Function: LibDataTypeElementComment =============================================================
%% Abstract:
%%   Return formatted comment for bus element
%%
%function LibDataTypeElementComment(id, idx) void
    %assign eComment = ""
    %if (ConfigSet.SimulinkDataObjDesc == 1)
        %assign eDesc = LibDataTypeElementDescription(id, idx)
        %% write out comment if desc is not empty
        %if !ISEMPTY(eDesc)
            %assign eComment = "/* " + eDesc + " */\n"
        %endif
    %endif
    %return eComment
%endfunction

%% Function: LibDataTypeElementContainerName =======================================================
%% Abstract:
%%   Return the implementation (container) type name of the idx'th element
%%   of a given strutured datatype
%%
%function LibDataTypeElementContainerName(id, idx) void
    %assign element = ::CompiledModel.DataTypes.DataType[id].Elements[idx]
    %return SLibGetRecordContainerOptStdTypeName(element, TLC_TRUE)
%endfunction

%% Function: LibDataTypeElementIsFixPt =============================================================
%% Abstract:
%%   Return whether the idx'th element of datatype is Fixed point data type
%%
%function LibDataTypeElementIsFixPt(id, idx) void
    %return ::CompiledModel.DataTypes.DataType[LibDataTypeElementDataTypeId(id,idx)].IsFixedPoint
%endfunction

%% Function: LibDataTypeElementSymbolicWidth =======================================================
%% Abstract:
%%   Returns the symbolic width of the idx'th element of datatype
%%
%function LibDataTypeElementSymbolicWidth(id, idx) void
    %assign element = ::CompiledModel.DataTypes.DataType[id].Elements[idx]
    %return LibGetSymbolicRecordWidth(element)
%endfunction

%% Function: LibDataTypeElementVectorDims ==========================================================
%% Abstract:
%%   Return the dimensions of the idx'th element of datatype as a string
%%   including the brackets, if it is a vector or matrix.
%%
%function LibDataTypeElementVectorDims(id, idx) void
    %assign element = ::CompiledModel.DataTypes.DataType[id].Elements[idx]
    %return LibGetRecordVectorDims(element)
%endfunction

%% Function: LibDataTypeElementVectorWidth =========================================================
%% Abstract:
%%   Return the width of the idx'th element of datatype as a string
%% including the brackets, if it is a vector.
%%
%function LibDataTypeElementVectorWidth(id, idx) void
    %assign element = ::CompiledModel.DataTypes.DataType[id].Elements[idx]
    %return LibGetRecordVectorWidth(element)
%endfunction

%% Function: LibDataTypeElementOffset ==============================================================
%% Abstract:
%%   Return the offset of the idx'th element of datatype
%%
%function LibDataTypeElementOffset(id, idx) void
    %return ::CompiledModel.DataTypes.DataType[id].Elements[idx].Offset
%endfunction

%% Function: LibDataTypeElementMax =================================================================
%% Abstract:
%%   Return the Max of the idx'th element of datatype
%%
%function LibDataTypeElementMax(id, idx) void
    %return DataTypes.DataType[id].Elements[idx].Max
%endfunction

%% Function: LibDataTypeElementMin =================================================================
%% Abstract:
%%   Return the Min of the idx'th element of datatype
%%
%function LibDataTypeElementMin(id, idx) void
    %return DataTypes.DataType[id].Elements[idx].Min
%endfunction


%% DocFunction{Other Useful Functions}: LibGetStringTypeMaxLength =====================
%% Abstract:
%%   Return the maximum length of a string type or 0 for dynamic string types
%%   Return -1 if the input data type is not string
%function LibGetStringTypeMaxLength(id) void
    %if LibIsStringDataType(id)
        %assign dtId = LibGetDataTypeIdAliasedThruToFromId(id)
        %assign dt = ::CompiledModel.DataTypes.DataType[dtId]
        %if ISFIELD(dt, "Object")
            %return CAST("Number", dt.Object.ObjectProperties.MaximumLength)
        %else
            %return 0
        %endif
    %else
        %return -1
    %endif
%endfunction

%function SLibIsDataTypeCGClassOrContainClass(id) void
    %assign dt = ::CompiledModel.DataTypes.DataType[id]
    %assign isClass = TLC_FALSE

    %%needed this for bus, since it is a struct containing classes
    %if LibIsStructDataType(id)
        %assign numElements = dt.NumElements
        %foreach eIdx = numElements
            %assign eDtId = LibDataTypeElementDataTypeId(dt.Id, eIdx)
            %if LibIsDataTypeCGClassType(eDtId)
                %return TLC_TRUE
            %endif
        %endforeach
        %return TLC_FALSE
    %else
        %return ( ( ISFIELD(dt,"CGTypeIdx") && LibCGTypeIsClass(dt.CGTypeIdx) ) || (ISFIELD(dt,"ContainerCGTypeIdx") && LibCGTypeIsClass(dt.ContainerCGTypeIdx) ) )
    %endif
%endfunction

%% DocFunction{Other Useful Functions}: LibIsDataTypeCGClassOrContainClass ====================
%% Abstract:
%%   Return TLC_TRUE when one of the following is true:
%%     (1) The input data type ID corresponds to a CG class type
%%     (2) The input data type ID corresponds to a Container type that is ClassType
%%     (3) The input data type corresponds to a structure that contains (1) or (2)
%%   Otherwise, return TLC_FALSE.
%function LibIsDataTypeCGClassOrContainClass(id) void
    %assign dt = ::CompiledModel.DataTypes.DataType[id]

    %if dt.IsCGClassOrContainClass == -1
        %assign dt.IsCGClassOrContainClass = SLibIsDataTypeCGClassOrContainClass(id)
    %endif

    %return dt.IsCGClassOrContainClass

%endfunction

%% DocFunction{Other Useful Functions}: LibDoesDataTypeMemberNeedConstructor ===========
%% Abstract:
%%   Returns whether if a constructor is needed for member of struct.
%%   Return TLC_TRUE when the data type is a struct, and one (or more) of its memeber
%%          needs constructor (LibDoesDataTypeNeedConstructor)
%%   Otherwise, return TLC_FALSE.
%function LibDoesDataTypeMemberNeedConstructor(id) void
    %if LibIsStructDataType(id)
        %assign dt = ::CompiledModel.DataTypes.DataType[id]
        %assign numElements = dt.NumElements
        %foreach eIdx = numElements
            %assign eDtId = LibDataTypeElementDataTypeId(dt.Id, eIdx)
            %if LibDoesDataTypeNeedConstructor(eDtId)
                %return TLC_TRUE
            %endif
        %endforeach
        %return TLC_FALSE
    %else
        %return TLC_FALSE
    %endif
%endfunction

%% DocFunction{Other Useful Functions}: LibDoesDataTypeNeedDestructor ===========
%% Abstract:
%%   Returns whether if a destructor is needed. This can also be default
%%           destructor that can be essentially omitted.
%%   Return TLC_TRUE when one of the following is true:
%%     (1) The input data type ID corresponds to a CG class type
%%     (2) The input data type corresponds to an opaque type that has explicit destructor
%%   Otherwise, return TLC_FALSE.
%function LibDoesDataTypeNeedDestructor(id) void
    %return !ISEMPTY(SLibDataTypeDestructFcnName(id))
%endfunction

%% DocFunction{Other Useful Functions}: LibDoesDataTypeMemberNeedDestructor ===========
%% Abstract:
%%   Returns whether if a destructor is needed for member of struct.
%%   Return TLC_TRUE when the data type is a struct, and one (or more) of its memeber
%%          needs destructor (LibDoesDataTypeNeedDestructor)
%%   Otherwise, return TLC_FALSE.
%function LibDoesDataTypeMemberNeedDestructor(id) void
    %if LibIsStructDataType(id)
        %assign dt = ::CompiledModel.DataTypes.DataType[id]
        %assign numElements = dt.NumElements
        %foreach eIdx = numElements
            %assign eDtId = LibDataTypeElementDataTypeId(dt.Id, eIdx)
            %if LibDoesDataTypeNeedDestructor(eDtId)
                %return TLC_TRUE
            %endif
        %endforeach
        %return TLC_FALSE
    %else
        %return TLC_FALSE
    %endif
%endfunction

%% DocFunction{Other Useful Functions}: LibIsDataTypeContainerClass ===========
%% Abstract:
%%   Returns whether this is a scalar type corresponding to a matrix vlue.
%%   Return TLC_TRUE when one of the following is true:
%%     (1) The input data type ID corresponds to a CG class type
%%     (2) The input data type corresponds to an opaque type that corresponds to container
%%   Otherwise, return TLC_FALSE.
%function LibIsDataTypeContainerClass(id) void
    %return !ISEMPTY(SLibDataTypeContainedDataFcn(id)) || LibIsDataTypeCGClassType(id)
%endfunction


%% DocFunction{Other Useful Functions}: LibGetEnumTypeStorageType =============
%% Abstract:
%%   For enumerated data types, get the storage type ID in the generated code.
%%
%function LibGetEnumTypeStorageType(id) void
    %assign dtId = LibGetDataTypeIdAliasedThruToFromId(id)
    %return ::CompiledModel.DataTypes.DataType[dtId].EnumStorageTypeId
%endfunction

%% DocFunction{Other Useful Functions}: LibIsEnumTypeStoredAsInt ==============
%% Abstract:
%%   For enumerated data types, return TLC_TRUE if enumerated type is stored as
%%   an int. Otherwise, return TLC_FALSE.
%%
%function LibIsEnumTypeStoredAsInt(id) void
    %assign storageType = LibGetEnumTypeStorageType(id)
    %return (storageType == -1)
%endfunction

%% Function: FcnGetEnumTypeNumEnums ================================================================
%% Abstract:
%%   For enumerated data types, get number of enumerations
%%
%function FcnGetEnumTypeNumEnums(id) void
    %assign dtId = LibGetDataTypeIdAliasedThruToFromId(id)
    %return ::CompiledModel.DataTypes.DataType[dtId].NumEnumerations
%endfunction

%% Function: FcnGetEnumTypeDefaultValue ============================================================
%% Abstract:
%%   For enumerated data types, get default enumeration value
%%
%function FcnGetEnumTypeDefaultValue(id) void
    %assign dtId = LibGetDataTypeIdAliasedThruToFromId(id)
    %return SLibGetEnumTypeValueFromIndex(id, FcnGetEnumTypeIndexOfDefaultValue(id))
%endfunction

%% Function: SLibGetEnumTypeStringFromIndex ========================================================
%% Abstract:
%%   For enumerated data types, get original string for a specific enumeration
%%   (does not include class name as prefix)
%%
%function SLibGetEnumTypeStringFromIndex(id, enumIdx) void
    %assign dtId = LibGetDataTypeIdAliasedThruToFromId(id)
    %return ::CompiledModel.DataTypes.DataType[dtId].Enumeration[enumIdx].String
%endfunction

%% Function: SLibGetEnumTypeValueFromIndex =========================================================
%% Abstract:
%%   For enumerated data types, get value for a specific enumeration
%%
%function SLibGetEnumTypeValueFromIndex(id, enumIdx) void
    %assign dtId = LibGetDataTypeIdAliasedThruToFromId(id)
    %return ::CompiledModel.DataTypes.DataType[dtId].Enumeration[enumIdx].Value
%endfunction

%% Function: SLibGetEnumTypeCodeGenStringFromIndexForVariantPreprocessor ===========================
%% Abstract:
%%   For enumerated data types, get enumeral string for a specific enumeration
%%   it does not include the enumeration name
%%
%function SLibGetEnumTypeCodeGenStringFromIndexForVariantPreprocessor(id, enumIdx) void
    %assign dtId = LibGetDataTypeIdAliasedThruToFromId(id)
    %assert(dtId < ::CompiledModel.DataTypes.NumDataTypes)
    %return ::CompiledModel.DataTypes.DataType[dtId].Enumeration[enumIdx].String
%endfunction

%% Function: SLibGetEnumTypeMinValue ===============================================================
%% Abstract:
%%   For enumerated data types, get minimum underlying value
%%
%function SLibGetEnumTypeMinValue(id) void
    %assign dtId = LibGetDataTypeIdAliasedThruToFromId(id)
    %assign dt = ::CompiledModel.DataTypes.DataType[dtId]
    %assign minValue = dt.Enumeration[0].Value

    %foreach enumIdx = dt.NumEnumerations
        %if (dt.Enumeration[enumIdx].Value < minValue)
            %assign minValue = dt.Enumeration[enumIdx].Value
        %endif
    %endforeach

    %return minValue
%endfunction

%% Function: SLibGetEnumTypeMaxValue ===============================================================
%% Abstract:
%%   For enumerated data types, get maximum underlying value
%%
%function SLibGetEnumTypeMaxValue(id) void
    %assign dtId = LibGetDataTypeIdAliasedThruToFromId(id)
    %assign dt = ::CompiledModel.DataTypes.DataType[dtId]
    %assign maxValue = dt.Enumeration[0].Value

    %foreach enumIdx = dt.NumEnumerations
        %if (dt.Enumeration[enumIdx].Value > maxValue)
            %assign maxValue = dt.Enumeration[enumIdx].Value
        %endif
    %endforeach

    %return maxValue
%endfunction

%% Function: SLibConvertBetweenEnumType ============================================================
%% Abstract:
%%   Convert between enumerated data types
%%
%%   Arguments:
%%     outDType = desired output data type
%%     inDType = actual input data type
%%     inLabel = input signal
%%     options = options
%%     outLabel = output signal
%function SLibConvertBetweenEnumType(outDType,inDType,inLabel,options,outLabel) Output
    %assign outDTypeName = LibGetDataTypeNameFromId(outDType)
    %if outDType == tSS_BOOLEAN
        %assign gnd = SLibGetEnumTypeCodeGenStringFromIndex(inDType, 0)
        %<outLabel> = (%<outDTypeName>) %<inLabel>;
    %elseif LibIsEnumDataType(outDType) %% Output data type is an enumerated data type
        %assign numStrings = FcnGetEnumTypeNumEnums(outDType)
        /* Convert to enumerated data type '%<outDTypeName>' */
        switch (%<inLabel>) {
            %foreach enumIdx = numStrings
                %assign enumValue = SLibGetEnumTypeValueFromIndex(outDType, enumIdx)
                %%
                %% Check if we have already generated a case for this enumValue
                %assign writeOutCase = TLC_TRUE
                %foreach tmpIdx = enumIdx
                    %if (enumValue == SLibGetEnumTypeValueFromIndex(outDType, tmpIdx))
                        %% Repeated value found, do not write it out
                        %assign writeOutCase = TLC_FALSE
                        %continue
                    %endif
                %endforeach
                %%
                %if writeOutCase
                    %assign enumString = SLibGetEnumTypeCodeGenStringFromIndex(outDType, enumIdx)
                    case %<enumValue>:
                    %<outLabel> = %<enumString>;
                    break;
                %endif
            %endforeach
            default:
            %assign assertText = "false && \"Invalid value for enumerated data type '%<outDTypeName>'.\""
            %<LibGenMathFcnCall("utAssert",tSS_BOOLEAN,assertText,"")>;
            /* Assigning default enumeration string */
            %<outLabel> = %<FcnGetEnumTypeDefaultCodeGenString(outDType)>;
        }
    %else
        %<outLabel> = (%<outDTypeName>) %<inLabel>;
    %endif
    %return 1
%endfunction


%% Function: LibDataTypeIsShared ===================================================================
%% Abstract:
%%   Return whether a data type will be tracked in the shared location
%%   if we are generating code there.
%%
%function LibDataTypeIsShared(dtIdx)
    %if ISFIELD(::CompiledModel.DataTypes.DataType[dtIdx], "IsShared")
        %return ::CompiledModel.DataTypes.DataType[dtIdx].IsShared
    %else
        %return TLC_FALSE
    %endif

%endfunction

%% Function: LibHeaderFileForDataType ==============================================================
%% Abstract:
%%   Return the header file for a data type
%%
%function LibHeaderFileForDataType(dt)
    %return LibHeaderForDataTypeIdx(dt.Id)
%endfunction

%% Function: LibHeaderFileFromOPForDataType ========================================================
%% Abstract:
%%   Return the header file for a data type
%%   The "FromOP" means this one fishes it out from the ObjectProperties
%%
%function LibHeaderFileFromOPForDataType(dt)
    %return LibHeaderFromOPForDataTypeIdx(dt.Id)
%endfunction

%% Function: LibSetHeaderFileForDataType ===========================================================
%% Abstract:
%%   Set the header file for a data type
%%
%function LibSetHeaderFileForDataType(dt, val) void
    %<LibSetHeaderForDataTypeIdx(dt.Id, val)>;
%endfunction

%% Function: LibDataTypeDependsOnHeaderFiles =======================================================
%% Abstract:
%%   Returns an array of include files that 'dt' depends on.
%%   The caller will add these to the RequiredIncludes section of
%%   the header file 'dt' is being written to.
%%   'dtHeaderFile' is the header file 'dt' itself is being written to,
%%   which we use to ensure the file doesn't include itself.
%%   Example: dt is struct type s1.
%%            s1 has fields a1 and a2.
%%            a1 and a2 are alias types, exported to a1.h and a2.h respectively.
%%            Return ['a1.h','a2.h']
%%
%function LibDataTypeDependsOnHeaderFiles(dt, dtHeaderFile)
    %assign dependsOnHeaderFiles = []
    %if LibIsAliasDataType(dt.Id)
        %% An alias type depends on the type it is aliased to.
        %assign aliasedToId = LibGetDataTypeIdAliasedToFromId(dt.Id)
        %% Note this gets either imported or exported header file, if any
        %assign dependsOnHeaderFileQuoted = LibHeaderForDataTypeIdx(aliasedToId)
        %% Include the header file if there is one. Noted it is quoted, but
        %% we want to return an array with unquoted header files.
        %if dependsOnHeaderFileQuoted != ""
            %assign sz = SIZE(dependsOnHeaderFileQuoted)
            %assign len = sz[1]
            %assign dependsOnHeaderFile = Substring(dependsOnHeaderFileQuoted, 1, len-1)
            %if dependsOnHeaderFile != dtHeaderFile
                %assign dependsOnHeaderFiles = AddToHeaderFiles(dependsOnHeaderFiles, dependsOnHeaderFile)
            %endif
        %endif
    %elseif LibIsStructDataType(dt.Id)
        %% A struct type depends on its element types
        %assign numElements = dt.NumElements
        %foreach eIdx = numElements
            %assign eDtId = LibDataTypeElementDataTypeId(dt.Id, eIdx)
            %% Note this gets either imported or exported header file, if any
            %assign dependsOnHeaderFileQuoted = LibHeaderForDataTypeIdx(eDtId)
            %% Include the header file if there is one. Noted it is quoted, but
            %% we want to return an array with unquoted header files.
            %% AddToHeaderFiles eliminates duplicates, so we don't add the same
            %% header file in multiple iterations of this loop.
            %if dependsOnHeaderFileQuoted != ""
                %assign sz = SIZE(dependsOnHeaderFileQuoted)
                %assign len = sz[1]
                %assign dependsOnHeaderFile = Substring(dependsOnHeaderFileQuoted, 1, len-1)
                %if dependsOnHeaderFile != dtHeaderFile
                    %assign dependsOnHeaderFiles = AddToHeaderFiles(dependsOnHeaderFiles, dependsOnHeaderFile)
                %endif
            %endif
            %if LibIsDataTypeMultiWordFixpt(eDtId)
                %assign dependsOnHeaderFiles = AddToHeaderFiles(dependsOnHeaderFiles, SLibCoderMultiwordTypesFilename())
            %endif
        %endforeach
    %endif
    %return dependsOnHeaderFiles
%endfunction

%% Function: LibRemoveDependsOnHeaderFiles =========================================================
%% Abstract:
%%  Computes dependencies of 'dt' for the purpose of removing these from
%%  headerFiles (which are the (quoted) header files included from the top-level model_types.h).
%%  Example: model_types.h includes "a1.h" that in turn includes "a2.h" and "a3.h".
%%  Let's say we're being called with type a1 (defined in "a1.h").
%%  Let's say the passed-in headerFiles array consists of ['"a1.h"','"a2.h"','"a3.h"'].
%%  Then the returned array, after subtracting out the dependent header files,
%%  is ['"a1.h"'].
%%  The passed-in 'dtHeaderFile' is the header file 'dt' itself is being written to
%%   ("a1.h" in this example), which we use to ensure we don't remove the top-level one.
%%
%function LibRemoveDependsOnHeaderFiles(dt, headerFiles, dtHeaderFile)
    %if LibIsAliasDataType(dt.Id)
        %% An alias type depends on the type it is aliased to.
        %assign aliasedToId = LibGetDataTypeIdAliasedToFromId(dt.Id)
        %assign dependsOnHeaderFile = LibHeaderForDataTypeIdx(aliasedToId)
        %if dependsOnHeaderFile != "" && dependsOnHeaderFile != dtHeaderFile
            %assign headerFiles = RemoveFromHeaderFiles(headerFiles, dependsOnHeaderFile)
        %endif
    %elseif LibIsStructDataType(dt.Id)
        %% A struct type depends on its element types
        %assign numElements = dt.NumElements
        %foreach eIdx = numElements
            %assign eDtId = LibDataTypeElementDataTypeId(dt.Id, eIdx)
            %assign dependsOnHeaderFile = LibHeaderForDataTypeIdx(eDtId)
            %if dependsOnHeaderFile != "" && dependsOnHeaderFile != dtHeaderFile
                %assign headerFiles = RemoveFromHeaderFiles(headerFiles, dependsOnHeaderFile)
            %endif
        %endforeach
    %endif
    %return headerFiles
%endfunction

%% Function: LibDescriptionForDataTypeIdx ==========================================================
%% Abstract:
%%   Return the Data Description string from the data type index
%%
%function LibDescriptionForDataTypeIdx(id) void
    %if !SLibDataTypeHasObject(id)
        %return ""
    %else
        %return ::CompiledModel.DataTypes.DataType[id].Object.ObjectProperties.Description
    %endif
%endfunction

%% Function: LibHeaderForDataTypeIdx ===============================================================
%% Abstract:
%%   Return the header file for Data Type from the data type index
%%
%function LibHeaderForDataTypeIdx(id) void
    %if ISFIELD(::CompiledModel.DataTypes.DataType[id], "HeaderFile")
        %return ::CompiledModel.DataTypes.DataType[id].HeaderFile
    %else
        %return ""
    %endif
%endfunction

%% Function: LibHeaderFromOPForDataTypeIdx =========================================================
%% Abstract:
%%   Return the header file for Data Type from the data type index
%%   The "FromOP" means this fishes it out from the ObjectProperties.
%%
%function LibHeaderFromOPForDataTypeIdx(id) void
    %if ::CompiledModel.DataTypes.DataType[id].HasObject == 0
        %return ""
    %else
        %if ISFIELD(::CompiledModel.DataTypes.DataType[id].Object.ObjectProperties, "HeaderFile")
            %return ::CompiledModel.DataTypes.DataType[id].Object.ObjectProperties.HeaderFile
        %else
            %return ""
        %endif
    %endif
%endfunction

%% Function: LibSetHeaderForDataTypeIdx ============================================================
%% Abstract:
%%   Set the header file for Data Type from the data type index
%%
%function LibSetHeaderForDataTypeIdx(id, val) void
    %assign ::CompiledModel.DataTypes.DataType[id].HeaderFile = val
%endfunction

%% Function: SLibDataTypeOpenCVFcnName =============================================================
%% Abstract:
%%   Return true if FcnName is coming from OpenCV Type
%function SLibDataTypeOpenCVFcnName(id) void
    %if ISFIELD(::CompiledModel.DataTypes.DataType[id], "ConstructFcnName")
        %if STRNCMP(::CompiledModel.DataTypes.DataType[id].ConstructFcnName, "opencv::",8)
            %return TLC_TRUE
        %endif
        %return TLC_FALSE
    %endif
%endfunction

%% Function: SLibDataTypeConstruct =================================================================
%% Abstract:
%%   Construct memory of this data type
%%
%function SLibDataTypeConstruct(mem, id) void
    %if ISFIELD(::CompiledModel.DataTypes.DataType[id], "CoderPropertiesMap")
        %assign props = ::CompiledModel.DataTypes.DataType[id].CoderPropertiesMap
        %if !ISFIELD(props, "TLCFileName")
            %<SLibReportErrorWithIdAndArgs("RTW:tlc:OpaqueTypeUndefinedTLCFileName", LibGetDataTypeNameFromId(id))>
        %endif
        %if !ISFIELD(props, "TLCConstructFunctionName")
            %<SLibReportErrorWithIdAndArgs("RTW:tlc:OpaqueTypeUndefinedTLCConstructFunctionName", LibGetDataTypeNameFromId(id))>
        %endif
        %if !ISFIELD(props, "TLCGenType")
            %<SLibReportErrorWithIdAndArgs("RTW:tlc:OpaqueTypeUndefinedTLCGenType", LibGetDataTypeNameFromId(id))>
        %endif
        %assign fcnName = props.TLCConstructFunctionName
        %assign genType = props.TLCGenType
        %if !%<GENERATE_TYPE_FUNCTION_EXISTS(props, fcnName, genType)>
            %assign fileName = FEVAL("which",props.TLCFileName)
            %generatefile "%<genType>" "%<fileName>"
        %endif
        %if !%<GENERATE_TYPE_FUNCTION_EXISTS(props, fcnName, genType)>
            %assign errTxt = "The function %<fcnName> does not exist in file: %<fileName>, " + ...
                "but it is needed for datatype %<LibGetDataTypeNameFromId(id)>"
            %<LibReportFatalError(errTxt)>
        %endif
        %openfile buffer
        %<GENERATE_TYPE(props, fcnName, genType, mem)>\
        %closefile buffer
        %return buffer
    %endif
    %return SLibDataTypeConstructFcnName(id) + "(" + mem + ", " + SLibGetNullDefinitionFromTfl() + ")"
%endfunction

%% Function: SLibDataTypeDestruct ==================================================================
%% Abstract:
%%   Destruct memory of this data type
%%
%function SLibDataTypeDestruct(mem, id) void
    %if ISFIELD(::CompiledModel.DataTypes.DataType[id], "CoderPropertiesMap")
        %assign props = ::CompiledModel.DataTypes.DataType[id].CoderPropertiesMap
        %if !ISFIELD(props, "TLCFileName")
            %<SLibReportErrorWithIdAndArgs("RTW:tlc:OpaqueTypeUndefinedTLCFileName", LibGetDataTypeNameFromId(id))>
        %endif
        %if !ISFIELD(props, "TLCDestructFunctionName")
            %<SLibReportErrorWithIdAndArgs("RTW:tlc:OpaqueTypeUndefinedTLCDestructFunctionName", LibGetDataTypeNameFromId(id))>
        %endif
        %if !ISFIELD(props, "TLCGenType")
            %<SLibReportErrorWithIdAndArgs("RTW:tlc:OpaqueTypeUndefinedTLCGenType", LibGetDataTypeNameFromId(id))>
        %endif
        %assign fcnName = props.TLCDestructFunctionName
        %assign genType = props.TLCGenType
        %if !%<GENERATE_TYPE_FUNCTION_EXISTS(props, fcnName, genType)>
            %assign fileName = FEVAL("which",props.TLCFileName)
            %generatefile "%<genType>" "%<fileName>"
        %endif
        %if !%<GENERATE_TYPE_FUNCTION_EXISTS(props, fcnName, genType)>
            %assign errTxt = "The function %<fcnName> does not exist in file: %<fileName>, " + ...
                "but it is needed for datatype %<LibGetDataTypeNameFromId(id)>"
            %<LibReportFatalError(errTxt)>
        %endif
        %openfile buffer
        %<GENERATE_TYPE(props, fcnName, genType, mem)>\
        %closefile buffer
        %return buffer
    %endif
    %return SLibDataTypeDestructFcnName(id) + "(" + mem + ", " + SLibGetNullDefinitionFromTfl() + ")"
%endfunction

%% Function: SLibDataTypeContainedDataFcn ==========================================================
%% Abstract:
%%   Return the name of Construct TLC function for this data type
%%
%function SLibDataTypeContainedDataFcn(id) void
    %if ISFIELD(::CompiledModel.DataTypes.DataType[id], "ContainedData")
        %return ::CompiledModel.DataTypes.DataType[id].ContainedData
    %else
        %return ""
    %endif
%endfunction

%% Function: SLibDataTypeDestructFcnName ===========================================================
%% Abstract:
%%   Return the name of Destruct TLC function for this data type
%%
%function SLibDataTypeDestructFcnName(id) void
    %if ISFIELD(::CompiledModel.DataTypes.DataType[id], "DestructFcnName")
        %return ::CompiledModel.DataTypes.DataType[id].DestructFcnName
    %else
        %return ""
    %endif
%endfunction

%% Function: SLibDataTypeDeepCopyFcnName ===========================================================
%% Abstract:
%%   Return the name of DeepCopy TLC function for this data type
%%
%function SLibDataTypeDeepCopyFcnName(id) void
    %if ISFIELD(::CompiledModel.DataTypes.DataType[id], "DeepCopyFcnName")
        %return ::CompiledModel.DataTypes.DataType[id].DeepCopyFcnName
    %else
        %return ""
    %endif
%endfunction

%% Function: LibConvertBetweenTLCFcnName ===========================================================
%% Abstract:
%%   Return the name of ConvertBetween TLC function
%%
%function LibConvertBetweenTLCFcnName(id) void
    %if ISFIELD(::CompiledModel.DataTypes.DataType[id], "ConvertBetweenTLCFcnName")
        %return ::CompiledModel.DataTypes.DataType[id].ConvertBetweenTLCFcnName
    %else
        %return ""
    %endif
%endfunction



%% Function: LibConvertBetweenTLCFcnFile ===========================================================
%% Abstract:
%%   Return the file of ConvertBetween TLC function
%%
%function LibConvertBetweenTLCFcnFile(id) void
    %if ISFIELD(::CompiledModel.DataTypes.DataType[id], "ConvertBetweenTLCFcnFile")
        %return ::CompiledModel.DataTypes.DataType[id].ConvertBetweenTLCFcnFile
    %else
        %return ""
    %endif
%endfunction



%% Function: LibIsPositiveTLCFcnName ===============================================================
%% Abstract:
%%   Return the name of IsPositive TLC function
%%
%function LibIsPositiveTLCFcnName(id) void
    %if ISFIELD(::CompiledModel.DataTypes.DataType[id], "IsPositiveTLCFcnName")
        %return ::CompiledModel.DataTypes.DataType[id].IsPositiveTLCFcnName
    %else
        %return ""
    %endif
%endfunction


%% Function: LibIsPositiveTLCFcnFile ===============================================================
%% Abstract:
%%   Return the file of IsPositive TLC function
%%
%function LibIsPositiveTLCFcnFile(id) void
    %if ISFIELD(::CompiledModel.DataTypes.DataType[id], "IsPositiveTLCFcnFile")
        %return ::CompiledModel.DataTypes.DataType[id].IsPositiveTLCFcnFile
    %else
        %return ""
    %endif
%endfunction


%% Function: LibSignTLCFcnFile =====================================================================
%% Abstract:
%%   Return the file of Sign TLC function
%%
%function LibSignTLCFcnFile(id) void
    %if ISFIELD(::CompiledModel.DataTypes.DataType[id], "SignTLCFcnFile")
        %return ::CompiledModel.DataTypes.DataType[id].SignTLCFcnFile
    %else
        %return ""
    %endif
%endfunction

%% DocFunction{Other Useful Functions}: LibGetRecordStorageDataTypeId ===============
%% Abstract:
%%   Return the storage data type ID for a given data record.
%%
%function LibGetRecordStorageDataTypeId(rec) void
    %return LibGetDataTypeStorageIdFromId(LibGetRecordDataTypeId(rec))
%endfunction

%function SLibGetVectorDimsForCGType(cgTypeIdx)
    %if cgTypeIdx < ::CompiledModel.DataTypes.NumSLBuiltInDataTypes
        %return ""
    %else
        %return LibCGTypeSymbolicVectorDims(cgTypeIdx)
    %endif
%endfunction


%% DocFunction{Other Useful Functions}: LibGetRecordVectorDims ============
%% Abstract:
%%   Return the dimension index specification for a given data record.
%%
%function LibGetRecordVectorDims(rec)
    %assign cgTypeIdx = SLibGetRecordContainerCGTypeIdx(rec)
    %return SLibGetVectorDimsForCGType(cgTypeIdx)
%endfunction

%% DocFunction{Other Useful Functions}: LibGetRecordVectorWidth ===========
%% Abstract:
%%   Return the width for a given data record.
%%
%function LibGetRecordVectorWidth(rec)
    %assign cgTypeIdx = SLibGetRecordContainerCGTypeIdx(rec)
    %if cgTypeIdx < ::CompiledModel.DataTypes.NumSLBuiltInDataTypes
        %return ""
    %else
        %return LibCGTypeSymbolicVectorDims(cgTypeIdx)
    %endif
%endfunction

%% DocFunction{Other Useful Functions}: LibRecordHasSymbolicWidth ===============
%% Abstract:
%%   Returns true if a given data record  has a symbolic width.
%%
%function LibRecordHasSymbolicWidth(rec) void
    %if ISFIELD(rec, "RecordType") && rec.RecordType == "ZcSignalInfo"
        %return 0
    %endif

    %assign cgTypeIdx = SLibGetRecordContainerCGTypeIdx(rec)
    %assign cgType = ::CompiledModel.CGTypes.CGType[cgTypeIdx]
    %return ISFIELD(cgType, "SymbolicWidth")
%endfunction %% LibRecordHasSymbolicWidth

%% DocFunction{Other Useful Functions}: LibGetRecordSymbolicWidth ===============
%% Abstract:
%%   Return the symbolic width for a given data record.
%% Eventually this function will be replaced by LibGetRecordSymbolicDims.
%%
%function LibGetRecordSymbolicWidth(rec) void
    %return SLibGetSymbolicWidthForCGType(...
        SLibGetRecordContainerCGTypeIdx(rec))
%endfunction %% LibGetRecordSymbolicWidth

%% DocFunction{Other Useful Functions}: LibGetRecordSymbolicDims ===============
%% Abstract:
%%   Return the symbolic dimensions for a given data record.
%% Eventually this function will replace LibGetRecordSymbolicWidth.
%%
%function LibGetRecordSymbolicDims(rec) void
    %return SLibGetSymbolicDimsForCGType(...
        SLibGetRecordContainerCGTypeIdx(rec))
%endfunction %% LibGetRecordSymbolicDims

%% DocFunction{Other Useful Functions}: LibGetRecordNumDimensions ==============
%% Abstract:
%%   Return the number of dimensions for a given data record.
%%
%function LibGetRecordNumDimensions(rec) void
    %if ISFIELD(rec, "NumDimensions")
        %assign dimensions = rec.NumDimensions
    %elseif ISFIELD(rec, "CGTypeIdx")
        %assign dimensions = LibCGTypeNumDimensions(LibGetRecordCGTypeIdx(rec))
    %else
        %assign errTxt = "NumDimensions is not contained within the specified record"
        %<LibReportFatalError(errTxt)>
    %endif
    %return dimensions
%endfunction

%% DocFunction{Other Useful Functions}: LibGetRecordNumDimsFromContainerCgTypeIdx ===
%% Abstract:
%%   Return the number of dimensions for a given data record from the container
%% CGType index.
%%
%function LibGetRecordNumDimsFromContainerCgTypeIdx(rec) void
    %return LibCGTypeNumDimensions(SLibGetRecordContainerCGTypeIdx(rec))
%endfunction

%% DocFunction{Other Useful Functions}: LibGetRecordSymbolicDimensions =========
%% Abstract:
%%   Return the symbolic dimensions for a given data record.
%%
%function LibGetRecordSymbolicDimensions(rec) void
    %if ISFIELD(rec, "CGTypeIdx")
        %assign dimensions = LibCGTypeSymbolicDimensions(LibGetRecordCGTypeIdx(rec))
    %else
        %assign errTxt = ...
            "Symbolic dimensions are not contained within the specified record"
        %<LibReportFatalError(errTxt)>
    %endif
    %return dimensions
%endfunction

%% Function: LibGetRecordDataTypeName ==============================================================
%% Abstract:
%%   Return the data type name for a specified record.
%%
%%   Arguments:
%%     rec  - TLC record
%%     reim - Return the data type name or the complex data type name
%%            depending if rec is a complex record and the value of reim.
%%            Assuming Name="real_T" and ComplexName="creal_T", for example,
%%            creal_T is returned for a complex record if reim is specified as
%%            tRealPart or tImagPart.  Otherwise real_T is returned.
%% TopTester: test/toolbox/simulink/blocks/lib_MathOperations/Gain/rtw/tdtgain4.m
%%
%function LibGetRecordDataTypeName(rec, reim)
    %return LibGetRecordOptStdDataTypeName(rec, reim, TLC_FALSE)
%endfunction

%% Function: LibGetRecordOptStdDataTypeName
%% Abstract:
%%   Return the data type name for a specified record.
%%
%%   Arguments:
%%     rec  - TLC record
%%     reim - Return the data type name or the complex data type name
%%            depending if rec is a complex record and the value of reim.
%%            Assuming Name="real_T" and ComplexName="creal_T", for example,
%%            creal_T is returned for a complex record if reim is specified as
%%            tRealPart or tImagPart.  Otherwise real_T is returned.
%%     useStdContainerName - Whether to return std container name if the type is
%%                           a pre-lowering std container type.
%%
%function LibGetRecordOptStdDataTypeName(rec, reim, useStdContainerName)
    %if ISFIELD(rec, "CGTypeIdx")
        %assign cgTypeIdx = SLibGetRecordContainerCGTypeIdx(rec)
        %if reim != ""
            %assign cgTypeIdx = LibCGTypeScalarBaseType(cgTypeIdx)
        %endif
        %return LibOptStdCGTypeName(cgTypeIdx, useStdContainerName)
    %else
        %if reim == "" && LibGetRecordIsComplex(rec)
            %return LibGetDataTypeComplexNameFromId(LibGetRecordDataTypeId(rec))
        %else
            %return LibGetDataTypeNameFromId(LibGetRecordDataTypeId(rec))
        %endif
    %endif
%endfunction


%% Function: LibGetRecordAliasedThruDataTypeName ===================================================
%% Abstract:
%%   Return the aliased thru data type name for a specified record.
%%
%%   Arguments:
%%     rec  - TLC record
%%     reim - Return the data type name or the complex data type name
%%            depending if rec is a complex record and the value of reim.
%%            Assuming Name="real_T" and ComplexName="creal_T", for example,
%%            creal_T is returned for a complex record if reim is specified as
%%            tRealPart or tImagPart.  Otherwise real_T is returned.
%% TopTester: test/toolbox/simulink/blocks/lib_MathOperations/Gain/rtw/tdtgain4.m
%%
%function LibGetRecordAliasedThruDataTypeName(rec, reim)
    %assign id = LibGetDataTypeIdAliasedThruToFromId(LibGetRecordDataTypeId(rec))
    %if reim == "" && LibGetRecordIsComplex(rec)
        %return LibGetDataTypeComplexNameFromId(id)
    %else
        %return LibGetDataTypeNameFromId(id)
    %endif
%endfunction

%% Function: LibGetRecordCompositeDataTypeName =====================================================
%% Abstract:
%%   Return the composite data type name for a specified record.  That is,
%%   return ComplexName if it exists, otherwise, return Name.
%%
%function LibGetRecordCompositeDataTypeName(rec) void
    %return LibGetRecordCompositeOptStdDataTypeName(rec, TLC_FALSE)
%endfunction

%% Function: LibGetRecordCompositeOptStdDataTypeName
%% Abstract:
%%   Return the composite data type name for a specified record.  That is,
%%   return ComplexName if it exists, otherwise, return Name.
%%
%%   Specify the useStdContainerName argument as whether to return std container name
%%   if the type is a pre-lowering std container type.
%%
%function LibGetRecordCompositeOptStdDataTypeName(rec, useStdContainerName) void
    %return LibGetRecordOptStdDataTypeName(rec, "", useStdContainerName)
%endfunction




%% Function: LibGetGroundName ======================================================================
%% Abstract:
%%   For a given record and real/imaginary specifier, return the name used for
%%   ground or complex ground depending the record type and the value of reim.
%%   Specifically, return:
%%
%%   Name        - Record not complex
%%   Name        - Record complex, and reim equals tRealPart or tImagPart
%%   ComplexName - Record complex and reim is null
%%
%%   Note that the model name is added as a prefix to both Name and ComplexName.
%%   this avoids name clashing when linking multiple models into the same
%%   executable.
%%
%%   Arguments:
%%     rec  - record containing a data type index
%%     reim - tRealPart, tImagPart or ""
%%
%function LibGetGroundName(rec, reim) void
    %assign      dtID = LibGetRecordDataTypeId(rec)
    %assign isComplex = LibGetRecordIsComplex(rec)
    %return SLibGetDtGroundName(dtID, isComplex, reim)
%endfunction

%% Function: SLibIsGroundValueRegistered ===========================================================
%% Abstract:
%%   Returns true if there is valid ground value is registered for dtRec
%%
%function SLibIsGroundValueRegistered(dtRec)
    %assign dTypeId = LibGetRecordDataTypeId(dtRec)
    %assign useIRGroundName = LibIsStructDataType(dTypeId) && ISFIELD(dtRec, "GroundVariableName")

    %if useIRGroundName
        %return TLC_TRUE
    %endif
    %if !ISFIELD(dtRec, "GroundValue")
        %return TLC_FALSE
    %endif
    %assign value = dtRec.GroundValue
    %% must check that the value was set for this data type
    %if ISEQUAL(value, "")
        %return TLC_FALSE
    %endif
    %return TLC_TRUE
%endfunction
%% Function: LibGetGroundValue =====================================================================
%% Abstract:
%%   For a given record and real/imaginary specifier, return the value used for
%%   ground depending on the record type and the value of reim.
%%   Specifically, return:
%%
%%   value - Record not complex
%%   value - Record complex, and reim equals tRealPart or tImagPart
%%   ERROR - Record complex and reim is null (complex values are undefined)
%%
%%   Note the value may be a string or an actual numeric value.  For example,
%%   ground is 0.0 for tSS_DOUBLE, but it may be "0x08" for a fixed-point
%%   8-bit integer with a bias.
%%
%%   Arguments:
%%     rec  - record containing a data type index
%%     reim - tRealPart, tImagPart or ""
%%
%function LibGetGroundValue(rec, reim) void
    %assign value = SLibGetGroundValueStrictOpt(rec, reim, 1)
    %return value
%endfunction

%% Function: SLibGetDtGroundValue ==================================================================
%% Abstract:
%%   Returns the value used for a ground or complex ground depending the
%%   data type ID, the value of reim and complexity.
%%   See SLibGetGroundValueStrictOpt for more details.
%%
%function SLibGetDtGroundValue(dtID, isComplex, reim, isStrict) void
    %if reim == "" && isComplex
        %% complex ground value undefined
        %assign errTxt = "Complex ground values are undefined."
        %<LibReportFatalError(errTxt)>
    %endif
    %% non-complex ground or real/imaginary part of complex ground
    %return SLibGetGroundValueFromIdStrictOpt(dtID, isStrict)
%endfunction

%% Function: SLibGetGroundValueStrictOpt ===========================================================
%% Abstract:
%%   Extend LibGetGroundValue
%%   with an option to be "strict" or "robust" about the registration of
%%   grounds by custom data types.
%%       In "strict" mode, an error will
%%   occur if ground has not been properly registered in TLC for
%%   the data type.
%%       In "robust" mode, if ground has not been properly registered
%%   then a default value of zero will be return (with no error or
%%   warning).
%%
%function SLibGetGroundValueStrictOpt(rec, reim, isStrict) void
    %assign dataTypeID = LibGetRecordDataTypeId(rec)
    %assign  isComplex = LibGetRecordIsComplex(rec)
    %return SLibGetDtGroundValue(dataTypeID, isComplex, reim, isStrict)
%endfunction


%%
%% Function: SLibGetGroundValueFromIdStrictOpt =====================================================
%% Abstract:
%%   Wrapper around SLibGetIRorTLCGround
%%   If we have a IR ground name available, that will be returned
%%   Else, the TLC ground name or value will be returned
%function SLibGetGroundValueFromIdStrictOpt(dTypeId,isStrict) void
    %return SLibGetIRorTLCGround(dTypeId, isStrict, TLC_FALSE, TLC_TRUE)
%endfunction

%% Function: SLibImageColorFormatFromId ============================================================
%% Abstract:
%%   Return image color format from data type ID
%%
%function SLibImageColorFormatFromId(id)
    %assert LibIsImageDataType(id)
    %return CompiledModel.DataTypes.DataType[id].ColorFormat
%endfunction

%% Function: SLibImageLayoutFromId =================================================================
%% Abstract:
%%   Return image layout from data type ID
%%
%function SLibImageLayoutFromId(id)
    %assert LibIsImageDataType(id)
    %return CompiledModel.DataTypes.DataType[id].Layout
%endfunction

%% Function: SLibImageBaseTypeFromId ===============================================================
%% Abstract:
%%   Return image base type from data type ID
%%
%function SLibImageBaseTypeFromId(id)
    %assert LibIsImageDataType(id)
    %return CompiledModel.DataTypes.DataType[id].ClassUnderlying
%endfunction

%% Function: SLibImageNumRowsFromId ================================================================
%% Abstract:
%%   Return image num rows from data type ID
%%
%function SLibImageNumRowsFromId(id)
    %assert LibIsImageDataType(id)
    %return CompiledModel.DataTypes.DataType[id].NumRows
%endfunction

%% Function: SLibImageNumColsFromId ================================================================
%% Abstract:
%%   Return image num columns from data type ID
%%
%function SLibImageNumColsFromId(id)
    %assert LibIsImageDataType(id)
    %return CompiledModel.DataTypes.DataType[id].NumCols
%endfunction

%% Function: SLibImageNumChannelsFromId ============================================================
%% Abstract:
%%   Return image num channels from data type ID
%%
%function SLibImageNumChannelsFromId(id)
    %assert LibIsImageDataType(id)
    %return CompiledModel.DataTypes.DataType[id].NumChannels
%endfunction

%function SLibDynamicArrayContainedDataTypeFromId(id)
    %assert LibDataTypeIsDynamicMatrix(id)
    %return CompiledModel.DataTypes.DataType[id].ContainedDataTypeId
%endfunction

%function SLibDynamicArrayIsContainedDataComplexFromId(id)
    %assert LibDataTypeIsDynamicMatrix(id)
    %return CompiledModel.DataTypes.DataType[id].IsContainedDataComplex
%endfunction

%function SLibDynamicArrayContainedDataDimensionsFromId(id)
    %assert LibDataTypeIsDynamicMatrix(id)
    %return CompiledModel.DataTypes.DataType[id].ContainedDataDimensions
%endfunction

%% Function: SLibIsSignedFromId ====================================================================
%% Abstract:
%%   Return whether the data type corresponding to a data type ID is signed
%%
%function SLibIsSignedFromId(id) void
    %switch LibGetDataTypeIdAliasedThruToFromId(id)
      %case tSS_UINT8
      %case tSS_UINT16
      %case tSS_UINT32
      %case tSS_BOOLEAN
        %return 0
        %%break
      %case tSS_INT8
      %case tSS_INT16
      %case tSS_INT32
      %case tSS_DOUBLE
      %case tSS_SINGLE
        %return 1
        %%break
      %default
        %if LibIsHalfDataType(LibGetDataTypeIdAliasedThruToFromId(id))
            %return 1
        %endif
        %assign errTxt = "Invalid data type %<dtypeName>."
        %<LibBlockReportFatalError([], errTxt)>
        %break
    %endswitch
%endfunction


%% Function: SLibIsUnsignedFromId ==================================================================
%% Abstract:
%%   Return whether the data type corresponding to a data type ID is an
%%   unsigned
%%
%function SLibIsUnsignedFromId(id) void
    %return !SLibIsSignedFromId(id)
%endfunction

%% Function: SLibGetMLidentFcnFromId ===============================================================
%% Abstract:
%%   This function returns a mx-function call which check a mxArray datatype
%%   for compatibility with the TLC datatype id.
%% TopTester: test/toolbox/simulink/blocks/lib_MathOperations/Gain/rtw/tGainBlk_Codegencheck_RapidAccel.m
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tmVariantsRSim.m
%%
%function SLibGetMLidentFcnFromId(id) void
    %switch LibGetDataTypeIdAliasedThruToFromId(id)
      %case tSS_DOUBLE
        %return "mxIsDouble"
      %case tSS_SINGLE
        %return "mxIsSingle"
      %case tSS_UINT8
        %return "mxIsUint8"
      %case tSS_UINT16
        %return "mxIsUint16"
      %case tSS_UINT32
        %return "mxIsUint32"
      %case tSS_BOOLEAN
        %return "mxIsLogical"
      %case tSS_INT8
        %return "mxIsInt8"
      %case tSS_INT16
        %return "mxIsInt16"
      %case tSS_INT32
        %return "mxIsInt32"
      %default
        %return "mxIsNumeric"
    %endswitch
%endfunction %% SLibGetMLidentFcnFromId


%% Function: SLibGetANCICDataTypeFromId ============================================================
%% Abstract:
%%   This function returns the equivalent ANCI data type to the specified
%%   TLC datatype id.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%%
%function SLibGetANSICDataTypeFromId(id) void
    %switch LibGetDataTypeIdAliasedThruToFromId(id)
      %case tSS_DOUBLE
        %return ::AnsiDataTypeName.tSS_DOUBLE
      %case tSS_SINGLE
        %return ::AnsiDataTypeName.tSS_SINGLE
      %case tSS_UINT8
        %return ::AnsiDataTypeName.tSS_UINT8
      %case tSS_UINT16
        %return ::AnsiDataTypeName.tSS_UINT16
      %case tSS_UINT32
        %return ::AnsiDataTypeName.tSS_UINT32
      %case tSS_BOOLEAN
        %return ::AnsiDataTypeName.tSS_BOOLEAN
      %case tSS_INT8
        %return ::AnsiDataTypeName.tSS_INT8
      %case tSS_INT16
        %return ::AnsiDataTypeName.tSS_INT16
      %case tSS_INT32
        %return ::AnsiDataTypeName.tSS_INT32
      %default
        %return "numeric"
    %endswitch
%endfunction %% SLibGetANCICDataTypeFromId


%% Function: SLibGetIdFromMLDataType ===============================================================
%% Abstract:
%%   Return the TLC data type id for the specified MATLAB data type name.
%%
%function SLibGetIdFromMLDataType(dtName)
    %switch dtName
      %case "double" %% sbcheck:ok:tlctypes
        %return tSS_DOUBLE
      %case "single"
        %return tSS_SINGLE
      %case "int32"
        %return tSS_INT32
      %case "int16"
        %return tSS_INT16
      %case "int8"
        %return tSS_INT8
      %case "uint32"
        %return tSS_UINT32
      %case "uint16"
        %return tSS_UINT16
      %case "uint8"
        %return tSS_UINT8
      %case "boolean"
      %case "logical"
        %return tSS_BOOLEAN
      %case "half"
        %return tSS_HALF
      %default
        %assign errTxt = "Unknown data type for: %<dtName>"
        %<LibReportFatalError(errTxt)>
    %endswitch
%endfunction  %% SLibGetIdFromMLDataType


%% Function: SLibIsUnsignedBuiltinFromId ===========================================================
%% Abstract:
%%   Return whether the data type corresponding to a data type ID is an
%%   unsigned builtin
%%
%function SLibIsUnsignedBuiltinFromId(id) void
    %if LibIsBuiltInDataType(id)
        %return SLibIsUnsignedFromId(id)
    %else
        %return 0
    %endif
%endfunction



%% Function: SLibIsIntegerFromId ===================================================================
%% Abstract:
%%   Return whether the data type corresponding to a data type ID is an
%%   integer
%% TopTester: test/toolbox/simulink/variants/var-inline-general/tIVfcnCall_neg.m
%%
%function SLibIsIntegerFromId(id) void
    %switch LibGetDataTypeIdAliasedThruToFromId(id)
      %case tSS_UINT8
      %case tSS_UINT16
      %case tSS_UINT32
      %case tSS_BOOLEAN
      %case tSS_INT8
      %case tSS_INT16
      %case tSS_INT32
      %case tSS_TIMER_UINT32_PAIR
        %return 1
        %%break
      %case tSS_DOUBLE
      %case tSS_SINGLE
        %return 0
        %%break
      %default
        %if LibIsHalfDataType(LibGetDataTypeIdAliasedThruToFromId(id))
            %return 0
        %endif
        %assign errTxt = "Invalid data type %<dtypeName>."
        %<LibBlockReportFatalError([], errTxt)>
        %break
    %endswitch
%endfunction


%% Function: LibGetNumDataTypesInModel =============================================================
%% Abstract:
%%   Return number of data types in a model.  This include built-in an non
%%   built-in data types.
%%
%function LibGetNumDataTypesInModel()
    %return ::CompiledModel.DataTypes.NumDataTypes
%endfunction


%% Function: LibBooleanDataTypeEnabled =============================================================
%% Abstract:
%%   Return whether boolean data types are enabled in model or not.
%%
%function LibStrictBooleanCheckEnabled()
    %return ::CompiledModel.DataTypes.StrictBooleanCheckEnabled
%endfunction



%%--------------------------%
%% System Library functions %
%%--------------------------%

%function SLibSetDataTypeGroundHasNonZero(dataTypeRec, gndHasNonZero) void
    %assign dataTypeRec.GroundHasNonZero = gndHasNonZero
%endfunction

%function SLibGetDataTypeGroundHasNonZero(dataTypeRec)
    %return dataTypeRec.GroundHasNonZero
%endfunction

%% Function: SLibGetRecordDataTypeID ===============================================================
%% Abstract:
%%   Return the data type ID for a given record.
%%
%function SLibGetRecordDataTypeId(rec) void
    %return LibGetRecordDataTypeId(rec)
%endfunction


%% Function: SLibGetRecordIsComplex ================================================================
%% Abstract:
%%   Return 1 if the specified record is complex.  Otherwise, return 0
%%
%function SLibGetRecordIsComplex(rec)
    %return LibGetRecordIsComplex(rec)
%endfunction


%% Function: SLibGetRecordDataTypeName =============================================================
%% Abstract:
%%   Return the data type name for a specified record.
%function SLibGetRecordDataTypeName(rec, reim)
    %return SLibGetRecordOptStdDataTypeName(rec, reim, TLC_FALSE)
%endfunction

%% Function: SLibGetRecordOptStdDataTypeName
%% Abstract:
%%   Return the data type name for a specified record.
%%
%%   Specify the useStdContainerName argument as whether to return std container name
%%   if the type is a pre-lowering std container type
%%
%function SLibGetRecordOptStdDataTypeName(rec, reim, useStdContainer)
    %return LibGetRecordOptStdDataTypeName(rec, reim, useStdContainer)
%endfunction

%% Function: SLibGetRecordCompositeDataTypeName ====================================================
%% Abstract:
%%   Return the composite data type name for a specified record.  That is,
%%   return ComplexName if it exists, otherwise, return Name.
%%
%function SLibGetRecordCompositeDataTypeName(rec) void
    %return LibGetRecordCompositeDataTypeName(rec)
%endfunction


%% Function: SLibGetGroundName =====================================================================
%% Abstract:
%%   For a given record and real/imaginary specifier, return the name used for
%%   ground or complex ground depending the record type and the value of reim.
%%
%function SLibGetGroundName(rec, reim) void
    %return LibGetGroundName(rec, reim)
%endfunction

%% Function: SLibGetGroundValue ====================================================================
%% Abstract:
%%   For a given record and real/imaginary specifier, return the value used for
%%   ground depending on the record type and the value of reim.
%%
%function SLibGetGroundValue(rec, reim) void
    %return LibGetGroundValue(rec, reim)
%endfunction

%% Function: SLibGetStoredIntegerZeroFromId ========================================================
%% Abstract:
%%   Returns the stored integer value for the data type of record passed in.
%function SLibGetStoredIntegerZeroFromId(dataTypeId) void
    %assign storageDataTypeId = ...
        LibGetDataTypeStorageIdFromId(...
        LibGetDataTypeIdAliasedThruToFromId(dataTypeId))
    %%
    %if LibIsBuiltInDataType(storageDataTypeId)
        %assign value = 0
    %else
        %assign value = LibGetGroundValueFromId(storageDataTypeId)
    %endif
    %return value
%endfunction

%% Function: SLibGetStoredIntegerZeroValue =========================================================
%% Abstract:
%%   Returns the stored integer value for the data type of record passed in.
%function SLibGetStoredIntegerZeroValue(rec,reim) void
    %if reim == "" && LibGetRecordIsComplex(rec)
        %assign errTxt = "Complex stored integer zero values are undefined."
        %<LibReportFatalError(errTxt)>
    %else
        %% non-complex ground or real/imaginary part of complex ground
        %assign dataTypeId = LibGetRecordDataTypeId(rec)
        %assign value = SLibGetStoredIntegerZeroFromId(dataTypeId)
    %endif
    %return value
%endfunction


%% Function: SLibGetDefaultInitialValueFromId ======================================================
%% Abstract:
%%   Returns the default initial value for the data type of record passed in.
%%   This function currently just makes a trivial call to another function, but
%%   this extra layer this function inserts lays the path for future improvements.
%%   Currently, this function just returns the Ground-Value.  The Ground-Value
%%   is the Stored-Integer-Value that best represents Real-World-Value zero.
%%   In order to get higher efficiency in the generated code, at a future
%%   time, the default initial value may be switched to just
%%   the Stored-Integer with value zero, irregardless of whether or not that
%%   corresponds to Real-World-Value zero.  The values are mainly different
%%   for data types with non-zero bias.  This future change is likely to be
%%   based on an optimization setting.
%%
%function SLibGetDefaultInitialValueFromId(dataTypeId) void
    %% %assign value = SLibGetStoredIntegerZeroFromId(dataTypeId)
    %assign value = SLibGetGroundValueFromIdStrictOpt(dataTypeId,0)
    %return value
%endfunction

%% Function: SLibGetDefaultInitialValue ============================================================
%% Abstract:
%% Abstract:
%%   Returns the default initial value for the data type of record passed in.
%%   This function currently just makes a trivial call to another function, but
%%   this extra layer this function inserts lays the path for future improvements.
%%   Currently, this function just returns the Ground-Value.  The Ground-Value
%%   is the Stored-Integer-Value that best represents Real-World-Value zero.
%%   In order to get higher efficiency in the generated code, at a future
%%   time, the default initial value may be switched to just
%%   the Stored-Integer with value zero, irregardless of whether or not that
%%   corresponds to Real-World-Value zero.  The values are mainly different
%%   for data types with non-zero bias.  This future change is likely to be
%%   based on an optimization setting.
%%
%%   Note that future change to this also means change to function
%%   SLibDefaultInitialValueIsAllZeroBits.
%%
%function SLibGetDefaultInitialValue(rec,reim) void
    %%  %assign value = SLibGetStoredIntegerZeroValue(rec,reim)
    %assign value = SLibGetGroundValueStrictOpt(rec,reim,0)
    %return value
%endfunction

%function SLibGetDefaultInitialValueByCGTypeIdx(typeIdx, reim) void
    %createrecord rec { CGTypeIdx typeIdx }

    %return SLibGetDefaultInitialValue(rec, reim)
%endfunction


%% Function: SLibGetCastedValue ====================================================================
%% Abstract:
%%   This function casts a numeric value based on its data type.  Non built-in
%%   data types are returned "untouched".  Note that this function is useful
%%   for making appropriate TLC types.
%%
%%   For example,
%%
%%     SLibGetCastedValue(Gain, 2)
%%       ==> returns 2 as a TLC "Number" if Gain is an "signed integer"
%%
%%     SLibGetCastedValue(Gain, 2)
%%       ==> returns 2 as a TLC "Unsigned" if Gain is an "unsigned integer"
%%
%%     SLibGetCastedValue(Gain, 2)
%%       ==> returns 2.0 as a TLC "Real" if Gain is a "real" data type
%%
%%     SLibGetCastedValue(Gain, 2)
%%       ==> returns 2 as a TLC "String" if Gain is an unknown data type
%%
%%  Arguments:
%%     rec          = TLC record containing data type information
%%     numericValue = numeric value to format
%%
%function SLibGetCastedValue(rec, numericValue)
    %return(SLibGetCastedValueFromId(LibGetRecordDataTypeId(rec), numericValue))
%endfunction

%% Function: SLibReplaceEnumLiteralValueWithTypeLimitId ============================================
%% Abstract:
%%   For an enumeration data type and a numerical value, this function will
%%   return the corresponding type limit ID if the value is a type limit.
%%   Otherwise the same input value is returned.
%%
%%   For example,
%%
%%     SLibReplaceEnumLiteralValueWithTypeLimitId(Int32TypeId, -2147483648)
%%       ==> returns MIN_int32_T
%%
%%     SLibReplaceEnumLiteralValueWithTypeLimitId(Int32TypeId, -2147483647)
%%       ==> returns -2147483647
%%
%%   Arguments:
%%     rec          = Data type id
%%     numericValue = Numeric value
%% TopTester: test/toolbox/simulink/blocks/tselect_EnumIndex.m
%% TopTester: test/toolbox/simulink/blocks/lib_Sources/Ground/rtw/tStringSupport.m
%%
%function SLibReplaceEnumLiteralValueWithTypeLimitId(id, numericValue)
    %% See Also:
    %%   SLibGetFormattedValueFromId, SLibGetFormattedValue,
    %%   SLibGetCastedValue
    %%
    %assign aliasedThroughDataType = LibGetDataTypeIdAliasedThruToFromId(id)

    %assert LibIsEnumDataType(aliasedThroughDataType)
    %assign enumStorageTypeId = LibGetEnumTypeStorageType(aliasedThroughDataType)
    %if enumStorageTypeId >= 0
        %assign aliasedThroughDataType = enumStorageTypeId
    %elseif LibIsEnumTypeStoredAsInt(aliasedThroughDataType)
        %assign aliasedThroughDataType = tSS_INT32
    %else
        %assert TLC_FALSE
    %endif

    %switch aliasedThroughDataType
      %case tSS_INT32
        %% Currently we only handle the integer 32 bit case, to avoid the
        %% C4146 Visual Studio C compiler warning. See g1652846 for details.

        %% signed integer
        %if numericValue == int32MinValue
            %% suppress compiler warning when using largest negative
            %% 2s-complement number for 32-bit integers
            %return "%<LibMinIntValue(aliasedThroughDataType)>"
        %elseif numericValue == int32MaxValue
            %return "%<LibMaxIntValue(aliasedThroughDataType)>"
        %endif
    %endswitch
    %% default case
    %return numericValue
%endfunction

%% Function: SLibGetFormattedValue =================================================================
%% Abstract:
%%   For a built-in data type, this function returns the formatted value of
%%   a numeric value based on its corresponding data type record.
%%   Values that are not associated with a known built-in data types are
%%   returned "untouched".
%%
%%   Arguments:
%%     rec          = TLC record containing data type information
%%     numericValue = numeric value to format
%%
%function SLibGetFormattedValue(rec, numericValue)
    %% See Also:
    %%   SLibGetFormattedValueFromId, SLibGetCastedValue
    %%
    %return SLibGetFormattedValueFromId(LibGetRecordDataTypeId(rec), numericValue)
%endfunction

%% LibComplexConvertBetween ====================================================
%% Abstract:
%%   Apply ConvertBetween to data that may be complex
%%
%%   Arguments:
%%     dstId = type being converted to
%%     srcId = type being converted from
%%     cmplx = whether the signal is complex
%%     input = input signal
%%     options = options
%%     output = output signal
%% TopTester: test/toolbox/simulink/blocks/lib_Sources/Ground/rtw/-tStringSupport.m
%%
%function LibComplexConvertBetweenForSrcId(dstId, srcId, cmplx, input, ...
    options, output) Output
    %assign ConvertBetweenFcn = ...
        LibConvertBetweenTLCFcnName(srcId)
    %if !cmplx
        %assign status = %<ConvertBetweenFcn>(dstId,srcId,input,options,output)
        %return status
    %else
        %assign realInput = "%<input>.%<tRealPart>"
        %assign imagInput = "%<input>.%<tImagPart>"
        %assign realOutput = "%<output>.%<tRealPart>"
        %assign imagOutput = "%<output>.%<tImagPart>"
        %assign status = %<ConvertBetweenFcn>(dstId,srcId,realInput,options,realOutput)
        %if status != 1
            %return status
        %endif
        %assign status = %<ConvertBetweenFcn>(dstId,srcId,imagInput,options,imagOutput)
        %return status
    %endif
%endfunction

%% SLibDeepCopyData ====================================================
%% Abstract:
%%   Apply DeepCopyor to opaque data
%%
%%   Arguments:
%%     id = type of data
%%     data = data being destructed inplace
%%
%function SLibDeepCopyData(id, dst, src) Output
    %assign DeepCopyFcn = SLibDataTypeDeepCopyFcnName(id)
    %assign status = 1
    %if !ISEMPTY(DeepCopyFcn)
        %assign status = %<DeepCopyFcn>(id, dst, src)
    %endif
    %return status
%endfunction

%% LibOutputExprCast ============================================================
%% Abstract:
%%   Return whether or not a block's output expression needs to be explicitly
%%   cast to the datatype of the block's output; this needs to be done for C
%%   to prevent implicit upcasts of short integer types
%% TopTester: test/toolbox/simulink/blocks/CPPCodeGen/tsmlk_core_cpp_coverage.m
%%
%function LibOutputExprCast(srcBlk, idx)
    %assign cast = ""
    %if !SLibBlockIntegerDowncastRequired(srcBlk)
        %return cast
    %endif
    %assign dtype = LibGetRecordDataTypeId(srcBlk.DataOutputPort[idx])
    %assign storageId = LibGetDataTypeStorageIdFromId(dtype)
    %% If the datatype is known to resolve to a builtin, do it for short
    %% integers
    %if LibIsBuiltInDataType(storageId)
        %if SLibIsIntegerFromId(storageId)
            %if ::CompiledModel.IntegerSizesExists
                %switch storageId
                  %case tSS_UINT8
                  %case tSS_INT8
                    %if 8 < ::IntegerSizes.IntNumBits
                        %assign cast = "(%<LibGetDataTypeNameFromId(storageId)>)"
                    %endif
                    %break
                  %case tSS_INT16
                  %case tSS_UINT16
                    %if 16 < ::IntegerSizes.IntNumBits
                        %assign cast = "(%<LibGetDataTypeNameFromId(storageId)>)"
                    %endif
                    %break
                  %default
                    %break
                %endswitch
                %% If IntegerSizes target property does not exist, go with default
            %else
                %switch storageId
                  %case tSS_UINT8
                  %case tSS_UINT16
                  %case tSS_INT8
                  %case tSS_INT16
                    %assign cast = "(%<LibGetDataTypeNameFromId(storageId)>)"
                    %break
                  %default
                    %break
                %endswitch
            %endif
        %endif
        %% If it doesn't resolve to a builtin, just cast to the output type
        %% unless a structure type
    %elseif !LibIsStructDataType(dtype)
        %assign cast = "(%<LibGetDataTypeNameFromId(dtype)>)"
    %endif
    %return cast
%endfunction

%% Function: SLibConvertBetweenBuiltin =============================================================
%% Abstract:
%%   Convert between builtin datatypes
%%
%%   Arguments:
%%     outDType = desired output data type
%%     inDType = actual input data type
%%     inLabel = input signal
%%     options = options
%%     outLabel = output signal
%function SLibConvertBetweenBuiltin(outDType,inDType,inLabel,options,outLabel) Output
    %if outDType == tSS_BOOLEAN
        %if inDType == tSS_BOOLEAN
            %<outLabel> = %<inLabel>;
        %else
            %assign zero = SLibGetFormattedValueFromId(inDType, 0)
            %<outLabel> = %<inLabel> != %<zero>;
        %endif
    %else
        %assign outDTypeName = LibGetDataTypeNameFromId(outDType)
        %<outLabel> = (%<outDTypeName>) %<inLabel>;
    %endif
    %return 1
%endfunction

%% Function: SLibIsPositiveBuiltin =================================================================
%% Abstract:
%%   Convert between builtin datatypes
%%
%%   Arguments:
%%    inDType = type of input
%%    inLabel = input signal
%%    options = options
%%    outLabel = output signal
%%
%function SLibIsPositiveBuiltin(inDType, inLabel, options, outLabel) Output
    %if inDType == tSS_BOOLEAN
        %<outLabel> = %<inLabel>;
    %else
        %assign zero = SLibGetFormattedValueFromId(inDType, 0)
        %<outLabel> = %<inLabel> > %<zero>;
    %endif
    %return 1
%endfunction

%% Function: SLibSignBuiltin =======================================================================
%% Abstract:
%%   Convert between builtin datatypes
%%
%%   Arguments:
%%      inDType = type of input
%%      inLabel = input signal
%%      options = options
%%      outLabel = output signal
%%
%function SLibSignBuiltin(inDType, inLabel, options, outLabel) Output
    %if inDType == tSS_BOOLEAN
        %<outLabel> = %<inLabel>;
    %else
        %assign zero = SLibGetFormattedValueFromId(inDType, 0)
        if (%<inLabel> > %<zero>) {
            %<outLabel> = 1;
        } else if (%<inLabel> < %<zero>) {
            %<outLabel> = -1;
        } else {
            %<outLabel> = 0;
        }
    %endif
    %return 1
%endfunction

%% Function: SLibSigToLogDataType ==================================================================
%% Abstract:
%%   Convenient utility to return signal datatype as log datatype
%%   if signal datatype is builtin, otherwise return the specified
%%   logging datatype to be used
%%
%function SLibSigToLogDataType(sigDataType, usedLogDataType) void
    %if LibIsBuiltInDataType(sigDataType)
        %return sigDataType
    %else
        %return usedLogDataType
    %endif
%endfunction


%% Function: SLibHandleSaturateOnOverflow ==========================================================
%% Abstract:
%%   Convenient utility to process a block's saturate on overflow flag;
%%   return whether or not to generate saturating code.
%%
%function SLibHandleSaturateOnOverflow(block) void
    %if block.ParamSettings.SaturateOnOverflow == "Needed"
        %assign doSaturate = 1
    %else
        %assign doSaturate = 0
    %endif
    %return doSaturate
%endfunction

%% Function: SetOrderedDataTypeIdx =================================================================
%% Consider to create sections:
%%   built-in types
%%   fixpoint types
%%   enum types
%%   non-anonymous buses
%%   anonymous struct types
%% TopTester: test/toolbox/simulink/variants/var-bus-vss/-tDefaultVariants.m
%%
%function GetOrderedDataTypeIdx(DtIdxMap) void

    %with ::CompiledModel

        %createrecord DtIdxAnonymousStructs { }

        %% All types excluding anonymous struct types
        %foreach dtIdx = ::CompiledModel.DataTypes.NumDataTypes
            %if (LibDataTypeIsAnonymousStruct(dtIdx) == TLC_FALSE)
                %addtorecord DtIdxMap Dt { idx %<dtIdx> }
            %else
                %addtorecord DtIdxAnonymousStructs Dt { idx %<dtIdx> }
            %endif
        %endforeach

        %% append anonymous struct types
        %if !ISEMPTY(DtIdxAnonymousStructs)
            %foreach idx = SIZE(DtIdxAnonymousStructs.Dt, 1)
                %addtorecord DtIdxMap Dt {idx DtIdxAnonymousStructs.Dt[idx].idx}
            %endforeach
        %endif
    %endwith

%endfunction

%% Function: SLibSetupDatatypeInfo =================================================================
%% Abstract:
%%   Setup variables and fields pertaining to Datatype information
%% TopTester: test/toolbox/simulink/variants/var-general/tStringSupport.m
%% Toptetser: test/toolbox/simulink/blocks/lib_Sources/Ground/rtw/-tStringSupport.m
%% TopTester: test/toolbox/rtw/targets/AUTOSAR/Variants/tValueVariants.m
%%
%function SLibSetupDatatypeInfo() void
    %%
    %% Map DataTypeTable
    %%

    %% reserve for target defined oversized(>32, or 24) long type
    %% unconditionally populate 64 bit, big long type and long long type
    %<LibAddToCompiledModel("tSS_LONG", INT32MIN)>
    %<LibAddToCompiledModel("tSS_ULONG", INT32MIN+3)>
    %<LibAddToCompiledModel("tSS_LONG_LONG", INT32MIN+4)>
    %<LibAddToCompiledModel("tSS_ULONG_LONG", INT32MIN+5)>

    %% reserve for function prototypes that contain void or size_t args
    %% Right now, this is used for TFL queries of memcpy, memset, and memcmp
    %<LibAddToCompiledModel("tSS_VOID", INT32MIN+1)>
    %<LibAddToCompiledModel("tSS_SIZET", INT32MIN+2)>

    %<LibAddToCompiledModel("tSS_UINTEGER", INT32MIN+6)>
    %<LibAddToCompiledModel("tSS_CHAR", INT32MIN+7)>
    %<LibAddToCompiledModel("tSS_UCHAR", INT32MIN+8)>
    %<LibAddToCompiledModel("tSS_TIME", INT32MIN+9)>

    %%Find Largest Multiword bits
    %assign LargestMultiwordBits = %<SLibGetLargestMultiwordDataTypeNeeded()>
    %<LibAddToCompiledModel("LargestMultiwordBits", LargestMultiwordBits)>
    %<LibAddToCompiledModel("DeclaredFixedPointWordSizeUsage", 0)>
    %<DeclareFixedPointWordSizeUsage(::CompiledModel.CGTypes.DeclareUsedMultiWordBits)>

    %% Code generation needs special half precision headers
    %<LibAddToCompiledModel("DeclaredHalfPrecisionUsage", CGMODEL_ACCESS("CGType.GetIsHalfUsed"))>

    %% Add tSS_INVALID_DATA_TYPE_ID = -10
    %<LibAddToCompiledModel("tSS_INVALID_DATA_TYPE_ID", -10)>

    %% Native 64-bit integer types must be fully configured before registering
    %% long and long long types
    %<FcnUpdate64BitIntegerTypes()>

    %% Register long types
    %if ::IntegerSizes.LongNumBits != 32
        %<FcnRegisterBuiltInLongType("ulong")>
        %<FcnRegisterBuiltInLongType("long")> %% sbcheck:ok:tlctypes
    %endif

    %% Register long long types
    %if (::IntegerSizes.LongLongMode == 1) && \
        (::IntegerSizes.LongLongNumBits != ::IntegerSizes.LongNumBits)
        %<FcnRegisterBuiltInLongType("ulonglong")>
        %<FcnRegisterBuiltInLongType("longlong")>
    %endif

    %% Register tSS_UINTEGER
    %<FcnRegisterUintType()>

    %createrecord dtIdxMap { }
    %<GetOrderedDataTypeIdx(dtIdxMap)>

    %foreach idx = LibGetNumBuiltInDataTypesInModel()
        %assign dtBuiltIn = ::CompiledModel.DataTypes.DataType[idx]
        %switch dtBuiltIn.DTName
          %case "double" %% sbcheck:ok:tlctypes
            %<LibAddToCompiledModel("tSS_DOUBLE", dtBuiltIn.Id)>
            %break
          %case "single"
            %<LibAddToCompiledModel("tSS_SINGLE", dtBuiltIn.Id)>
            %break
          %case "boolean"
            %<LibAddToCompiledModel("tSS_BOOLEAN", dtBuiltIn.Id)>
            %break
          %case "int8"
            %<LibAddToCompiledModel("tSS_INT8", dtBuiltIn.Id)>
            %break
          %case "uint8"
            %<LibAddToCompiledModel("tSS_UINT8", dtBuiltIn.Id)>
            %break
          %case "int16"
            %<LibAddToCompiledModel("tSS_INT16", dtBuiltIn.Id)>
            %break
          %case "uint16"
            %<LibAddToCompiledModel("tSS_UINT16", dtBuiltIn.Id)>
            %break
          %case "int32"
            %<LibAddToCompiledModel("tSS_INT32", dtBuiltIn.Id)>
            %break
          %case "uint32"
            %<LibAddToCompiledModel("tSS_UINT32", dtBuiltIn.Id)>
            %break
          %default
        %endswitch
    %endforeach

    %foreach idx0 = SLibGetNumPredefinedDataTypesInModel()
        %assign idx = idx0 + LibGetNumBuiltInDataTypesInModel()
        %assign dtBuiltIn = ::CompiledModel.DataTypes.DataType[idx]
        %switch dtBuiltIn.DTName
          %case "fcn_call"
            %<LibAddToCompiledModel("tSS_FCN_CALL", dtBuiltIn.Id)>
            %break
          %case "integer"
            %<LibAddToCompiledModel("tSS_INTEGER", dtBuiltIn.Id)>
            %break
          %case "pointer"
            %<LibAddToCompiledModel("tSS_POINTER", dtBuiltIn.Id)>
            %break
          %case "action"
            %<LibAddToCompiledModel("tSS_ACTION", dtBuiltIn.Id)>
            %break
          %case "timer_uint32_pair"
            %<LibAddToCompiledModel("tSS_TIMER_UINT32_PAIR", dtBuiltIn.Id)>
            %break
        %endswitch
    %endforeach

    %<LibAddToCompiledModel("tSS_STRING", SLibGetIdForDynamicallyAssignedStandardType("string"))>
    %<LibAddToCompiledModel("tSS_HALF", SLibGetIdForDynamicallyAssignedStandardType("half"))>

    %with ::CompiledModel
        %foreach dtIdx0 = ::CompiledModel.DataTypes.NumDataTypes
            %assign dtIdx = dtIdxMap.Dt[dtIdx0].idx
            %assign dt = ::CompiledModel.DataTypes.DataType[dtIdx]

            %% The Name property might still be used by custom TLC code
            %% that is not yet updated to call LibGetDataTypeNameFromId
            %<LibAddIdentifier(dt, "Name", LibGetDataTypeNameFromId(dtIdx))>

            %if ISFIELD(dt, "RegistrationComplete") && dt.RegistrationComplete==TLC_TRUE
                %continue
            %endif
            %<SLibGetFieldsFromModel(dt, dtIdx)>
            %%
            %% Setup all types
            %%
            %switch dtIdx
              %case ::CompiledModel.tSS_DOUBLE
                %if ::PurelyIntegerCode==1
                    %continue
                %endif
                %<SLibPopulateDoubleDataType(dt)>
                %break
              %case ::CompiledModel.tSS_SINGLE
                %if ::PurelyIntegerCode==1
                    %continue
                %endif
                %<SLibPopulateSingleDataType(dt)>
                %break
              %case ::CompiledModel.tSS_HALF
                %if ::PurelyIntegerCode==1
                    %continue
                %endif
                %<FixPt_RegisterHalfAsBuiltInType(dtIdx)>
                %break
              %case ::CompiledModel.tSS_BOOLEAN
                %<SLibPopulateBooleanDataType(dt)>
                %break
              %case ::CompiledModel.tSS_INT8
                %<SLibPopulateInt8DataType(dt)>
                %break
              %case ::CompiledModel.tSS_UINT8
                %<SLibPopulateUInt8DataType(dt)>
                %break
              %case ::CompiledModel.tSS_INT16
                %<SLibPopulateInt16DataType(dt)>
                %break
              %case ::CompiledModel.tSS_UINT16
                %<SLibPopulateUInt16DataType(dt)>
                %break
              %case ::CompiledModel.tSS_INT32
                %<SLibPopulateInt32DataType(dt)>
                %break
              %case ::CompiledModel.tSS_UINT32
                %<SLibPopulateUInt32DataType(dt)>
                %break
              %case ::CompiledModel.tSS_FCN_CALL
                %<fcnSetDataTypeName(dt, "fcn_call_T", TLC_FALSE)>
                %<SLibSetDataTypeEnum(dt, "SS_FCN_CALL")>
                %break
              %case ::CompiledModel.tSS_POINTER
                %<fcnSetDataTypeName(dt, CGMODEL_ACCESS("DataTypes.GetBasicTypeSymbolFromName", "pointer"), TLC_FALSE)>
                %<SLibSetDataTypeEnum(dt, "SS_POINTER")>
                %<SLibSetDataTypeGroundValue(dt, 0)>
                %break
              %case ::CompiledModel.tSS_INTEGER
                %<SLibSetDataTypeEnum(dt, "SS_INTEGER")>
                %break
              %case ::CompiledModel.tSS_ACTION
                %<fcnSetDataTypeName(dt, "action_T", TLC_FALSE)>
                %break
              %case ::CompiledModel.tSS_TIMER_UINT32_PAIR
                %<fcnSetDataTypeName(dt, "timer_uint32_pair_T", TLC_FALSE)>
                %<SLibSetDataTypeEnum(dt, "SS_TIMER_UINT32_PAIR")>
                %break

                %% Handle the string types in their own case
                %% All the handlings of the string types are now done in rtwgen_datatypes.cpp
              %case ::CompiledModel.tSS_STRING
                %<fcnSetDataTypeName(dt, dt.DTName, TLC_FALSE)>
                %break

              %default
                %if ISEMPTY(LibGetDataTypeNameFromId(dt.Id))
                    %% Name property in CGModel is not yet populated
                    %<fcnSetDataTypeName(dt,dt.DTName, TLC_FALSE)>
                %endif
                %assign aIdx = dt.IdAliasedThruTo
                %if CGMODEL_ACCESS("DataTypes.GetDataTypeRegistrationFlag", dtIdx)
                    %%If Registration flag set (eg. Multiword types etc) - update scopes from CGModel
                    %<SLibUpdateScopeFromModel(dt, dtIdx)>
                    %% Enumerated type
                %elseif LibIsEnumDataType(dtIdx)
                    %<SLibSetDataTypeConvertBetweenTLCFcnName(dt, ...
                        "SLibConvertBetweenEnumType")>
                    %assign gndName = ::CompiledModel.Name + "_" + SLibGetDataTypeName(dt.Id) + "GND"
                    %<SLibSetDataTypeGroundName(dt, gndName)>
                    %% Default enumerator
                    %<SLibSetDataTypeGroundValue(dt, FcnGetEnumTypeDefaultCodeGenString(dtIdx))>
                    %% Structure type
                %elseif LibIsStructDataType(dtIdx)
                    %assign gndName = ::CompiledModel.Name + "_rtZ" + SLibGetDataTypeName(dt.Id)
                    %<SLibSetDataTypeGroundName(dt, "%<gndName>")>
                    %<SLibSetDataTypeGroundValue(dt, "%<gndName>")>
                    %assign gndHasFloats = 0
                    %foreach eIdx = dt.NumElements
                        %assign eDtId = LibDataTypeElementDataTypeId(dtIdx, eIdx)
                        %assign gndHasFloats = gndHasFloats || ...
                            ::CompiledModel.DataTypes.DataType[eDtId].GroundHasFloats
                    %endforeach
                    %assign dt.GroundHasFloats = gndHasFloats
                    %addtorecord dt NeedGroundInit 1
                %elseif LibIsSimulinkPointerDataType(dtIdx)
                    %<SLibSetDataTypeGroundValue(dt, SLibGetNullDefinitionFromTfl())>
                    %% Image type
                %elseif LibIsImageDataType(dtIdx)
                    %% Request for image type header
                    %<DeclareImageTypeUsage(TLC_TRUE)>
                    %<fcnSetDataTypeName(dt, FcnGetImageImplementationTypeName(), TLC_FALSE)>
                    %assign gndName = ::CompiledModel.Name + "_rtZ_" + dt.DTName
                    %<SLibSetDataTypeGroundName(dt, gndName)>
                    %<SLibSetDataTypeGroundValue(dt, "%<gndName>")>
                %elseif LibDoesDataTypeNeedConstructor(dtIdx) && !LibIsStringDataType(dtIdx)
                    %assign gndName = ::CompiledModel.Name + "_rtZ_" + SLibGetDataTypeName(dt.Id)
                    %assign gndName = STRREP(gndName, "::", "_")
                    %<SLibSetDataTypeGroundName(dt, gndName)>
                    %<SLibSetDataTypeGroundValue(dt, "%<gndName>")>
                    %% Alias type
                %elseif aIdx != dtIdx
                    %assign aDt = ::CompiledModel.DataTypes.DataType[aIdx]
                    %<SLibSetDataTypeEnum(dt, aDt.Enum)>
                    %<SLibSetDataTypeConvertBetweenTLCFcnName(dt, ...
                        aDt.ConvertBetweenTLCFcnName)>
                    %<SLibSetDataTypeIsPositiveTLCFcnName(dt, ...
                        aDt.IsPositiveTLCFcnName)>
                    %<SLibSetDataTypeSignTLCFcnName(dt, ...
                        aDt.SignTLCFcnName)>
                    %<SLibSetDataTypeConvertBetweenTLCFcnFile(dt, ...
                        aDt.ConvertBetweenTLCFcnFile)>
                    %<SLibSetDataTypeIsPositiveTLCFcnFile(dt, ...
                        aDt.IsPositiveTLCFcnFile)>
                    %<SLibSetDataTypeSignTLCFcnFile(dt, ...
                        aDt.SignTLCFcnFile)>
                    %assign gndName = ::CompiledModel.Name + "_" + SLibGetDataTypeName(dt.Id) + "GND"
                    %<SLibSetDataTypeGroundName(dt, gndName)>
                    %<SLibSetDataTypeGroundValue(dt, aDt.GroundValue)>
                    %<SLibSetDataTypeGroundInit(dt, aDt.GroundInit)>
                    %<SLibSetDataTypeGroundHasNonZero(dt, aDt.GroundHasNonZero)>
                    %<SLibSetDataTypeGroundHasFloats(dt, aDt.GroundHasFloats)>
                    %if LibGetDataTypeComplexNameFromId(aIdx) != ""
                        %assign cName = "c" + SLibGetDataTypeName(dt.Id)
                        %<SLibSetDataTypeComplexName(dt, cName)>
                        %<SLibSetDataTypeComplexGroundName(dt, gndName + "_Complex")>
                    %endif
                    %% Simulink.OpaqueType
                %elseif LibPackageForDataType(dt) == "Simulink" && ...
                    LibClassForDataType(dt) == "OpaqueType"
                    %<SLibSetDataTypeGroundValue(dt, 0)>
                %endif
                %<FcnMapIfEquivToTargetInt(dtIdx)>
                %break
            %endswitch
            %<FcnSetupCoderProperties(dtIdx)>
            %<FixPt_DataTypeSetup(dtIdx)>
        %endforeach
    %endwith

    %% Register tSS_CHAR, tSS_UCHAR
    %<FcnRegisterCharTypes()>

    %% Register tSS_TIME
    %<FcnRegisterTimeType()>

%endfunction %% SLibSetupDatatypeInfo

%function FcnRegisterCharTypes() void

    %assign charIDs = %<RegisterCharTypes()>
    %assign charDTIdx = charIDs[0]
    %assign uCharDTIdx = charIDs[1]

    %<updateTypeScopes(charDTIdx)>
    %<updateTypeScopes(uCharDTIdx)>

%endfunction

%function updateTypeScopes(dtID) void

    %if CGMODEL_ACCESS("DataTypes.GetDataTypeRegistrationFlag", dtID)
        %return
    %endif
    %<CGMODEL_ACCESS("DataTypes.SetDataTypeRegistrationFlag", dtID, TLC_TRUE)>

    %assign dtScope = ::CompiledModel.DataTypes.DataType[dtID]

    %if ISFIELD(dtScope, "RegistrationComplete") && dtScope.RegistrationComplete==TLC_TRUE
        %return
    %endif

    %addtorecord dtScope ActualBits CGMODEL_ACCESS("DataTypes.GetRequiredBits", dtID)
    %addtorecord dtScope DTName CGMODEL_ACCESS("DataTypes.GetDataTypeDTName", dtID)
    %addtorecord dtScope DataTypeName CGMODEL_ACCESS("DataTypes.GetName", dtID)
    %addtorecord dtScope Enum CGMODEL_ACCESS("DataTypes.GetDataTypeEnum", dtID)
    %addtorecord dtScope IdAliasedThruTo CGMODEL_ACCESS("DataTypes.GetDataTypeIdAliasedThruToForNonBusDtype", dtID)
    %addtorecord dtScope Name CGMODEL_ACCESS("DataTypes.GetName", dtID)
    %addtorecord dtScope NativeType CGMODEL_ACCESS("DataTypes.GetNativeType", dtID)
    %addtorecord dtScope Size CGMODEL_ACCESS("DataTypes.GetDataTypeSize", dtID)
    %addtorecord dtScope StorageId CGMODEL_ACCESS("DataTypes.GetDataTypeStorageId", dtID)
    %addtorecord dtScope ComplexGroundReqInMemory CGMODEL_ACCESS("DataTypes.GetDataTypeComplexGroundReqInMemory", dtID)
%endfunction


%function FcnRegisterUintType() void
    %assign dtID = %<RegisterUintType()>
    %<updateTypeScopes(dtID)>
%endfunction


%function FcnRegisterTimeType() void
    %assign timeID = %<RegisterTimeType()>
    %<updateTypeScopes(timeID)>
%endfunction

%function FcnSetupCoderProperties(dtIdx) void
    %if ISFIELD(::CompiledModel.DataTypes.DataType[dtIdx], "CoderProperties")
        %assign props = ::CompiledModel.DataTypes.DataType[dtIdx].CoderProperties
        %createrecord map {}
        %assign numProps = SIZE(props, 1)/2
        %foreach idx = numProps
            %assign propName = props[2*idx]
            %assign propValue = props[2*idx+1]
            %addtorecord map %<propName> "%<propValue>"
        %endforeach
        %addtorecord ::CompiledModel.DataTypes.DataType[dtIdx] CoderPropertiesMap map
    %endif
%endfunction

%function LibDumpFixptOddSizeTypedefs() void
    %if ISFIELD(::CompiledModel, "FixptOddSizeTypedefs") && !WHITE_SPACE(CompiledModel.FixptOddSizeTypedefs)
        %return "\n%<::CompiledModel.FixptOddSizeTypedefs>"
    %else
        %return ""
    %endif
%endfunction

%% Function: SLibUpdateAlignmentForBusTypeHelper ===================================================
%% Abstract:
%function SLibUpdateAlignmentForBusTypeHelper(aTypeIdx, align) void
    %foreach idx = LibCGTypeNumMembers(aTypeIdx)
        %assign mCGTIdx = LibCGTypeMemberCGTypeIdx(aTypeIdx, idx)
        %if SLibCGTypeIsStructStrict(mCGTIdx)
            %<SLibUpdateAlignmentForBusTypeHelper(mCGTIdx, align)>
        %else
            %assign dtIdx = ::CompiledModel.CGTypes.CGType[aTypeIdx].SLTypeIdx
            %assign memberDT = ::CompiledModel.DataTypes.DataType[dtIdx]
            %if !ISFIELD(memberDT, "Alignment")
                %% Add Alignment field in the Bus type
                %% Should add it to the DataTypes.DataType record, not the CGType!
                %addtorecord ::CompiledModel.DataTypes.DataType[dtIdx] Alignment align
            %elseif ::CompiledModel.DataTypes.DataType[dtIdx].Alignment < align
                %assign ::CompiledModel.DataTypes.DataType[dtIdx].Alignment = align
            %endif
        %endif
    %endforeach
%endfunction


%% Function: SLibUpdateAlignmentForBusType =========================================================
%% Abstract:
%%    If a CGType is a struct, its member can also be a struct (or Bus). In this
%% case, the alignment should be propagated to the fields of the sub-structure.
%% TopTester: test/toolbox/simulink/variants/var-vss-sigobj/tVSSSigObj.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function SLibUpdateAlignmentForBusType() void
    %foreach idx = ::CompiledModel.CGTypes.NumCGTypes
        %% deal with model parameters
        %assign cgType   = ::CompiledModel.CGTypes.CGType[idx]
        %if SLibCGTypeIsStructStrict(idx)
            %if cgType.SLTypeIdx > 0
                %assign dtIdx = cgType.SLTypeIdx
                %assign SLdt = ::CompiledModel.DataTypes.DataType[dtIdx]
                %assign align = LibCGTypeStructAlignment(idx)
                %% Setting the DataType Alignment field regardless of DataScope -
                %% imported types shouldn't show up in generated code
                %if (ISFIELD(SLdt,"Object") ...
                    && ISFIELD(SLdt.Object,"ObjectProperties") ...
                    && ISFIELD(SLdt.Object.ObjectProperties,"Alignment") ...
                    && SLdt.Object.ObjectProperties.Alignment > LibCGTypeStructAlignment(idx))

                    %assign align = SLdt.Object.ObjectProperties.Alignment
                %endif
                %if align>0
                    %if !ISFIELD(SLdt, "Alignment")
                        %% Add Alignment field in the Bus type
                        %% Should add it to the DataTypes.DataType record, not the CGType!
                        %addtorecord ::CompiledModel.DataTypes.DataType[dtIdx] Alignment align
                    %elseif ::CompiledModel.DataTypes.DataType[dtIdx].Alignment < align
                        %assign ::CompiledModel.DataTypes.DataType[dtIdx].Alignment = align
                    %endif
                %endif
            %endif

            %% deal with each member
            %foreach mIdx = LibCGTypeNumMembers(idx)
                %assign memberAlignment = LibCGTypeMemberAlignment(idx, mIdx)
                %assign memberCGTypeIdx = LibCGTypeMemberCGTypeIdx(idx, mIdx)
                %if memberAlignment > 0 && ...
                    SLibCGTypeIsStructStrict(memberCGTypeIdx)  %% struct member is a struct
                    %<SLibUpdateAlignmentForBusTypeHelper(memberCGTypeIdx, memberAlignment)>
                    %<CGMODEL_ACCESS("CGType.Member.SetAlignment", idx, mIdx, -1)>
                %endif
            %endforeach  %% each member
        %endif %% current CGType is a struct
    %endforeach  %% each CGType

    %% Local BlockIO may also have Bus types that need to be updated with alignment.
    %foreach idx = ::CompiledModel.BlockOutputs.NumLocalBlockOutputs
        %assign lbo = ::CompiledModel.BlockOutputs.LocalBlockOutput[idx]
        %assign align = lbo.Alignment
        %if align > 0     %% has alignment requirement
            %if SLibCGTypeIsStructStrict(lbo.CGTypeIdx)
                %<SLibUpdateAlignmentForBusTypeHelper(lbo.CGTypeIdx, align)>
                %assign ::CompiledModel.BlockOutputs.LocalBlockOutput[idx].Alignment = -1
            %endif
        %endif
    %endforeach

%endfunction
%%

%% Function: Substring =============================================================================
%% Abstract:
%%   Utility function that returns the substring
%%   from s[start] up to (but not including) s[end].
%%   Example:
%%   s = "Got it? Good!"
%%   Substring(s, 0, 7) is "Got it?"
%%   Substring(s, 8, 14) is "Good!"
%%
%function Substring(s, start, end)
    %assign ret = ""
    %assign len = end-start
    %foreach i = len
        %assign ret = ret + s[start+i]
    %endforeach
    %return ret
%endfunction

%% Function: IsDuplicateHeaderFile =================================================================
%% Abstract: Is the given header file in the given array of header files?
%%
%function IsDuplicateHeaderFile(headerFiles, headerFile)
    %assign numHeaderFiles = SIZE(headerFiles, 1)
    %if numHeaderFiles == 0
        %return TLC_FALSE
    %else
        %assign duplicate = TLC_FALSE
        %foreach idx = numHeaderFiles
            %if headerFiles[idx] == headerFile
                %assign duplicate = TLC_TRUE
                %break
            %endif
        %endforeach
        %return duplicate
    %endif
%endfunction

%% Function: AddToHeaderFiles ======================================================================
%% Abstract: Add the given header file to the headerFiles array (checking first for dups)
%%
%function AddToHeaderFiles(headerFiles, headerFile)
    %assign duplicate = IsDuplicateHeaderFile(headerFiles, headerFile)
    %if !duplicate
        %assign headerFiles = headerFiles + "%<headerFile>"
    %endif
    %return headerFiles
%endfunction

%% Function: RemoveFromHeaderFiles =================================================================
%% Abstract: Remove the given header file from the headerFiles array
%%
%function RemoveFromHeaderFiles(headerFiles, headerFile)
    %assign newHeaderFiles = []
    %assign numHeaderFiles = SIZE(headerFiles, 1)
    %foreach idx = numHeaderFiles
        %if headerFiles[idx] != headerFile
            %assign newHeaderFiles = newHeaderFiles + headerFiles[idx]
        %endif
    %endforeach
    %return newHeaderFiles
%endfunction

%% Function: SLibGetContainerSLTypeComplexName =====================================================
%% Abstract:
%%   Given an SL datatype, returns the complex name of it's container if
%%   one exists. Otherwise, returns its complex name
%function SLibGetContainerSLTypeComplexName(slDataType) void
    %if ISFIELD(slDataType, "ContainerSLTypeIdx") && ...
        slDataType.ContainerSLTypeIdx >= 0
        %assign containerTypeIdx = slDataType.ContainerSLTypeIdx
        %return LibGetDataTypeComplexNameFromId(containerTypeIdx)
    %else
        %return LibGetDataTypeComplexNameFromId(slDataType.Id)
    %endif
%endfunction

%% Function: SLibWriteDatatypeTypedefs =============================================================
%% Abstract:
%%   Write datatype typedefs, e.g. to the <model>_types.h file
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tMdlRefWithFcnOnDataAsVSSChoice.m
%% TopTester: test/toolbox/simulink/blocks/lib_Sources/Ground/rtw/-tStringSupport.m
%% TopTester: test/toolbox/rtw/targets/AUTOSAR/Variants/tValueVariants.m
%% TopTester: test/toolbox/simulink/variants/var-general/tVariantGecks6.m
%% TopTester: test/toolbox/simulink/variants/var-general/tVariantGecks2.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants3.m
%% TopTester: test/toolbox/simulink/blocks/A/assignment/tassign_1.m
%%
%function SLibWriteDatatypeTypedefs() void

    %% Special case- When a Custom storage class file is not being generated to the shared area,
    %% and it depends on a type present in model.h(This case happens when compact file packaging
    %% is enabled for a model), we generate the type to model_types.h. The function
    %% SLibGenCustomNonSharedHeaderFileForCSC determines if we need to generate model_types.h
    %% file based on the above mentioned conditions. This function is not currently present in
    %% C++(the logic is too involved, requires moving parts of code in data_customdata.tlc to c++).
    %% Hence the typedef buffer is populated by C++ and emitted by TLC.
    %% geck:g2711932 For Modular File packaging, by design "TypedefsToModelTypesOrHeader" contents
    %% should always be emitted to <model>_types.h.

    %assign fileContents = GET_FILE_REP_SCRATCH_BUFFER_CONTENTS("TypedefsToModelTypesOrHeader")
    %assign isModularFilePackaging = !SLibIsCompactFileFormat()
    %assign needModelTypesFile = isModularFilePackaging || SLibGenCustomNonSharedHeaderFileForCSC()
    %if !ISEMPTY(fileContents)
        %if needModelTypesFile
            %assign modelTypesFile = LibGetMdlTypesHdrBaseName()
            %assign typesFile = LibCreateSourceFile("SystemHeader", "Simulink", modelTypesFile)
            %<SLibSetModelFileAttribute(typesFile, "Typedefs", fileContents)>
        %else
            %assign modelHdrFile = LibGetMdlPubHdrBaseName()
            %assign hdrFile = LibCreateSourceFile("SystemHeader", "Simulink", modelHdrFile)
            %<SLibSetModelFileAttribute(hdrFile, "Typedefs", fileContents)>
        %endif
    %endif

    %assign variantFileContents = GET_FILE_REP_SCRATCH_BUFFER_CONTENTS("VariantTypedefsToModelTypesOrHeader")
    %if !ISEMPTY(variantFileContents)
        %if needModelTypesFile
            %assign modelTypesFile = LibGetMdlTypesHdrBaseName()
            %assign typesFile = LibCreateSourceFile("SystemHeader", "Simulink", modelTypesFile)
            %<SLibSetModelFileAttribute(typesFile, "Defines", variantFileContents)>
        %else
            %assign modelHdrFile = LibGetMdlPubHdrBaseName()
            %assign hdrFile = LibCreateSourceFile("SystemHeader", "Simulink", modelHdrFile)
            %<SLibSetModelFileAttribute(hdrFile, "ModelTypesDefines", variantFileContents)>
        %endif
    %endif

    %assign fileName = needModelTypesFile ? LibGetMdlTypesHdrBaseName() : LibGetMdlPubHdrBaseName()
    %assign success = CGMODEL_ACCESS("FileRepository.updateTypesAndSymbolsToModelTypesOrHeader", fileName + ".h")
    %assert success

    %createrecord dtIdxMap { }
    %<GetOrderedDataTypeIdx(dtIdxMap)>

    %foreach dtIdx0 = ::CompiledModel.DataTypes.NumDataTypes
        %% Get the type
        %assign dtIdx = dtIdxMap.Dt[dtIdx0].idx
        %assign dt = ::CompiledModel.DataTypes.DataType[dtIdx]
        %assign dtIsUserProvided = dt.IsUserProvided

        %% If the type is an imported shared type, add its file
        %% to the generated files list. This will ensure that the
        %% file appears in the code gen report. Fix for regression
        %% g1861492.
        %if dtIsUserProvided && dt.IsShared
            %assign dtHeaderFileQuoted = LibHeaderFileForDataType(dt)
            %assign sz = SIZE(dtHeaderFileQuoted)
            %assign len = sz[1]
            %assign dtHeaderFile = Substring(dtHeaderFileQuoted, 1, len-1)

            %<SLibAddGeneratedFileToList(dtHeaderFile,"custom","header","")>
        %endif
    %endforeach

    %% Remove this function in R2020b. Geck: g1722190
    %if CGMODEL_ACCESS("CGModel.NonSharedTypesInIR") && (::CompiledModel.SharedTypesInIR)
        %return
    %endif

    %% headerFiles will represent the list of header files we write out to model_types.h
    %% fullHeaderFiles will also include header files that are included in a nested way
    %% (i.e., if we include a.h and that includes b.h, then fullHeaderFiles will
    %% have both a.h and b.h in it)

    %assign headerFiles = []
    %assign fullHeaderFiles = []

    %% objInfoArr will be an array of objInfo records,
    %% one for each type exported to _sharedutils
    %createrecord objInfoArr { NumInfo 0 }

    %% ObjInfoArrNonShared will be an array of objInfo records
    %% one for each Auto type that is not exported to _sharedutils
    %% Check whether clashes exist
    %createrecord objInfoArrNonShared { NumInfo 0 }

    %createrecord fixptStructType{}

    %createrecord dtIdxMap { }
    %<GetOrderedDataTypeIdx(dtIdxMap)>

    %with ::CompiledModel

        %% Figure out if replacement types is on. This can live outside the main loop.
        %if ISFIELD(ConfigSet,"ReplacementTypes")
            %assign RTWReplacementTypesON = FEVAL("rtwprivate","rtwattic","AtticData","isReplacementOn")
        %else
            %assign RTWReplacementTypesON = TLC_FALSE
        %endif

        %assign genToShared = (::CompiledModel.GenUtilsSrcInSharedLocation == 1)
        %% Loop through the types
        %foreach dtIdx0 = ::CompiledModel.DataTypes.NumDataTypes

            %% Get the type
            %assign dtIdx = dtIdxMap.Dt[dtIdx0].idx
            %assign dt = ::CompiledModel.DataTypes.DataType[dtIdx]
            %assign dtIsUserProvided = dt.IsUserProvided

            %% Skip the handling of data types that are not used in the code
            %if dt.Skip
                %continue
            %endif

            %% Include 'slMsgSvc.h' for slMessage data payload struct
            %% Type names matches the ones inside MsgCompSolver
            %if LibIsDataTypeMessage(dtIdx) && ~::CompiledModel.MsgUsingIRBasedCG
                %assign headerFiles = AddToHeaderFiles(headerFiles, "\"slMsgSvc.h\"")
                %assign unquotedSlMsgSvc = "slMsgSvc.h"
                %assign fullHeaderFiles = AddToHeaderFiles(fullHeaderFiles, unquotedSlMsgSvc)
            %endif

            %% See if this type is subject to data type replacement
            %if ISEQUAL(TYPE(RTWReplacementTypesON),"Boolean") && RTWReplacementTypesON
                %% Skip the data types which are also a replacement data type.
                %% The reason is, the typedefs for these will be emitted to rtwtypes.h instead.
                %assign datatypeName = SLibGetDataTypeName(dt.Id)
                %if datatypeName == ConfigSet.ReplacementTypes.double %% sbcheck:ok:tlctypes
                    %continue
                %elseif datatypeName == ConfigSet.ReplacementTypes.single || ...
                    datatypeName == ConfigSet.ReplacementTypes.int32 || ...
                    datatypeName == ConfigSet.ReplacementTypes.int16 || ...
                    datatypeName == ConfigSet.ReplacementTypes.int8 || ...
                    datatypeName == ConfigSet.ReplacementTypes.uint32 || ...
                    datatypeName == ConfigSet.ReplacementTypes.uint16 || ...
                    datatypeName == ConfigSet.ReplacementTypes.uint8 || ...
                    datatypeName == ConfigSet.ReplacementTypes.boolean
                    %continue
                %elseif datatypeName == ConfigSet.ReplacementTypes.int %% sbcheck:ok:tlctypes
                    %continue
                %elseif datatypeName == ConfigSet.ReplacementTypes.uint || ...
                    datatypeName == ConfigSet.ReplacementTypes.char %% sbcheck:ok:tlctypes
                    %continue
                %endif
            %endif

            %% Open the buffer into which we'll write the type
            %openfile tmpBuffer

            %% Get the HeaderFile.
            %% There are two copies of HeaderFile, one at the top level of the DataType and
            %% one buried in the ObjectProperties. We're getting the top-level one here.
            %% This has already been defaulted as needed and quoted if necessary.
            %% If nonempty, it'll be of the form "a1.h" or <a1.h>, i.e. either quoted
            %% or angle-bracketed. See the C++ code in rtwgen_datatypes.cpp where
            %% the defaulting and quoting happens.
            %assign dtHeaderFileQuoted = LibHeaderFileForDataType(dt)

            %% See if we're generating to a shared location
            %assign dtIsShared = dt.IsShared
            %assign generateCmplxTypedef = 0

            %% One final check: If we're in Compact file format,
            %% and not generating to a shared location, throw an error
            %if (dtIsShared && !dtIsUserProvided) && SLibIsCompactFileFormat() && !genToShared
                %<SLibReportErrorWithIdAndArgs("RTW:tlc:SharedTypeInCompactFormat", "%<SLibGetDataTypeName(dt.Id)>")>
            %endif

            %if dtIsShared
                %% We'll need both the quoted and unquoted header file,
                %% and also the base filename without the trailing .h.
                %% For example:
                %%   dtHeaderFileQuoted  "a.h" or <a.h>
                %%   dtHeaderFile        a.h
                %%   dtHeaderFileBase    a

                %assign sz = SIZE(dtHeaderFileQuoted)
                %assign len = sz[1]
                %assign dtHeaderFile = Substring(dtHeaderFileQuoted, 1, len-1)
                %assign dtHeaderFileBase = Substring(dtHeaderFile, 0, len-4)
            %endif

            %% If a header file was given, add it to the headerFiles and fullHeaderFiles arrays
            %% (checking first for dups)
            %if dtHeaderFileQuoted != ""
                %assign headerFiles = AddToHeaderFiles(headerFiles, dtHeaderFileQuoted)
                %% Use the unquoted one for fullHeaderFiles, because at the point genSharedUtilsHeader
                %% subtracts this out, it is dealing with unquoted names.
                %assign fullHeaderFiles = AddToHeaderFiles(fullHeaderFiles, dtHeaderFile)
            %endif

            %assign typedefBuffer = ""
            %% We'll write the type in all cases except when they're importing from a header file
            %if !dtIsUserProvided
                %% This will become part of a comment
                %assign descStr = SLibGetDescriptionForData(::CompiledModel.DataTypes.DataType[dtIdx])
                %assign descStr = ISEMPTY(descStr) ? "" : "/* " + descStr + " */"

                %assign needGuard = !dtIsShared

                %% Emit alias types
                %% fixpt type with wordsize fits in target's new long type, is aliased to the target new long type
                %% in this case aDt.name == dt.Name, so no need to generate alias typedef again
                %if LibIsAliasDataType(dtIdx)
                    %assign aIdx = LibGetDataTypeIdAliasedToFromId(dt.Id)
                    %if (dt.DefinedInLegacyCode == 0) || LibIsModelReferenceSimTarget()
                        %assign aDt = DataTypes.DataType[aIdx]

                        %if !LibIsAliasDataType(aIdx)
                            %assign complexName = SLibGetContainerSLTypeComplexName(aDt)
                        %else
                            %assign complexName = LibGetDataTypeComplexNameFromId(aDt.Id)
                        %endif

                        %assign generateCmplxTypedef = SupportComplex && complexName != ""
                        %% For exported types, the file guard suffices.
                        %% For types going to model_types.h, put out a type guard.
                        %if needGuard
                            #ifndef DEFINED_TYPEDEF_FOR_%<SLibGetDataTypeName(dt.Id)>_
                            #define DEFINED_TYPEDEF_FOR_%<SLibGetDataTypeName(dt.Id)>_
                        %endif
                        %<descStr>
                        typedef %<SLibGetDataTypeName(aDt.Id)> %<SLibGetDataTypeName(dt.Id)>;
                        %if generateCmplxTypedef
                            typedef %<complexName> %<LibGetDataTypeComplexNameFromId(dt.Id)>;
                        %endif
                        %if needGuard
                            #endif
                        %endif
                    %endif

                    %% Emit enumeration types
                %elseif LibIsEnumDataType(dtIdx)

                    %% For exported types, the file guard suffices.
                    %% For types going to model_types.h, put out a type guard.
                    %if needGuard
                        #ifndef DEFINED_TYPEDEF_FOR_%<SLibGetDataTypeName(dt.Id)>_
                        #define DEFINED_TYPEDEF_FOR_%<SLibGetDataTypeName(dt.Id)>_
                    %endif
                    %if (LibIsEnumTypeStoredAsInt(dtIdx))
                        typedef enum {

                            %% By default we only initialize the first enumeration.
                            %% However, if we need to initialize any of the other enumerations
                            %% we will initialize all of them (in accordance with MISRA Rule 9.3).
                            %assign initAllEnums = TLC_FALSE
                            %assign firstEnumValue = SLibGetEnumTypeValueFromIndex(dtIdx, 0)
                            %foreach enumIdx = FcnGetEnumTypeNumEnums(dtIdx)
                                %if (SLibGetEnumTypeValueFromIndex(dtIdx, enumIdx) != (firstEnumValue+enumIdx))
                                    %assign initAllEnums = TLC_TRUE
                                    %break
                                %endif
                            %endforeach
                            %%
                            %% Now generate the typedef
                            %%
                            %assign lastIdx = FcnGetEnumTypeNumEnums(dtIdx)-1
                            %assign eol = ","
                            %foreach enumIdx = FcnGetEnumTypeNumEnums(dtIdx)
                                %assign enumString = SLibGetEnumTypeCodeGenStringFromIndex(dtIdx, enumIdx)
                                %if (initAllEnums || (enumIdx == 0))
                                    %assign enumInitValue = SLibGetEnumTypeValueFromIndex(dtIdx, enumIdx)
                                    %assign valueString = " = %<SLibReplaceEnumLiteralValueWithTypeLimitId(dtIdx, enumInitValue)>"
                                %else
                                    %assign valueString = ""
                                %endif
                                %%
                                %% Add comment next to default value
                                %if enumIdx == FcnGetEnumTypeIndexOfDefaultValue(dtIdx)
                                    %assign defaultComment = " /* Default value */"
                                %else
                                    %assign defaultComment = ""
                                %endif
                                %%
                                %% Don't add ',' after last enumeration
                                %if (enumIdx == lastIdx)
                                    %assign eol = ""
                                %endif
                                %%
                                %<enumString>%<valueString>%<eol>%<defaultComment>
                            %endforeach
                        } %<SLibGetDataTypeName(dt.Id)>; %<descStr>
                    %else
                        %% Typedef enumerated data type to storage type
                        %assign storageTypeId   = LibGetEnumTypeStorageType(dtIdx)
                        %assign storageTypeName = LibGetDataTypeNameFromId(storageTypeId)
                        typedef %<storageTypeName> %<SLibGetDataTypeName(dt.Id)>; %<descStr>
                        %% Generate #define for each enumeration string
                        %foreach enumIdx = FcnGetEnumTypeNumEnums(dtIdx)
                            %assign enumString = SLibGetEnumTypeCodeGenStringFromIndex(dtIdx, enumIdx)
                            %assign enumValue  = SLibGetEnumTypeValueFromIndex(dtIdx, enumIdx)
                            %assign enumValue = SLibReplaceEnumLiteralValueWithTypeLimitId(dtIdx, enumValue)

                            %%
                            %% Add comment next to default value
                            %%
                            %if enumIdx == FcnGetEnumTypeIndexOfDefaultValue(dtIdx)
                                %assign defaultComment = " /* Default value */"
                            %else
                                %assign defaultComment = ""
                            %endif
                            %%
                            %% Generate a #define for each enumeration string
                            #define %<enumString> ((%<SLibGetDataTypeName(dt.Id)>)%<enumValue>) %<defaultComment>
                        %endforeach
                    %endif
                    %if needGuard
                        #endif
                    %endif

                    %% Emit struct types
                %elseif LibIsStructDataType(dtIdx)
                    %assign numElements = dt.NumElements
                    %assign padded = 0
                    %%keep a record of the generated types to avoid generating duplicated structural equivalent types
                    %if LibIsDataTypeMultiWordFixpt(dtIdx)
                        %% Suppress generation of fixed-point types
                        %closefile tmpBuffer
                        %continue
                    %endif

                    %% For exported types, the file guard suffices.
                    %% For types going to model_types.h, put out a type guard.
                    %if needGuard
                        #ifndef DEFINED_TYPEDEF_FOR_%<SLibGetDataTypeName(dt.Id)>_
                        #define DEFINED_TYPEDEF_FOR_%<SLibGetDataTypeName(dt.Id)>_
                    %endif
                    %<descStr>
                    %% Align the whole structure if necessary
                    %assign alignWholeStruct = !fieldAlign && structAlign
                    %assign SAlign = ""
                    %if ISFIELD(dt, "Alignment") && alignWholeStruct
                        %assign SAlign = SLibGetAlignmentSyntax(::CompiledModel.Name, SLibGetDataTypeName(dt.Id), "", ...
                            dt.Alignment, "DATA_ALIGNMENT_WHOLE_STRUCT")
                    %endif
                    %if SAlign != ""
                        %if structDAFlag.position == "DATA_ALIGNMENT_PREDIRECTIVE"
                            typedef %<SAlign> struct {
                        %elseif structDAFlag.position == "DATA_ALIGNMENT_PRECEDING_STATEMENT"
                            %<SAlign>
                            typedef struct {
                        %else
                            typedef struct {
                        %endif
                    %else
                        typedef struct {
                    %endif

                    %foreach eIdx = numElements
                        %assign eName = LibDataTypeElementName(dtIdx, eIdx)
                        %assign eDtId = LibDataTypeElementDataTypeId(dtIdx, eIdx)
                        %assign eComment = LibDataTypeElementComment(dtIdx, eIdx)
                        %assign eDtNm = LibDataTypeElementContainerName(dtIdx, eIdx)
                        %assign arrayDim = LibDataTypeElementVectorDims(dtIdx, eIdx)
                        %% Verify that an exported type doesn't depend on an Auto type
                        %if dtIsShared && (LibIsStructDataType(eDtId) || LibIsEnumDataType(eDtId) || LibIsAliasDataType(eDtId))
                            %if SLibDataTypeHasObject(eDtId) && !LibDataTypeIsShared(eDtId)
                                %assign args = ["%<SLibGetDataTypeName(dt.Id)>", "%<eDtNm>", "%<SLibGetDataTypeName(dt.Id)>", "%<eDtNm>"]
                                %<SLibReportErrorWithIdAndArgs("RTW:tlc:ExportTypeDependsOnNonExported", args)>
                            %endif
                        %endif

                        %% Deal with alignment.
                        %% Must consider nested structure
                        %assign align = ""
                        %if fieldAlign && !LibIsStructDataType(eDtId) && ...
                            ISFIELD(dt, "Alignment")
                            %assign align = SLibGetAlignmentSyntax(::CompiledModel.Name, eName, eDtNm, ...
                                ::CompiledModel.DataTypes.DataType[dtIdx].Alignment, ...
                                "DATA_ALIGNMENT_STRUCT_FIELD")
                        %endif

                        %% Add comments for this bus element
                        %if !ISEMPTY(eComment)
                            %<eComment>
                        %endif

                        %<align> %<eDtNm> %<eName>%<arrayDim>;
                        %assign padding = LibDataTypeElementPadding(dtIdx, eIdx)
                        %if padding == 1
                            %<LibGetDataTypeNameFromId(tSS_UINT8)> sl_padding%<padded>;
                            %assign padded = padded + 1
                        %elseif padding > 0
                            %<LibGetDataTypeNameFromId(tSS_UINT8)> sl_padding%<padded>[%<padding>];
                            %assign padded = padded + 1
                        %endif
                    %endforeach

                    %% Align the whole structure if necessary
                    %if SAlign != ""
                        %if structDAFlag.position == "DATA_ALIGNMENT_POSTDIRECTIVE"
                        } %<SLibGetDataTypeName(dt.Id)> %<SAlign>;
                        %elseif structDAFlag.position == "DATA_ALIGNMENT_FOLLOWING_STATEMENT"
                        } %<SLibGetDataTypeName(dt.Id)>;
                        %<SAlign>
                        %else
                        } %<SLibGetDataTypeName(dt.Id)>;
                        %endif
                    %else
                    } %<SLibGetDataTypeName(dt.Id)>;
                    %endif

                    %if LibIsDataTypeMultiWordFixpt(dtIdx)
                        %% generate multiword complex type
                        typedef struct {
                            %<SLibGetDataTypeName(dt.Id)> re;
                            %<SLibGetDataTypeName(dt.Id)> im;
                        } c%<SLibGetDataTypeName(dt.Id)>;
                    %endif
                    %if needGuard
                        #endif
                    %endif

                %endif %% Struct
            %endif %% if we're writing the type

            %% Close the buffer
            %closefile tmpBuffer

            %% Take care of the case of exporting the type to a separate file
            %% or to check for clashes
            %% Add this type to the array of records describing types being exported
            %% to _sharedutils.
            %% We're checking IsShared OR has an object here, because anonymous struct
            %% types are shared, but have to associated data type object.
            %if dtIsShared || dt.HasObject
                %assign dtChecksum = ::CompiledModel.DataTypes.DataType[dtIdx].Checksum
                %assign dtChecksumStr = ...
                    "%<dtChecksum[0]>,%<dtChecksum[1]>,%<dtChecksum[2]>,%<dtChecksum[3]>"

                %if !dtIsUserProvided
                    %assign dtDependencies = ::CompiledModel.DataTypes.DataType[dtIdx].Dependencies
                    %assign numDtDepends = SIZE(dtDependencies, 1)
                    %assign depVecStr = ""
                    %assign depBuiltinVec = ""
                    %assign depComplexVec = ""
                    %assign depMultiwordVec = ""
                    %assign depNonfiniteLiteralVec = ""
                    %foreach idxDep = numDtDepends
                        %assign thisIdx = dtDependencies[idxDep]
                        %assign isBuiltin = "0"
                        %if LibIsFundamentalBuiltInDataType(thisIdx)
                            %assign isBuiltin = "1"
                        %endif
                        %assign isComplex = "0"
                        %assign isMultiword = "0"
                        %assign isNonfiniteLiteral = "0"
                        %if LibIsDataTypeMultiWordFixpt(thisIdx)
                            %assign isMultiword = "1"
                        %endif
                        %if idxDep == 0
                            %assign depVecStr = LibGetDataTypeNameFromId(thisIdx)
                            %assign depBuiltinVec = isBuiltin
                            %assign depComplexVec = isComplex
                            %assign depMultiwordVec = isMultiword
                            %assign depNonfiniteLiteralVec = isNonfiniteLiteral
                        %else
                            %assign depVecStr = depVecStr + "," + LibGetDataTypeNameFromId(thisIdx)
                            %assign depBuiltinVec = depBuiltinVec + "," + isBuiltin
                            %assign depComplexVec = depComplexVec + "," + isComplex
                            %assign depMultiwordVec = depMultiwordVec + "," + isMultiword
                            %assign depNonfiniteLiteralVec = depNonfiniteLiteralVec + "," + isNonfiniteLiteral
                        %endif
                    %endforeach
                %else
                    %assign definition = ""
                    %assign depVecStr = ""
                    %assign depComplexVec = "0"
                    %assign depMultiwordVec = "0"
                    %assign depNonfiniteLiteralVec = "0"
                    %assign depBuiltinVec = "0"
                %endif

                %if dtIsShared
                    %assign objInfoArr.NumInfo = objInfoArr.NumInfo + 1
                    %addtorecord objInfoArr objInfo { name SLibGetDataTypeName(dt.Id); ...
                        kind "type"; ...
                        manglename SLibGetDataTypeName(dt.Id); ...
                        file dtHeaderFile; ...
                        checksum dtChecksumStr; ...
                        definition "%<tmpBuffer>"; ...
                        dependencies depVecStr; ...
                        isComplex depComplexVec; ...
                        isMultiword depMultiwordVec; ...
                        isNonfiniteLiteral depNonfiniteLiteralVec; ...
                        builtin depBuiltinVec; ...
                        typeUserProvided dtIsUserProvided; ...
                        genComplexTypedef generateCmplxTypedef}
                    %if !dtIsUserProvided
                        %<SLibAddGeneratedFileToList(dtHeaderFile,"utility","header","")>
                    %else
                        %<SLibAddGeneratedFileToList(dtHeaderFile,"custom","header","")>
                    %endif
                %else
                    %assign objInfoArrNonShared.NumInfo = objInfoArrNonShared.NumInfo + 1
                    %addtorecord objInfoArrNonShared objInfo { name SLibGetDataTypeName(dt.Id); ...
                        kind "type"; ...
                        manglename SLibGetDataTypeName(dt.Id); ...
                        file " "; ...
                        checksum dtChecksumStr; ...
                        definition "%<tmpBuffer>"; ...
                        dependencies depVecStr; ...
                        isComplex depComplexVec; ...
                        isMultiword depMultiwordVec; ...
                        isNonfiniteLiteral depNonfiniteLiteralVec; ...
                        builtin depBuiltinVec; ...
                        typeUserProvided dtIsUserProvided; ...
                        genComplexTypedef generateCmplxTypedef}
                %endif

                %if !genToShared && (dtIsShared && !dtIsUserProvided) && !(::CompiledModel.SharedTypesInIR)
                    %% Create the file as typename.h
                    %assign fileName = dtHeaderFileBase
                    %assign fileH = LibCreateSourceFileAtPath("Header", "Simulink", fileName, dtHeaderFileBase)

                    %% Write out the header file dependencies, if any, to the RequiredIncludes section.
                    %% SLibSetModelFileAttribute takes care of de-duping the RequiredIncludes section.
                    %assign dependsOnHeaderFiles = LibDataTypeDependsOnHeaderFiles(dt, dtHeaderFile)
                    %assign numDependsOnHeaderFiles = SIZE(dependsOnHeaderFiles, 1)
                    %foreach idx = numDependsOnHeaderFiles
                        %<LibSetIncludesSection(fileH, "RequiredIncludes", dependsOnHeaderFiles[idx])>
                    %endforeach

                    %% Remove header files we are including here from the top-level includes
                    %% (since those are now redundant). Do not remove from fullHeaderFiles.
                    %assign headerFiles = LibRemoveDependsOnHeaderFiles(dt, headerFiles, dtHeaderFileQuoted)

                    %% Write the tmpBuffer (containing the type definition) to the file
                    %% This'll append to existing contents if any (i.e. if >1 type is being
                    %% written to the same file, we'll concatenate the buffers)
                    %% We also write "coder_types.h" to the RequiredIncludes section
                    %if !WHITE_SPACE(tmpBuffer)
                        %<SLibSetModelFileDeferredIncludeCoderTypes(fileH, TLC_TRUE)>
                        %<SLibSetModelFileAttribute(fileH, "Typedefs", tmpBuffer)>
                    %endif
                    %% Put this file with the "utility" group
                    %<SLibSetModelFileAttribute(fileH, "Group", "utility")>
                    %% Set the "please indent me properly" flag,
                    %<SLibSetModelFileIndent(fileH, TLC_TRUE)>
                    %% Mark this as a shared type.
                    %<SLibSetModelFileSharedType(fileH, TLC_TRUE)>
                %endif
            %endif

            %if !dtIsShared
                %% Figure out what file we'll be writing this typedef to (typically model_types.h)
                %assign typesFile = SLibGetFileRecForCode("mdl_data_typedef")

                %% This puts the contents of tmpBuffer into the typedefs section of the specified file (model_types.h)
                %% We use the function that also writes "coder_types.h" to the RequiredIncludes
                %% section, on the assumption that the typedefs we are writing to the file might depend on "coder_types.h".
                %if !WHITE_SPACE(tmpBuffer)
                    %<SLibSetModelFileDeferredIncludeCoderTypes(typesFile, TLC_TRUE)>
                    %<SLibSetModelFileAttribute(typesFile, "Typedefs", tmpBuffer)>
                %endif
            %endif
        %endforeach

        %% Check for clashes with shared types
        %if !(::CompiledModel.SharedTypesInIR)
            %if genToShared
                %% Check non-shared data have no conflict with existing shared data in slprj
                %assign sharedHdrInfo = FEVAL("rtwprivate", "add2FileMap", ::CompiledModel.Name, ::CompiledModel.RTWInfoMatFile.sharedSourcesDir, objInfoArrNonShared, 4, 1, "traperror")
                %if TYPE(sharedHdrInfo)!="Scope" || sharedHdrInfo.status != 1
                    %assign errmsg = sharedHdrInfo.errorMessage
                    %<SLibReportErrorWithIdAndArgs("RTW:tlc:ErrWhenGenSharedType",  errmsg)>
                %endif
            %endif

            %% After the loop over types, call add2FileMap to add the exported-to-sharedutils types
            %% to the file map. (See matlab/toolbox/rtw/rtw/private/add2FileMap.m)
            %% Temporary - pass actual cgtInfo (info about .cgt templates) in the future

            %if objInfoArr.NumInfo > 0
                %if genToShared
                    %assign sharedHdrInfo = FEVAL("rtwprivate", "add2FileMap", ::CompiledModel.Name, CompiledModel.RTWInfoMatFile.sharedSourcesDir, objInfoArr, 1, 1)
                %else
                    %assign sharedHdrInfo = FEVAL("rtwprivate", "add2FileMap", ::CompiledModel.Name, "", objInfoArr, 2, 1)
                %endif
                %if TYPE(sharedHdrInfo)!="Scope" || sharedHdrInfo.status != 1
                    %assign errmsg = FEVAL("lasterr")
                    %<SLibReportErrorWithIdAndArgs("RTW:tlc:ErrWhenGenSharedType",  errmsg)>
                %else
                    %<SLibSynchronizeFileRepWithFileRecords()>

                    %% For every header file that did not need to be regenerated, make sure the file
                    %% is still registered as generated. This will allow for better error reporting
                    %% when file names collide (see geck 705830)
                    %foreach idx = sharedHdrInfo.numNotGeneratedFiles
                        %assign thisFile = sharedHdrInfo.notGeneratedFileList[idx].Name
                        %assign thisFileKind = sharedHdrInfo.notGeneratedFileList[idx].Kind
                        %assign thisUserProvided = sharedHdrInfo.notGeneratedFileList[idx].UserProvidedType
                        %if thisFileKind == "type" && !thisUserProvided
                            %assign thisFileName = thisFile
                            %assign thisMdlFile = SLibAddModelFile("SystemHeader", "TFL callback", thisFileName)
                            %<SLibSetModelFileSharedType(thisMdlFile, TLC_TRUE)>
                            %<SLibSetModelFileAttribute(thisMdlFile, "Filter", TLC_TRUE)>
                        %endif
                    %endforeach
                %endif
            %endif
        %endif

        %% Now collect the include directives we need to write, e.g. for exported or imported types
        %% Note we no longer explicitly add "rtwtypes.h" to this list, instead
        %% relying on the RequiredIncludes mechanism
        %openfile tmpBuffer
        %assign numHeaderFiles = SIZE(headerFiles, 1)
        %if numHeaderFiles > 0
            %foreach idx = numHeaderFiles
                #include %<headerFiles[idx]>
            %endforeach
        %endif
        %closefile tmpBuffer

        %% Also remember the header file information. For this, we pass fullHeaderFiles.
        %assign numFullHeaderFiles = SIZE(fullHeaderFiles, 1)
        %addtorecord DataTypes numHeaderFiles numFullHeaderFiles
        %addtorecord DataTypes headerFiles fullHeaderFiles

        %% This writes the include directives to the model_type.h file.
        %% "data_typedef_incl" is a codeGroupName, as defined in the file packaging table.
        %<SLibCacheCodeToFile("data_typedef_incl", tmpBuffer)>
    %endwith
%endfunction %% SLibWriteDatatypeTypedefs


%% Function: SLibSfunRegisterAndSetDataType ========================================================
%% Abstract:
%%   Set the Data Type the data type for an sfunction, input, output, or DWork.
%%   Register the data type if necessary, such as for fixed point data types.
%%
%% Arguments:
%%  categoryStr       string   "input", "output", or "dwork"
%%  SimstrucLabel     string   generated code RValue for simstruct
%%  elementIndexLabel string   generated code RValue for index of
%%                                 input, output, dwork
%%  origDataTypeIndex integer  data type index written to .rtw file
%%  modeForUnknownStr string   How to handle case when data type is unknown
%%                              "namedObject", "none", "warning", "error"
%% TopTester: test/toolbox/simulink/blocks/lib_MathOperations/Gain/rtw/tGainBlk_Codegencheck_RapidAccel.m
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-codegen/subsystemBuild/tIVSubsystemBuild_1.m
%%
%function SLibSfunRegisterAndSetDataType(...
    categoryStr, ...
    SimstrucLabel, ...
    elementIndexLabel, ...
    origDataTypeIndex, ...
    modeForUnknownStr) Output
    %%
    if (ssGetSimMode(%<SimstrucLabel>) != SS_SIMMODE_SIZES_CALL_ONLY) {
        %switch categoryStr
            %%
          %case "input"
            %%
            %assign dataTypeSetFuncStr = "ssSetInputPortDataType"
            %%
            %break
            %%
          %case "output"
            %%
            %assign dataTypeSetFuncStr = "ssSetOutputPortDataType"
            %%
            %break
            %%
          %case "dwork"
            %%
            %assign dataTypeSetFuncStr = "ssSetDWorkDataType"
            %%
            %break
            %%
          %default
            %%START_ASSERT
            %<LibReportFatalError("Unknown category, %<category>, for setting sfunction data type.")>
            %%END_ASSERT
        %endswitch
        %%
        %if LibIsFundamentalBuiltInDataType(origDataTypeIndex)
            %assign dtEnum = LibGetDataTypeEnumFromId(origDataTypeIndex)
            %<dataTypeSetFuncStr>(%<SimstrucLabel>, %<elementIndexLabel>, %<dtEnum>);
        %else
            %%
            %assign curDT = FixPt_GetDataTypeFromIndex(origDataTypeIndex)
            %%
            #if defined (MATLAB_MEX_FILE)
            %if LibIsHalfDataType(origDataTypeIndex)
                {
                    DTypeId halfID = ssRegisterDataTypeHalfPrecision(
                    %<SimstrucLabel>,
                    0/* do NOT obey data type override setting for this subsystem */);
                    %<dataTypeSetFuncStr>(%<SimstrucLabel>, %<elementIndexLabel>, halfID );
                }
            %elseif curDT.IsFixedPoint && !LibIsAliasDataType(origDataTypeIndex)
                %% NOTE:
                %% The source code for user written fixed-point C S-Functions must
                %% contain two extra #includes.
                %% First, at the beginning of the C file, just after the standard
                %%      #include "simstruc.h"
                %% also put
                %%      #include "fixedpoint.h"
                %% Second, at the end of the C file, just after the standard
                %%      # include "simulink.c"
                %% also put
                %%      # include "fixedpoint.c"
                %%
                {
                    DTypeId dataTypeIdReg =
                    %if FixPt_DataTypeIsFloat(curDT)
                        ssRegisterDataTypeFxpScaledDouble(
                    %else
                        ssRegisterDataTypeFxpFSlopeFixExpBias(
                    %endif
                    %<SimstrucLabel>,
                    %<curDT.IsSigned>,
                    %<curDT.RequiredBits>,
                    %<curDT.FracSlope>,
                    %<curDT.FixedExp>,
                    %<curDT.Bias>,
                    0 /* false means do NOT obey data type override setting for this subsystem */ );

                    %<dataTypeSetFuncStr>(%<SimstrucLabel>, %<elementIndexLabel>, dataTypeIdReg );
                }
            %else
                %assign dtEnum = LibGetDataTypeEnumFromId(origDataTypeIndex)
                %%
                %if dtEnum == "SS_POINTER" || dtEnum == "SS_INTEGER" || dtEnum == "SS_FCN_CALL"
                    %<dataTypeSetFuncStr>(%<SimstrucLabel>, %<elementIndexLabel>, %<dtEnum>);
                %else
                    %switch modeForUnknownStr
                        %%
                      %case "namedObject"
                        %%
                        {
                            DTypeId dataTypeIdReg;

                            ssRegisterTypeFromNamedObject(
                            %<SimstrucLabel>,
                            "%<LibGetDataTypeNameFromId(origDataTypeIndex)>",
                            &dataTypeIdReg);

                            if(dataTypeIdReg == INVALID_DTYPE_ID) return;
                            %<dataTypeSetFuncStr>(%<SimstrucLabel>, %<elementIndexLabel>, dataTypeIdReg );
                        }
                        %%
                        %break
                        %%
                      %case "none"
                        %%
                        %break
                        %%
                      %default
                        %%
                        %openfile dataTypeRegFailMsg
                        User-defined data type %<LibGetDataTypeNameFromId(origDataTypeIndex)> is required
                        for %<categoryStr> %<elementIndexLabel>, but the information needed to define
                        this data type in the generated S-Function is unknown.
                        %if modeForUnknownStr == "warning"
                            The generated code that normally specifies the data type of this
                            %<categoryStr> is being omitted.  If additional custom code does not register
                            this user-define data type and set the data type of this %<categoryStr>,
                            then the generated code will be incomplete.
                        %endif
                        %closefile dataTypeRegFailMsg
                        %if SLibInBlockScope()
                            %assign block = SLibGetCurrentBlock()
                            %if modeForUnknownStr == "warning"
                                %<LibBlockReportWarning(block,dataTypeRegFailMsg)>
                            %else
                                %<LibBlockReportFatalError(block,dataTypeRegFailMsg)>
                            %endif
                        %else
                            %if modeForUnknownStr == "warning"
                                %<LibReportWarning(dataTypeRegFailMsg)>
                            %else
                                %<LibReportFatalError(dataTypeRegFailMsg)>
                            %endif
                        %endif
                    %endswitch
                %endif
            %endif
            #endif
        %endif
    }
    %return
%endfunction %% SLibSfunRegisterAndSetDataType

%% Function: DeclareFixedPointWordSizeUsage ========================================================
%% Abstract:
%%   Determines the largest block-declared fixed point wordsize usage.  Used by
%%   front-ends which generate TLC code.
%%
%function DeclareFixedPointWordSizeUsage(maxSizeInBits) void
    %if maxSizeInBits > ::CompiledModel.DeclaredFixedPointWordSizeUsage
        %assign ::CompiledModel.DeclaredFixedPointWordSizeUsage = maxSizeInBits
    %endif
%endfunction



%% Function: SLibGetTypeForBitfield ================================================================
%% Abstract:
%%   This function returns the appropriate data type for a bitfield,
%%   considering the users preference and whether the bitfield will fit
%%
%%   For example,
%%
%%     SLibGetTypeForBitfield(1)
%%       ==> returns "unsigned char" if the user said to use 8-bit containers
%%
%%     SLibGetTypeForBitfield(1)
%%       ==> returns "unsigned int" if the user said so, or let it default
%%
%%     SLibGetTypeForBitfield(9)
%%       ==> returns "unsigned int" even if the user said to use 8-bits
%%
%%   Argument:
%%     BitFieldWidth = width of the current bitfield
%% TopTester: test/toolbox/rtw/targets/AUTOSAR/Variants/tValueVariants.m
%%
%function SLibGetTypeForBitfield(BitFieldWidth) void
    %% This optimization only applies to the BooleansAsBitfields optimization
    %% so only do the substitution if the bitfield is one bit.
    %if ISFIELD(ConfigSet,"BitfieldContainerType") && ...
        BitFieldWidth == 1
        %% TopTester: test/toolbox/rtw/targets/ert/tLangStandardTypesBooleansAsBitfields.m
        %if ConfigSet.BitfieldContainerType=="uint_T" %% sbcheck:ok:tlctypes
            %return LibGetDataTypeNameFromId(::CompiledModel.tSS_UINTEGER)
        %elseif  ConfigSet.BitfieldContainerType=="uchar_T" %% sbcheck:ok:tlctypes
            %return LibGetDataTypeNameFromId(::CompiledModel.tSS_UCHAR)
        %else
            %error "Invalid bitfield container type"
        %endif
    %else
        %% TopTester: test/toolbox/rtw/targets/ert/tLangStandardTypesStateflowBitfields.m
        %return LibGetDataTypeNameFromId(::CompiledModel.tSS_UINTEGER)
    %endif

%endfunction %%SLibGetTypeForBitfield

%% Function: SLibDeclareDataAsPointer ==============================================================
%% Abstract:
%%  Returns TLC_TRUE if the dtID passed in should be declared
%% as a pointer.  Currently this means that the it is either a struct
%% that is not a multi-word data type, or data with a deepcopy method
%% (memcpy is not desired)
%function SLibDeclareDataAsPointer(dtID) void
    %return (LibIsStructDataType(dtID) && !LibIsDataTypeMultiWordFixpt(dtID)) || ...
        !ISEMPTY(SLibDataTypeDeepCopyFcnName(dtID))
%endfunction

%% Function: SLibConvert2DMatrix ===================================================================
%% Abstract:
%%   Generate the code for converting a col (row) major 2D matrix to a
%%   row (col) major 2D matrix (backward compatibility for old LCT generated
%%   S-Functions)
%function SLibConvert2DMatrix(col2Row, typeId, width, dims, cMatStr, slMatStr, kind, isCplx, level) Output
    %<SLibMarshalNDArray(col2Row, typeId, width, dims, cMatStr, slMatStr, kind, isCplx, level)>
%endfunction

%% Function: SLibMarshalNDArray ====================================================================
%% Abstract:
%%   Generate the code for converting a col (row) major ND array to a
%%   row (col) major ND array:
%%     - col2Row: TLC_TRUE for col to row major convertion, TLC_FALSE otherwise
%%     - typeId: data type record ID
%%     - width: total number of elements in the array
%%     - dims: dimensions as [1xN] vector
%%     - cMatStr: base address of the row-major ND C array
%%     - slMatStr: base address of the col-major ND SL array
%%     - kind: 1 (simple conversion without recursion) or 2 (convert structure's fields)
%%     - isCplx: TLC_TRUE for complex data, TLC_FALSE otherwise
%%     - level: mangler for the automatic variable's names
%function SLibMarshalNDArray(col2Row, typeId, width, dims, cMatStr, slMatStr, kind, isCplx, level) Output
    %assign intType = LibGetDataTypeNameFromId(::CompiledModel.tSS_INTEGER)
    %assign typeName = isCplx ? LibGetDataTypeComplexNameFromId(typeId) : LibGetDataTypeNameFromId(typeId)
    %%
    %if kind==1
        %% Simple transposition of the ND array
        %<SLibGenerateNDArrayMarshaling(col2Row, cMatStr, slMatStr, dims, typeName, level)>
        %%
    %elseif kind==2
        %% Complex (non trivial) transposition
        %assign numDims = SIZE(dims,1)
        %assign isScalar = ISEQUAL(width, 1)
        %assign colMatStr = slMatStr
        %assign rowMatStr = cMatStr
        %%
        %if isScalar
            %assign colMatStr = slMatStr
            %assign rowMatStr = cMatStr
            %if level==0
                %assign colMatStr = "(*" + colMatStr + ")"
                %assign rowMatStr = "(*" + rowMatStr + ")"
            %endif
            %<SLibMarshalNDArrayForBus(col2Row, typeId, rowMatStr, colMatStr, level)>
        %elseif numDims >= 2
            {
                %<intType> __idx%<level> = 0;
                %assign subs = []
                %foreach dimIdx = numDims
                    %assign loopVar = "__idx%<level>_%<dimIdx+1>"
                    %<intType> %<loopVar>;
                    for (%<loopVar> = 0; %<loopVar> < %<dims[dimIdx]>; ++%<loopVar>) {
                        %assign subs = subs + loopVar
                    %endforeach
                    %<typeName>* __cMatPtr%<level> = &%<rowMatStr>[__idx%<level>++];
                    %<typeName>* __slMatPtr%<level> = &%<colMatStr>[%<FcnGenSubscriptsToIndex(subs, dims, TLC_TRUE)>];
                    %<SLibMarshalNDArrayForBus(col2Row, typeId, "(*__cMatPtr%<level>)", "(*__slMatPtr%<level>)", level+1)>
                    %foreach dimIdx = numDims
                    }
                %endforeach
            }
        %else
            %assign fakeBlk = BLOCK { Name "" }
            %assign rollThresh = 0 %%RollThreshold
            %roll iIdx=[0:%<width-1>], iLcv=rollThresh, fakeBlk, "Roller", ""
                %assign iLoc = (iLcv == "") ? iIdx : iLcv
                %<SLibMarshalNDArrayForBus(col2Row, typeId, "%<cMatStr>[%<iLoc>]", "%<slMatStr>[%<iLoc>]", level+1)>
            %endroll
        %endif
    %else
        %% No marshaling required but level > 0 then need to memcpy the fields
        %if level!=0
            %assign widthStr = width > 1 ? "%<width>*" : ""
            %if col2Row==TLC_TRUE
                (void) %<LibGenMemFcnCall("memcpy", "%<cMatStr>", "%<slMatStr>", "%<widthStr>sizeof(%<typeName>)")>;
            %else
                (void) %<LibGenMemFcnCall("memcpy", "%<slMatStr>", "%<cMatStr>", "%<widthStr>sizeof(%<typeName>)")>;
            %endif
        %endif
        %%
    %endif
%endfunction

%% Function: SLibMarshalNDArrayForBus ==============================================================
%% Abstract:
%%   Walk through a Bus/Struct hierarchy for generating the code for each field
%%   that converts a col (row) major ND array to a row (col) major ND array:
%%     - col2Row: TLC_TRUE for col to row major convertion, TLC_FALSE otherwise
%%     - typeId: data type record ID
%%     - cMatStr: base address of the row-major ND C array
%%     - slMatStr: base address of the col-major ND SL array
%%     - level: mangler for the automatic variable names
%function SLibMarshalNDArrayForBus(col2Row, typeId, cMatStr, slMatStr, level) Output
    %%
    %foreach idxE = LibDataTypeNumElements(typeId)
        %assign eName = LibDataTypeElementName(typeId, idxE)
        %assign eDTypeId = LibGetDataTypeIdAliasedThruToFromId(LibDataTypeElementDataTypeId(typeId, idxE))
        %assign eWidth = LibDataTypeElementWidth(typeId, idxE)
        %assign eDims = LibDataTypeElementDimensions(typeId, idxE)
        %assign eIsCplx = LibDataTypeElementIsComplex(typeId, idxE)
        %%
        %assign eCMatStr = cMatStr + "." + eName
        %assign eSLMatStr = slMatStr + "." + eName
        %%
        %assign matInfo = FcnGetNDArrayMarshalingInfo(eDTypeId, eDims)
        %if matInfo==0
            %% This element does not need special care then just memcpy it in the
            %% generated code but need to pass the address of the element
            %% to the marshaling function
            %assign optAddr = eWidth==1 ? "&" : ""
            %assign eCMatStr = "%<optAddr>%<eCMatStr>"
            %assign eSLMatStr = "%<optAddr>%<eSLMatStr>"
        %else
            %if (eWidth > 1) && (SIZE(eDims, 1) > 1)
                %% Need a cast since the sub array of structure is accessed with a linear index
                %assign eDTypeName = eIsCplx ? LibGetDataTypeComplexNameFromId(eDTypeId) : LibGetDataTypeNameFromId(eDTypeId)
                %assign eCMatStr = "((%<eDTypeName>*)" + eCMatStr + ")"
                %assign eSLMatStr = "((%<eDTypeName>*)" + eSLMatStr + ")"
            %endif
        %endif
        %<SLibMarshalNDArray(col2Row, eDTypeId, eWidth, eDims, eCMatStr, eSLMatStr, matInfo, eIsCplx, level+1)>
    %endforeach
%endfunction

%% Function: SLibGenerateNDArrayMarshaling =========================================================
%% Abstract:
%%   Helper for generating an inlined convertion to change a col (row) major
%%   ND array to a row (col) major ND array:
%%     - col2Row: TLC_TRUE for col to row major convertion, TLC_FALSE otherwise
%%     - cMatStr: base address of the row-major ND C array
%%     - slMatStr: base address of the col-major ND SL array
%%     - dims: dimensions as [1xN] vector
%%     - typeName: data type name
%%     - level: mangler for the automatic variable names
%function SLibGenerateNDArrayMarshaling(col2Row, cMatStr, slMatStr, dims, typeName, level) Output
    %assign intType = LibGetDataTypeNameFromId(::CompiledModel.tSS_INTEGER)
    {
        %if level > 0
            %<typeName>* __colMat%<level> = (%<typeName>*)%<slMatStr>;
            %<typeName>* __rowMat%<level> = (%<typeName>*)%<cMatStr>;
            %assign slMatStr = "__colMat%<level>"
            %assign cMatStr = "__rowMat%<level>"
        %endif
        %<intType> __idx%<level> = 0;
        %assign numDims = SIZE(dims,1)
        %assign subs = []
        %foreach dimIdx = numDims
            %assign loopVar = "__idx%<level>_%<dimIdx+1>"
            %<intType> %<loopVar>;
            for (%<loopVar> = 0; %<loopVar> < %<dims[dimIdx]>; ++%<loopVar>) {
                %assign subs = subs + loopVar
            %endforeach
            %assign cMatAddr = "&%<cMatStr>[__idx%<level>++]"
            %assign slMatAddr = "&%<slMatStr>[%<FcnGenSubscriptsToIndex(subs, dims, TLC_TRUE)>]"
            %if col2Row==TLC_TRUE
                (void)%<LibGenMemFcnCall("memcpy", "%<cMatAddr>", "%<slMatAddr>", "sizeof(%<typeName>)")>;
            %else
                (void)%<LibGenMemFcnCall("memcpy", "%<slMatAddr>", "%<cMatAddr>", "sizeof(%<typeName>)")>;
            %endif
            %foreach dimIdx = numDims
            }
        %endforeach
    }
%endfunction

%% Function: FcnGenSubscriptsToIndex ===============================================================
%% Abstract:
%%   Convert subscripts to linear index for col/row major array
%%     - subs: subscripts as [1xN] string vector
%%     - dims: dimensions as [1xN] vector
%%     - isColMajor: TLC_TRUE for column major indexing
%function FcnGenSubscriptsToIndex(subs, dims, isColMajor) void
    %assign linIdx = ""
    %assign revDimIdx = SIZE(dims,1)-1
    %foreach dimIdx = SIZE(dims,1)
        %assign idx = isColMajor ? revDimIdx : dimIdx
        %assign offset = ""
        %if dimIdx > 0
            %if dimIdx > 1
                %assign linIdx = "(" + linIdx + ")"
            %endif
            %assign offset = linIdx + "*%<dims[idx]> + "
        %endif
        %assign linIdx = offset + "%<subs[idx]>"
        %assign revDimIdx = revDimIdx - 1
    %endforeach
    %return linIdx
%endfunction

%% Function: FcnGetNDArrayMarshalingInfo ===========================================================
%% Abstract:
%%   Returns information about the (potential) need for marshaling when
%%   converting from/to col major to/from row major.
%%     - typeId: data type record ID
%%     - dims: dimensions as [1xN] vector
%%   The output is one of the following values:
%%     0 -> no marshaling required
%%     1 -> need simple marshaling
%%     2 -> need complex marshaling (bus for instance)
%function FcnGetNDArrayMarshalingInfo(typeId, dims) void
    %if LibIsStructDataType(typeId) && FcnBusNeedNDArrayMarshaling(typeId, TLC_FALSE)
        %% Structure with ND leafs of sub-structures
        %return 2
    %elseif (SIZE(dims,1)>=2) && (FcnProdVectorElement(dims)>1)
        %% Simple ND conversion
        %return 1
    %else
        %return 0
    %endif
%endfunction

%% Function: FcnBusNeedNDArrayMarshaling ===========================================================
%% Abstract:
%%   Returns information about the need for marshaling Bus when
%%   converting from/to col major to/from row major.
%function FcnBusNeedNDArrayMarshaling(typeId, status) void
    %foreach idxE = LibDataTypeNumElements(typeId)
        %assign dims = LibDataTypeElementDimensions(typeId, idxE)
        %if (SIZE(dims,1)>=2) && (FcnProdVectorElement(dims)>1)
            %% TRUE ND array
            %return TLC_TRUE
        %else
            %if LibIsStructDataType(typeId)
                %% Recurse on sub structure
                %assign status = status || ...
                    FcnBusNeedNDArrayMarshaling(LibDataTypeElementDataTypeId(typeId, idxE), status)
            %endif
        %endif
    %endforeach
    %return status
%endfunction

%% Function: FcnProdVectorElement ==================================================================
%% Abstract:
%%   Similar to the MATLAB function prod but for vector only
%function FcnProdVectorElement(vec) void
    %assign val = 1
    %foreach idx = SIZE(vec,1)
        %assign val = val * vec[idx]
    %endforeach
    %return val
%endfunction

%% DocFunction{Other Useful Functions}: LibGetRecordUnitId =================
%% Abstract:
%%   Return the unit ID for a given data record.
%%
%function LibGetRecordUnitId(rec) void
    %return rec.UnitIdx
%endfunction


%% Function: LibGetRecordUnitExpr ==================================================================
%% Abstract:
%%   Return the data type name for a specified record.
%%
%%   Arguments:
%%     rec  - TLC record
%%
%function LibGetRecordUnitExpr(rec)
    %return LibGetUnitExprFromId(LibGetRecordUnitId(rec))
%endfunction


%% Function: SLibGetRecordUnitExpr =================================================================
%% Abstract:
%%   Return the data type name for a specified record.
%function SLibGetRecordUnitExpr(rec)
    %return LibGetRecordUnitExpr(rec)
%endfunction

%% Function: SLibGetRecordASCIIEscapedUnitExpr =====================================================
%% Abstract:
%%   Return the escaped unit expression for a specified record.
%function SLibGetRecordASCIIEscapedUnitExpr(rec)
    %return LibGetASCIIEscapedUnitExprFromId(LibGetRecordUnitId(rec))
%endfunction


%% Function: SLibGetRecordIsUnitsEnabled ===========================================================
%% Abstract:
%%   Return whether or not units is enabled.
%function SLibGetRecordIsUnitsEnabled()
    %if !EXISTS(::UnitsEnabled)
        %assign ::UnitsEnabled = CGMODEL_ACCESS("CGModel.IsUnitsEnabled")
    %endif

    %return ::UnitsEnabled
%endfunction

%% Function: SLibIsUnknownType =====================================================================
%% Abstract:
%%   Returns true if and only if the given CG type index corresponds
%%   to an unknown type. This function also returns true if the given
%%   type is a matrix and the base type is an unknown type.
%function SLibIsUnknownType(aCGTypeIdx) void
    %return LibCGTypeIsMatrix(aCGTypeIdx) ? ...
        LibCGTypeIsUnknown(LibCGTypeScalarBaseType(aCGTypeIdx)) : ...
        LibCGTypeIsUnknown(aCGTypeIdx)
%endfunction

%% DocFunction{Other Useful Functions}: LibGetRecordIsOrContainsStdContainer
%% Abstract:
%%   Returns true if the given data record corresponds to a std container type or
%%   a struct that contains a std container type.
%function LibGetRecordIsOrContainsStdContainer(rec) void
    %if LibGetRecordIsStdContainer(rec)
        %return TLC_TRUE
    %else
        %assign cgTypeIdx = SLibGetRecordContainerCGTypeIdx(rec)
        %return LibCGTypeContainsStdContainer(cgTypeIdx)
    %endif
%endfunction

%% DocFunction{Other Useful Functions}: LibGetRecordIsStdContainer
%% Abstract:
%%   Returns true if the given data record corresponds to a std container type or
%%   a container type that is a std container type.
%function LibGetRecordIsStdContainer(rec) void
    %return (ISFIELD(rec, "CGTypeIdx") && LibCGTypeIsStdContainer(rec.CGTypeIdx)) || ...
        (ISFIELD(rec, "ContainerCGTypeIdx") && LibCGTypeIsStdContainer(rec.ContainerCGTypeIdx))
%endfunction

%% Function: SLibOptStdCGTypeIdx
%% Abstract:
%%   Returns the CGType index for file packaging analysis.
%%
%%   Specify the useStdContainer argument as whether to return matrix or base
%%   type index if the type is a pre-lowering std container type.
%%
%function SLibOptStdCGTypeIdx(cgTypeIdx, useStdContainer) void
    %if !useStdContainer && LibCGTypeIsStdContainer(cgTypeIdx)
        %return LibCGTypeBaseIndex(cgTypeIdx)
    %else
        %return cgTypeIdx
    %endif
%endfunction

%% Function: SLibGetRecordContainerOptStdCGTypeIdx
%% Abstract:
%%   Returns the container or implementation type index for a given
%%   data record.
%%
%%   Specify the useStdContainer argument as whether to return matrix or base
%%   type index if the type is a pre-lowering std container type.
%%
%function SLibGetRecordContainerOptStdCGTypeIdx(rec, useStdContainer) void
    %assign containerCgTypeIdx = SLibGetRecordContainerCGTypeIdx(rec)
    %if LibCGTypeIsEnum(SLibGetRecordOriginalCGTypeIdx(rec)) && ...
        !(useStdContainer && LibCGTypeIsStdContainer(containerCgTypeIdx))
        %assign cgTypeIdx = SLibGetRecordOriginalCGTypeIdx(rec)
    %else
        %assign cgTypeIdx = containerCgTypeIdx
    %endif
    %return SLibOptStdCGTypeIdx(cgTypeIdx, useStdContainer)
%endfunction

%% Function: SLibGetRecordOptStdCGTypeIdx
%% Abstract:
%%   Returns the CGType index for a specified record.
%%
%%   Specify the useStdContainer argument as whether to return matrix or base
%%   type index if the type is a pre-lowering std container type.
%%
%function SLibGetRecordOptStdCGTypeIdx(rec, useStdContainer) void
    %if ISFIELD(rec, "CGTypeIdx")
        %assign cgTypeIdx = SLibGetRecordContainerCGTypeIdx(rec)
        %return SLibOptStdCGTypeIdx(cgTypeIdx, useStdContainer)
    %else
        %assign dtId = LibGetRecordDataTypeId(rec)
        %assign dt = ::CompiledModel.DataTypes.DataType[dtId]
        %if ISFIELD(dt, "CGTypeIdx")
            %return dt.CGTypeIdx
        %elseif ISFIELD(dt, "ContainerCGTypeIdx")
            %return dt.ContainerCGTypeIdx
        %else
            %return -1
        %endif
    %endif
%endfunction

%% Function: SLibGetAlignmentForCGType
%% Abstract:
%%   Returns the data alignment value registered/specified for a given type
%%   Currently, only complex/struct/class will have this setup
%%   Natural alignment of other types are not yet set up
%%
%function SLibGetAlignmentForCGType(cgTypeIdx)
    %%for matrix types, get the base type and check its alignment
    %if LibCGTypeIsMatrix(cgTypeIdx)
        %assign baseCGIdx = LibCGTypeBaseIndex(cgTypeIdx)
        %return LibCGTypeStructAlignment(baseCGIdx)
    %endif

    %return LibCGTypeStructAlignment(cgTypeIdx)
%endfunction
%% End of library code
%%

%endif %% _DTYPELIB_

%% [EOF] dtypelib.tlc
