%%
%%
%%
%% Copyright 1994-2023 The MathWorks, Inc.
%%
%% Abstract:
%%   This TLC library file contains the general purpose utility functions.
%%

%if EXISTS(::_UTILLIB_) == 0
%assign ::_UTILLIB_ = 1

%if !EXISTS(::NEWLINE)
    %assign ::NEWLINE = FEVAL("newline")
%endif

%include "utils_api.tlc"
%include "utility_private_api.tlc"

%function SLibGetBlockIdxFromSID(system, sid) void
    %foreach blkIdx = system.NumBlocks
        %if ISFIELD(system.Block[blkIdx], "TLCBlockSID") && ...
            system.Block[blkIdx].TLCBlockSID == sid
            %return blkIdx
        %endif
    %endforeach
    %return -1
%endfunction %%SLibGetBlockFromSID

%% Function: FcnSFDworkInfo ========================================================================
%% Abstract:
%%   Helper function to generate meaningful comments for Stateflow dworks
%%
%function FcnSFDworkInfo(srcBlk, dwRec, dwIdx) void
    %generatefile "chartSource" "%<srcBlk.SFInfo.ChartTLCFile>.tlc"
    %assign chartDataMap = ...
        GENERATE_TYPE(srcBlk, "ChartDataMap", "chartSource", ...
        System[dwRec.SigSrc[0]])
    %if ISFIELD(chartDataMap, "ChartData")
        %assign info = chartDataMap.ChartData[dwIdx]
        %assign path = info.Path
        %assign description = info.Description
        %switch description
          %case "ChartLocal"
            %return "Local data '" + path + "'"
            %break
          %case "Constant"
            %return "Constant data '" + path + "'"
            %break
          %case "StateIsActive"
            %if ISEMPTY(path)
                %return "Chart is active"
            %else
                %return "State '" + path + "' is active"
            %endif
            %break
          %case "StateActiveChild"
            %if ISEMPTY(path)
                %return "Active substate of the chart"
            %else
                %return "Active substate of '" + path + "'"
            %endif
            %break
          %case "EmlPersistent"
          %case "EmlPersistentSentinel"
            %return "DWork:" + info.Description + ":" + info.SrcLocation +  " %<dwIdx+1>"
            %break
          %default
            %return "DWork %<dwIdx+1>"
            %break
        %endswitch
    %endif
%endfunction

%function SLibGetMdlBlockFromSID(aSID)
    %assign blk = []
    %assign mdlRefBlks = ISFIELD(::CompiledModel,"ModelReferenceBlocks") ? ...
        ::CompiledModel.ModelReferenceBlocks : []
    %if !ISEMPTY(mdlRefBlks)
        %foreach rowIdx = SIZE(mdlRefBlks,0)
            %assign mdlRefInfo = mdlRefBlks[rowIdx]
            %assign mSysIdx = mdlRefInfo[0]
            %assign bIdx    = mdlRefInfo[1]
            %assign blk = ::CompiledModel.System[mSysIdx].Block[bIdx]
            %if blk.TLCBlockSID == aSID
                %return blk
            %endif
        %endforeach
    %endif
    %return []
%endfunction

%% Function: SLibTrackCanIOForSLF
%% This function is intended to handle a Stateflow
%% exported graphical function's access of a global
%% canonical I/O variable. It is a Stateflow parallel to Simulink's
%% logic in commonpass.tlc (look for ConnectedToSimulinkFunction)
%% and WriteCanonicalInputArgDefs in rtwgen_signal.cpp
%function SLibTrackCanIOForSLF(argName) void
    %assign baseSystemIdx = GetBaseSystemIdx()
    %if IsModelReferenceTarget()
        %assign intf = System[baseSystemIdx].Interface
        %foreach idx = intf.NumCanonicalInputArgDefs
            %assign argdef = intf.CanonicalInputArgDef[idx]
            %if argdef.GlobalIdentifier == argName
                %assign argdef.ConnectedToSimulinkFunction = "yes"
                %<LibAccessThisSysFcnArg(argdef, "Start", "Global")>
                %<SLibAccessArg(argdef, "Start", 0, 0)>
                %return
            %endif
        %endforeach
        %foreach idx = intf.NumCanonicalOutputArgDefs
            %assign argdef = intf.CanonicalOutputArgDef[idx]
            %if argdef.GlobalIdentifier == argName
                %assign argdef.ConnectedToSimulinkFunction = "yes"
                %<LibAccessThisSysFcnArg(argdef, "Start", "Global")>
                %<SLibAccessArg(argdef, "Start", 0, 0)>
                %return
            %endif
        %endforeach
    %endif
    %return
%endfunction

%% Function: SLibReferencedBy ======================================================================
%% Abstract:
%%   Routine to return referencing paths
%% TopTester: test/toolbox/simulink/variants/var-general/tvariant_merge.m
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tmg1317695_VC1.m
%%
%function SLibReferencedBy(dataRec) void
    %assign comment = ""
    %% If dataRec is a model parameter, return SLibGenModelPrmDefnComment
    %if ISFIELD(dataRec, "RecordType") && dataRec.RecordType == "ModelParameter"
        %assign comment = SLibGenModelPrmDefnComment(dataRec)
        %% Otherwise, comment is graphical path (except for global DSM)
    %else
        %if ISFIELD(dataRec, "BlkZcRecIdx")
            %assign dataGrBlk = SLibGrBlock(::CompiledModel.ZcRec.BlkZcRec[dataRec.BlkZcRecIdx].GrSrc)
        %else
            %assign dataGrBlk = ISFIELD(dataRec, "GrSrc") ? SLibGrBlock(dataRec.GrSrc) : []
        %endif
        %if ISFIELD(dataRec, "OwnerBlockName") && !ISEMPTY(dataRec.OwnerBlockName)
            %assign comment = "'" + dataRec.OwnerBlockName + "'"
        %elseif !ISEMPTY(dataGrBlk)
            %assign gen2Shared = TLC_FALSE
            %if ISFIELD(dataRec, "VarGroupIdx")
                %assign varGrp = ::CompiledModel.VarGroups.VarGroup[dataRec.VarGroupIdx[0]]
                %assign sysIdx = varGrp.SysIdx
                %assign instIdx = 0
                %if ISFIELD(varGrp,"InstanceIdx")
                    %assign instIdx = varGrp.InstanceIdx
                %endif
                %if LibSystemIsContainedWithinReusedLibraryFcn(sysIdx, instIdx)
                    %assign gen2Shared = TLC_TRUE
                %endif
            %endif
            %% Only Shared files should have comments pointing to libraries
            %if ISFIELD(dataGrBlk, "RLSCommentName") && gen2Shared
                %assign comment = dataGrBlk.RLSCommentName
            %else
                %if SLibGetBlockCommentType() == "BlockPathComment"
                    %if ISFIELD(dataGrBlk, "OrigInlineVarBlkName")
                        %assign comment = "'" + dataGrBlk.OrigInlineVarBlkName + "'"
                    %else

                        %assign comment = "'" + dataGrBlk.Name + "'"

                    %endif
                %else
                    %assign comment = SLibGrBlockSIDComment(dataGrBlk)
                %endif
            %endif
        %elseif ISFIELD(dataRec, "RecordType") && ...
            dataRec.RecordType == "DWork"
            %assign comment = LibBlockDWorkOwnerComment(dataRec)
        %elseif ISFIELD(dataRec, "RecordType") && ...
            ISFIELD(dataRec, "BlockName") && ...
            (dataRec.RecordType == "ExternalInput" || dataRec.RecordType == "ExternalOutput")
            %if ISFIELD(dataRec, "GrSrc")
                %assign comment = SLibGrBlockCommentName(dataRec.GrSrc)
            %else
                %assign comment = "'" + dataRec.BlockName + "'"
            %endif
        %else
            %assign comment = ""
        %endif
        %% If SLCI is on, enhance block output and dwork comments
        %assign slciOn = ::CompiledModel.SLCI == "on"
        %if slciOn && ISFIELD(dataRec, "StorageClass") && ...
            (dataRec.StorageClass == "Auto") && ISFIELD(dataRec, "RecordType")
            %if dataRec.RecordType == "BlockOutput"
                %assign portIdx = dataRec.GrSrc[2]
                %if portIdx >= 0
                    %assign comment = comment + " (Output %<portIdx+1>)"
                %endif
            %elseif dataRec.RecordType == "DWork"
                %assign dwIdx = dataRec.GrSrc[2]
                %if dataRec.GrSrc[1] != -1 && ...
                    !dataRec.DWorkForDimSize
                    %assign grBlk = SLibGrBlock(dataRec.GrSrc)
                    %if grBlk.Type == "Stateflow"
                        %assign slBlk = ::CompiledModel.System[dataRec.SigSrc[0]].Block[dataRec.SigSrc[2]]
                        %% Don't generate special comments for dworks added to the subsystem shell
                        %% (e.g. subsysRanBc) instead of the S-Function actually implementing the chart
                        %if slBlk.Type == "S-Function"
                            %assign dworkInfo = FcnSFDworkInfo(slBlk, dataRec, dwIdx)
                            %assign comment = comment + " (%<dworkInfo>)"
                            %return comment
                        %endif
                    %endif
                %endif
                %if dwIdx >= 0
                    %assign comment = comment + " (DWork %<dwIdx+1>)"
                %endif
            %endif
            %if ISFIELD(dataRec, "SynthBlockName") && !ISEMPTY(dataRec.SynthBlockName)
                %assign comment = comment + " (" + dataRec.SynthBlockName + ")"
            %endif
        %endif
    %endif
    %return comment
%endfunction

%% Function: FcnDataStoreMemoryNonAutoData =========================================================
%% Abstract:
%%   Is this data a data store with non-auto storage class?
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%%
%function FcnDataStoreMemoryNonAutoData(data) void
    %if data.RecordType == "DWork"
        %if data.StorageClass == "ExportedGlobal" || ...
            data.StorageClass == "ImportedExtern" || ...
            data.StorageClass == "ImportedExternPointer" || ...
            data.StorageClass == "Custom"
            %return data.IsDataStoreMemory
        %endif
    %endif
    %return TLC_FALSE
%endfunction

%% Function: SLibDataGetInlineVariantCondition =====================================================
%% Abstract:
%%  Return the net variant condition associated with a data record's existance
%%  net variant condition in this case = the data record's condition && the specific callside condition
%%  used to guard block I/O initialization
%%  TopTester: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tmblockio_initialization_simple.m
%%  TopTester: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tmblockio_initialization_subsystem.m
%%
%function SLibDataGetInlineVariantCondition(data) void

    %assign sysCondition = ""
    %assign condition = ""
    %% Time-saving short cut applicable 99%+ of the time
    %if (!::CompiledModel.HasVariants)
        %return condition %% return empty
    %endif

    %assign indices = SLibGetSystemAndCallSideIndex(data)
    %assign sysIdx = indices[0]
    %assign instIdx = indices[1]
    %if instIdx == -1
        %assign instIdx = 0
    %endif
    %assign conditions = ::CompiledModel.System[sysIdx].NetInlineVariantPreprocessorInstanceConditions
    %if !ISEMPTY(conditions)
        %assign sysCondition = conditions[instIdx]
    %endif

    %if (!ISEMPTY(data) && ISFIELD(data, "VariantCondition"))
        %assign condition = data.VariantCondition
    %endif

    %if !ISEMPTY(condition) && !ISEMPTY(sysCondition)
        %%AND the subsystem condition to this element condition
        %assign condition = "(" + condition + ") && (" + sysCondition + ")"
    %elseif !ISEMPTY(sysCondition)
        %assign condition = sysCondition
    %endif
    %%else sysCondition is empty then return condition whether it is empty or not

    %return condition

%endfunction

%% Function: SLibIsFunctionProfilingOn =============================================================
%% Abstract:
%%   return true if function-level profiling is on
%%
%function SLibIsFunctionProfilingOn() void
    %if !ISFIELD(::CompiledModel.ConfigSet, "CodeProfilingInstrumentation") || ...
        !ISFIELD(::CompiledModel.ConfigSet, "CodeExecutionProfiling")
        %return TLC_FALSE
    %endif

    %if ISEQUAL(::CompiledModel.ConfigSet.CodeProfilingInstrumentation, "off")
        %return TLC_FALSE
    %endif

    %return TLC_TRUE
%endfunction

%% Function: SLibIsCoderDictionaryActiveForDefaults ================================================
%%   Is coder dictionary mapping active for function defaults?
%%
%function SLibIsCoderDictionaryActiveForDefaults() void
    %% Initialize Function always exists if there is mapping support for
    %% entry point functions
    %return ISFIELD(::CompiledModel, "CoderDictionary") && ...
        ISFIELD(::CompiledModel.CoderDictionary, "FunctionDefaults")
%endfunction

%% Function: SLibHasRootInportCoderGroup ===========================================================
%% Abstract:
%%   Are root Inports handled by coder groups
%%
%function SLibHasRootInportCoderGroup() void
    %return ISFIELD(::CompiledModel.GlobalScope, "tCoderDataGroup_ExtUPointer")
%endfunction

%% Function: SLibHasRootOutportCoderGroup ==========================================================
%% Abstract:
%%   Are root Outports handled by coder groups
%%
%function SLibHasRootOutportCoderGroup() void
    %return ISFIELD(::CompiledModel.GlobalScope, "tCoderDataGroup_ExtYPointer")
%endfunction

%% Function: SLibHasFcnCallRootInport===========================================
%% Abstract
%%  Does the model has at least one root inport that outputs Function Call
%function SLibHasFcnCallRootInport() void
    %return ISFIELD(::CompiledModel, "ExternalPortGroups") && ...
        (::CompiledModel.ExternalPortGroups.NumFcnCallPortGroups >  0)
%endfunction

%% Function: SLibIsReusableExportFcn ===============================================================
%% Abstract
%%  Is this an export function diagram with reusable code packaging
%function SLibIsReusableExportFcn() void
    %return SLibIsExportFcnDiagram() && MultiInstanceERTCode
%endfunction

%% Function: SLibIsTempModelGeneratedToExportFcn ===================================================
%% Abstract
%%  Is this a temporary model generated during conversion from export
%%  function-call subsystems to an export function model
%function SLibIsTempModelGeneratedToExportFcn() void
    %return ISFIELD(::CompiledModel, "IsTempModelGeneratedToExportFcn") && ...
        (::CompiledModel.IsTempModelGeneratedToExportFcn == "yes")
%endfunction

%% Function: SLibIsRuntimeEventTID =================================================================
%% Abstract
%%  Is this a tid correspond to a rate in a runtime event
%%
%function SLibIsRuntimeEventTID(tid) void
    %return TYPE(tid) == "Number" && tid >= 0 && ...
        ISFIELD(::CompiledModel.SampleTime[tid], "RuntimeEventIndex")
%endfunction

%% Function: SLibRuntimeEventIndexOfTID ============================================================
%% Abstract
%%  get runtime event index corresponding to tid
%%
%function SLibRuntimeEventIndexOfTID(tid) void
    %assert SLibIsRuntimeEventTID(tid)
    %return ::CompiledModel.SampleTime[tid].RuntimeEventIndex

%endfunction

%% Function: SLibIsExplicitPartitioningTID =========================================================
%% Abstract
%%  Is this a tid corresponding to a partition
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function SLibIsExplicitPartitioningTID(tid) void
    %assign hasNonEmptyTaskName =  TYPE(tid) == "Number" && tid >= 0 && ...
        ISFIELD(::CompiledModel.SampleTime[tid],"TaskName") && !ISEMPTY(::CompiledModel.SampleTime[tid].TaskName)

    %assert !(!SLibIsExportFcnDiagram() && !LibAsynchronousTriggeredTID(tid) && SLibExplicitTaskingTID(tid)) || hasNonEmptyTaskName

    %return SLibExplicitTaskingTID(tid) && !LibAsynchronousTriggeredTID(tid) && hasNonEmptyTaskName && ...
        !(SLibIsExportFcnDiagram() && SLibIsExplicitTaskingExportFcnRateGrouping("Output", tid))
%endfunction

%% Function: SLibIsExplicitAperiodicPartitioningTID ================================================
%% Abstract
%%  Is this a tid corresponding to an aperiodic partition
%%
%function SLibIsExplicitAperiodicPartitioningTID(tid) void
    %assign retVal = TLC_FALSE
    %assign retVal = SLibIsExplicitPartitioningTID(tid) && SLibIsRuntimeEventTID(tid)
    %assert !retVal || (tid > ::CompiledModel.NumSynchronousSampleTimes)
    %return retVal
%endfunction

%% Function: SLibIsRuntimeExportedSystemFcn ========================================================
%% Abstract
%%  Is there a runtime exported system function corresponding to tid
%% The problem is even if tid < NumRuntimeExportedRates
%% System function body might be empty
%function SLibIsRuntimeExportedSystemFcn(fcnType, tid) void
    %if fcnType != "Outputs" && fcnType != "Update"
        %return TLC_FALSE
    %else
        %assign rootSystem = ::CompiledModel.System[::CompiledModel.NumSystems - 1]
        %assign rootModule = ::CompiledModel.RTWCGModules.RTWCGModule[rootSystem.CGIRModuleIdx]
        %return !SLibIsExportFcnDiagram() && tid < NumRuntimeExportedRates && ...
            ISFIELD(rootModule.RTWFcnConst, "%<fcnType>_FunctionTID%<tid>")
    %endif
%endfunction

%% Function: SLibIsExplicitPartitioningSystemFcn ===================================================
%% Abstract
%%  Is there a system function corresponding to tid
%% The problem is even if SLibIsExplicitPartitioningTID(tid) == TLC_TRUE
%% System function body might be empty
%function SLibIsExplicitPartitioningSystemFcn(fcnType, tid) void
    %if fcnType != "Outputs" && fcnType != "Update"
        %return TLC_FALSE
    %else
        %assign rootSystem = ::CompiledModel.System[::CompiledModel.NumSystems - 1]
        %assign rootModule = ::CompiledModel.RTWCGModules.RTWCGModule[rootSystem.CGIRModuleIdx]
        %return SLibIsExplicitPartitioningTID(tid) && ...
            ISFIELD(rootModule.RTWFcnConst, "%<fcnType>_FunctionTID%<tid>")
    %endif
%endfunction

%% Function: SLibExplicitPartitioningSystemFcnName =================================================
%% Abstract
%% Entry point name of the funtion corresponding to partition with tid
%function SLibExplicitPartitioningSystemFcnName(baseSysFcnName, tid) void
    %if tid == 0 && !IsModelReferenceTarget()
        %% We don't adjust the name of the base task. We generate code as if it were implicit.
        %return baseSysFcnName
    %endif
    %assert SLibIsExplicitPartitioningTID(tid)
    %assign taskName = ::CompiledModel.SampleTime[tid].TaskName
    %assign taskName = STRREP(taskName, "." , "_")
    %return "%<baseSysFcnName>_%<taskName>_TID%<tid>"
%endfunction

%% Function: SLibAppendTIDToSystemFcnName ==========================================================
%% Abstract
%% Append TID to System Function name and this is different when
%% SLibIsExplicitPartitioningTID(tid) is true
%function SLibAppendTIDToSystemFcnName(baseSysFcnName, tid) void
    %if SLibIsExplicitPartitioningTID(tid)
        %return SLibExplicitPartitioningSystemFcnName(baseSysFcnName, tid)
    %else
        %return "%<baseSysFcnName>TID%<tid>"
    %endif
%endfunction

%% Function: SLibFcnProtoCtrlActive ================================================================
%% Abstract:
%%   Is function prototype control active?
%%
%function SLibFcnProtoCtrlActive() void
    %if CompiledModel.ModelReferenceTargetType == "SIM"
        %return TLC_FALSE
    %endif

    %if CGMODEL_ACCESS("CGModel.isIndividualFunctionMappingEnabled")
        %return CGMODEL_ACCESS("CGModel.FunctionPrototype.hasFunctionPrototype")
    %else
        %return ISFIELD(::CompiledModel, "RTWFcnClass")
    %endif
%endfunction

%% Function: SLibRTWCPPClassActive =================================================================
%% Abstract:
%%   Is CPP Class Generation active?
%%
%function SLibRTWCPPClassActive() void
    %return ISFIELD(::CompiledModel, "RTWFcnCPPClass")
%endfunction

%% Function: SLibRTWCPPClassPassesArgs==============================================================
%% Abstract:
%%   Is CPP Class using step function prototype control?
%%
%function SLibRTWCPPClassPassesArgs(fpcData) void
    %if EXISTS(fpcData.noArgOnList) && fpcData.noArgOnList
        %return TLC_FALSE
    %endif
    %if !EXISTS(fpcData.ArgSpecData)
        %return TLC_FALSE
    %endif
    %return TLC_TRUE
%endfunction

%% Function: SLibAutosarCompliant ==================================================================
%% Abstract:
%%   Is the model Autosar compliant?
%%   This will return true for an Autosar-target model in model reference mode
%%
%function SLibAutosarCompliant() void
    %return CGMODEL_ACCESS("CGModel.isAutosarCompliant")
%endfunction

%% Function: SLibMappingCPPClassActive =============================================================
%% Abstract:
%%   C++ Target enabled via mapping
%%
%function SLibMappingCPPClassActive() void
    %return ::GenCPP && CGMODEL_ACCESS("CGModel.isCPPMappingEnabled")
%endfunction

%% Function: SLibHasCPPStepFPC =====================================================================
%% Abstract:
%%   Is C++ FPC specified
%%
%function SLibHasCPPStepFPC() void
    %if ::GenerateClassInterface
        %if SLibMappingCPPClassActive()
            %if CGMODEL_ACCESS("CGModel.CppStepFunctionHasArguments")
                %return TLC_TRUE
            %endif
        %else
            %if ::CompiledModel.RTWFcnCPPClass.Object.Class == "ModelCPPArgsClass"
                %return TLC_TRUE
            %endif
        %endif
    %endif
    %return TLC_FALSE
%endfunction

%% Function: SLibIsCPPModelRefStepVoidVoid =========================================================
%% Abstract:
%%   Does the reference model have void void step
%%
%function SLibIsCPPModelRefStepVoidVoid() void
    %if ::GenerateClassInterface && IsModelReferenceTarget() &&  ...
        !SLibHasCPPStepFPC()
        %return TLC_TRUE
    %endif
    %return TLC_FALSE
%endfunction

%% Function: SLibIsAutosarSubComponent =============================================================
%% Abstract:
%%   Is the model Autosar compliant and has sub-component mapping?
%%
%function SLibIsAutosarSubComponent() void
    %return CGMODEL_ACCESS("CGModel.isAutosarSubComponent")
%endfunction

%% Function: SLibAutosarActive =====================================================================
%% Abstract:
%%   Is AUTOSAR active?
%%
%function SLibAutosarActive() void
    %return ISFIELD(::CompiledModel, "RTWAutosar")
%endfunction

%% Function: SLibAutosarGenRTEHeader ===============================================================
%% Abstract:
%%   Should AUTOSAR RTE header files be generated?
%%
%function SLibAutosarGenRTEHeader() void
    %return SLibAutosarActive()
%endfunction

%% Function: SLibAdaptiveAutosarActive
%% Abstract:
%%   Is the active target Adaptive Application?
%%
%function SLibAdaptiveAutosarActive() void
    %return SLibRTWCPPClassActive() && SLibAutosarCompliant()
%endfunction

%% Function: SLibMdlEnableDisablePermitted =========================================================
%% Abstract:
%%    Do we produce enable and disable methods at the model level?
%%
%function SLibMdlEnableDisablePermitted() void
    %return  (GenerateEnableDisable == 1)  && ...
        !HasModelReferenceBlocks() && ...
        ExportFunctionsMode != 1 && ...
        !EXISTS(CodeGenForPIL)
%endfunction

%% Function: LibIsDeploymentDiagram()
%% Abstract:
%%   Returns true if block diagram type is deployment diagram and code generation
%%   is not for rsim, rapid accel or accel
%function  LibIsDeploymentDiagram() void
    %return (SLibIsDeploymentDiagramType() && ...
        ISFIELD(::CompiledModel,"NumEventHandlers") && ...
        (!Accelerator) && (!isRAccel) && (!isRSim) && (!isRSimWithSolverModule))
%endfunction

%% Function: SLibIsMappedInDeploymentDiagram()
%% Abstract:
%%   Returns true if the subsystem was synthesized for a mapped component
%%   in a deployment diagram
%function SLibIsMappedInDeploymentDiagram(system) void
    %return LibIsDeploymentDiagram() && ...
        SLibDeploymentDiagramIsMapped(system.SystemIdx)
%endfunction

%% Function: SLibIsMappedInDeploymentDiagram()
%% Abstract:
%%   Returns true if the subsystem was synthesized for a mapped component
%%   in a deployment diagram
%function SLibIsMappedSystemInDeploymentDiagram(systemIdx) void
    %return LibIsDeploymentDiagram() && ...
        SLibDeploymentDiagramIsMapped(systemIdx)
%endfunction

%% Function: SLibIsDeploymentDiagramWithNoTopSolver
%% Abstract:
%%   Returns true if the block diagram type is deployment diagram and
%%   the root system does not need a solver for the root system.
%function SLibIsDeploymentDiagramWithNoTopSolver() void
    %return LibIsDeploymentDiagram() && !SLibDeploymentDiagramWithTopSolver()
%endfunction

%% Function: SLibIsDeploymentDiagramWithTopSolver
%% Abstract:
%%   Returns true if the block diagram type is deployment diagram and
%%   the root system needs a solver for the root system.
%function SLibIsDeploymentDiagramWithTopSolver() void
    %return LibIsDeploymentDiagram() && SLibDeploymentDiagramWithTopSolver()
%endfunction

%% Function: SLibIsExplicitTaskingExportFcnRateGrouping
%% Abstract:
%%   This function return true if a given TID is an explicit tasking
%%   TID with an exported function
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function SLibIsExplicitTaskingExportFcnRateGrouping(aSystemFcnType, aTID)
    %return TYPE(aTID) == "Number" && ...
        SLibExplicitTaskingTID(aTID) && ...
        (aSystemFcnType == "OutputUpdate" || aSystemFcnType == "Output" ) && ...
        ISFIELD(SampleTime[aTID],"EntryFcnName") && ...
        !ISEMPTY(SampleTime[aTID].EntryFcnName) && ...
        !SLibNonInlinedIRTEventTID(aTID)
%endfunction

%function SLibIsRateGroupedSLFcn(system, aFcnType, aTID)
    %assign thisModule = ...
        ::CompiledModel.RTWCGModules.RTWCGModule[system.CGIRModuleIdx]
    %if (SLibIsExportFcnDiagram() || SLibMultiCallerLegacyAsynchronousTID(aTID)) && ...
        (aFcnType == "OutputUpdate" || aFcnType == "Output" ) && ...
        TYPE(aTID) == "Number" && aTID > 0 && ...
        ISFIELD(SampleTime[aTID], "EntryFcnName") && ...
        ISFIELD(thisModule, "SystemFunctions") && ...
        ISFIELD(thisModule.SystemFunctions, SampleTime[aTID].EntryFcnName)
        %assign fcnIndex = GETFIELD(thisModule.SystemFunctions, SampleTime[aTID].EntryFcnName)
        %assign thisFcn  = thisModule.Function[fcnIndex]
        %if ISFIELD(thisFcn,"IsRateGroupedSLFcn") && thisFcn.IsRateGroupedSLFcn == TLC_TRUE
            %return TLC_TRUE
        %endif
    %endif
    %return TLC_FALSE
%endfunction

%function SLibIsGlobalRateGroupedSLFcn(system, aFcnType, aTID)
    %if SLibIsRateGroupedSLFcn(system, aFcnType, aTID)
        %foreach idx = NumSystems
            %assign thisSystem = System[idx]
            %if thisSystem.IsRateGroupedSLFcn ...
                && thisSystem.Identifier == SampleTime[aTID].EntryFcnName
                %return LibIsGlobalServer(thisSystem)
            %endif
        %endforeach
    %endif
    %return TLC_FALSE
%endfunction

%function SLibGetRateGroupedFcnPrototype(module, aTID)
    %assign fcnName = ""
    %assign fcnPrototype = ""
    %assign cgirParams = ""
    %assign fcnReturns = ""
    %assign moduleIfCondition = ""
    %assign moduleEndIfCondition = ""
    %assign fcnTIDCGVCEIfCondition = ""
    %assign fcnTIDCGVCEEndIfCondition = ""

    %if TYPE(aTID) == "Number" && aTID > 0 && ...
        ISFIELD(SampleTime[aTID], "EntryFcnName")
        %assign fcnName = SampleTime[aTID].EntryFcnName
        %assign fcnIndex = GETFIELD(module.SystemFunctions, fcnName)
        %assign thisFcn  = module.Function[fcnIndex]
        %% For the rate grouped simulink functions, use the module condition of the function
        %% cached into the aFcnprototype record and use it to guard the function declaration
        %% and definition.
        %% TopTester: test/toolbox/simulink/variants/var-simulinkfcns/tmLatchInputFromServer1_VC1.m
        %if ISFIELD(thisFcn, "ModuleIfCondition")

            %assign moduleIfCondition = thisFcn.ModuleIfCondition
            %assign moduleEndIfCondition = thisFcn.ModuleEndIfCondition

        %endif
        %% For the rate grouped simulink functions treated as subsystems, use the FcnTID variant condition
        %% of the function cached into the aFcnprototype record and use it to guard the function declaration
        %if ISFIELD(thisFcn, "FcnTIDCGVCEIfCondition")

            %assign fcnTIDCGVCEIfCondition = thisFcn.FcnTIDCGVCEIfCondition
            %assign fcnTIDCGVCEEndIfCondition = thisFcn.FcnTIDCGVCEEndIfCondition

        %endif

        %assign fcnPrototype = thisFcn.ProtoType + ")"
        %if thisFcn.ConstMemberMethod && CGMODEL_ACCESS("CGModel.getConstMemberMethodsFeature")
            %assign fcnPrototype = fcnPrototype + " const"
        %endif
        %assign fcnPrototype = REGEXPREP(fcnPrototype, "^\\s*(extern|static)\\s+", "")
        %assign cgirParams = REGEXPREP( fcnPrototype, "^[^\(]*\(", "")
        %assign fcnReturns = FEVAL("regexp",fcnPrototype," ","split")[0]
    %endif
    %% add the variant condition information to the function prototype record.
    %createrecord FcnPrototype { Name fcnName; Prototype fcnPrototype; Params cgirParams; Return fcnReturns; ModuleIfCondition moduleIfCondition; ModuleEndIfCondition moduleEndIfCondition; FcnTIDCGVCEIfCondition fcnTIDCGVCEIfCondition; FcnTIDCGVCEEndIfCondition fcnTIDCGVCEEndIfCondition}
    %return FcnPrototype
%endfunction

%% Function: SLibTLCSystemFcnCallExists ============================================================
%% Abstract:
%%  Returns true if a TLC interface function for a given TLC system function
%%  call exists.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tvss_code_variants.m
%%
%function SLibTLCSystemFcnCallExists(aSystemFcnType, ...
    aSystemIdx, aCallSiteIdx, aModuleIdx, aFcnIdx) void

    %if aModuleIdx  > -1 && aFcnIdx > -1
        %assign sysFcnType   = ...
            ("OutputUpdate" == aSystemFcnType) ? "Output" : aSystemFcnType
        %assign thisModule   = ::CompiledModel.RTWCGModules.RTWCGModule[aModuleIdx]
        %assign tlcFileName  = thisModule.TLCFileName + "_TLCInterface"
        %assign thisModule.IsTLCInterfaceLoaded = TLC_TRUE
        %assign opaqueBlock  = FcnRootOpaqueBlock()
        %assign thisSytemIdx = BlockIdx[0]
        %assign thisBlockIdx = BlockIdx[2]
        %assign fcnName = "getSystem" + sysFcnType + "FcnCallInfo" + ...
            "_%<thisSytemIdx>_%<thisBlockIdx>_%<aModuleIdx>_%<aFcnIdx>_" + ...
            "%<aSystemIdx>_%<aCallSiteIdx>"
        %return GENERATE_TYPE_FUNCTION_EXISTS(opaqueBlock, fcnName, tlcFileName)
    %endif

    %return TLC_FALSE
%endfunction

%% Function: SLibTLCSystemFcnCall ==================================================================
%% Abstract:
%%  Invokes the TLC interface function for a given system function call and
%%  returns
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc/tVariantSource3.m-
%%
%function SLibTLCSystemFcnCallInfo(aSystemFcnType, ...
    aSystemIdx, aCallSiteIdx, aModuleIdx, aFcnIdx) void

    %if aModuleIdx > -1 && aFcnIdx > -1
        %assign sysFcnType   = ...
            ("OutputUpdate" == aSystemFcnType) ? "Output" : aSystemFcnType
        %assign thisModule   = ::CompiledModel.RTWCGModules.RTWCGModule[aModuleIdx]
        %assign tlcFileName  = thisModule.TLCFileName + "_TLCInterface"
        %assign thisModule.IsTLCInterfaceLoaded = TLC_TRUE
        %assign opaqueBlock  = FcnRootOpaqueBlock()
        %assign thisSytemIdx = BlockIdx[0]
        %assign thisBlockIdx = BlockIdx[2]
        %assign fcnName = "getSystem" + sysFcnType + "FcnCallInfo" + ...
            "_%<thisSytemIdx>_%<thisBlockIdx>_%<aModuleIdx>_%<aFcnIdx>_" + ...
            "%<aSystemIdx>_%<aCallSiteIdx>"
        %% Extract the traceability comments for the call site
        %assign callInfo =  GENERATE_TYPE(opaqueBlock, fcnName, tlcFileName)
        %assign callSiteInfo = FEVAL("coder.trace.internal.extractTraceComments", callInfo.Name)
        %if !ISEMPTY(callSiteInfo.openingComment)
            %assign callInfo.Name = callSiteInfo.content
            %addtorecord callInfo OpeningTraceComment "%<callSiteInfo.openingComment>"
            %addtorecord callInfo ClosingTraceComment "%<callSiteInfo.closingComment>"
        %endif
        %return callInfo
    %endif

    %return ""
%endfunction

%% Function: SLibInvokeTLCInterface ================================================================
%% Abstract:
%%   Invokes the TLC interface for a given block and property.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants3.m
%%
%function SLibInvokeTLCInterface(block, property, propertyIdx, elementIdx, ...
    bAddr, lcv, ucv, sigIdx, reim) void

    %assign    modIdx = ::CurrentModuleIdx
    %assign    fcnIdx = ::CurrentFunctionIdx
    %assign blkFcnIdx = ::CurrentBlockFcnIdx

    %if modIdx > -1 && fcnIdx > -1 && blkFcnIdx > -1
        %assign thisModule  = ::CompiledModel.RTWCGModules.RTWCGModule[modIdx]
        %assign tlcFileName = thisModule.TLCFileName + "_TLCInterface"
        %assign thisModule.IsTLCInterfaceLoaded = TLC_TRUE
        %assign opaqueBlock = FcnRootOpaqueBlock()
        %assign sysIdx      = block.BlockIdx[0]
        %assign blkIdx      = block.BlockIdx[2]
        %assign fcnName = "get" + property + (bAddr  ? "Addr"  : "") + ...
            "_%<sysIdx>_%<blkIdx>_%<modIdx>_%<fcnIdx>_%<blkFcnIdx>_%<propertyIdx>_%<elementIdx>"
        %if GENERATE_TYPE_FUNCTION_EXISTS(opaqueBlock, fcnName, tlcFileName)
            %return GENERATE_TYPE(opaqueBlock, fcnName, tlcFileName, block, lcv, ucv, ...
                sigIdx, reim)
        %endif
    %endif

    %return ""
%endfunction

%% Function: SLibBlockOutputExprIdx ================================================================
%% Abstract:
%%   Returns the index expression for a TLC expression with a matrix type
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%%
%function SLibBlockOutputExprIdx(aSystemIdx, aBlockIdx, aPortIdx, aExprIdx) void
    %assign modIdx = ::CurrentModuleIdx
    %assign fcnIdx = ::CurrentFunctionIdx

    %if modIdx > -1 && fcnIdx > -1
        %assign thisModule  = ::CompiledModel.RTWCGModules.RTWCGModule[modIdx]
        %assign tlcFileName = thisModule.TLCFileName + "_TLCInterface"
        %assign thisModule.IsTLCInterfaceLoaded = TLC_TRUE
        %assign opaqueBlock = FcnRootOpaqueBlock()
        %assign fcnName     = "getOutputExprIdx_%<aSystemIdx>_%<aBlockIdx>_" + ...
            "%<modIdx>_%<fcnIdx>_%<aPortIdx>_%<aExprIdx>"
        %if GENERATE_TYPE_FUNCTION_EXISTS(opaqueBlock, fcnName, tlcFileName)
            %assign indexVector = GENERATE_TYPE(opaqueBlock, fcnName, tlcFileName)
            %assign indexExpr = ""
            %assign seperator = ""
            %foreach dimsIdx = SIZE(indexVector, 1)
                %assign indexExpr = indexExpr + seperator + indexVector[dimsIdx]
                %assign seperator = "]["
            %endforeach
            %return indexExpr
        %endif
    %endif
    %return ""
%endfunction %% SLibBlockOutputExprIdx

%% Function: SLibUnloadTLCInterface ================================================================
%% Abstract:
%%   This function is used to unload the TLC interface function and release
%%   some memory that is no longer used.
%%
%function SLibUnloadTLCInterface(module) void
    %if module.IsTLCInterfaceLoaded
        %assign    block = FcnRootOpaqueBlock()
        %assign fileName = module.TLCFileName + "_TLCInterface"
        %assign unused = UNLOAD_GENERATE_TYPE(block, fileName)
        %assign module.IsTLCInterfaceLoaded = TLC_FALSE
    %endif
%endfunction %% SLibUnloadTLCInterface

%%
%% Invoking the auto-generated TLC interface functions for the current TLC
%% block. Notice that those will update all required access flags for the DSM.
%%
%function SLibGetDSMBaseAddr(block, dsmIdx) void
    %return SLibInvokeTLCInterface(block, "DSM", dsmIdx, 0, TLC_TRUE, "", "", ...
        0, "")
%endfunction

%function SLibGetDSMElement(block, dsmIdx, elemIdx) void
    %return SLibInvokeTLCInterface(block, "DSM", dsmIdx, 0, TLC_FALSE, "", "", ...
        elemIdx, "")
%endfunction

%% FcnAccelOrGlbMdlRefSimDataStoreTransfer ====================================
%% Abstract:
%%    This function is used to transfer to and from data stores for
%%    simulation modes: accelator, rapid accelerator and model reference
%%    sim target with global DSMs
%function FcnAccelOrGlbMdlRefSimDataStoreTransfer(block, system, dWorkSrc, globalDSM, dataAddr, direction) Output
    %if ((IsModelReferenceSimTarget() && globalDSM) || Accelerator)
        %if Accelerator
            %assign simS = "S"
            %if globalDSM
                %assign reslvDsmIdx = dWorkSrc
            %else
                %assign reslvDsmIdx = "%<LibBlockDWork(dWorkSrc, "", "", 0)>"
            %endif
        %else
            %assign simS = RTMGet("MdlRefSfcnS")
            %assign reslvDsmIdx = "%<::CompiledModel.Name>_DSMIdx[%<dWorkSrc>]"
        %endif
        %<SLibCG_AccessRTM()>
        %if direction == "read"
            ssReadFromDataStoreWithPath(%<simS>, ...
                %<reslvDsmIdx>, ...
                "%<LibGetFormattedBlockPath(block)>", ...
                %<dataAddr>);
        %else
            ssWriteToDataStoreWithPath(%<simS>, ...
                %<reslvDsmIdx>, ...
                "%<LibGetFormattedBlockPath(block)>", ...
                %<dataAddr>);
        %endif
    %else
        %<LibReportFatalError("Should not be here")>
    %endif
%endfunction

%% FcnWriteToDataStoreCodeGen ====================================================
%% Abstract: This function handles data store transfers for rapid accelerator
%%     mode with global DSM and model reference sim target
%function FcnDataStoreTransferCodeGen(block, system, globalDSM, dWorkSrc, uAddr, dsmIdx, direction) Output
    %assert (IsModelReferenceSimTarget() && globalDSM)

    %assign dWorkSrc2     = block.ParamSettings.GlobalDataStoreSource[dsmIdx]
    %assign dworkAndRec   = FcnGetDworkAndRec(dWorkSrc2)
    %assign dwRec         = dworkAndRec.DWorkRec
    %assign dworkDataType = SLibGetRecordDataTypeName(dwRec, "")
    %assign dworkWidth    = SLibDWorkWidth(dwRec)

    %if direction == "write"
        (void)memcpy(%<::CompiledModel.Name>_DSM[%<dWorkSrc>], %<uAddr>, %<dworkWidth>*sizeof(%<dworkDataType>));
    %else
        (void)memcpy(%<uAddr>, %<::CompiledModel.Name>_DSM[%<dWorkSrc>], %<dworkWidth>*sizeof(%<dworkDataType>));
    %endif
%endfunction


%% LibSFcnReadFromDataStore ====================================================
%% Abstract:
%%   This function is used by an sfunction to read a global data store
%%   it has registered and copy the contents to an address in memory
%%
%function LibSFcnReadFromDataStore(block, system, dsmIdx, yAddr) Output
    %assign dWorkSrc  = block.ParamSettings.DataStoreSource[dsmIdx]
    %assign globalDSM = block.ParamSettings.DataStoreGlobalDSM[dsmIdx]

    %if (IsModelReferenceSimTarget() && globalDSM)
        if(slIsRapidAcceleratorSimulating()) {
            %<FcnDataStoreTransferCodeGen(block, system, globalDSM, dWorkSrc, yAddr, dsmIdx, "read")>
        } else {
            %<FcnAccelOrGlbMdlRefSimDataStoreTransfer(block, system, dWorkSrc, globalDSM, yAddr, "read")>
        }
    %elseif (Accelerator)
        %<FcnAccelOrGlbMdlRefSimDataStoreTransfer(block, system, dWorkSrc, globalDSM, yAddr, "read")>
    %else
        %assign dworkAndRec   = FcnGetDworkAndRec(dWorkSrc)
        %assign dwRec         = dworkAndRec.DWorkRec
        %assign dworkWidth    = SLibDWorkWidth(dwRec)
        %assign hasCustomSC   = LibHasCustomStorage(dwRec)
        %assign isAddressable = !hasCustomSC || LibCustomDataIsAddressable(dwRec)
        %if isAddressable
            %assign dworkBaseAddr = hasCustomSC ...
                ? LibBlockDWorkAddr(dWorkSrc, "", "", 0) ...
                : SLibGetDSMBaseAddr(block, dsmIdx)
            %if SLibDWorkIsComplex(dwRec)
                %assign dworkWidth = dworkWidth * 2
            %endif
            %assign dworkDataType = SLibGetRecordDataTypeName(dwRec, "")
            (void) %<LibGenMemFcnCall("memcpy", "%<yAddr>", "%<dworkBaseAddr>", ...
                "%<dworkWidth>*sizeof(%<dworkDataType>)")>;
        %else
            %foreach elemIdx = dworkWidth
                %if dworkWidth > 1
                    %assign y = "(" + yAddr + ")[" + STRING(elemIdx) + "]"
                %else
                    %assign y = "*(" + yAddr + ")"
                %endif
                %<y> = %<LibBlockDWork(dWorkSrc, "", "", elemIdx)>;
            %endforeach
        %endif
    %endif
%endfunction

%% LibSFcnWriteToDataStore =====================================================
%% Abstract:
%%   This function is used by an sfunction to write to a global data store
%%   it has registered and get the value
%%
%function LibSFcnWriteToDataStore(block, system, dsmIdx, uAddr) Output
    %assign dWorkSrc = block.ParamSettings.DataStoreSource[dsmIdx]
    %assign globalDSM = block.ParamSettings.DataStoreGlobalDSM[dsmIdx]

    %if (IsModelReferenceSimTarget() && globalDSM)
        if(slIsRapidAcceleratorSimulating()) {
            %<FcnDataStoreTransferCodeGen(block, system, globalDSM, dWorkSrc, uAddr, dsmIdx, "write")>
        } else {
            %<FcnAccelOrGlbMdlRefSimDataStoreTransfer(block, system, dWorkSrc, globalDSM, uAddr, "write")>
        }
    %elseif (Accelerator)
        %<FcnAccelOrGlbMdlRefSimDataStoreTransfer(block, system, dWorkSrc, globalDSM, uAddr, "write")>
    %else
        %assign dworkAndRec   = FcnGetDworkAndRec(dWorkSrc)
        %assign dwRec         = dworkAndRec.DWorkRec
        %assign dworkWidth    = SLibDWorkWidth(dwRec)
        %assign hasCustomSC   = LibHasCustomStorage(dwRec)
        %assign isAddressable = !hasCustomSC || LibCustomDataIsAddressable(dwRec)
        %if isAddressable
            %assign dworkBaseAddr = hasCustomSC ...
                ? LibBlockDWorkAddr(dWorkSrc, "", "", 0) ...
                : SLibGetDSMBaseAddr(block, dsmIdx)
            %if SLibDWorkIsComplex(dwRec)
                %assign dworkWidth = dworkWidth * 2
            %endif
            %assign dworkDataType = SLibGetRecordDataTypeName(dwRec, "")
            (void) %<LibGenMemFcnCall("memcpy", dworkBaseAddr, uAddr, ...
                "%<dworkWidth>*sizeof(%<dworkDataType>)")>;
        %else
            %foreach elemIdx = dworkWidth
                %if dworkWidth > 1
                    %assign u = "(" + uAddr + ")[" + STRING(elemIdx) + "]"
                %else
                    %assign u = "*(" + uAddr + ")"
                %endif
                %<LibBlockAssignDWork(dWorkSrc, "", "", elemIdx, u)>
            %endforeach
        %endif
    %endif
%endfunction

%% FcnDataStoreCopyCodeGen =======================================================
%% Abstract:
%%    This function is used to copy information to and from data store given a
%%    input/output port index for model reference sim target with global DSMs
%%    in rapid accelerator mode
%function FcnDataStoreCopyCodeGen(block, system, globalDSM, dWorkSrc, pIdx, dsmIdx, direction) Output
    %assert (IsModelReferenceSimTarget() && globalDSM)

    %assign dWorkSrc2 = block.ParamSettings.GlobalDataStoreSource[dsmIdx]
    %assign dworkAndRec   = FcnGetDworkAndRec(dWorkSrc2)
    %assign dwRec         = dworkAndRec.DWorkRec
    %assign dworkDataType = SLibGetRecordDataTypeName(dwRec, "")

    %if direction == "write"
        %foreach elemIdx = LibBlockInputSignalWidth(pIdx)
            %assign uAddr = LibBlockInputSignalAddr(pIdx, "", "", elemIdx)
            ((%<dworkDataType>*)(%<::CompiledModel.Name>_DSM[%<dWorkSrc>]))[%<elemIdx>] = *(%<uAddr>);
        %endforeach
    %else
        %foreach elemIdx = LibBlockOutputSignalWidth(pIdx)
            %assign yAddr = LibBlockOutputSignalAddr(pIdx, "", "", elemIdx)
            *(%<yAddr>) = ((%<dworkDataType>*)(%<::CompiledModel.Name>_DSM[%<dWorkSrc>]))[%<elemIdx>];
        %endforeach
    %endif
%endfunction

%% LibSFcnCopyFromDataStoreToOutput ============================================
%% Abstract:
%%   This function is used by an sfunction to read a global data store
%%   it has registered and copy the contents to a block output port
%%
%function LibSFcnCopyFromDataStoreToOutput(block, system, dsmIdx, pIdx) Output
    %assign dWorkSrc  = block.ParamSettings.DataStoreSource[dsmIdx]
    %assign globalDSM = block.ParamSettings.DataStoreGlobalDSM[dsmIdx]

    %if (IsModelReferenceSimTarget() && globalDSM)
        if(slIsRapidAcceleratorSimulating()) {
            %<FcnDataStoreCopyCodeGen(block, system, globalDSM, dWorkSrc, pIdx, dsmIdx, "read")>
        } else {
            %assign yAddr = LibBlockOutputSignalAddr(pIdx, "", "", 0)
            %<FcnAccelOrGlbMdlRefSimDataStoreTransfer(block, system, dWorkSrc, globalDSM, yAddr, "read")>
        }
    %elseif (Accelerator)
        %assign yAddr = LibBlockOutputSignalAddr(pIdx, "", "", 0)
        %<FcnAccelOrGlbMdlRefSimDataStoreTransfer(block, system, dWorkSrc, globalDSM, yAddr, "read")>
    %else
        %foreach elemIdx = LibBlockOutputSignalWidth(pIdx)
            %assign y = LibBlockOutputSignal(pIdx, "", "", elemIdx)
            %assign u = LibBlockDWork(dWorkSrc, "", "", elemIdx)
            %<y> = %<u>;
        %endforeach
    %endif
%endfunction


%% LibSFcnCopyToDataStoreFromInput =============================================
%% Abstract:
%%   This function is used by an sfunction to write to a global data store
%%   it has registered and get the value from a (contiguous) input port
%%
%function LibSFcnCopyToDataStoreFromInput(block, system, dsmIdx, pIdx) Output
    %assign dWorkSrc  = block.ParamSettings.DataStoreSource[dsmIdx]
    %assign globalDSM = block.ParamSettings.DataStoreGlobalDSM[dsmIdx]

    %if (IsModelReferenceSimTarget() && globalDSM)
        if(slIsRapidAcceleratorSimulating()) {
            %<FcnDataStoreCopyCodeGen(block, system, globalDSM, dWorkSrc, pIdx, dsmIdx, "write")>
        } else {
            %assign uAddr = LibBlockInputSignalAddr(pIdx, "", "", 0)
            %<FcnAccelOrGlbMdlRefSimDataStoreTransfer(block, system, dWorkSrc, globalDSM, uAddr, "write")>
        }
    %elseif (Accelerator)
        %assign uAddr = LibBlockInputSignalAddr(pIdx, "", "", 0)
        %<FcnAccelOrGlbMdlRefSimDataStoreTransfer(block, system, dWorkSrc, globalDSM, uAddr, "write")>
    %else
        %assign dworkAndRec   = FcnGetDworkAndRec(dWorkSrc)
        %assign dwRec         = dworkAndRec.DWorkRec
        %if LibHasCustomStorage(dwRec)
            %foreach elemIdx = LibBlockInputSignalWidth(pIdx)
                %assign u = LibBlockInputSignal(pIdx, "", "", elemIdx)
                %<LibBlockAssignDWork(dWorkSrc, "", "", elemIdx, u)>
            %endforeach
        %else
            %foreach elemIdx = LibBlockInputSignalWidth(pIdx)
                %assign u = LibBlockInputSignal(pIdx, "", "", elemIdx)
                %<SLibGetDSMElement(block, dsmIdx, elemIdx)> = %<u>;
            %endforeach
        %endif
    %endif
%endfunction

%% FcnDataStoreElementTransferCodeGen =================================================
%% Abstract:
%%    This function handles data store element transfers for model reference target
%%    with global DSMs in rapid accel mode.
%function FcnDataStoreElementTransferCodeGen(block, system, globalDSM, dWorkSrc, dsmIdx, uAddr, dsmElem, direction) Output
    %assert (IsModelReferenceSimTarget() && globalDSM)

    %assign dWorkSrc2 = block.ParamSettings.GlobalDataStoreSource[dsmIdx]
    %assign dworkAndRec   = FcnGetDworkAndRec(dWorkSrc2)
    %assign dwRec         = dworkAndRec.DWorkRec
    %assign dworkDataType = SLibGetRecordDataTypeName(dwRec, "")

    %if direction == "write"
        ((%<dworkDataType>*)(%<::CompiledModel.Name>_DSM[%<dWorkSrc>]))[%<dsmElem>] = *(%<uAddr>);
    %else
        *(%<uAddr>) = ((%<dworkDataType>*)(%<::CompiledModel.Name>_DSM[%<dWorkSrc>]))[%<dsmElem>];
    %endif
%endfunction

%% FcnDataStoreElementTransferSim =========================================================
%% Abstract:
%%    This function andles data store element transfers for non rapid accelerator modes.
%function FcnDataStoreElementTransferSim(block, system, globalDSM, dWorkSrc, dsmIdx, addr, dsmElem, direction) Output
    %if ((IsModelReferenceSimTarget() && globalDSM) || Accelerator)
        %if Accelerator
            %assign simS = "S"
            %if globalDSM
                %assign reslvDsmIdx = dWorkSrc
            %else
                %assign reslvDsmIdx = "%<LibBlockDWork(dWorkSrc, "", "", 0)>"
            %endif
        %else
            %assign simS = RTMGet("MdlRefSfcnS")
            %assign reslvDsmIdx = "%<::CompiledModel.Name>_DSMIdx[%<dWorkSrc>]"
        %endif
        %if (direction == "read")
            ssReadFromDataStoreElementWithPath(%<simS>, ...
                %<reslvDsmIdx>, ...
                "%<LibGetFormattedBlockPath(block)>", ...
                %<addr>,%<dsmElem>);
        %else
            ssWriteToDataStoreElementWithPath(%<simS>, ...
                %<reslvDsmIdx>, ...
                "%<LibGetFormattedBlockPath(block)>", ...
                %<addr>,%<dsmElem>);
        %endif
    %else
        %assign dworkAndRec   = FcnGetDworkAndRec(dWorkSrc)
        %assign dwRec         = dworkAndRec.DWorkRec
        %assign dworkVal = LibHasCustomStorage(dwRec) ...
            ? LibBlockDWork(dWorkSrc, "", "", dsmElem) ...
            : SLibGetDSMElement(block, dsmIdx, dsmElem)
        %if (direction == "read")
            (%<addr>)[0] = %<dworkVal>;
        %else
            %<dworkVal> = (%<addr>)[0];
        %endif
    %endif
%endfunction

%% LibSFcnReadFromDataStoreElement =============================================
%% Abstract:
%%   This function is used by an sfunction to read a global data store
%%   it has registered
%%
%function LibSFcnReadFromDataStoreElement(block, system, dsmIdx, yAddr,dsmElem) Output
    %assign dWorkSrc  = block.ParamSettings.DataStoreSource[dsmIdx]
    %assign globalDSM = block.ParamSettings.DataStoreGlobalDSM[dsmIdx]

    %if (IsModelReferenceSimTarget() && globalDSM)
        if(slIsRapidAcceleratorSimulating()) {
            %<FcnDataStoreElementTransferCodeGen(block, system, globalDSM, dWorkSrc, dsmIdx, yAddr, dsmElem, "read")>
        } else {
            %<FcnDataStoreElementTransferSim(block, system, globalDSM, dWorkSrc, dsmIdx, yAddr, dsmElem, "read")>
        }
    %else
        %<FcnDataStoreElementTransferSim(block, system, globalDSM, dWorkSrc, dsmIdx, yAddr, dsmElem, "read")>
    %endif
%endfunction

%% LibSFcnWriteToDataStoreElement ==============================================
%% Abstract:
%%   This function is used by an sfunction to write to a global data store
%%   it has registered
%%
%function LibSFcnWriteToDataStoreElement(block, system, dsmIdx, uAddr,dsmElem) Output
    %assign dWorkSrc  = block.ParamSettings.DataStoreSource[dsmIdx]
    %assign globalDSM = block.ParamSettings.DataStoreGlobalDSM[dsmIdx]

    %if (IsModelReferenceSimTarget() && globalDSM)
        if(slIsRapidAcceleratorSimulating()) {
            %<FcnDataStoreElementTransferCodeGen(block, system, globalDSM, dWorkSrc, dsmIdx, uAddr, dsmElem, "write")>
        } else {
            %<FcnDataStoreElementTransferSim(block, system, globalDSM, dWorkSrc, dsmIdx, uAddr, dsmElem, "write")>
        }
    %else
        %<FcnDataStoreElementTransferSim(block, system, globalDSM, dWorkSrc, dsmIdx, uAddr, dsmElem, "write")>
    %endif
%endfunction

%% Function: SLibReportNonAddressableError =========================================================
%% Abstract:
%%    Report an attempt to take the address of nonaddressable data
%%
%function SLibReportNonAddressableError(type, block, record) void
    %switch type
      %case "Input"
        %assign errTxt = "block attempts to take the address of its " + ...
            "input signal " + ...
            "'%<LibGetRecordVarName(record)>' but that signal " + ...
            "is not addressable because of its custom storage class. " + ...
            "Consider inserting a Signal Conversion block at the input to the block. " + ...
            "Make sure to select the Signal Conversion block's parameter " + ...
            "'Exclude this block from 'Block reduction' optimization'"
        %break
      %case "Output"
        %assign errTxt = "block attempts to take the address of its " + ...
            "output signal " + ...
            "'%<LibGetRecordVarName(record)>' but that signal " + ...
            "is not addressable because of its custom storage class. " + ...
            "Consider inserting a Signal Conversion block at the output of the " + ...
            "block, and moving the signal '%<LibGetRecordVarName(record)>' " + ...
            "to the output of that Signal Conversion block. " + ...
            "Make sure to select the Signal Conversion block's parameter " + ...
            "'Exclude this block from 'Block reduction' optimization'"
        %break
      %case "Dwork"
        %assign errTxt = "block attempts to take the address of its " + ...
            "dwork '%<LibGetRecordVarName(record)>' but that dwork " + ...
            "is not addressable because of its custom storage class. "
        %break
      %default
        %assign errTxt = "block attempts to take the address of " + ...
            "'%<LibGetRecordVarName(record)>', but " + ...
            "'%<LibGetRecordVarName(record)>' is not addressable because " + ...
            "of its custom storage class."
    %endswitch
    %<LibBlockReportError(block, errTxt)>
%endfunction %% SLibReportNonAddressableError

%% DocFunction{Other Useful Functions}: LibIsMinorTimeStep=====================
%% Abstract:
%%
%%   Returns a string to access whether the current simulation step is
%%   is a minor time step.
%%
%%   This function is the TLC version of the SimStruct macro:  ssIsMinorTimeStep
%%
%function LibIsMinorTimeStep() void

    %return RTMIs("MinorTimeStep")

%endfunction %% LibIsMinorTimeStep


%% DocFunction{Other Useful Functions}: LibIsMajorTimeStep=====================
%% Abstract:
%%
%%   Returns a string to access whether the current simulation step is
%%   is a major time step.
%%
%%   This function is the TLC version of the SimStruct macro: ssIsMajorTimeStep
%%
%function LibIsMajorTimeStep() void

    %return RTMIs("MajorTimeStep")

%endfunction %% LibIsMajorTimeStep


%% DocFunction{Other Useful Functions}: LibGetT ================================
%% Abstract:
%%   Return a string to access the absolute time. You should only use this
%%   function to access time.
%%
%%   This function is the TLC version of the SimStruct macro: ssGetT.
%%
%function LibGetT() void
    %if SLibIsERTCodeFormat()
        %return LibGetTaskTime(0)
    %else
        %return RTMGet("T")
    %endif

%endfunction %% LibGetT

%% Function: LibTaskComment ========================================================================
%% Abstract:
%%   Produces a sample time comment containing period
%%   and offset given a task identifier.
%% TopTester: test/toolbox/simulink/variants/var-vss-sigobj/tVSSSigObj.m
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function LibTaskComment(tid) void
    %if TYPE(tid) == "Number"  && tid >= 0
        %if SLibExplicitTaskingTID(tid)
            %if SLibIsExportFcnDiagram() && LibAsynchronousTriggeredTID(tid)
                %return ""
            %else
                %assign taskName = ::CompiledModel.SampleTime[tid].TaskName
                %return "/* Explicit Task: %<taskName> */"
            %endif
        %endif
        %assign period = ::CompiledModel.SampleTime[tid].PeriodAndOffset[0]
        %assign offset = ::CompiledModel.SampleTime[tid].PeriodAndOffset[1]
        %return "/* Sample time: [%<period>s, %<offset>s] */"
    %elseif WHITE_SPACE(tid)
        %return ""
    %else
        %return "/* Sample time: %<tid> */"
    %endif
%endfunction %% LibTaskComment

%if EXISTS(UseGlobalTIDTracking) == 0
    %assign ::UseGlobalTIDTracking = TLC_FALSE
%else
    %assign ::UseGlobalTIDTracking = TLC_TRUE
%endif

%% Function: LibNeedTID ============================================================================
%% Abstract:
%%   LibNeedTID sets the global flag ::CompiledModel.NeedTID to TLC_TRUE.
%%   TID is a argument that must be passed in from the parent, so the
%%   subsystem block propagates this flag up in the system hierarchy.
%%
%function LibNeedTID() void
    %<SLibCG_AccessTID()>
    %assign ::CompiledModel.NeedTID = %<::UseGlobalTIDTracking>
%endfunction %% LibNeedTID


%% Function: LibNeedCPI ============================================================================
%% Abstract:
%%   LibNeedCPI sets the system flag NeedCPIInOutputUpdate (Control Port
%%   Index) flag.  This flag is needed when a function-call subsystem
%%   trigger port block has outputs and the control width is greater
%%   than one.  It needs to be attached to the system because system code
%%   generation recurses and using one global flag is not possible.
%%
%function LibNeedCPI(system) void
    %assign fcn = ::BlockFcn
    %if fcn == "Output" || fcn == "OutputUpdate"
        %assign fcn = "OutputUpdate"
    %endif
    %<SLibCG_AccessCPI()>
    %assign tempName = "NeedCPIIn" + fcn
    %<LibSetSystemField(system,tempName, TLC_TRUE)>
%endfunction


%% Function: LibTID ================================================================================
%% Abstract:
%%   LibTID returns tid and informs the code generator that the tid is
%%   used in the context of this call.
%%   This function should always be used instead of hard-coding %<::tTID>.
%%
%function LibTID() void
    %if ::CompiledModel.NumSampleTimes == 1 || ...
        SLibSingleTasking()
        %return "0"
    %else
        %<LibNeedTID()>
        %return ::tTID
    %endif
%endfunction %% LibTID

%% Function: SLibSetEmptyModelRefInitializeFcn =====================================================
%% Abstract:
%%   SLibSetEmptyModelRefInitializeFcn sets the global falg ::CompiledModel.EmptyModelRefInitializeFcn
%%   to TLC_TRUE
%%   This flag indicates that whether the generated initialize function of the Referenced model is empty.
%%
%function SLibSetEmptyModelRefInitializeFcn() void
    %assign ::CompiledModel.EmptyModelRefInitializeFcn = TLC_TRUE
%endfunction %%SLibSetEmptyModelRefInitializeFcn

%% Function: SLibSetEmptyTopModelInitializeFcn =====================================================
%% Abstract:
%%   SLibSetEmptyModelRefInitializeFcn sets the global falg ::CompiledModel.EmptyTopMdlInitializeFcn
%%   to TLC_TRUE
%%   This flag indicates that whether the generated initialize function of the top model is empty.
%%
%function SLibSetEmptyTopModelInitializeFcn() void
    %assign ::CompiledModel.EmptyFunctionsInfo.EmptyInitFcn = TLC_TRUE
%endfunction %%SLibSetEmptyTopModelInitializeFcn

%% Function: SLibGetEmptyModelRefInitializeFcn =====================================================
%% Abstract:
%%   SLibGetEmptyModelRefInitializeFcn returns the global falg ::CompiledModel.EmptyModelRefInitializeFcn
%%
%%
%function SLibGetEmptyModelRefInitializeFcn() void
    %return ::CompiledModel.EmptyModelRefInitializeFcn
%endfunction %%SLibGetEmptyModelRefInitializeFcn

%% Function: SLibGetEmptyTopMdlInitializeFcn =======================================================
%% Abstract:
%%   SLibGetEmptyTopMdlInitializeFcn returns the global flag ::CompiledModel.EmptyTopMdlInitializeFcn
%%
%%
%function SLibGetEmptyTopMdlInitializeFcn() void
    %return ::CompiledModel.EmptyFunctionsInfo.EmptyInitFcn
%endfunction %%SLibGetEmptyTopMdlInitializeFcn

%% Function: SLibEmptyModelRefInitializeFcn ========================================================
%% Abstract:
%%  Returns "EmptyModelRefInitializeFcn" and informs the code generator that "EmptyModelRefInitializeFcn"
%%  is used.
%%
%function SLibEmptyModelRefInitializeFcn() void
    %<SLibSetEmptyModelRefInitializeFcn()>
    %return "EmptyModelRefInitializeFcn"
%endfunction %% SLibEmptyModelRefInitializeFcn

%% DocFunction{Sample Time Functions}: LibGetTaskTimeFromTID ===================
%% Abstract:
%%   Returns a string to access the absolute time of the task accociated with
%%   the block.
%%   If the block is constant or the system is single rate, this is the TLC
%%   version of the SimStruct macro: "ssGetT(S)" and "ssGetTaskTime(S, tid)"
%%   otherwise.  In both cases, S is the name of the SimStruct.
%% TopTester: test/toolbox/simulink/blocks/CPPCodeGen/tsmlk_core_cpp_coverage.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tvss_code_variants.m
%%
%function LibGetTaskTimeFromTID(block) void
    %% register NeedAbsoluteTime whenever absolute time is required.
    %% Scope block Logging with Array datatype needs to be revisted.
    %if !ISFIELD(block, "NeedAbsoluteTime") && GenRTModel && ...
        !IsModelReferenceSimTarget() && block.Type != "Scope" && block.Type != "WebTimeScopeBlock"
        %<LibBlockReportWarning(block, "Absolute time is required. The block does not " + ...
            "register NeedAbsoluteTime. Obsolete absolute time will be used.")>
    %endif

    %if ISEQUAL(TID, "constant")
        %if RTMChildSfunctionIsReqFcn()
            %% rtM has StartTime field
            %return RTMGet("TStart")
        %else
            %return ::CompiledModel.StartTime
        %endif
    %endif

    %assign tid = SLibGetNumericTID(block)
    %% g2315512 Error out case when async export fcn accesses absolute time. This currently is not supported.
    %% Need revisit and remove the error when TimerService is on.
    %% In addition, it is necessary to turn on the warning above as soon as possible.
    %if !ISFIELD(block, "NeedAbsoluteTime") && SLibIsExportFcnDiagram() && ...
        LibAsynchronousTriggeredTID(tid)
        %<LibBlockReportError(block, "Asynchronous function-call subsystem in export-function model " + ...
            "cannot access absolute time. Set function-call inport to be periodic to access absolute time.")>
    %endif

    %if ISFIELD(block, "StateflowChartType")
        %% Need hard code in tid value for StateflowChart
        %% because SF is single rate and it doesn't passed
        %% in tid via arg list
        %return RTMGetTaskTimeForTID(tid)
    %else
        %return LibGetTaskTime(tid)
    %endif

%endfunction %% LibGetTaskTimeFromTID

%function LibGetTaskTimeFromTIDWrapper(systemIdx, blockIdx) void
    %with ::CompiledModel.System[systemIdx]
        %with Block[blockIdx]
            %assign result = LibGetTaskTimeFromTID(Block[blockIdx])
        %endwith
    %endwith
    %return result
%endfunction

%% DocFunction{Sample Time Functions}: LibGetTaskTime ==========================
%% Abstract:
%%   Returns a string to access the absolute time of the task.
%%   This function is the TLC version of the SimStruct macro:
%%   "ssGetTaskTime(S,tid)"
%% TopTester: test/toolbox/simulink/blocks/lib_Sources/Ground/rtw/tStringSupport.m
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortEnable.m
%%
%function LibGetTaskTime(tid) void

    %% This is temporary code to support timer service in code gen. Will be removed later.
    %% See g2060510.
    %if SLibNeedAbsoluteTimeService(tid)

        %if SLibUseBaseTIDForTimerServices(tid)
            %assign tid = 0
        %endif

        %if IsModelReferenceTarget()
            %return RTMGet("AbsoluteTime%<tid>")
        %elseif SLibGetTimerServiceWhenToCallRule(tid) == "DuringExecution"
            %return RTMGet("TaskTime%<tid>")
        %else
            %assign service = ::CompiledModel.TimerService[tid]
            %return "%<service.GetAbsoluteTimeFcnName>()"
        %endif
    %endif



    %if SLibIsERTCodeFormat()
        %return RTMGetTaskTimeForTID(tid)
    %else
        %if LibIsSingleRateSystem(System[NumSystems-1])
            %return RTMGet("T")
        %else
            %if ::BlockFcn == "Output" || ...
                ::BlockFcn == "OutputUpdate" || ...
                ::BlockFcn == "Update"
                %% tid is passed in for these functions
                %return RTMGetTaskTimeForTID(tid)
            %else
                %% tid is not passed in, need hard code here
                %return RTMGetTaskTimeForTID(tid)
            %endif
        %endif
    %endif
%endfunction %% LibGetTaskTime

%function LibGetTaskElapseTick(tid) void
    %% This is temporary code to support timer service in code gen. Will be removed later.
    %% See g2060510.
    %if SLibNeedFunctionStepTickService(tid)
        %if IsModelReferenceTarget()
            %return RTMGet("FunctionStepTick%<tid>")
        %elseif SLibGetTimerServiceWhenToCallRule(tid) == "DuringExecution"
            %return RTMGet("FunctionStepTick%<tid>")
        %else
            %assign service = ::CompiledModel.TimerService[tid]
            %return "%<service.GetFunctionStepTickFcnName>()"
        %endif
    %endif
    %return ""
%endfunction %% LibGetBaseRate

%function LibGetTaskElapseTime(tid) void
    %% This is temporary code to support timer service in code gen. Will be removed later.
    %% See g2060510.
    %if SLibNeedFunctionStepSizeService(tid)
        %if IsModelReferenceTarget()
            %return RTMGet("FunctionStepSize%<tid>")
        %elseif SLibGetTimerServiceWhenToCallRule(tid) == "DuringExecution"
            %return RTMGet("FunctionStepSize%<tid>")
        %else
            %assign service = ::CompiledModel.TimerService[tid]
            %return "%<service.GetFunctionStepSizeFcnName>()"
        %endif
    %endif
    %return ""
%endfunction %% LibGetBaseRate

%% DocFunction{Sample Time Functions}: LibGetClockTick =========================
%% Abstract:
%%   Returns integer task time (current clock tick of the task timer).
%%   The resolution of the timer can be obtained from
%%   LibGetClockTickStepSize(tid). The data type id of the timer can
%%   be obtained from LibGetClockTickDataTypeId(tid).
%% TopTester: test/toolbox/simulink/blocks/lib_Discrete/DiscreteTimeIntegrator/rtw/tdintegrt.m
%%
%function LibGetClockTick(tid) void
    %% This is temporary code to support timer service in code gen. Will be removed later.
    %% See g2060510.
    %if SLibGetUsingTimerServiceLevel() > 0
        %if SLibNeedFunctionClockTickService(tid)
            %if IsModelReferenceTarget() || SLibGetTimerServiceWhenToCallRule(tid) == "DuringExecution"
                %return RTMGet("ClockTick%<tid>")
            %else
                %assign service = ::CompiledModel.TimerService[tid]
                %return "%<service.GetFunctionClockTickFcnName>()"
            %endif
        %else
            %<SLibReportErrorWithIdAndArgs("RTW:SoftwareDeploymentPlatform:ClockTickServiceFromTLC", "%<::CompiledModel.Name>")>
        %endif
    %endif

    %assert TYPE(tid) == "Number" && tid >= 0
    %assign retVal = ""
    %if ClockTickForTIDIsReqFcn(tid)
        %<SLibSetNeedAbsoluteTime(tid)>
        %assign retVal = RTMGet("ClockTick%<tid>")
    %else
        %assign timer_resolution = SampleTime[tid].ClockTickStepSize
        %if timer_resolution == 0
            %assign retVal = LibGetTaskTime(tid)
        %else
            %assign clockTick_DTypeId = SampleTime[tid].ClockTickDataTypeId
            %if clockTick_DTypeId == tSS_TIMER_UINT32_PAIR
                %assign clockTick_DType   = LibGetDataTypeNameFromId(tSS_UINT32)
            %else
                %assign clockTick_DType = LibGetDataTypeNameFromId(clockTick_DTypeId)
            %endif
            %assign intTime = "%<LibGetTaskTime(tid)>/%<timer_resolution>+0.5"
            %assign floorTime = LibGenMathFcnCall("floor",  tSS_DOUBLE,"%<intTime>","")
            %assign retVal = "((%<clockTick_DType>)(%<floorTime>))"
        %endif
    %endif
    %return retVal
%endfunction %% LibGetClockTick

%% DocFunction{Sample Time Functions}: LibGetClockTickHigh =====================
%% Abstract:
%%   Returns high order word of integer task time. This function is used  when
%%   uint32 pairs are used to store absolute time. The resolution of the timer
%%   can be obtained from LibGetClockTickStepSize(tid).
%% TopTester: test/toolbox/simulink/blocks/lib_Discrete/DiscreteTimeIntegrator/rtw/tdintegrt.m
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function LibGetClockTickHigh(tid) void
    %assert TYPE(tid) == "Number" && tid >= 0
    %if LongClockTickForTIDIsReqFcn(tid)
        %<SLibSetNeedAbsoluteTime(tid)>
        %return RTMGet("ClockTickH%<tid>")
    %else
        %assign timer_resolution  = SampleTime[tid].ClockTickStepSize
        %assign weighedResolution = timer_resolution * 4.294967296e+09
        %assert timer_resolution > 0
        %assign clockTick_DType   = LibGetDataTypeNameFromId(tSS_UINT32)
        %assign clockTick = LibGenMathFcnCall("floor", tSS_DOUBLE, ...
            "%<LibGetTaskTime(tid)> / (%<weighedResolution>) + 0.5", "")
        %return "((%<clockTick_DType>)%<clockTick>)"
    %endif
%endfunction %% LibGetClockTick

%% DocFunction{Sample Time Functions}: LibGetClockTickStepSize =================
%% Abstract:
%%   Returns clock tick step size, which is the resolution of the integer task
%%   time. This function can't be used if the task doesn't have a timer.
%%
%function LibGetClockTickStepSize(tid) void
    %% This is temporary code to support timer service in code gen. Will be removed later.
    %% See g2060510.
    %if SLibNeedResolutionService(tid)
        %if IsModelReferenceTarget()
            %return RTMGet("Resolution%<tid>")
        %else
            %assign service = ::CompiledModel.TimerService[tid]
            %return "%<service.GetResolutionFcnName>()"
        %endif
    %endif
    %assert TYPE(tid) == "Number" && tid >= 0
    %assert ClockTickForTIDIsReqFcn(tid)
    %return SampleTime[tid].ClockTickStepSize
%endfunction %% LibGetClockTickStepSize

%function LibGetBaseRate() void
    %% This is temporary code to support timer service in code gen. Will be removed later.
    %% See g2060510.
    %return "getBaseTimeResolution"
%endfunction %% LibGetBaseRate

%% DocFunction{Sample Time Functions}: LibGetClockTickDataTypeId ===============
%% Abstract:
%%   Returns clock tick data type id.
%%
%function LibGetClockTickDataTypeId(tid) void
    %assert TYPE(tid) == "Number" && tid >= 0
    %assert ClockTickForTIDIsReqFcn(tid)
    %return SampleTime[tid].ClockTickDataTypeId
%endfunction %% LibGetClockTickDataTypeId

%% SLibGetDbBufReadBuf =========================================================
%% Abstract:
%%   Returns DbBufReadBuf. This flag is used by a double buffer algorithm.
%%   The algorithm insures data integrity when asynchronous task reads absolute
%%   time from base rate.
%%
%function SLibGetDbBufReadBuf(tid)
    %assert RTMClockTick0DbBufIsReqFcn(%<tid>) || RTMContTDbBufIsReqFcn(%<tid>)
    %return RTMGet("DbBufReadBuf%<tid>")
%endfunction %%SLibGetDbBufReadBuf

%% SLibGetDbBufWriteBuf ========================================================
%% Abstract:
%%   Returns DbBufWriteBuf. This flag is used by a double buffer algorithm. The
%%   algorithm insures data integrity when asynchronous task reads absolute
%%    time from base rate.
%%
%function SLibGetDbBufWriteBuf(tid)
    %assert RTMClockTick0DbBufIsReqFcn(%<tid>) || RTMContTDbBufIsReqFcn(%<tid>)

    %return RTMGet("DbBufWriteBuf%<tid>")
%endfunction %%SLibGetDbBufWriteBuf

%% SLibGetDbBufLastBufWr ======================
%% Abstract:
%%  Returns DbBufLastBufWr(last buffer written) . This flag is used by a double
%% buffer algorithm. The algorithm insures data integrity when
%% asynchronous task reads absolute time from base rate. %%
%function SLibGetDbBufLastBufWr(tid)
    %assert RTMClockTick0DbBufIsReqFcn(%<tid>) || RTMContTDbBufIsReqFcn(%<tid>)

    %return RTMGet("DbBufLastBufWr%<tid>")
%endfunction %%SLibGetDbBufLastBufWr


%% SLibGetDbBufClockTickForTid ==================================
%% Abstract:
%%  Returns the pointer of clock tick double buffers for specific tid.
%% The double is used to insures data integrity when
%% asynchronous task reads absolute time from base rate.
%%
%function SLibGetDbBufClockTickForTID(tid)
    %assert RTMClockTick0DbBufIsReqFcn(%<tid>)

    %return RTMGet("DbBufClockTick%<tid>")
%endfunction %%SLibGetDbBufClockTickForTID


%% SLibGetDbBufClockTickHForTID ==================================
%% Abstract:
%%  Returns the pointer of clock tick high word double buffers
%% for specific tid. The double is used to insures data integrity when
%% asynchronous task reads absolute time from base rate.
%%
%%
%function SLibGetDbBufClockTickHForTID(tid)
    %assert RTMClockTick0DbBufIsReqFcn(%<tid>) && LongClockTickForTIDIsReqFcn(0)

    %return RTMGet("DbBufClockTickH%<tid>")
%endfunction %%SLibGetDbBufClockTickHForTID

%% SLibGetDbBufContTForTID ===================================
%% Abstract::
%%  Returns the pointer of continuous double buffers for specific tid.
%% The double is used to insures data integrity when
%% asynchronous task reads absolute time from base rate.
%%
%function SLibGetDbBufContTForTID(tid)
    %assert RTMContTDbBufIsReqFcn(tid)

    %return RTMGet("DbBufContT%<tid>")
%endfunction %% SLibGetDbBufContTForTID


%% SLibGetH2LBufBeingRead ======================
%% Abstract:
%%  Return flag in Timing H2LBufBeingRead.
%%  This flag help to ensured data integrity
%%  of time when lower priority async task
%%  read time from base rate task. This flag
%%  keep track which buffer is being read
%%
%function SLibGetH2LBufBeingRead(tid)
    %assert RTMClockTick0H2LIsReqFcn(tid) || RTMContTH2LIsReqFcn(tid)

    %return RTMGet("H2LBufBeingRead%<tid>")
%endfunction %%SLibGetH2LBufBeingRead

%% SLibGetH2LLastBufWr ============================
%% Abstract:
%%  Return flag in Timing H2LLastBufWr.
%%  This flag help to insured data integrity
%%  of time when lower priority async task
%%  read time from base rate task. This flag
%%  keep track what is the buffer being written last.
%%
%function SLibGetH2LLastBufWr(tid)
    %assert RTMClockTick0H2LIsReqFcn(tid) || RTMContTH2LIsReqFcn(tid)

    %return RTMGet("H2LLastBufWr%<tid>")
%endfunction %%SLibGetH2LLastBufWr

%% SLibGetH2LDbBufClockTickForTID ==================================
%% Abstract::
%%  Return pointer of double buffer for clocktick0 used for H2L
%%  data transfer: H2LDbBufClockTick0
%%
%function SLibGetH2LDbBufClockTickForTID(tid)
    %assert RTMClockTick0H2LIsReqFcn(tid)

    %return RTMGet("H2LDbBufClockTick%<tid>")
%endfunction %%SLibGetH2LDbBufClockTickForTID

%% SLibGetH2LDbBufClockTickHForTID ==================================
%% Abstract::
%%  Return pointer of double buffer for clocktick0H used for H2L
%%  data transfer: H2LDbBufClockTickH0
%%
%function SLibGetH2LDbBufClockTickHForTID(tid)
    %assert RTMClockTick0H2LIsReqFcn(tid) && LongClockTickForTIDIsReqFcn(0)

    %return RTMGet("H2LDbBufClockTickH%<tid>")
%endfunction %%SLibGetH2LDbBufClockTickHForTID

%% SLibGetH2LDbBufContTForTID ===================================
%% Abstract::
%%  Return pointer of double buffer for ContT used for H2L
%%  data transfer: H2LDbBufContT
%%
%function SLibGetH2LDbBufContTForTID(tid)
    %assert RTMContTH2LIsReqFcn(tid)

    %return RTMGet("H2LDbBufContT%<tid>")
%endfunction %% SLibGetH2LDbBufContTForTID

%% SLibGetL2HLastBufWr ======================================
%% Abstract::
%%  Return flag in Timing L2HLastBufWr.
%%  This flag help to insured data integrity
%%  of time when higher priority async task
%%  read time from base rate task. This flag
%%  keep track what is the buffer being written last.
%%
%function SLibGetL2HLastBufWr()
    %assert RTMClockTick0L2HIsReqFcn() || RTMContTL2HIsReqFcn()

    %return RTMGet("L2HLastBufWr")
%endfunction %% SLibGetL2HLastBufWr

%% SLibGetL2HDbBufClockTick ==================================
%% Abstract::
%%  Return pointer of double buffer for clocktick0 used for L2H
%%  data transfer: L2HDbBufClockTick
%%
%function SLibGetL2HDbBufClockTick()
    %assert RTMClockTick0L2HIsReqFcn()

    %return RTMGet("L2HDbBufClockTick")
%endfunction %%SLibGetL2HDbBufClockTick

%% SLibGetL2HDbBufClockTickH ==================================
%% Abstract::
%%  Return pointer of double buffer for clocktick0H used for L2H
%%  data transfer: L2HDbBufClockTickH
%%
%function SLibGetL2HDbBufClockTickH()
    %assert RTMClockTick0L2HIsReqFcn() && LongClockTickForTIDIsReqFcn(0)

    %return RTMGet("L2HDbBufClockTickH")
%endfunction %%SLibGetL2HDbBufClockTickH

%% SLibGetL2HDbBufContT ===================================
%% Abstract::
%%  Return pointer of double buffer for ContT used for L2H
%%  data transfer: L2HDbBufContT
%%
%function SLibGetL2HDbBufContT()
    %assert RTMContTL2HIsReqFcn()

    %return RTMGet("L2HDbBufContT")
%endfunction %%SLibGetL2HDbBufContT

%function SLibGetTimerSemID(tid)
    %return RTMGet("SemIdForTask%<tid>")
%endfunction

%function SLibGetClockTickBufForTID(tid)
    %return RTMGet("ClockTickBuf%<tid>")
%endfunction

%function SLibGetClockTickHBufForTID(tid)
    %return RTMGet("ClockTickHBuf%<tid>")
%endfunction

%% DocFunction{Sample Time Functions}: LibGetElapseTimeCounter =================
%% Abstract:
%%     Returns an integer elapsed time. This is the number of clock ticks
%%  elapsed since the last time the system started. To get realworld elapsed time,
%%  this integer elapsed time must be multiplied by the applicable resolution.
%%  You can obtain the resolution by calling LibGetElapseTimeResolution(system).
%%  You can obtain the data type id of integer elapsed time counter
%%  by calling LibGetElapseTimeCounterDTypeId(system)
%%
%function LibGetElapseTimeCounter(system) void
    %assign callSites      = system.CallSites
    %assign sysIdx = system.CallSites[0][2]
    %assign blkIdx = system.CallSites[0][3]
    %assign ssBlock = ::CompiledModel.System[sysIdx].Block[blkIdx]

    %assert system.Type != "root"

    %if (ISFIELD(ssBlock, "NeedElapseTime") && ...
        ssBlock.NeedElapseTime)
        %if ISFIELD(ssBlock, "%<ssBlock.ElapseTimeSource>")
            %% pass in DW record
            %return LibBlockDWork(ssBlock.%<ssBlock.ElapseTimeSource>,"","",0)
        %else
            %% pass in string.
            %return LibBlockDWork("%<ssBlock.ElapseTimeSource>","","",0)
        %endif
    %else
        %assert LibIsSingleRateSystem(system)
        %return 1
    %endif

%endfunction %% LibGetElapseTimeCounter

%function LibGetElapseTimeCounterH(system) void
    %assign callSites      = system.CallSites
    %assign sysIdx = system.CallSites[0][2]
    %assign blkIdx = system.CallSites[0][3]
    %assign ssBlock = ::CompiledModel.System[sysIdx].Block[blkIdx]

    %assert system.Type != "root"

    %assert (ISFIELD(ssBlock, "NeedElapseTime") && ...
        ssBlock.NeedElapseTime)
    %assert LibGetElapseTimeCounterDTypeId(system) == ...
        tSS_TIMER_UINT32_PAIR

    %if ISFIELD(ssBlock, "%<ssBlock.ElapseTimeSource>")
        %% pass in DW record
        %return LibBlockDWork(ssBlock.%<ssBlock.ElapseTimeSource>,"","",1)
    %else
        %% pass in string.
        %return LibBlockDWork("%<ssBlock.ElapseTimeSource>","","",1)
    %endif

%endfunction %% LibGetElapseTimeCounter

%% SLibGetElapseTimeCounterUsesVector  =========================
%%  Determine if the Elapse Time Counter uses a two element
%%  vector of uint32_T's
%%
%function SLibGetElapseTimeCounterUsesVector(system) void
    %%
    %assign dtypeId = LibGetElapseTimeCounterDTypeId(system)
    %%
    %assign isVector = (dtypeId == tSS_TIMER_UINT32_PAIR)
    %return isVector
    %%
%endfunction %% SLibGetElapseTimeCounterUsesVector

%% LibBlockGetElapseTimeCounter =================
%% Abstract:
%%   for non timer_uint32_pair, return rt_elapsetime,
%%   for timer_uint32_pair, return rt_elapsetime[0]
%function LibBlockGetElapseTimeCounter(system) void
    %return LibGetElapseTimeCounter(system)
%endfunction

%% DocFunction{Sample Time Functions}: LibGetElapseTimeCounterDTypeId ===
%% Abstract:
%%  Returns the date type id of the integer elapsed time returned by
%% LibGetElapseTimeCounter(system)
%%
%function LibGetElapseTimeCounterDTypeId(system) void
    %if ISFIELD(system,"ElapseTimeDataTypeId")
        %return system.ElapseTimeDataTypeId
    %else
        %return tSS_UINT8
    %endif

%endfunction %% LibGetElapseTimeCounterDTypeId

%% DocFunction{Sample Time Functions}: LibGetElapseTimeResolution ===
%% Abstract:
%%  Returns resolution of integer elapsed time returned by
%% LibGetElapseTimeCounter
%%
%function LibGetElapseTimeResolution(system) void
    %assert LibIsSingleRateSystem(system)

    %if LibSystemIsRoot(system)
        %assign t_resolution = SampleTime[0].ClockTickStepSize
    %else
        %assign sysIdx = system.CallSites[0][2]
        %assign blkIdx = system.CallSites[0][3]
        %assign ssBlock = System[sysIdx].Block[blkIdx]

        %with ssBlock
            %if LibAsynchronousTriggeredTID(SubsystemTID)
                %assign t_resolution =  SampleTime[SubsystemTID].ClockTickStepSize
            %else
                %assign tid = SLibGetNumericTID(ssBlock)
                %assign t_resolution = SampleTime[tid].ClockTickStepSize
            %endif
        %endwith
    %endif

    %return t_resolution

%endfunction %% LibGetElapseTimeResolution

%function FcnEffectiveTid(block) void
    %return ISFIELD(block, "TriggerTID") ? block.TriggerTID : block.TID
%endfunction

%% DocFunction{Sample Time Functions}: LibGetElapseTime ===================
%% Abstract:
%%  Returns time elapsed since the last time the
%% subsystem started.
%%
%function LibGetElapseTime(system) void
    %assign callSites      = system.CallSites

    %assert system.Type != "root"

    %assign t_resolution = LibGetElapseTimeResolution(system)
    %if t_resolution == 0
        %return LibGetElapseTimeCounter(system)
    %endif

    %assign elapse_T =  LibGetElapseTimeCounter(system)
    %if LibGetElapseTimeCounterDTypeId(system) == tSS_TIMER_UINT32_PAIR
        %assign elapse_T_H = LibGetElapseTimeCounterH(system)
        %if t_resolution == 1
            %return "(%<elapse_T> + " + ...
                "(%<LibGetDataTypeNameFromId(tSS_DOUBLE)>)" + ...
                "(%<elapse_T_H>)*4294967296.0)"
        %else
            %return "(%<elapse_T> + " + ...
                "(%<LibGetDataTypeNameFromId(tSS_DOUBLE)>)" + ...
                "(%<elapse_T_H>)*4294967296.0)" + ...
                " * %<t_resolution>"
        %endif
    %else
        %if t_resolution == 1
            %return "(%<elapse_T>)"
        %else
            %return "(%<elapse_T> * %<t_resolution>)"
        %endif
    %endif

%endfunction %% LibGetElapseTime

%% Function: SLibForceNonfiniteGeneration ==========================================================
%% Abstract:
%%   Force generation of nonfinite files
%%
%function SLibForceNonfiniteGeneration() void
    %assign isSfcnFmt            = (CodeFormat == "S-Function")
    %assign isSfcnFmtAndNotAccel = isSfcnFmt && !Accelerator

    %return (isSfcnFmtAndNotAccel || isRSimWithSolverModule) && !IsModelReferenceTarget()
%endfunction

%% Function: SLibErtNeedNonFiniteInit ==============================================================
%% Abstract:
%%   Return whether call to nonfinite initialize function is needed.
%%   Note, this function is dependent on all caching being completed due to
%%   calls to SLibRealNonFinitesRequired().
%%
%function SLibERTNeedNonFiniteInit() void
    %assign needNonFinites = ( GenerateGRTWrapper && !SLibIsERTTarget() ) || ...
        SLibRealNonFinitesRequired() || ...
        ModelReferenceTargetType == "SIM"
    %if needNonFinites && !::UseNonFiniteLiterals
        %return TLC_TRUE
    %else
        %return TLC_FALSE
    %endif
%endfunction %% SLibERTNeedNonFiniteInit

%% Function: LibRealNonFinite ======================================================================
%% Abstract:
%%   LibRealNonFinite returns the appropriate non-finite and sets the
%%   corresponding global flag indicating the non-finite value's usage.
%%   This function should always be used instead of hard-coding %<::tInf>,
%%   %<::tMinusInf>, or %<::tNaN>.
%%
%%   Arguments:
%%      value: One of {inf, -inf, nan, "inf", "-inf", "nan"}
%% TopTester: test/toolbox/simulink/blocks/lib_MathOperations/Product/rtw/tNumerics_product_float.m
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%% TopTester: test/toolbox/simulink/variants/var-general/tStringSupport.m
%%
%function LibRealNonFinite(value) void
    %%
    %% Get past a TLC bug which say
    %%  nan == inf
    %%  nan == -inf
    %% Also get past a TLC bug that doesn't allow you to change
    %% the value mid-stream of the if-then-else evaluation.
    %%
    %if (SLibSupportNonfiniteLiterals())
        %<FcnTrackMathDotH()>
    %endif
    %if TYPE(value) == "Real"
        %if ISNAN(value)
            %assign newValue = "nan"
        %elseif value == rtInf
            %assign newValue = "inf"
        %elseif value == rtMinusInf
            %assign newValue = "-inf"
        %else
            %<LibReportFatalError("Unknown value: %<value>")>
        %endif
        %assign value = newValue
    %endif

    %switch value
      %case "inf"
        %<LibNeedRealNonFinite("inf")>
        %return ::tInf
      %case "-inf"
        %<LibNeedRealNonFinite("-inf")>
        %return ::tMinusInf
      %case "nan"
        %<LibNeedRealNonFinite("nan")>
        %return ::tNaN
      %default
        %<LibReportFatalError("Unknown non-finite value: %<value>")>
    %endswitch
%endfunction %% end LibRealNonFinite

%% Function: SLibRealNonFinitesRequired ============================================================
%% Abstract:
%%   SLibRealNonFinitesRequired returns one if a non-finite value was used
%%   in the generated code or there is non-inline sfunction.
%%
%% TopTester: test/toolbox/simulink/variants/var-vss-sigobj/tVSSSigObj.m
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-codegen/subsystemBuild/tIVSubsystemBuild_1.m
%%
%function SLibRealNonFinitesRequired() void
    %assign retVal = (::NeedRealInf || ::NeedRealMinusInf || ::NeedRealNaN) ? 1 : 0
    %assign retVal = retVal || NumChildSFunctions > 0 || MatFileLogging

    %% Consider nonfinite rtIsInf(F)/rtIsNaN(F) TFL function access
    %assign numcbs = FEVAL("rtwprivate", "rtw_get_tfl_used_fcns_info", ...
        LibGetModelName(), -1)
    %foreach i = numcbs
        %assign fctInfo = FEVAL("rtwprivate", "rtw_get_tfl_used_fcns_info", ...
            LibGetModelName(), i+1)
        %if fctInfo.FcnName == "rtIsInf" || fctInfo.FcnName == "rtIsInfF" || ...
            fctInfo.FcnName == "rtGetInf" || fctInfo.FcnName == "rtGetMinusInf" || ...
            fctInfo.FcnName == "rtGetInfF" || fctInfo.FcnName == "rtGetMinusInfF" || ...
            fctInfo.FcnName == "rtInf" || fctInfo.FcnName == "rtInfF" || ...
            fctInfo.FcnName == "rtMinusInf" || fctInfo.FcnName == "rtMinusInfF"
            %% Invoke error check to ensure nonfinite support is selected
            %<LibRealNonFinite("inf")>
            %assign retVal = 1
            %break
        %elseif fctInfo.FcnName == "rtIsNaN" || fctInfo.FcnName == "rtIsNaNF" || ...
            fctInfo.FcnName == "rtGetNaN" || fctInfo.FcnName == "rtGetNaNF" || ...
            fctInfo.FcnName == "rtNaN" || fctInfo.FcnName == "rtNaNF"
            %% Invoke error check to ensure nonfinite support is selected
            %<LibRealNonFinite("nan")>
            %assign retVal = 1
            %break
        %elseif fctInfo.NonFiniteSupportNeeded == 1
            %% This will be true for TFL entries that will support non-finites
            %% in the gen callbacks.
            %assign retVal = 1
            %break
        %endif
    %endforeach

    %% make sure both non-finite support and floating point support are enabled
    %% if noninlined S-Functions exist
    %if (NumChildSFunctions > 0) && ((SupportNonFinite==0) || (PurelyIntegerCode==1))
        %<SLibReportErrorWithId("RTW:tlc:SupportNonInlinedSFcn")>
    %endif
    %return retVal
%endfunction %% SLibRealNonFinitesRequired

%% Function SLibExplicitTaskingTID ===================
%% Abstract:
%%   Returns whether this TID corresponds to Explicit Tasking
%%
%function SLibExplicitTaskingTID(tid) void

    %return TYPE(tid) == "Number" && tid >= 0 && ...
        ::CompiledModel.SampleTime[tid].ExplicitTasking == "yes"

%endfunction %% LibExplicitTaskingTID

%% Function SLibExplicitPeriodicInExportFcnDiagram ===================
%% Abstract:
%%   Returns whether this TID is a Periodic Explicit Tasks in Export
%%   Function diagram
%%
%function SLibExplicitPeriodicInExportFcnDiagram(tid) void

    %return TYPE(tid) == "Number" && tid >= 0 && ...
        SLibIsExportFcnDiagram() && ...
        SLibExplicitTaskingTID(tid) && !LibAsynchronousTriggeredTID(tid)

%endfunction %% SLibExplicitPeriodicInExportFcnDiagram

%function SLibLegacyAsynchronousTID(tid) void
    %return TYPE(tid) == "Number" && tid >= 0 && ...
        ISFIELD(::CompiledModel.SampleTime[tid], "EventSourceType") && ...
        ::CompiledModel.SampleTime[tid].EventSourceType =="AsyncSfcnBlk"
%endfunction %% SLibLegacyAsynchronousTID

%function SLibMultiCallerLegacyAsynchronousTID(tid) void
    %return TYPE(tid) == "Number" && tid >= 0 && ...
        ISFIELD(::CompiledModel.SampleTime[tid], "EventSourceType") && ...
        ::CompiledModel.SampleTime[tid].EventSourceType == "MultiCaller"
%endfunction %% SLibMultiCallerLegacyAsynchronousTID

%function SLibUnionSampletimeTID(tid) void
    %return TYPE(tid) == "Number" && tid >= 0 && ...
        ::CompiledModel.SampleTime[tid].IsUnionTs == "yes"
%endfunction %% SLibUnionSampletimeTID

%function SLibIsUnionSampleTimeTIDWithoutTask(tid) void
    %% The Union sample time is virtual when it is used in the BIMO context
    %% i.e. for branched inputs/outputs and multi-caller fcn-call subsystem in
    %% non-export-function models. These union rates don't contain only legacy
    %% async rates. We do not access these TIDs in referenced models or use them
    %% for timing services.
    %return SLibUnionSampletimeTID(tid) && ...
        ::CompiledModel.SampleTime[tid].UnionRateHasTask == "no"
%endfunction %% SLibIsUnionSampleTimeTIDWithoutTask

%function SLibUseBaseTIDForTimerServices(tid) void
    %% Simstruct based targets have time slots that are set appropriately, therefore
    %% use of base TID for timing services isn't needed
    %if !IsModelReferenceForASimstructBasedTarget() && ...
        ::CompiledModel.NumSynchronousSampleTimes > 0

        %if SLibIsUnionSampleTimeTIDWithoutTask(tid)
            %% We use the base rate if available for generating the
            %% timing services of union rates without task

            %return TLC_TRUE
        %elseif SLibIsExplicitAperiodicPartitioningTID(tid)
            %% Aperiodic partitions use the master time when there are timed rates

            %return TLC_TRUE
        %endif
    %endif

    %return TLC_FALSE
%endfunction %% SLibUseBaseTIDForTimerServices


%function SLibSynchronousTID(tid) void
    %return ::CompiledModel.SampleTime[tid].Asynchronous == "no"
%endfunction %% SLibLegacyAsynchronousTID

%function SLibControllableRateTID(tid) void
    %return TYPE(tid) == "Number" && tid > 0 && ...
        ISFIELD(::CompiledModel.SampleTime[tid], "CtrlRateInstanceIndex")
%endfunction %% SLibControllableRateTID

%function SLibModelHasControllableRate() void
    %return ::CompiledModel.NumControllableSampleTimes > 0
%endfunction %% SLibModelHasControllableRate

%function SLibFirstControllableRateTID() void
    %assert SLibModelHasControllableRate()
    %foreach tid = NumRuntimeExportedRates
        %if SLibControllableRateTID(tid)
            %return tid
        %endif
    %endforeach
    %return -1
%endfunction %% SLibFirstControllableRateTID

%function SLibGetBlockCtrlRateIndex(block, locSTI) void
    %% Currently, only single rate blocks could be ctrl rate onwers. In the future, this
    %% restriction will be removed.
    %assign blockTid = block.TID
    %assert locSTI == 0 && TYPE(blockTid) == "Number" && SLibControllableRateTID(blockTid)
    %if !IsModelReferenceTarget() && !Accelerator && !isRAccel
        %return CompiledModel.SampleTime[blockTid].CtrlRateInstanceIndex
    %else
        %return blockTid
    %endif
%endfunction %% SLibGetBlockCtrlRateIndex

%function SLibModelWideEventTID(tid) void
    %return TYPE(tid) == "Number" && tid >= 0 && ...
        ::CompiledModel.SampleTime[tid].IsModelWideEvent == "yes"
%endfunction %% SLibModelWideEventTID

%function SLibNonInlinedModelWideEventTIDImpl(tid) void
    %return SLibNonInlinedIRTEventTID(tid) || ...
        SLibParameterChangeEventTID(tid)
%endfunction %% SLibNonInlinedModelWideEventTID

%function SLibNonInlinedModelWideEventTID(tid) void
    %if TYPE(tid) == "Number" && tid >= 0
        %if ::CompiledModel.SampleTime[tid].NonInlinedModelWideEvent == -1
            %assign ::CompiledModel.SampleTime[tid].NonInlinedModelWideEvent = ...
                (SLibNonInlinedModelWideEventTIDImpl(tid) ? 1 : 0)
        %endif
        %return (::CompiledModel.SampleTime[tid].NonInlinedModelWideEvent == 1)
    %endif
    %return TLC_FALSE
%endfunction %% SLibNonInlinedModelWideEventTID

%function SLibInitEventTID(tid) void
    %return TYPE(tid) == "Number" && tid >= 0 && ...
        ISFIELD(::CompiledModel.SampleTime[tid], "EventSourceType") && ...
        ::CompiledModel.SampleTime[tid].EventSourceType == "PowerUpEvent"
%endfunction %% SLibInitEventTID

%function SLibTermEventTID(tid) void
    %return TYPE(tid) == "Number" && tid >= 0 && ...
        ISFIELD(::CompiledModel.SampleTime[tid], "EventSourceType") && ...
        ::CompiledModel.SampleTime[tid].EventSourceType == "PowerDownEvent"
%endfunction %% SLibTermEventTID

%function SLibNonInlinedIRTEventTID(tid) void
    %return TYPE(tid) == "Number" && tid >= 0 && ...
        ISFIELD(::CompiledModel.SampleTime[tid], "EventSourceType") && ...
        (::CompiledModel.SampleTime[tid].EventSourceType == "ResetEvent" || ...
        ::CompiledModel.SampleTime[tid].EventSourceType == "ResetWithInitEvent" || ...
        (::CompiledModel.SampleTime[tid].EventSourceType == "PowerDownEvent" && ...
        IsModelReferenceSimTarget()))
%endfunction %% SLibNonInlinedIRTEventTID

%function SLibResetOrResetWithInitEventTID(tid) void
    %return TYPE(tid) == "Number" && tid >= 0 && ...
        ISFIELD(::CompiledModel.SampleTime[tid], "EventSourceType") && ...
        (::CompiledModel.SampleTime[tid].EventSourceType == "ResetEvent" || ...
        ::CompiledModel.SampleTime[tid].EventSourceType == "ResetWithInitEvent")
%endfunction %% SLibResetOrResetWithInitEventTID

%function SLibSimEventTID(tid) void
    %return TYPE(tid) == "Number" && tid >= 0 && ...
        ISFIELD(::CompiledModel.SampleTime[tid], "EventSourceType") && ...
        ::CompiledModel.SampleTime[tid].EventSourceType == "SimEvent"
%endfunction %% SLibSimEventTID

%function SLibSystemFcnUsedByReinitializeEvent(system, fcn, callerTid)
    %if ISFIELD(system, "IsSynthesizedUtilityFcnForReinit") && system.IsSynthesizedUtilityFcnForReinit
        %if SLibReinitializeEventTID(callerTid)
            %assert fcn == "Output"
            %return TLC_TRUE
        %endif
    %endif
    %return TLC_FALSE
%endfunction

%function SLibReinitializeEventTID(tid) void
    %return TYPE(tid) == "Number" && tid >= 0 && ...
        ISFIELD(::CompiledModel.SampleTime[tid], "EventSourceType") && ...
        ::CompiledModel.SampleTime[tid].EventSourceType == "ResetWithInitEvent"
%endfunction %% SLibReinitializeEventTID

%function SLibInitResetTermEventTID(tid) void
    %return TYPE(tid) == "Number" && tid >= 0 && ...
        ISFIELD(::CompiledModel.SampleTime[tid], "EventSourceType") && ...
        (::CompiledModel.SampleTime[tid].EventSourceType == "PowerUpEvent" || ...
        ::CompiledModel.SampleTime[tid].EventSourceType == "PowerDownEvent" || ...
        ::CompiledModel.SampleTime[tid].EventSourceType == "ResetEvent" || ...
        ::CompiledModel.SampleTime[tid].EventSourceType == "ResetWithInitEvent")
%endfunction %% SLibInitResetTermEventTID

%function SLibParameterChangeEventTID(tid) void
    %return TYPE(tid) == "Number" && tid >= 0 && ...
        ISFIELD(::CompiledModel.SampleTime[tid], "EventSourceType") && ...
        ::CompiledModel.SampleTime[tid].EventSourceType =="ParameterChangeEvent"
%endfunction %% SLibParameterChangeEventTID

%function SLibTidOfParameterChangeEvent() void
    %foreach tid = NumSampleTimes
        %if SLibParameterChangeEventTID(tid)
            %return tid
        %endif
    %endforeach
    %return -1
%endfunction %% SLibTidOfParameterChangeEvent

%% This function is used to check if the model parameterizes discrete rates.
%function SLibParameterizeDiscreteRate() void
    %return (ISFIELD(::CompiledModel,"ParamterizeDiscreteRates") && ...
        ::CompiledModel.ParamterizeDiscreteRates == "yes")
%endfunction %% SLibParameterizeDiscreteRate

%% This function is used to check the level that the model enables timer service.
%function SLibGetUsingTimerServiceLevel() void
    %if  ISFIELD(::CompiledModel,"UsingTimerServicesLevel")
        %return ::CompiledModel.UsingTimerServicesLevel
    %endif
    %return 0
%endfunction %% SLibGetUsingTimerServiceLevel

%% This function is used to check if the model needs timer service.
%function SLibGetNeedTimerServices() void
    %return  ISFIELD(::CompiledModel,"NeedTimerServices") && ...
        ::CompiledModel.NeedTimerServices == "yes"
%endfunction %% SLibGetNeedTimerServices


%function SLibNeedResolutionService(tid) void
    %if SLibGetUsingTimerServiceLevel() == 0
        %return TLC_FALSE
    %endif
    %if ISEMPTY(tid)
        %assign tid = 0
    %endif
    %return  ISFIELD(::CompiledModel.TimerService[tid], "GetResolutionFcnName")
%endfunction

%function SLibNeedAbsoluteTimeService(tid) void
    %if SLibGetUsingTimerServiceLevel() == 0
        %return TLC_FALSE
    %endif
    %if ISEMPTY(tid)
        %assign tid = 0
    %endif
    %return ISFIELD(::CompiledModel.TimerService[tid], "GetAbsoluteTimeFcnName")
%endfunction %%SLibNeedAbsoluteTimeService

%function SLibNeedFunctionClockTickService(tid) void
    %if SLibGetUsingTimerServiceLevel() == 0
        %return TLC_FALSE
    %endif
    %if ISEMPTY(tid)
        %assign tid = 0
    %endif
    %return ISFIELD(::CompiledModel.TimerService[tid], "GetFunctionClockTickFcnName")
%endfunction %%SLibNeedFunctionClockTickService

%function SLibNeedFunctionStepSizeService(tid) void
    %if SLibGetUsingTimerServiceLevel() == 0
        %return TLC_FALSE
    %endif
    %if ISEMPTY(tid)
        %assign tid = 0
    %endif
    %return ISFIELD(::CompiledModel.TimerService[tid], "GetFunctionStepSizeFcnName")
%endfunction %%SLibNeedFunctionStepSizeService

%function SLibNeedFunctionStepTickService(tid) void
    %if SLibGetUsingTimerServiceLevel() == 0
        %return TLC_FALSE
    %endif
    %if ISEMPTY(tid)
        %assign tid = 0
    %endif
    %return ISFIELD(::CompiledModel.TimerService[tid], "GetFunctionStepTickFcnName")
%endfunction %%SLibNeedFunctionStepTickService

%function SLibGetTimerServiceWhenToCallRule(tid)
    %if ISEMPTY(tid)
        %assign tid = 0
    %endif

    %if SLibGetUsingTimerServiceLevel() > 0 && ...
        ISFIELD(::CompiledModel.TimerService[tid], "WhenToCallRule")
        %return ::CompiledModel.TimerService[tid].WhenToCallRule
    %else
        %return ""
    %endif
%endfunction

%function SLibGetFundamentalStepSize() void
    %if SLibParameterizeDiscreteRate()
        %return 1
    %else
        %return ::CompiledModel.FundamentalStepSize
    %endif
%endfunction

%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%% TopTester: test/toolbox/simulink/variants/var-inline-general/tCSCDefine.m
%%
%function FcnModelTaskToFirstTID(includeAsync) void
    %assign v = []
    %assign firstPeriodic = TLC_TRUE
    %foreach tid = NumSampleTimes
        %if SLibSynchronousTID(tid)
            %if ISEQUAL(SolverType, "FixedStep") && FixedStepOpts.TID01EQ && ...
                !ISEMPTY(v) && v[0] == 0 && tid == 1 && !IsModelReferenceTarget()
                %continue
            %endif

            %% UnionSampleTime doesn't have ModelEntryPoint.
            %if ::CompiledModel.SampleTime[tid].IsUnionTs == "yes"
                %continue
            %endif

            %% ExplicitTasking rate entry function is called
            %% explicitly by it caller.
            %if ::CompiledModel.SampleTime[tid].ExplicitTasking == "yes"
                %if SLibIsExplicitPartitioningTID(tid)
                    %assign v = v + tid
                %elseif SLibIsExportFcnDiagram()
                    %if !LibIsModelReferenceTarget()
                        %assign v = v + tid
                    %endif
                %endif
                %continue
            %endif

            %if !SLibIsPeriodicRateGrouping()
                %if firstPeriodic
                    %assign v = v + tid
                    %assign firstPeriodic = TLC_FALSE
                %endif
            %else
                %assign v = v + tid
            %endif
        %elseif SLibNonInlinedModelWideEventTID(tid)
            %assign v = v + tid
        %elseif includeAsync
            %assign v = v + tid
        %endif
    %endforeach
    %return v
%endfunction

%function SLibModelEntryPointTid(idx, returnEmptyStringForNonRateGrouping) void
    %assign tidsWithEntryPoints = FcnModelTaskToFirstTID(TLC_FALSE)
    %assert (idx >= 0) && (idx < SIZE(tidsWithEntryPoints, 1))
    %assign tid = tidsWithEntryPoints[idx]
    %if returnEmptyStringForNonRateGrouping && ...
        SLibSynchronousTID(tid) && !SLibIsPeriodicRateGrouping() && ...
        (!LibIsModelReferenceTarget() || ::CompiledModel.SolverType == "FixedStep" || ...
        ::CompiledModel.HasPartitions == "no" || ...
        ::CompiledModel.NumRuntimeExportedRates == 1)
        %return ""
    %else
        %return tid
    %endif
%endfunction

%function SLibNumTidsWithModelEntryPoints() void
    %assign tidsWithEntryPoints = FcnModelTaskToFirstTID(TLC_FALSE)
    %return SIZE(tidsWithEntryPoints, 1)
%endfunction

%% DocFunction{Sample Time Functions}: LibIsSFcnSampleHit ======================
%% Abstract:
%%   Returns 1 if a sample hit occurs for the specified local S-function task
%%   identifier (TID), 0 otherwise.
%%
%%   The input argument to this function should be either:
%%
%%      sfcnTID: integer (e.g. 2)
%%               For block-based sample times (e.g. in S-function
%%               mdlInitializeSizes, ssSetNumSampleTimes(S,N)
%%               with N > 1 was specified), sfcnTID is an integer starting at
%%               0 of the corresponding local S-function sample time.
%%         or
%%
%%      sfcnTID: "InputPortIdxI", "OutputPortIdxI" (e.g. "InputPortIdx0",
%%               "OutputPortIdx7") For port based sample times (e.g. in
%%               S-function mdlInitializeSizes,
%%               ssSetNumSampleTimes(S,PORT_BASED_SAMPLE_TIMES) was specified),
%%               sfcnTID is a string giving the input (or output) port index.
%%
%%   Examples:
%%   1) Consider a multirate S-function block with 4 block sample times.
%%      The call LibIsSFcnSampleHit(2) will return the code to check
%%      for a sample hit on the 3rd S-function block sample time.
%%
%%   2) Consider a multirate S-function block with 3 input and 8 output
%%      sample times. The call LibIsSFcnSampleHit("InputPortIdx0") returns the
%%      code to check for a sample hit on the first input port. The call
%%      LibIsSFcnSampleHit("OutputPortIdx7") returns the code to check for
%%      a sample hit on the eight output port.
%%
%function LibIsSFcnSampleHit(sfcnTID) void

    %% See also:
    %%   LibGetNumSFcnSampleTimes
    %%   LibIsSFcnSingleRate
    %%   LibGetGlobalTIDFromLocalSFcnTID
    %%   LibIsSFcnSpecialSampleHit
    %%   LibGetSFcnTIDType
    %%   LibIsSampleHit
    %%   LibIsSpecialSampleHit
    %%

    %if Type != "S-Function"
        %<LibReportFatalError("Called with non-S-Function block")>
    %endif
    %if  ((SIZE(TID,1) == 1) && (PortBasedSampleTimes != "yes"))
        %<LibReportFatalError("Called non-multirate S-function block")>
    %endif

    %assign tid = LibGetGlobalTIDFromLocalSFcnTID(sfcnTID)
    %return LibIsSampleHit(tid)
%endfunction %% LibIsSFcnSampleHit



%% DocFunction{Sample Time Functions}: LibIsSFcnSpecialSampleHit ===============
%% Abstract:
%%   Returns the Simulink macro to promote a slow task (sfcnSTI) into a faster
%%   task (sfcnTID).
%%
%%   This advanced function is specifically intended for use in rate transition
%%   blocks. This function determines the global TID from the S-function TID
%%   and calls LibIsSpecialSampleHit using the global TIDs for both the sample
%%   time index (sti) and the task id (tid).
%%
%%   The input arguments to this function are:
%%
%%   o) For multirate S-function blocks:
%%      sfcnSTI: local S-function sample time index (sti) of the slow task that
%%               is to be promoted
%%      sfcnTID: local S-function task Id (tid) of the fast task where the slow
%%               task will be run.
%%
%%   o) For single rate S-function blocks using SS_OPTION_RATE_TRANSITION,
%%      the sfcnSTI and sfcnTID are ignored and should be specified as "".
%%
%%   The format of sfcnSTI and sfcnTID must follow that of the argument
%%   to LibIsSFcnSampleHit
%%
%%   Examples:
%%     1) A rate transition S-function (one sample time with
%%        SS_OPTION_RATE_TRANSITION):
%%
%%        if (%<LibIsSFcnSpecialSampleHit("","")>) {
%%
%%     2) A multi-rate S-function with port-based sample times where the
%%        output rate is slower than the input rate (e.g. a zero-order
%%        hold operation):
%%
%%        if (%<LibIsSFcnSpecialSampleHit("OutputPortIdx0","InputPortIdx0")>) {
%%
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc/tmMultiRateAsyncTask_VC1.m
%%
%function LibIsSFcnSpecialSampleHit(sfcnSTI, sfcnTID)

    %% See also:
    %%   LibGetNumSFcnSampleTimes
    %%   LibIsSFcnSingleRate
    %%   LibGetGlobalTIDFromLocalSFcnTID
    %%   LibIsSFcnSampleHit
    %%   LibGetSFcnTIDType
    %%   LibIsSampleHit
    %%   LibIsSpecialSampleHit
    %%

    %if SIZE(TID,1) == 1
        %if !EXISTS(SampleTimeIdx)
            %<LibReportFatalError("Called with non-multirate S-function block")>
        %endif
        %assign sti = SampleTimeIdx
        %assign tid = TID
    %else
        %assign sti = LibGetGlobalTIDFromLocalSFcnTID(sfcnSTI)
        %assign tid = LibGetGlobalTIDFromLocalSFcnTID(sfcnTID)
    %endif

    %% Run in task tid but at frequency of sti.
    %return LibIsSpecialSampleHit(sti,tid)

%endfunction %% LibIsSFcnSpecialSampleHit



%% DocFunction{Sample Time Functions}: LibGetSFcnTIDType =======================
%% Abstract:
%%   Returns the type of the specified S-Functions task identifier (sfcnTID).
%%
%%     "continuous" if the specified sfcnTID is continuous.
%%     "discrete"   if the specified sfcnTID is discrete.
%%     "triggered"  if the specified sfcnTID is triggered.
%%     "constant"   if the specified sfcnTID is constant
%%     "asynchronous" if the specified sfcnTID is asynchronous
%%
%%   The format of sfcnTID must follow be the same as for LibIsSFcnSampleHit
%%
%%   Note:
%%     This is useful primarily in the context of S-functions that specified an
%%     inherited sample time.
%%
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc/tmMultiRateAsyncTask_VC1.m
%%
%function LibGetSFcnTIDType(sfcnTID)

    %% See also:
    %%   LibGetNumSFcnSampleTimes
    %%   LibIsSFcnSingleRate
    %%   LibGetGlobalTIDFromLocalSFcnTID
    %%   LibIsSFcnSampleHit
    %%   LibIsSFcnSpecialSampleHit
    %%

    %if SIZE(TID,1) == 1
        %assign tid = TID
    %else
        %assign tid = LibGetGlobalTIDFromLocalSFcnTID(sfcnTID)
    %endif

    %if TYPE(tid) == "Number"
        %if SLibParameterChangeEventTID(tid) || tid == -2
            %return "constant"
        %endif

        %assign period = ::CompiledModel.SampleTime[tid].PeriodAndOffset[0]
        %assign offset = ::CompiledModel.SampleTime[tid].PeriodAndOffset[1]
        %if period == 0.0 && offset == 0.0
            %return "continuous"
        %elseif period > 0.0
            %return "discrete"
        %elseif period == -1.0 && offset < -1.0
            %return "asynchronous"
        %endif
    %elseif TYPE(tid) == "String" || TYPE(tid) == "Identifier"
        %return tid
    %endif

%endfunction %% LibGetSFcnTIDType

%% DocFunction{Other Useful Functions}: SLibIsContainerCGTypeND ===========
%% Abstract:
%%   Returns true if the container CG type for the given indexing is ND.
%%
%%   For optimization reasons if ContainerCGTypeIdx is the same as
%%   CGTypeIdx the former gets optimized away. For this reason
%%   if the former is not found the later is used.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%%
%function SLibIsContainerCGTypeND(rec) void
    %if !ISEMPTY(rec) && (ISFIELD(rec, "ContainerCGTypeIdx") || ...
        ISFIELD(rec, "CGTypeIdx"))
        %assign containerCgTypeIdx = SLibGetRecordContainerCGTypeIdx(rec)
        %if containerCgTypeIdx >= 0 && ...
            LibCGTypeIsMatrix(containerCgTypeIdx)
            %assign ctnrTypeIdx = containerCgTypeIdx
            %assign recDims = LibCGTypeDimensions(ctnrTypeIdx)
            %if !ISEMPTY(recDims) && SIZE(recDims, 1) > 1
                %return TLC_TRUE
            %endif
        %endif
    %endif
    %return TLC_FALSE
%endfunction %% SLibIsContainerCGTypeND

%% DocFunction{Other Useful Functions}: LibDataTypeIsContainerClass ===========
%% Abstract:
%%   Returns true if the record correspond to a CG::ClassType or scalar opaque
%%   type that is a container to matrix data
%function LibDataTypeIsContainerClass(rec) void
    %if !ISEMPTY(rec) && ISFIELD(rec, "DataTypeIdx")
        %return LibIsDataTypeContainerClass(rec.DataTypeIdx)
    %elseif !ISEMPTY(rec) && ISFIELD(rec, "OriginalDataTypeIdx")
        %return LibIsDataTypeContainerClass(rec.OriginalDataTypeIdx)
    %endif
    %return TLC_FALSE
%endfunction %% SLibIsContainerClass

%% DocFunction{Other Useful Functions}: SLibIsContainerCGTypeStdContainer =======
%% Abstract:
%%   Returns true if the container CG type for the given data record is a std container type.
%function SLibIsContainerCGTypeStdContainer(rec) void
    %if !ISEMPTY(rec) && (ISFIELD(rec, "ContainerCGTypeIdx") || ...
        ISFIELD(rec, "CGTypeIdx"))
        %assign containerCgTypeIdx = SLibGetRecordContainerCGTypeIdx(rec)
        %if containerCgTypeIdx >= 0
            %return LibCGTypeIsStdContainer(containerCgTypeIdx)
        %endif
    %endif
    %return TLC_FALSE
%endfunction %% SLibIsContainerCGTypeStdContainer

%% Function: LibOptionalMatrixDims =================================================================
%% Abstract:
%%   LibOptionalMatrixDims returns a string that can be used for
%%   C declarations of 1-D arrays (1-D or 2-D arrays).
%%
%%   This functions returns
%%      ""             if the inputs are 0
%%      "[number]"     if non-zero inputs, where number is nRows*nCols
%%
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%%
%function LibOptionalMatrixDims(nRows, nCols) void
    %if nRows == 1 && nCols == 1
        %return ""
    %elseif nCols == 1 && nRows > 1
        %return "[%<nRows>]"
    %elseif nRows == 1 && nCols > 1
        %return "[%<nCols>]"
    %elseif nCols > 1 && nRows > 1
        %if SLibIsNdIndexingFeatureOn()
            %return "[%<nCols>][%<nRows>]"
        %else
            %return "[%<nRows*nCols>]"
        %endif
    %else
        %<LibReportFatalError("Invalid matrix size (%<nRows> x %<nCols>)")>
    %endif
%endfunction %% LibOptionalMatrixDims

%% Function: LibOptionalMatrixWidth ================================================================
%% Abstract:
%%   LibOptionalMatrixWidth returns a string that can be used for
%%   C declarations of 1-D arrays (1-D or 2-D arrays).
%%
%%   This functions returns
%%      ""             if the inputs are 0
%%      "[number]"     if non-zero inputs, where number is nRows*nCols
%%
%function LibOptionalMatrixWidth(nRows, nCols) void
    %if nRows == 1 && nCols == 1
        %return ""
    %elseif nCols == 1 && nRows > 1
        %return "[%<nRows>]"
    %elseif nRows == 1 && nCols > 1
        %return "[%<nCols>]"
    %elseif nCols > 1 && nRows > 1
        %return "[%<nRows*nCols>]"
    %else
        %<LibReportFatalError("Invalid matrix size (%<nRows> x %<nCols>)")>
    %endif
%endfunction %% LibOptionalMatrixWidth

%% Function: LibGetDimensionDefString ==============================================================
%% Abstract:
%%   For the dimensions of the given parameter returns a string that can
%% be used, for example, for variable definitions in C language.
%%
%%   [d1, d2, ..., dn] -> "[d1][d2]...[dn]"
%%
%function LibGetDimensionDefString(record) void
    %assign width = LibGetDataWidth(record)
    %if width == 1
        %return ""
    %else
        %assign tmpDims = LibGetDataSymbolicDims(record)
        %assign retDims = ""
        %foreach dimIdx = SIZE(tmpDims, 1)
            %assign retDims = retDims + "[%<tmpDims[dimIdx]>]"
        %endforeach
        %return retDims
    %endif
%endfunction %% LibGetDimensionDefString

%% Function: LibOptionalVectorWidth ================================================================
%% Abstract:
%%   LibOptionalVectorWidth returns "[length]" if the length of the input
%%   vector is greater than one and returns "" otherwise.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%%
%function LibOptionalVectorWidth(length) void
    %if TYPE(length) == "Number"
        %if length == 1
            %return ""
        %elseif length > 1
            %return "[%<length>]"
        %else
            %<LibReportFatalError("Invalid vector length (%<length>) specified")>
        %endif
    %else
        %assert TYPE(length) == "String"
        %if length == "1"
            %return ""
        %else
            %return "[%<length>]"
        %endif
    %endif
%endfunction %% LibOptionalVectorWidth

%% Function: LibGetIndexOfFirstElement =============================================================
%% Abstract:
%%   Returns the Index of the first element for the given variable
%% access, if the number of dimensions is larger than 1. For example:
%%
%% aDims         = [3, 4, 10]
%% Returns       => "[0][0][0]"
%%
%% In the example above if aDims == "1", [1], or [n] then empty str is
%% returned.
%%
%function LibGetIndexOfFirstElement(aNumDims) void
    %assign retAccess = ""
    %if aNumDims >= 2
        %foreach dimIdx = aNumDims
            %assign retAccess = retAccess + "[0]"
        %endforeach
    %endif
    %return retAccess
%endfunction %% LibGetIndexOfFirstElement

%% Function: LibGetAddressOfFirstElement ===========================================================
%% Abstract:
%%   Returns the address of the first element for the given variable
%% access, if the number of dimensions is larger than 1. For example:
%%
%% aVarAccessStr = "structVar.oneField"
%% aDims         = [3, 4, 10]
%% Returns       => "(&structVar.oneField[0][0][0])"
%%
%% In the example above if aDims == "1", [1], or [n] then aVarAccessStr is
%% returned.
%%
%function LibGetAddressOfFirstElement(aVarAccessStr, aNumDims) void
    %if aNumDims < 2
        %return aVarAccessStr
    %else
        %assign retAccess = "(&" + aVarAccessStr
        %assign retAccess = retAccess + LibGetIndexOfFirstElement(aNumDims)
        %assign retAccess = retAccess + ")"
        %return retAccess
    %endif
%endfunction %% LibGetAddressOfFirstElement

%% Function: SLibGet1DArrayIndexer =================================================================
%% Abstract:
%%      If the variable (e.g. rtB.idname) is non-scalar 1-D vector, this
%%      function returns
%%            C: "[index_expression]" or
%%          Ada: "(index_expression)"
%%      otherwise this function returns
%%             ""
%%      for the scalar case (when width == 1)
%%
%%      The arguments determine how to index a variable depending on whether it
%%      is a scalar or a vector and whether or not it is in a rolled loop.
%%
%% Arguments:
%%      width - width of variable.
%%      ucv   - user control index variable
%%      lcv   - loop control index variable (when rolling)
%%      offset - offset into the source vector
%%
%% Returns:
%%      ""                 If signal is scalar (width is one)
%%      "[ucv+offset]"     If ucv specified (i.e. ucv not equal to "")
%%      "[lcv]"            If lcv specified (i.e. lcv not equal to "",
%%                         ucv equal to "").
%%      "[offset]"         otherwise (ucv equal to "" and lcv equal to "")
%%
%function SLibGet1DArrayIndexer(width, ucv, lcv, offset) void
    %return SLibGet1DStructFieldIndexer(width, "", ucv, lcv, offset)
%endfunction %% SLibGet1DArrayIndexer

%% TopTester: test/toolbox/simulink/variants/var-general/tStringSupport.m
%% TopTester: test/toolbox/simulink/blocks/CPPCodeGen/tsmlk_core_cpp_coverage.m
%%
%function SLibGetStructFieldIndexExpr(memberStr, ucv, lcv, offset) void
    %if ucv != ""
        %assign offsetStr = ""
        %if TYPE(offset) == "Number"
            %if offset > 0
                %assign offsetStr = "+%<offset>"
            %endif
        %endif
        %return memberStr + "[" + ucv + offsetStr + "]"
    %elseif lcv != ""
        %return memberStr + "[" + lcv + "]"
    %else
        %if TYPE(offset) == "String" && ISEMPTY(offset)
            %return memberStr
        %elseif TYPE(offset) == "Number" && offset == -1
            %return memberStr
        %else
            %% Handle the case of idx being an integer literal or string
            %return memberStr + "[%<offset>]"
        %endif
    %endif
%endfunction %% SLibGetStructFieldIndexExpr

%% Function: SLibGet1DStructFieldIndexer ===========================================================
%% Abstract:
%%      If the variable (e.g. rtB.idname) is non-scalar 1-D vector, this
%%      function returns
%%            C: "memberStr[index_expression]" or
%%             ""
%%      for the scalar case (when width == 1)
%%
%%      The arguments determine how to index a variable depending on whether it
%%      is a scalar or a vector and whether or not it is in a rolled loop.
%%
%% Arguments:
%%      width     - width of variable.
%%      memberStr - additional strucutre member string
%%      ucv       - user control index variable
%%      lcv       - loop control index variable (when rolling)
%%      offset    - offset into the source vector
%% TopTester: test/toolbox/simulink/blocks/lib_Sources/Ground/rtw/tStringSupport.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%%
%function SLibGet1DStructFieldIndexer(width, memberStr, ucv, lcv, offset) void
    %% scalar case
    %if TYPE(width) == "Number"
        %if width == 1
            %return memberStr
        %endif
        %% vector case
        %return SLibGetStructFieldIndexExpr(memberStr, ucv, lcv, offset)
    %else
        %assert TYPE(width) == "String"
        %if width == "1"
            %return memberStr
        %endif
        %return SLibGetStructFieldIndexExpr(memberStr, ucv, lcv, offset)
    %endif
%endfunction %% SLibGet1DStructFieldIndexer

%% Function: SLibGet2DArrayIndexer =================================================================
%% Abstract:
%%   Generate the index string for accessing elements of a
%%   2-D Simulink Coder array.
%%
%%   Note: use LibOptionalMatrixDims to generate
%%         index string for declarations.
%%
%%   Matrices (2-D arrays) are saved within a vector in column-major format.
%%   If the accessed vector (e.g. rtB.idname) is non-scalar, this
%%   function returns
%%          C: "[index_expression]" or
%%        Ada: "(index_expression)"
%%   otherwise this function returns
%%        ""
%%   for the scalar case (when width == nRows*nCols == 1)
%%
%%   The general case for column order indexing is:
%%       [rowIdx + nRows * colIdx]
%%
%%   This function goes further by allowing for the abstraction of
%%   user and loop control variables analogous to SLibGet1DArrayIndexer.
%%
%%   The indexer string consists of a preceding delimiter, the row index
%%   summed with the product of the column index and the number of rows
%%   in the matrix, following by a close delimiter.  For row or column
%%   vectors, the result is the minimum amount of information necessary
%%   to correctly access the matrix.
%%
%%   Note: commonhdrlib.tlc collapses degenerate arrays into the minimum
%%         declaration, i.e., 1x1 => scalar and Nx1 or 1xN => N.  This function
%%         generates an indexer with this knowledge.
%%
%%   Arguments:
%%        offset: Offset to the base of the vector (generally 0).
%%        nRows:  Number of rows in matrix
%%        rucv:   User control variable string for row
%%        rlcv:   Loop control variable string for row
%%        ridx:   Row index (must be an integer)
%%        nCols:  Number of columns in matrix
%%        cucv:   User control variable string for columns
%%        clcv:   Loop control variable string for columns
%%        cidx:   Column index (must be an integer)
%%
%%   Returns:
%%      1) "" if signal is scalar (nRows*nCols equals one).
%%      2) "[offset + rowIdx + nRows * colIdx]" if signal is a matrix
%%           where rowIdx =
%%             rucv   if rcuv != ""
%%             rlcv   if rucv == "" and rlcv != ""
%%             ridx   if rucv == "" and rlcv == ""
%%           where colIdx =
%%             cucv   if ccuv != ""
%%             clcv   if cucv == "" and clcv != ""
%%             cidx   if cucv == "" and clcv == ""
%%
%function SLibGet2DArrayIndexer(offset, nRows, rucv, rlcv, ridx, ...
    nCols, cucv, clcv, cidx) void
    %return SLibGet2dArrayIndexer(offset, nRows, rucv, rlcv, ridx, ...
        nCols, cucv, clcv, cidx, TLC_TRUE)
%endfunction %% SLibGet2DArrayIndexer

%% Function: SLibGet2dArrayIndexer =================================================================
%% Abstract:
%%   Same as SLibGet2DArrayIndexer, with the addition of the flatIndex
%% argument. When this argument is true, a flat index is returned; e.g.,
%% [offset + col+Ncols*row]. If flatIndex is false, then 2-D index is
%% returned; e.g., [row][col]. Note that non-zero offset is not allowed
%% when flatIndex is false.
%%
%% TopTester: test/toolbox/simulink/blocks/sb2sl/tsb2slmdlref2.m
%%
%function SLibGet2dArrayIndexer(offset, nRows, rucv, rlcv, ridx, ...
    nCols, cucv, clcv, cidx, flatIndex) void
    %if !flatIndex
        %assert offset == 0
    %endif

    %if rlcv != "" || clcv != ""
        %assign ::ShowErrorStackTrace = TLC_TRUE
        %<SLibReportErrorWithId("RTW:tlc:SLibGet2DArrayIndexerUsage")>
    %endif

    %if nRows*nCols == 1
        %return ""
    %elseif nRows > 1 && nCols > 1
        %%
        %% actual 2-D matrix case:
        %%   first, generate the row index
        %%
        %assign rowIdxIsConst = 0
        %assign colIdxIsConst = 0

        %if rucv != ""
            %assign rowIdx = rucv
        %elseif rlcv != ""
            %assign rowIdx = rlcv
        %else
            %if ridx > 0
                %assign rowIdx = "%<ridx>"
                %assign rowIdxIsConst = 1  %% possible optimization exists
            %else
                %assign rowIdx = ""
            %endif
        %endif

        %%
        %% now generate the column index
        %%
        %if flatIndex
            %if cucv != ""
                %assign colIdx = "%<nRows>*%<cucv>"
            %elseif clcv != ""
                %assign colIdx = "%<nRows>*%<clcv>"
            %else
                %if cidx > 0
                    %assign colIdx = "%<nRows*cidx>"
                    %assign colIdxIsConst = 1  %% possible optimization exists
                %else
                    %assign colIdx = ""
                %endif
            %endif
        %else
            %if cucv != ""
                %assign colIdx = cucv
            %elseif clcv != ""
                %assign colIdx = clcv
            %else
                %if cidx > 0
                    %assign colIdx = "%<cidx>"
                    %assign colIdxIsConst = 1  %% possible optimization exists
                %else
                    %assign colIdx = ""
                %endif
            %endif
        %endif

        %if !flatIndex
            %if rowIdx == ""
                %assign rowIdx = "0"
            %endif
            %if colIdx == ""
                %assign colIdx = "0"
            %endif
        %endif

        %%
        %% put row and column index calculation text together
        %%
        %if rowIdx != "" && colIdx != ""
            %if flatIndex
                %if rowIdxIsConst == 1 && colIdxIsConst == 1
                    %assign returnVal = ridx+nRows*cidx  %% avoid expression
                %else
                    %assign returnVal = "%<rowIdx> + %<colIdx>"
                %endif
            %else
                %return "[%<ridx>][%<colIdx>]"
            %endif
        %elseif rowIdx != ""
            %assign returnVal = rowIdx
        %elseif colIdx != ""
            %assign returnVal = colIdx
        %else
            %assign returnVal = "0" %% need to access first element
        %endif
    %else
        %if nRows > 1
            %assign ucv = rucv
            %assign lcv = rlcv
            %assign idx = ridx
        %else %% nCols > 1
            %assign ucv = cucv
            %assign lcv = clcv
            %assign idx = cidx
        %endif
        %if ucv != ""
            %assign returnVal = ucv
        %elseif lcv != ""
            %assign returnVal = lcv
        %else
            %assign returnVal = idx
        %endif
    %endif

    %%
    %% Add array offset
    %%
    %if offset != 0
        %if TYPE(returnVal) == "Number"
            %assign returnVal = offset + returnVal
        %else
            %assign returnVal = "%<offset>+%<returnVal>"
        %endif
    %endif
    %assign returnVal = "[%<returnVal>]"

    %return returnVal

%endfunction %% end SLibGet2dArrayIndexer



%% Function: LibComputeNumBlocks ===================================================================
%% Abstract:
%%   LibComputeNumBlocks computes the number of nonvirtual blocks in the
%%   entire model.
%%
%function LibComputeNumBlocks() void
    %assign numBlocks = 0
    %foreach sysIdx = NumSystems
        %assign numBlocks = numBlocks + ::CompiledModel.System[sysIdx].NumBlocks
    %endforeach
    %return numBlocks
%endfunction %% LibComputeNumBlocks


%%adzc

%% Function: SLibGetZCAttributes ===================================================================
%% Abstract:
%%   Convert Simulink Coder zero crossing direction to a SimStruct
%%   representation.
%%
%%   Returns: zcAttribute vector
%%
%function SLibGetZCAttributes(isDisc, needEvent, zcDir) void
    %if (needEvent ==0) && (isDisc ==0)
        %return "(" + zcDir + ")"
    %endif
    %if (needEvent ==0) && (isDisc ==1)
        %return "(0x40|" + zcDir +")"
    %endif
    %if (needEvent ==1) && (isDisc ==0)
        %return "(0x80|" + zcDir +")"
    %endif
    %if (needEvent ==1) && (isDisc ==1)
        %return "(0xc0|" + zcDir +")"
    %endif
%endfunction %%  SLibGetZCAttribute

%% Function: SLibGetZCEvents =======================================================================
%% Abstract:
%%   Convert Simulink Coder zero crossing direction to a SimStruct
%%   representation.
%%
%%   Returns: zcEvent vector
%%
%function SLibGetZCEvents(needsSolverReset, reserved, zcDir) void
    %if (reserved ==0) && (needsSolverReset ==0)
        %return "(" + zcDir + ")"
    %endif
    %if (reserved ==0) && (needsSolverReset ==1)
        %return "(0x40|" + zcDir +")"
    %endif
    %if (reserved ==1) && (needsSolverReset ==0)
        %return "(0x80|" + zcDir +")"
    %endif
    %if (reserved ==1) && (needsSolverReset ==1)
        %return "(0xc0|" + zcDir +")"
    %endif
%endfunction %%  SLibGetZCEvents

%%adzc

%% Function: LibConvertZCDirection =================================================================
%% Abstract:
%%   Convert Simulink Coder zero crossing direction to a SimStruct
%%   representation.
%%
%%   Returns:
%%        "RISING_ZERO_CROSSING"  if direction is "Rising"
%%        "ANY_ZERO_CROSSING"     if direction is "Any"
%%        "FALLING_ZERO_CROSSING" if direction is "Falling"
%%
%function LibConvertZCDirection(direction) void
    %switch direction
      %case "Falling"
      %case "ZC_EVENT_P2N"
      %case "ZC_EVENT_P2Z"
      %case "ZC_EVENT_Z2N"
      %case "ZC_EVENT_ALL_DN"
        %return "FALLING_ZERO_CROSSING"
        %%break
      %case "Any"
      %case "ALL"
        %return "ANY_ZERO_CROSSING"
        %%break
      %case "Rising"
      %case "ZC_EVENT_N2P"
      %case "ZC_EVENT_N2Z"
      %case "ZC_EVENT_Z2P"
      %case "ZC_EVENT_ALL_UP"
        %return "RISING_ZERO_CROSSING"
        %%break
      %default
        %<LibReportFatalError("Invalid zc direction (%<direction>)")>
    %endswitch
%endfunction %%  LibConvertZCDirection


%% Function: LibBaseAddrOfVariable =================================================================
%% Abstract:
%%   Determine the base address of a C variable (prefix with &).
%%
%function LibBaseAddrOfVariable(variable, nrows, ncols) void
    %if nrows < 1 || ncols < 1
        %<LibReportFatalError("Invalid size (%<nrows> by %<ncols>)")>
    %elseif nrows == 1 && ncols == 1      /% scalar %/
        %return "&%<variable>"
    %elseif nrows > 1 && ncols == 1       /% vector %/
        %return "&%<variable>[0]"
    %elseif nrows > 1 && ncols > 1        /% matrix %/
        %return "&%<variable>[0]"
    %endif
%endfunction %% LibBaseAddrOfVariable

%% Function: SLibSafeIDNUM =========================================================================
%% Abstract:
%%   Returns safe id and number for strings and arrays.
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function SLibSafeIDNUM(aIdNumArray, aIdx) void
    %if "String" == TYPE(aIdNumArray)
        %assert 0 == aIdx
        %return IDNUM(aIdNumArray)
    %else
        %assert "Vector" == TYPE(aIdNumArray)
        %return IDNUM(aIdNumArray[aIdx])
    %endif
%endfunction

%% SLibGrBlock =============================================================
%% Abstract:
%%   SLibGrBlock returns the Simulink block for a given
%%   BlockHierarchyMap block index.
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function SLibGrBlock(grBlockIndex) void
    %if grBlockIndex[1] != -1
        %with ::CompiledModel.BlockHierarchyMap
            %if Subsystem[grBlockIndex[0]].MaskType == "Stateflow"
                %assign grBlock = Subsystem[grBlockIndex[0]]
            %else
                %assign grBlock = Subsystem[grBlockIndex[0]].Block[grBlockIndex[1]]
            %endif
        %endwith
        %return grBlock
    %else
        %return ""
    %endif
%endfunction %% SLibGrBlock

%% SLibGrBlockSIDComment ======================================================
%% Abstract:
%%   SLibGrBlockName returns a string with block name and
%%   a compact SID without model name for the input graphical
%%   block record
%function SLibGrBlockSIDComment(grBlock) void
    %if ISFIELD(grBlock, "RLSCommentName")
        %return grBlock.RLSCommentName
    %else
        %return grBlock.Name
    %endif
%endfunction

%% SLibGrBlockSIDCommentByIdx ======================================================
%% Abstract:
%%   SLibGrBlockName returns a string with block name and
%%   a compact SID without model name for the input graphical
%%   block index
%function SLibGrBlockSIDCommentByIdx(grBlockIndex) void
    %if grBlockIndex[1] != -1
        %assign grBlock = SLibGrBlock(grBlockIndex)
        %return SLibGrBlockSIDComment(grBlock)
    %else
        %return "synthesized block"
    %endif
%endfunction

%% SLibGrBlockPath =============================================================
%% Abstract:
%%   SLibGrBlockPath return the full Simulink block path for a given
%%   BlockHierarchyMap block index.
%% TOptester: test/toolbox/simulink/variants/var-inline-vsrc-codegen/tg1375551.m
%%
%function SLibGrBlockPath(grBlockIndex) void
    %if grBlockIndex[1] != -1
        %with ::CompiledModel.BlockHierarchyMap
            %assign grSubSys = Subsystem[grBlockIndex[0]]
            %assign grBlock  = grSubSys.Block[grBlockIndex[1]]
            %if grSubSys.SubsystemBlockIndex[0] == -1 %% root
                %return grSubSys.SLName + "/" + grBlock.SLName
            %elseif grSubSys.MaskType == "Stateflow" && grBlock.SLName == " SFunction "
                %return SLibGrBlockPath(grSubSys.SubsystemBlockIndex)
            %else
                %return SLibGrBlockPath(grSubSys.SubsystemBlockIndex) + ...
                    "/" + grBlock.SLName
            %endif
        %endwith
    %else
        %return "synthesized block"
    %endif
%endfunction %% SLibGrBlockPath

%% SLibGrStateIdx
%% Abstract:
%% SLibGrStateIdx return the record index for a given stateIdx
%%
%function SLibGrStateIdx(grBlockIndex, stateIdx, isContState) void
    %if grBlockIndex[1] == -1 || stateIdx == -1
        %return 0
    %endif
    %with ::CompiledModel.BlockHierarchyMap
        %assign grSubSys = Subsystem[grBlockIndex[0]]
        %assign grBlock  = grSubSys.Block[grBlockIndex[1]]
        %if(grBlock.NumContStates > 0 && isContState)
            %return grBlock.ContState[stateIdx]._idx
        %elseif (grBlock.NumDiscStates > 0)
            %return grBlock.DiscState[stateIdx]._idx
        %endif
    %endwith
%endfunction

%% Function: SLibMangledSubsystemPathName ==========================================================
%% Abstract:
%%   This is an internal function that is called by commonhdrlib.
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-codegen/subsystemBuild/tIVSubsystemBuild_1.m
%%
%function SLibMangledSubsystemPathName(rootName, name) void
    %if SLibGetBlockCommentType() == "BlockSIDComment"
        %return FEVAL("coder.internal.getMangledBlockFullPath", rootName, name)
    %endif
    %% Can't issue a warning yet ... should be using LibGetFormattedBlockPath.
    %if Accelerator
        %% Accelerator encodes names, return its name.
        %return name
    %endif
    %assign sysName = SYSNAME(name)
    %if sysName[0] == ""
        %return name
    %elseif sysName[0] == "Root"
        %return rootName + "/" + sysName[1]
    %else
        %assign idNum = IDNUM(sysName[0])
        %assign subsystemNum = idNum[1] - 1
        %return SLibMangledSubsystemPathName(rootName, LibSubsystemName(subsystemNum) + "/" + sysName[1])
    %endif
%endfunction %% SLibMangledSubsystemPathName

%function SLibAddTrace(prop, value) void
    %return CGMODEL_ACCESS("Trace.addCustomTraceInfo", prop, value)
%endfunction

%function SLibAddTrace2(prop1, value1, prop2, value2) void
    %return CGMODEL_ACCESS("Trace.addCustomTraceInfo2", prop1, value1, prop2, value2)
%endfunction

%function SLibAddCustomTraces(props, values) void
    %return CGMODEL_ACCESS("Trace.addCustomTraceInfos", props, values)
%endfunction

%function SLibTraceBegin(traceMarker) void
    %if !ISEMPTY(traceMarker)
        %return traceMarker
    %endif
%endfunction

%function SLibTraceEnd(traceMarker) void
    %if !ISEMPTY(traceMarker)
        %return "/*@]*/"
    %endif
%endfunction

%% Add block traceability information to inline traceability database
%% Input argument "blockOrComment" can either be block name or comments
%% containing block names
%function SLibAddBlockTrace(blockComment) void
    %return CGMODEL_ACCESS("Trace.addBlockTrace", LibGetModelName(), blockComment)
%endfunction


%% Function: LibBlockFunctionExists ================================================================
%% Abstract:
%%   LibBlockFunctionExists determines if a given block function (method)
%%   exists. For S-function blocks, it first checks to see if the
%%   corresponding TLC file exists and then it checks to see if the
%%   function exists.
%% TopTester: test/toolbox/simulink/variants/var-inline-general/tIVfcnCall_neg.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function LibBlockFunctionExists(block, fcn) void
    %if block.Type == "S-Function"
        %assign sfuncName = block.ParamSettings.FunctionName
        %%
        %assign fileExists = LibBlockSFunctionFileExists(sfuncName)
        %%
        %if fileExists
            %return GENERATE_TYPE_FUNCTION_EXISTS(block, fcn, sfuncName)
        %else
            %return 0
        %endif
    %else
        %return GENERATE_FUNCTION_EXISTS(block, fcn)
    %endif
%endfunction


%% Function: LibIsValidCVariable ===================================================================
%% Abstract:
%%   For a string s, LibIsValidCVariable(s) returns one for alphanumeric
%%   variables starting with [_a-zA-Z] and zero otherwise.
%%
%function LibIsValidCVariable(s) void
    %return FEVAL("iscvar", s)
%endfunction

%% Function: LibAddToFile ==========================================================================
%% Abstract:
%%   Used to create additional source files.
%%   Adds the buffer to the file, if the file is not already "opened", it
%%   will be created and added to.  During code generation, any files created
%%   with this function will be created on disk.
%%   Note: Should also call LibAddToModelSources() or LibCacheIncludes() as
%%   desired to get file into the build process.
%%
%function LibAddToFile(file, buffer) void
    %assign existingFile = 0
    %% scan for existing name
    %foreach idx = ::CompiledModel.NumFiles
        %if ::CompiledModel.Files.Name[idx] == file
            %assign existingFile = 1
            %assign fileIdx = idx
            %break
        %endif
    %endforeach
    %if existingFile
        %% Add buffer to file
        %assign contents    = "::CompiledModel.Files.File[%<fileIdx>]"
        %assign %<contents> = %<contents> + buffer
    %else
        %if ::CompiledModel.NumFiles == 0
            %% Create record to hold all files
            %assign tmpVar = Files { Name []; File [] }
            %assign ::CompiledModel = ::CompiledModel + Files
            %undef Files
            %undef tmpVar
        %endif
        %% Start file and buffer
        %assign ::CompiledModel.Files.Name = ::CompiledModel.Files.Name + file
        %assign ::CompiledModel.Files.File = ::CompiledModel.Files.File + buffer
        %assign ::CompiledModel.NumFiles   = ::CompiledModel.NumFiles   + 1
    %endif
%endfunction


%% Function: SLibCrudeParseSafeExpression ==========================================================
%% TopTester: test/toolbox/simulink/blocks/lib_Sources/Ground/rtw/tStringSupport.m
%%
%function SLibCrudeParseSafeExpression(blockName, in, checkSideEffects) void

    %assign eRetValNeedsParen = 1
    %assign eRetValHasSideEffect = 2
    %assign eRetValMismatchedDelimiters = 4
    %%
    %assert TYPE(in) == "String"
    %%
    %assign retVal = NEEDS_PAREN(in)
    %%
    %if checkSideEffects && (retVal & eRetValHasSideEffect)

        %<LibReportFatalError("Block: %<blockName>.  Expression '%<in>' has a side effect.")>

    %endif
    %%
    %if retVal & eRetValMismatchedDelimiters

        %<LibReportFatalError("Block: %<blockName>.  Expression '%<in>' has a [] or () mismatch.")>

    %endif
    %%
    %if !(retVal & eRetValNeedsParen)
        %%
        %return in
    %else
        %<LibReportWarning("Block: %<blockName>.  Expression '%<in>' does not protect precedence of operators with parentheses.")>
        %return "(%<in>)"
    %endif
    %%
%endfunction %% SLibCrudeParseSafeExpression(in)


%% Function: SLibProcessSafeExpression =============================================================
%%
%%   This function converts negative numeric inputs into
%%   precedence immune expressions.
%%
%%   Input
%%       Type must be a string or a non-complex numeric type.
%%
%%   Output
%%       If the input is numeric and its value is negative, then
%%         the output is a string that wraps the input value in
%%         parentheses to make it a "precedence immune expression"
%%       Otherwise
%%         the output is identical to the input.
%% TopTester: test/toolbox/simulink/blocks/lib_Sources/Ground/rtw/tStringSupport.m
%%
%function SLibProcessSafeExpression(blockName, in, checkSideEffects) void
    %%
    %switch TYPE(in)
        %%
      %case "String"
        %%
        %assign in = SLibCrudeParseSafeExpression(blockName, in, checkSideEffects)
        %%
        %% Fall Thru is Desired Here
        %%
      %case "Unsigned"
        %%
        %return in
        %%
        %%break
        %%
      %case "Real"
      %case "Number"
      %case "Real32"
      %case "Real16"
        %%
        %if in >= 0
            %%
            %return in
        %else
            %return "(%<in>)"
        %endif
        %%
        %%break
        %%
      %default
        %<LibReportFatalError("Block: %<blockName>.  Input required to be precedence immune expression, but had unsupported type.")>
    %endswitch
    %%
%endfunction %% SLibProcessSafeExpression

%% Function: SLibCreateSafeExpression ==============================================================
%%
%%   This function attempts to create safe expression that is immune to
%%   operator precedence interaction with the context of this expression
%%
%%   Input
%%       Type must be a string or a non-complex numeric type.
%%
%%   Output
%%       Original expression or parethesis protected expression
%%
%function SLibCreateSafeExpression(in) void
    %return SLibCG_SE(in)
%endfunction %% SLibCreateSafeExpression

%% Function: LibCallEventSystem ====================================================================
%% Abstract:
%%     This function is used by blocks that post events to call the subsystem
%%     for an event
%%
%function LibCallEventSystem(block, eventIdx) Output
    %assign sysIdx      = block.ModelEventSystemsToCall[eventIdx*2]
    %assign callSiteIdx = block.ModelEventSystemsToCall[eventIdx*2 + 1]
    %if sysIdx >= 0
        %assign ss = ::CompiledModel.System[sysIdx]
        %if !LibSystemFcnIsEmpty(ss, "Output")
            %<LibGenSystemFcnCall(ss, "Output", callSiteIdx)>\
        %endif
    %endif
%endfunction

%%TopTester: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tmg1317695_VC1.m
%%
%function LibAddToReusableLibModelSources(newFile) void
    %assign duplicate = 0
    %% scan for duplicates
    %foreach idx = ::CompiledModel.NumReusableLibSources
        %if (::CompiledModel.ReusableLibSources[idx] == "%<newFile>")
            %assign duplicate = 1
            %break
        %endif
    %endforeach
    %if (!duplicate)
        %assign ::CompiledModel.ReusableLibSources = ::CompiledModel.ReusableLibSources + "%<newFile>"
        %assign ::CompiledModel.NumReusableLibSources = ::CompiledModel.NumReusableLibSources + 1
    %endif
    %return (duplicate)
%endfunction %% LibAddToReusableLibModelSources

%% Function: SLibAddToStaticSources ================================================================
%% Abstract:
%%    To notify the Simulink Coder build process that it must build with
%% the specified static source file.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%%
%function SLibAddToStaticSources(newFile) void
    %assign duplicate = CGMODEL_ACCESS("CGModel.AddToStaticSources", newFile)
    %return duplicate
%endfunction %% SLibAddToStaticSources

%% Function: SLibAddToStaticHeaders ================================================================
%% Abstract:
%%    To notify the Simulink Coder build process that it must build with
%%    the specified static header file.
%%
%function SLibAddToStaticHeaders(newFile) void
    %assign duplicate = CGMODEL_ACCESS("CGModel.AddToStaticHeaders", newFile)
%endfunction %% SLibAddToStaticHeaders

%% Function: SLibComparePriority ===================================================================
%% Abstract:
%%  Compare priority of tid1 and tid2.
%%  -1: tid1 or tid2 is not assigned a priority,
%%      comparing failed.
%%   0: tid1 has priority as tid2, this only
%%      happens if tid1==tid2.
%%   1: tid1 has higher priority than tid2
%%   2: tid1 has lower priority than tid2
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tmg1281133.m
%% TopTester: test/toolbox/simulink/blocks/lib_Discrete/DiscreteTimeIntegrator/rtw/tNumerics_DIntCleanupRTWSIMLoop2.m
%%
%function SLibComparePriority(tid1, tid2)

    %assert TYPE(tid1) == "Number" && TYPE(tid2) == "Number"

    %if tid1 == -2 || tid2 == -2
        %% either of the tids is constant,
        %return 0
    %endif

    %if tid1 < 0 || tid2 < 0 || ...
        !ISFIELD(::CompiledModel.SampleTime[tid1], "Priority") || ...
        !ISFIELD(::CompiledModel.SampleTime[tid2], "Priority")

        %assign retVal = -1
    %else
        %assign priority1 = ::CompiledModel.SampleTime[tid1].Priority
        %assign priority2 = ::CompiledModel.SampleTime[tid2].Priority

        %if priority1 > priority2
            %assign retVal = ::CompiledModel.PositivePriority == "yes" ? 1 : 2
        %elseif priority1 < priority2
            %assign retVal = ::CompiledModel.PositivePriority == "yes" ? 2 : 1
        %else
            %assign retVal = 0
        %endif
    %endif

    %return retVal
%endfunction %% SLibComparePriority

%% Function: SLibIsAsyncTaskOnlyModel ==============================================================
%%
%%     Return true if the model has only Async task block.
%% Code for async task is empty. In this case don't need register
%% rtOneStep function.
%%
%%    The all the followings must be true if a model is an
%% AsyncTaskOnly model:
%%    1. Model is a single sync rate model.
%%    2. No async task need absolute time, or
%%       Async task that need absolute time manage own
%%       absolute time.
%%    3. Blocks in root subsystem must be
%%         fcn-call subsystem block, or
%%         block is an async top caller, or
%%         blocks output code is white space
%%    4. Not all async tasks are init/term/reset/parameterchange tasks.
%%
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/simulink/variants/var-export-fcns/tExportFcnsWithInlineVariants.m
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc/tVariantSource3.m
%%
%function SLibIsAsyncTaskOnlyModel()
    %if ISFIELD(::CompiledModel, "IsAsyncTaskOnlyModel")
        %return IsAsyncTaskOnlyModel
    %endif
    %assign retVal = TLC_TRUE %% assume
    %assign numModelWideEvents = 0
    %if MatFileLogging
        %assign retVal = TLC_FALSE
    %elseif  LibGetNumAsyncTasks() > 0 && ...
        NumRuntimeExportedRates <= 1
        %foreach tid = ::CompiledModel.NumSampleTimes

            %% Check each non-union Asynchronous sample time
            %if LibAsynchronousTriggeredTID(tid) && ...
                !SLibUnionSampletimeTID(tid)

                %if SLibInitResetTermEventTID(tid) || SLibParameterChangeEventTID(tid)
                    %assign numModelWideEvents = numModelWideEvents + 1
                    %continue
                %endif

                %if SampleTime[tid].NeedAbsoluteTime == "yes" && ...
                    SampleTime[tid].TimeSource == "BaseRate" && ...
                    SLibGetUsingTimerServiceLevel() == 0
                    %assign retVal = TLC_FALSE
                %endif
            %endif
        %endforeach
    %else
        %assign retVal = TLC_FALSE
    %endif

    %% Init/Reset/Term are not considered as async here.
    %if LibGetNumAsyncTasks() == numModelWideEvents
        %assign retVal = TLC_FALSE
    %endif

    %if retVal
        %assign rootSystem = System[NumSystems-1]
        %foreach tid = NumRuntimeExportedRates
            %if !LibSystemFcnIsEmptyHelper(rootSystem,"Output",tid)
                %assign retVal = TLC_FALSE
                %break
            %endif
        %endforeach
    %endif

    %addtorecord ::CompiledModel IsAsyncTaskOnlyModel retVal
    %return retVal
%endfunction

%% Function: BlkHasPeriodicAndAysncTid =============================================================
%% Abstract:
%%    Return true if block has perodic sample rate and
%% asynchronous sample time.
%%
%function BlkHasPeriodicAndAysncTid(block)
    %assign hasAsyncTid    = TLC_FALSE
    %assign hasPeriodicTid = TLC_FALSE
    %with block
        %if TYPE(block.TID) == "Vector"
            %assign TIDlen = SIZE(TID,1)
            %foreach tidIdx = TIDlen
                %if LibAsynchronousTriggeredTID(TID[tidIdx])
                    %assign hasAsyncTid = TLC_TRUE
                %else
                    %assign hasPeriodicTid = TLC_TRUE
                %endif
            %endforeach
        %endif
    %endwith
    %return hasAsyncTid && hasPeriodicTid
%endfunction


%% Function: GetSystemNameForComments ==============================================================
%%   Return the name of the system to be used in the comments
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tmg1317695_VC1.m
%%
%function GetSystemNameForComments(sys) void
    %if IsModelReferenceBaseSys(sys)
        %assign sysInfo = "model '%<::CompiledModel.Name>'"
    %elseif  LibSystemIsReusedLibraryFcn(sys) && ISFIELD(sys, "RLSCommentName")
        %assign sysInfo =  "system %<sys.RLSCommentName>"
    %else
        %if SLibGetBlockCommentType() == "BlockSIDComment"
            %assign sysInfo = "system %<sys.SIDCommentName>"
        %else
            %assign sysInfo =  "system '%<sys.Name>'"
            %if sys.Synthesized && ISFIELD(sys,"OriginatorBlock")
                %assign sysInfo =  "system '%<sys.OriginatorBlock>'"
            %endif
        %endif
    %endif
    %return sysInfo
%endfunction


%% Function: GetSystemNameForStartOfComments =======================================================
%%   Return the name of the system to be used at the start of comments
%%
%function GetSystemNameForStartOfComments(sys) void
    %if IsModelReferenceBaseSys(sys)
        %assign sysInfo = "Model '%<::CompiledModel.Name>'"
    %else
        %if SLibGetBlockCommentType() == "BlockPathComment"
            %assign sysInfo = "System '%<sys.Name>'"
        %else
            %assign sysInfo = "System %<sys.SIDCommentName>"
        %endif
    %endif
    %return sysInfo
%endfunction

%function GetPointerField(fieldName)
    %if !::UseMemberFunctionsForRTM
        %return "&%<RTMGet(fieldName)>"
    %endif
    %% Some RTM macros are implemented as "&" +
    %% a real field, if we are making member methods
    %% we need to capture that relationship so we can make
    %% a pointer member function
    %if(!EXISTS(::RTMPointerFields))
        %createrecord ::RTMPointerFields {}
    %endif
    %if !ISFIELD(::RTMPointerFields, fieldName)
        %addtorecord ::RTMPointerFields %<fieldName> TLC_TRUE
    %endif
    %assign ret =  RTMGet(fieldName)
    %assign ret = STRREP(ret, "()","")
    %return ret + "Ptr()"
%endfunction


%% Function: GetRTMErrorStatusPtr ==================================================================
%% Return pointer of RTModel ErrorStatus.
%% In some cases this pointer need be volatile to provent compiler from
%% optimizing out unused pointer, customer can't access the field anymore
%% (see RTMErrorStatusNeedVolatile). When the point is accessed in generate code,
%% we don't need add volatile anymore. Volatile may cause compiler warning
%% becuase the customer of the errorStatus may not expect volatile.
%%
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants10.m
%%
%function GetRTMErrorStatusPtr() void
    %if ::UseMemberFunctionsForRTM
        %assign lhs = GetSimStructExpr(FcnInferredSystemAndAccessRTMArgDef(), ::tSimStruct)
        %assign esptr = "%<lhs>->getErrorStatusPtr()"
        %<GetPointerField("ErrorStatus")>
    %else
        %assign esptr = "(&%<RTMGetErrStat()>)"
    %endif
    %if RTMErrorStatusNeedVolatile()
        %assign rtRecs = RTMGetRTModelRecShell()
        %assign recordName = "ErrorStatusFlag"
        %assign theRec = rtRecs.%<recordName>
        %assign theRec.StorageType = "POINTER"
        %assign ::ErrorStatusPtrAccess = 1
    %endif
    %return esptr
%endfunction

%% Function: CorCPPForBuildLogsandComment ==========================================================
%%   Return the generated language to be displayed by build logs and comments
%%
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%%
%function CorCPPForBuildLogsandComments() void
    %if GenCPP
        %assign langForLogsandComments = "C++"
    %else
        %assign langForLogsandComments = "C"
    %endif
    %return langForLogsandComments
%endfunction

%% Function: ExternorExternC =======================================================================
%%   Return the appropriate extern declartions depending on target language.
%%
%function ExternorExternC () void
    %if ::LangFileExt == "cpp"
        %assign prefix = "extern \"C\""
    %else
        %assign prefix = LibExternInFcnDecls()
    %endif

    %return prefix
%endfunction

%% Function: SLibSetSystemMap ======================================================================
%% Abstract:
%%   Save system map to attic. Called in commonentry.tlc.

%function SLibSetSystemMap() void
    %if !ISFIELD(::CompiledModel,"Subsystem") || ...
        !ISFIELD(::CompiledModel,"NumSubsystems")
        %return
    %endif
    %assign systemMap = "{"
    %foreach sysIdx = NumSubsystems
        %assign systemMap = systemMap + ...
            "'%<LibUnmangledPathName(LibSubsystemName(sysIdx))>',"
    %endforeach
    %assign systemMap = systemMap + "}"
    %matlab rtwprivate("rtwattic", "setSystemMap", systemMap)
%endfunction

%% Function: SLibGetModelIsLinearlyImplicit ========================================================
%% Abstract:
%%   Return the corrected ModelIsLinearlyImplicit for the model.
%%
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%%
%function SLibGetModelIsLinearlyImplicit() void
    %assign isLinearlyImplicit = ::CompiledModel.ModelIsLinearlyImplicit
    %if (isLinearlyImplicit == "yes") && SLibIsDeploymentDiagramWithTopSolver()
        %foreach tgIdx = ::CompiledModel.NumEventHandlers
            %assign tg = ::CompiledModel.EventHandler[tgIdx]
            %% Only periodic tasks can have continuous states
            %if !ISEQUAL(tg.Periodicity.Type, "PeriodicTrigger")
                %continue
            %endif
            %foreach tIdx = tg.NumTasks
                %assign task = tg.Task[tIdx]
                %if (SLibDeploymentIsSynthesizedTask(tgIdx, tIdx) && (task.NumContStates > 0))
                    %assign isLinearlyImplicit = task.IsLinearlyImplicit
                %endif
            %endforeach
        %endforeach
    %endif
    %return isLinearlyImplicit
%endfunction

%% Function: SLibMassMatrixType ====================================================================
%% Abstract:
%%   Convert MassMatrixType (enum) to a mnemonic.
%%
%function SLibMassMatrixType(massMatrixTypeId) void
    %assign retVal = "none"
    %if (::CompiledModel.ModelIsLinearlyImplicit == "yes")
        %switch massMatrixTypeId
          %case 0
            %assign retVal = "none"
            %break
          %case 1
            %assign retVal = "constant"
            %break
          %case 2
            %assign retVal = "timedep"
            %break
          %case 3
            %assign retVal = "statedep"
            %break
        %endswitch
    %endif  %% ModelIsLinearlyImplicit
    %return retVal
%endfunction

%% Function: SLibMassMatrixType ====================================================================
%% Abstract:
%%   Return the MassMatrixType (mnemonic) for the model.
%%
%function SLibModelMassMatrixType() void
    %assert (::CompiledModel.ModelIsLinearlyImplicit == "yes")
    %return SLibMassMatrixType(::CompiledModel.ModelMassMatrixType)
%endfunction

%% Function: SLibGetModelHasProjections ============================================================
%% Abstract:
%%   Return the corrected ModelHasProjection for the model.
%% TopTester: test/toolbox/simulink/blocks/tconcat.m
%%
%function SLibGetModelHasProjections() void
    %assign hasProjections = ::CompiledModel.ModelHasProjections
    %if (hasProjections == "yes") && SLibIsDeploymentDiagramWithTopSolver()
        %foreach tgIdx = ::CompiledModel.NumEventHandlers
            %assign tg = ::CompiledModel.EventHandler[tgIdx]
            %% Only periodic tasks can have continuous states
            %if !ISEQUAL(tg.Periodicity.Type, "PeriodicTrigger")
                %continue
            %endif
            %foreach tIdx = tg.NumTasks
                %assign task = tg.Task[tIdx]
                %if (SLibDeploymentIsSynthesizedTask(tgIdx, tIdx) && (task.NumContStates > 0))
                    %assign hasProjections = task.HasProjections
                %endif
            %endforeach
        %endforeach
    %endif
    %return hasProjections
%endfunction

%function SLibNonEmptyModel() void
    %assign rootSystem = ::CompiledModel.System[::CompiledModel.NumSystems-1]
    %return rootSystem.NumBlocks > 0
%endfunction

%function SLibGetNumUnionSampleTimes()
    %return ::CompiledModel.NumUnionSampleTimes
%endfunction

%function SLibSetNeedRateInteraction(tid1, tid2) void
    %assert tid1 > tid2
    %assign ::CompiledModel.MatrixOfRequireRateInteraction[tid2][tid1] = TLC_TRUE
    %assign ::CompiledModel.RequireRateInteraction = TLC_TRUE
    %% if not SuppressMultiTaskScheduler, SpecialSampleHit is calculated from SampleHit flags
    %if !SuppressMultiTaskScheduler
        %assign ::CompiledModel.RequireMultiRateSampleHits = 1
    %endif
%endfunction

%function SLibGetNeedRateInteraction(tid1, tid2) void
    %return (::CompiledModel.MatrixOfRequireRateInteraction[tid1][tid2] == TLC_TRUE)
%endfunction

%% Function: LibIsRapidAccelTargetLangCPP
%% Abstract:
%% This function returns 1, if the target language for rapid accel
%% code generation is C++. 0 otherwise.
%%
%function LibIsRapidAccelTargetLangCPP() void
    %return ISFIELD(::CompiledModel.ConfigSet, "TargetLang") && ...
        (::CompiledModel.ConfigSet.TargetLang == "C++") && ...
        (::isRAccel)
%endfunction

%% Function: InsertExternCOpen
%% Abstract: add extern "C" for export to c++
%%
%function InsertExternCOpen() void
    %return "\#ifdef __cplusplus \n extern \"C\" { \n \#endif"
%endfunction

%% Function: InsertExternCClose
%% Abstract: add closing of extern "C" for export to c++
%%
%function InsertExternCClose() void
    %return "\#ifdef __cplusplus \n  } \n \#endif"
%endfunction

%% Function: LibStaticInFcnDecls ===================================================================
%% Abstract:
%%   Returns "static " if the Code style "Preserve static in function
%%   declarations is on and we are not generating code in shared location
%%   and the model uses "Compact" file packaging format, "" otherwise
%%
%function LibStaticInFcnDecls() void
    %if (CGMODEL_ACCESS("CGModel.AddStaticKeywordToFcn"))  && ...
        SLibIsCompactFileFormat() && ...
        (::CompiledModel.GenUtilsSrcInSharedLocation == 0)
        %return "static "
    %else
        %return ""
    %endif
%endfunction

%% Function: LibStaticOrExternInFcnDecls ===========================================================
%% Abstract:
%%   Returns "static " or "extern " keywords based on certain conditions
%function LibStaticOrExternInFcnDecls() void
    %if !ISEMPTY(LibStaticInFcnDecls())
        %return "static "
    %else
        %return LibExternInFcnDecls()
    %endif
%endfunction

%% Utility Function: SLibIsPragmaOnDecls ===========================================================
%% Abstract:
%%   Returns true to indicate pragmas are applied to data and function declarations
%%   Define and set global variable PragamOnDecls to TLC_FALSE to turn it off
%%
%function SLibIsPragmaOnDecls() void
    %if EXISTS(::_PragmaOnDecls) == 0
        %return TLC_TRUE
    %elseif ::_PragmaOnDecls > 0
        %return TLC_TRUE
    %else
        %return TLC_FALSE
    %endif
%endfunction

%% Utility Function: SLibGetMemSecCategoryForUtilityFcn() ===========
%% Abstract:
%%   Return proper memory section function category based upon shared or not
%%
%function SLibGetMemSecCategoryForUtilityFcn() void
    %assign msfcn = "MemSecFuncSharedUtil"
    %return msfcn
%endfunction


%function LibUpdateBlockCStateAbsoluteTolerance(block, system) Output
    %assign ncStates  = ContStates[0]
    %if EXISTS(AbsoluteTolerance)
        %assign rollRegions = [0:%<ncStates-1>]
        %assign rollVars = ["xAbsTol", "<param>/AbsoluteTolerance"]
        %roll sigIdx = rollRegions, lcv = RollThreshold, block, "Roller", rollVars
            %assign absTol = LibBlockParameter(AbsoluteTolerance, "", lcv, sigIdx)
            %<LibBlockContStateAbsoluteTolerance("", lcv, sigIdx)> = %<absTol>;
        %endroll
    %endif
%endfunction

%%namespace utility functions
%function SLibSystemNeedsNamespace(system)
    %assign needNamespace = TLC_FALSE

    %if ::GenerateClassInterface && EXISTS(::NamespaceName) && (::NamespaceName != "")
        %if (system.SystemNamespaceFlag == 0)
            %assign needNamespace = TLC_TRUE
        %endif
    %endif
    %return needNamespace
%endfunction

%function SLibEmitNamespaceStartForSystem(system)
    %assign namespaceStr = CGMODEL_ACCESS("CGModel.getClassNamespaceDeclStr")
    %assign system.SystemNamespaceFlag = 1

    %return namespaceStr
%endfunction

%function SLibEmitNamespaceCloseForSystem(system)
    %assign closeStr = ""
    %% No need to check if using CPP Encap since
    %% SystemNamespaceFlag will never be 1 if it is not
    %if system.SystemNamespaceFlag == 1
        %assign closeStr = CGMODEL_ACCESS("CGModel.getClassNamespaceDeclCloseStr")
        %assign system.SystemNamespaceFlag = 0
    %endif

    %return closeStr
%endfunction

%% Function: SLibIsCPP11SingleThreadMainEnabled ====================================================
%% Abstract:
%%   This will return true if using C++11SingleThreadMain
%function SLibIsCPP11SingleThreadMainEnabled() void
    %return CGMODEL_ACCESS("CGModel.IsCPP11SingleThreadMain")
%endfunction

%% Function: SLibIsCPP11ConcurrentMainEnabled ======================================================
%% Abstract:
%%   This will return true if using C++11ConcurrentMain
%function SLibIsCPP11ConcurrentMainEnabled() void
    %return CGMODEL_ACCESS("CGModel.IsCPP11ConcurrentMain")
%endfunction

%% Function: SLibGetSDPPlatformType ================================================================
%% Abstract:
%%   Return SDP platform type
%function SLibGetSDPPlatformType() void
    %return CGMODEL_ACCESS("CGModel.getSDPPlatformType")
%endfunction

%% Function: SLibGetSDPDeploymentType ==============================================================
%% Abstract:
%%   Return SDP deployment type
%function SLibGetSDPDeploymentType() void
    %return CGMODEL_ACCESS("CGModel.getSDPDeploymentType")
%endfunction

%% Function: SLibIsSchedulingServiceOn =============================================================
%% Abstract:
%%   Return true if using SchedulingService
%function SLibIsSchedulingServiceOn() void
    %return CGMODEL_ACCESS("CGModel.SchedulingService")
%endfunction

%% Function: SLibIsDataTransferServiceOn ===========================================================
%% Abstract:
%%   This will return true if using DataTransferService
%function SLibIsDataTransferServiceOn() void
    %return CGMODEL_ACCESS("CGModel.DataTransferService") && (SLibGetSDPDeploymentType() == "Component")
%endfunction

%% Function: SLibNeedWrapperStepFcn ================================================================
%% Abstract:
%%   Does wrapper step function need to be generated?
%%
%%   Return Value:
%%      0: Not generated
%%      1: Generated in <model>.c/cpp
%%      2: Generated in rtmodel.c/cpp
%%      3: Generated in main
%function SLibNeedWrapperStepFcn() void
    %if (SLibGetSDPPlatformType() == "FUNCTION_PLATFORM") || ...
        SLibIsExportFcnDiagram() || SLibAdaptiveAutosarActive() || ...
        (GenerateClassInterface && !CombineOutputUpdateFcns)
        %% These cases do not need to generate wrapper
        %return 0
    %endif

    %%case 1: MDS
    %if LibIsDeploymentDiagram()
        %if GenerateGRTWrapper || ...
            !ISEQUAL(::CompiledModel.ConfigSet.HardwareBoard, "None")
            %% Generate switchyard wrapper in model.c/.cpp
            %% when using classic call interface
            %return 1
        %else
            %% Generate wrapper in main if GenerateSampleERTMain is on
            %if SLibIsERTTarget() && !GenerateSampleERTMain
                %return 0
            %else
                %return 3
            %endif
        %endif
    %endif
    %%case 2: rateBased multirate
    %assign retVal = 0
    %assign rootSystem = System[NumSystems-1]
    %if SLibIsMultiRateAndPeriodicRateGrouping(rootSystem) && ...
        !IsModelReferenceTarget()
        %if GenerateGRTWrapper
            %% Generate switchyard in model.c/cpp
            %assign retVal = 1
        %elseif SLibGenerateNativeThreads()
            %if ISEQUAL(::CompiledModel.ConfigSet.HardwareBoard, "None")
                %% Generate switchyard in main
                %assign retVal = 3
            %else
                %% Generate switchyard in model.c/cpp
                %assign retVal = 1
            %endif
        %elseif !(GenerateSampleERTMain || RateBasedStepFcn)
            %if ISEQUAL(::CompiledModel.ConfigSet.HardwareBoard, "None")
                %% Generate switchyard in rtmodel.c/cpp
                %assign retVal = 2
            %else
                %% Generate switchyard in model.c/cpp
                %assign retVal = 1
            %endif
        %endif
    %endif

    %return retVal
%endfunction

%% Function: LibHasClientsOrServers ================================================================
%% Abstract:
%%    Return true if we are generating code for a model that contains
%%    clients or servers
%%
%function LibHasClientsOrServers() void
    %return ::CompiledModel.HasClientsOrServers == "yes"
%endfunction

%% Function: SLibHasSimulinkFunctionRootIO =========================================================
%% Abstract:
%%    Return true if we are generating code for a model that contains
%%    simulink functions connected directly to root I/O
%%
%% TopTester: test/toolbox/rtw/targets/ert/model2model/pir2engine/tPir2EngineLutGecks04.m
%%
%function SLibHasSimulinkFunctionRootIO() void
    %if IsModelReferenceTarget()
        %assign baseSystemIdx = GetBaseSystemIdx()
        %assign intf = ::CompiledModel.System[baseSystemIdx].Interface
        %foreach idx = intf.NumCanonicalInputArgDefs
            %assign argdef = intf.CanonicalInputArgDef[idx]
            %if argdef.ConnectedToSimulinkFunction == "yes"
                %return TLC_TRUE
            %endif
        %endforeach
        %foreach idx = intf.NumCanonicalOutputArgDefs
            %assign argdef = intf.CanonicalOutputArgDef[idx]
            %if argdef.ConnectedToSimulinkFunction == "yes"
                %return TLC_TRUE
            %endif
        %endforeach
    %endif
    %return TLC_FALSE
%endfunction

%% Function: SLibCacheModelArgsInStart =============================================================
%% Abstract:
%%   Returns true if global model reference arguments should be cached in the
%%   start function.
%%
%function SLibCacheModelArgsInStart(system) void
    %return IsModelReferenceBaseSys(system) && ...
        (system.Interface.CacheCanonicalPrmInStart ...
        || SLibHasSimulinkFunctionRootIO())
%endfunction %% SLibCacheModelArgsInStart

%% Function: SLibEndIfVariantConditionForm =========================================================
%% Abstract:
%%   Return endif or ""
%%
%function SLibEndIfVariantConditionForm(condition) void
    %if ISEMPTY(condition)
        %return ""
    %else
        %return "\n #endif \n"
    %endif
%endfunction

%% Function: SLibIfVariantConditionForm ============================================================
%% Abstract:
%%   Return if condition or ""
%%
%function SLibIfVariantConditionForm(condition) void
    %if ISEMPTY(condition)
        %return ""
    %else
        %return "\n #if %<condition> \n"
    %endif
%endfunction

%% Function: SLibMakeSingleLine ====================================================================
%% Abstract:
%%   Ensure a statement is output on its own line
%%
%function SLibMakeSingleLine(stmt)
    %return "\n" + stmt + "\n"
%endfunction


%% Function: SLibVarGroupHasElementDefine ==========================================================
%% Abstract:
%%   Define the has element preprocessor define for this vargroup
%%
%function SLibVarGroupHasElementDefine(varGroup)
    %return SLibMakeSingleLine("#define " + varGroup.HasElement)
%endfunction


%% Function: SLibWrapBody ==========================================================================
%% Abstract:
%%   Wrap a body with some preprocessor conditions
%%
%function SLibWrapBody(ifCond, body, endIfCond) void
    %if WHITE_SPACE(ifCond)
        %return body
    %endif
    %return SLibMakeSingleLine(ifCond) + body + SLibMakeSingleLine(endIfCond)
%endfunction


%% Function: SLibWrapHasElement ====================================================================
%% Abstract:
%%   Wrap a body with some preprocessor conditions
%%
%function SLibWrapDefinedHasElement(varGroup, body)
    %assign hasElementName = varGroup.HasElement
    %return SLibWrapBody("#ifdef " + hasElementName, body, "#endif /* %<hasElementName> */")
%endfunction


%% Function: SLibWrapDoesNotHaveElement ============================================================
%% Abstract:
%%   Wrap a body with some preprocessor conditions
%%
%function SLibWrapUndefinedHasElement(varGroup, body)
    %assign hasElementName = varGroup.HasElement
    %return SLibWrapBody("#ifndef " + hasElementName, body, "#endif /* %<hasElementName> undefined */")
%endfunction

%function IsExtOutAndHasVarCond(Element) void
    %if !ISEMPTY(Element) && ISFIELD(Element,"RecordType") && (Element.RecordType == "ExternalOutput") ...
        && !ISFIELD(Element,"Inactive") && ISFIELD(VariantConditions, "CGVCEList") ...
        && ISFIELD(Element, "LocalCGVCEIdx") && (Element.LocalCGVCEIdx != -1)
        %return TLC_TRUE
    %endif
    %return TLC_FALSE
%endfunction


%% Function: SLibIfVariantCondition ================================================================
%% Abstract:
%%   Return the opening preprocessor condition
%%   uses the compiled version not the graphical one!
%%   variantcondition = LocalInlineVariantsPreprocessorCondition
%%
%function SLibIfVariantCondition(Element) void
    %if SLibHasVariantCondition(Element)
        %return SLibIfVariantConditionForm(Element.VariantCondition)
    %elseif IsExtOutAndHasVarCond(Element)
        %assign cgvceList = ::CompiledModel.VariantConditions.CGVCEList
        %assign varCond = cgvceList[Element.LocalCGVCEIdx]
        %return SLibIfVariantConditionForm(varCond)
    %else
        %return ""
    %endif
%endfunction


%% Function: SLibVariantCondition ==================================================================
%% Abstract:
%%   Return the Variant Condition without preprocessor
%%
%function SLibVariantCondition(Element) void
    %if SLibHasVariantCondition(Element)
        %return Element.VariantCondition
    %elseif IsExtOutAndHasVarCond(Element)
        %assign cgvceList = ::CompiledModel.VariantConditions.CGVCEList
        %return cgvceList[Element.LocalCGVCEIdx]
    %else
        %return ""
    %endif
%endfunction

%% Function: SLibIfNetVariantConditionForData ======================================================
%% Abstract:
%%   Return the opening preprocessor condition
%%   uses the compiled version not the graphical one!
%%
%function SLibIfNetVariantConditionForData(Element) void
    %if SLibHasNetVariantConditionForData(Element)
        %return SLibIfVariantConditionForm(Element.NetVariantConditionForData)
    %else
        %return ""
    %endif
%endfunction

%% Function: SLibNetVariantConditionForData ========================================================
%% Abstract:
%%   Return the Variant Condition without preprocessor
%%
%function SLibNetVariantConditionForData(Element) void
    %if SLibHasNetVariantConditionForData(Element)
        %return Element.NetVariantConditionForData
    %else
        %return ""
    %endif
%endfunction

%% Function: SLibEndIfVariantCondition =============================================================
%% Abstract:
%%   Return the closing preprocessor condition
%%   use the compiled version not the graphical one!
%%   variantcondition = LocalInlineVariantsPreprocessorCondition
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function SLibEndIfVariantCondition(Element) void
    %if SLibHasVariantCondition(Element)
        %return SLibEndIfVariantConditionForm(Element.VariantCondition)
    %elseif IsExtOutAndHasVarCond(Element)
        %assign cgvceList = ::CompiledModel.VariantConditions.CGVCEList
        %assign varCond = cgvceList[Element.LocalCGVCEIdx]
        %return SLibEndIfVariantConditionForm(varCond)
    %else
        %return ""
    %endif
%endfunction

%% Function: SLibEndIfNetVariantConditionForData ===================================================
%% Abstract:
%%   Return the closing preprocessor condition
%%   use the compiled version not the graphical one!
%%
%function SLibEndIfNetVariantConditionForData(Element) void
    %if SLibHasNetVariantConditionForData(Element)
        %return SLibEndIfVariantConditionForm(Element.NetVariantConditionForData)
    %else
        %return ""
    %endif
%endfunction


%% Function: SLibWrapVariantCondition ==============================================================
%% Abstract:
%%   Wrap a body with a variant condition
%%
%function SLibWrapVariantCondition(element, body) void
    %assign ifCond = SLibIfVariantCondition(element)
    %assign endIfCond = SLibEndIfVariantCondition(element)
    %return SLibWrapBody(ifCond, body, endIfCond)
%endfunction

%% Function: SLibGetVPrmIfCond()
%% Abstract:
%%   Get the #if/#elif/#else condition to insert for variant parameters
%%   First choice index, we insert #if
%%   Second choice onwards, we insert #elif
%%   For default condition, we insert #else
%function SLibGetVPrmIfCond(variantCondition, choiceIdx, numelVarChoices) void
    %assign ifCond = ""

    %if (choiceIdx == 0)
        %assign ifCond = SLibIfVariantConditionForm(variantCondition)
    %else
        %if (variantCondition == "(default)")
            %% default condition must always be processed at the end
            %assert (choiceIdx == (numelVarChoices-1))
            %%TopTester: test/toolbox/simulink/variants/var-parameter/tDefaultChoice.m
            %assign ifCond = "#else"
        %else
            %assign ifCond = "#elif " + variantCondition
        %endif
    %endif

    %return ifCond
%endfunction %%SLibGetVPrmIfCond

%% Function: SLibWrapVariantVariableCondition ======================================================
%% Abstract:
%%   Wrap a body with a variant condition for variant variable
%%
%function SLibWrapVariantVariableCondition(body, variantCondition, choiceIdx, numelVarChoices) void
    %assign ifCond = SLibGetVPrmIfCond(variantCondition, choiceIdx, numelVarChoices)
    %assign endIfCond = ""

    %if (choiceIdx == (numelVarChoices-1))
        %assign endIfCond = SLibEndIfVariantConditionForm(variantCondition)
    %endif

    %return SLibWrapBody(ifCond, body, endIfCond)
%endfunction


%% Function: SLibHasVariantCondition ===============================================================
%% Abstract:
%%   Tell whether an element has a variant condition
%%
%function SLibHasVariantCondition(element) void
    %return !ISEMPTY(element) && ISFIELD(element, "VariantCondition") && element.VariantCondition != ""
%endfunction

%% Function: SLibHasNetVariantConditionForData =====================================================
%% Abstract:
%%   Tell whether an element has a variant condition
%%
%function SLibHasNetVariantConditionForData(element) void
    %return !ISEMPTY(element) && ISFIELD(element, "NetVariantConditionForData") && element.NetVariantConditionForData != ""
%endfunction

%% Function: SLibIfSystemVariantCondition ==========================================================
%% Abstract:
%%   Return the opening system preprocessor condition
%%   uses the compiled version not the graphical one!
%%
%function SLibIfSystemVariantCondition(system) void
    %if SLibHasSystemVariantCondition(system)
        %return SLibIfVariantConditionForm(system.SystemInlineVariantPreprocessorCondition)
    %else
        %return ""
    %endif
%endfunction

%% Function: SLibEndIfSystemVariantCondition =======================================================
%% Abstract:
%%   Return the closing system preprocessor condition
%%   use the compiled version not the graphical one!
%%
%function SLibEndIfSystemVariantCondition(system) void
    %if SLibHasSystemVariantCondition(system)
        %return SLibEndIfVariantConditionForm(system.SystemInlineVariantPreprocessorCondition)
    %else
        %return ""
    %endif
%endfunction

%% Function: SLibVariantConditionRecord ============================================================
%% Abstract:
%%   A record to hold a pair of variant conditions
%%
%function SLibVariantConditionRecord()
    %createrecord emptyRecord { ifCond ""; endIfCond ""; hasConds TLC_FALSE; sysIdx -1; varCond ""}
    %return emptyRecord
%endfunction


%% Function: SLibGetSystemVariantConditions ========================================================
%% Abstract:
%%   Return the pair of system inline variant conditions
%%
%function SLibGetSystemVariantConditions(element)
    %assign vcRecord = SLibVariantConditionRecord()
    %assign vcRecord.ifCond = SLibIfSystemVariantCondition(element)
    %assign vcRecord.endIfCond = SLibEndIfSystemVariantCondition(element)
    %assign vcRecord.hasConds = SLibHasSystemVariantCondition(element)
    %return vcRecord
%endfunction

%% Function: SLibGetInlineVariantConditions ========================================================
%% Abstract:
%%   Return the pair of inline variant conditions
%%
%function SLibGetInlineVariantConditions(element)
    %assign vcRecord = SLibVariantConditionRecord()
    %assign vcRecord.ifCond = SLibIfVariantCondition(element)
    %assign vcRecord.endIfCond = SLibEndIfVariantCondition(element)
    %assign vcRecord.varCond = SLibVariantCondition(element)
    %assign vcRecord.hasConds = IsExtOutAndHasVarCond(element) ? TLC_TRUE : SLibHasVariantCondition(element)
    %return vcRecord
%endfunction

%% Function: SLibGetNetInlineVariantConditionForData ===============================================
%% Abstract:
%%   Return the inline variant conditions for DWORKs and Block I/O
%%
%function SLibGetNetInlineVariantConditionForData(element)
    %assign vcRecord = SLibVariantConditionRecord()
    %assign vcRecord.ifCond = SLibIfNetVariantConditionForData(element)
    %assign vcRecord.endIfCond = SLibEndIfNetVariantConditionForData(element)
    %assign vcRecord.hasConds = SLibHasNetVariantConditionForData(element)
    %assign vcRecord.varCond = SLibNetVariantConditionForData(element)
    %return vcRecord
%endfunction

%% Function: SLibGetSystemFromVarGroup =============================================================
%% Abstract:
%%   If a vargroup represents a system, return it
%%
%function SLibGetSystemFromVarGroup(varGroup)
    %createrecord system {}
    %if ::CompiledModel.NumSystems > 1
        %assign systemIndex = varGroup.SysIdx
        %if systemIndex != -1
            %assign systems = ::CompiledModel.System
            %assign system = systems[systemIndex]
        %endif
    %endif
    %return system
%endfunction


%% Function: SLibGetInlineSystemNetConditionFromVarGroup ===========================================
%% Abstract:
%%   If a net condition exists, return it
%%
%function SLibGetInlineSystemNetConditionFromVarGroup(varGroup)
    %return SLibGetIndexedSystemCondition(varGroup, "NetInlineVariantPreprocessorInstanceConditions")
%endfunction


%% Function: SLibGetInlineSystemRelativeConditionFromVarGroup ======================================
%% Abstract:
%%   If a relative condition exists, return it
%%
%function SLibGetInlineSystemRelativeConditionFromVarGroup(varGroup)
    %return SLibGetIndexedSystemCondition(varGroup, "RelativeInlineVariantPreprocessorInstanceConditions")
%endfunction


%% Function: SLibGetIndexedSystemCondition =========================================================
%% Abstract:
%%   If an indexed system condition exists, return it
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%% test/toolbox/simulink/variants/var-inline-vsrc-codegen/-tg1375551.m
%%
%function SLibGetIndexedSystemCondition(varGroup, fieldName)
    %assign vcRecord = SLibVariantConditionRecord()
    %assign instanceIndex = varGroup.InstanceIdx
    %if instanceIndex == -1
        %assign instanceIndex = 0
    %endif
    %assign system = SLibGetSystemFromVarGroup(varGroup)
    %if !ISEMPTY(system)
        %if ISFIELD(system, fieldName)
            %assign conditions = GETFIELD(system, fieldName)
            %% The vargroup has indexed conditions
            %if !ISEMPTY(conditions)
                %assign condition = conditions[instanceIndex]
                %if condition != ""
                    %assign vcRecord.ifCond = SLibIfVariantConditionForm(condition)
                    %assign vcRecord.endIfCond = SLibEndIfVariantConditionForm(condition)
                    %assign vcRecord.hasConds = TLC_TRUE
                    %assign vcRecord.sysIdx = system.SystemIdx
                %endif
            %endif
        %endif
    %endif
    %return vcRecord
%endfunction


%% Function: SLibGetInlineSystemNetConditions ======================================================
%% Abstract:
%%   If the containing system has a net condition, return it
%%
%function SLibGetInlineSystemNetConditions(dataRecord)
    %assign vcRecord = SLibVariantConditionRecord()
    %if ISFIELD(dataRecord, "VarGroupIdx")
        %assign varGroup = ::CompiledModel.VarGroups.VarGroup[dataRecord.VarGroupIdx[0]]
        %assign vcRecord = SLibGetInlineSystemNetConditionFromVarGroup(varGroup)
    %endif
    %return vcRecord
%endfunction


%% Function: SLibGetDataInlineVariantNetConditions =================================================
%% Abstract:
%%   Return the pair of net conditions for either instance data or a plain data
%%      record
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function SLibGetDataInlineVariantNetConditions(element)
    %assign netInstanceCondition = SLibGetNetInlineVariantConditionForData(element)
    %assign elementConds = SLibGetInlineVariantConditions(element)

    %assign vcRecord = SLibVariantConditionRecord()

    %if netInstanceCondition.hasConds
        %assign vcRecord = netInstanceCondition
        %% Instance data for a parent system
    %elseif elementConds.hasConds
        %assign vcRecord = elementConds
    %endif

    %return vcRecord
%endfunction


%% Function: SLibHasSystemVariantCondition =========================================================
%% Abstract:
%%   Tell whether an element has a system variant condition
%%
%function SLibHasSystemVariantCondition(element) void
    %return !ISEMPTY(element) && ISFIELD(element, "SystemInlineVariantPreprocessorCondition") ...
        && element.SystemInlineVariantPreprocessorCondition != ""
%endfunction

%% Function: SLibGetBlockVariantCondition ==========================================================
%% Abstract:
%%   Get the variant conditions associated with a block.
%%   - If net condition exists return that
%%   - else, return the local condition if it exists
%%
%function SLibGetBlockVariantCondition(block)
    %assign blockCond = ""
    %if ISFIELD(block, "NetVariantConditionForBlock")
        %assign blockCond = block.NetVariantConditionForBlock
    %elseif ISFIELD(block, "VariantCondition")
        %assign blockCond = block.VariantCondition
    %endif
    %return blockCond
%endfunction

%% Function: SLibGetParameterInitValueForChoice ====================================================
%% Abstract:
%%   Get the initial value of a parameter for given choice index.
%%
%function SLibGetParameterInitValueForChoice(prm, prmWidth, parameterIdx, comment, choiceIdx)
    %assign shouldGeneratePP = SLibGeneratePPForParam(parameterIdx)
    %assign value = ""

    %if (!shouldGeneratePP)
        %assign value = SLibGetFormattedPrmValue(prm, (prmWidth == 1) ? "" : comment)
    %else
        %assign value = LibParameterInstanceInitStrPerChoice(parameterIdx, choiceIdx)
        %if prmWidth != 1
            %assign value = "/* " + comment + " */\n" + value
        %endif
    %endif
    %return value
%endfunction


%% Function: SLibGetParameterInitValueWithVariantCondition =========================================
%% Abstract:
%%   Get the initial value of a parameter wrapped in corresponding variant condition
%%
%function SLibGetParameterInitValueWithVariantCondition(prm, prmWidth, parameterIdx, comment)

    %assign numelVarChoices = CGMODEL_ACCESS("CGModel.GetNumberOfVariantChoices", parameterIdx)
    %assign shouldGeneratePP = SLibGeneratePPForParam(parameterIdx)

    %if (!shouldGeneratePP)
        %assign value = SLibGetFormattedPrmValue(prm, (prmWidth == 1) ? "" : comment)
    %else
        %assign value = ""
        %foreach choiceIdx = numelVarChoices
            %assign choiceCondition = CGMODEL_ACCESS("CGModel.GetParameterChoiceCondition", parameterIdx, choiceIdx)
            %assign choiceValue = LibParameterInstanceInitStrPerChoice(parameterIdx, choiceIdx)
            %assign value = value + SLibWrapVariantVariableCondition(choiceValue, choiceCondition, choiceIdx, numelVarChoices)
        %endforeach
        %if prmWidth != 1
            %assign value = "/* " + comment + " */\n" + value
        %endif
    %endif
    %return value
%endfunction

%% Function: SLibGetFormattedVariantParameterValue =================================================
%% Abstract:
%%   This function returns the value string for given variant parameter
%function SLibGetFormattedVariantParameterValue(prm, value)
    %openfile choiceValue
    %assign choicePrmValue = SLibPrepParameterCoreFromValue(prm, value)
    %assign choiceValueData = choicePrmValue
    %if ISSLDATAREF(choicePrmValue)
        %assign choiceValueData = GENERATE_FORMATTED_VALUE(choicePrmValue, "")
    %else
        %<choiceValueData>
    %endif
    %closefile choiceValue
    %return choiceValue
%endfunction

%% Function: SLibGetSelfCoderDataGroupVarGroupIndex
%% Abstract:
%%   Returns the VarGroup Index for the Self Coder Data Group
%%   Returns -1 if there is no Coder Data Group associated with Self
%function SLibGetSelfCoderDataGroupVarGroupIndex() void
    %assign selfCoderDataGroupVarGroupIndex = ...
        ::CompiledModel.SelfCoderDataGroupVarGroupIndex
    %if selfCoderDataGroupVarGroupIndex != -1
        %assign selfCoderDataGroupVarGroup = ...
            ::CompiledModel.VarGroups.VarGroup[selfCoderDataGroupVarGroupIndex]
        %assert selfCoderDataGroupVarGroup.IsModelSelfCoderGroupVarGroup == 1
        %return selfCoderDataGroupVarGroupIndex
    %else
        %return -1
    %endif
%endfunction

%% Function: SLibGetSelfCoderGroupArgumentName
%% Abstract:
%%   Returns the self argument name of the self group, if there is any.
%%   If there is no self group, returns empty string.
%function SLibGetSelfCoderGroupArgumentName() void
    %assign selfCoderGroupVarGroupIndex = SLibGetSelfCoderDataGroupVarGroupIndex()
    %if selfCoderGroupVarGroupIndex != -1
        %assign selfCoderGroupVarGroup = ::CompiledModel.VarGroups.VarGroup[selfCoderGroupVarGroupIndex]
        %assert ISFIELD(selfCoderGroupVarGroup, "SelfStructureArgumentName")
        %return selfCoderGroupVarGroup.SelfStructureArgumentName
    %endif

    %return ""
%endfunction

%% Function: SLibGetSelfVarGroupIndex
%% Abstract:
%%   Returns the VarGroup index for Self
%%   Self can be mapped (Coder Group) or unmapped (RTM)
%%   Note: This utility is more general than SLibGetSelfCoderDataGroupVarGroupIndex
%function SLibGetSelfVarGroupIndex() void
    %assign rootSystem = ::CompiledModel.System[::CompiledModel.NumSystems-1]
    %if SLibGetDoesSelfHasCoderDataGroup()
        %return SLibGetSelfCoderDataGroupVarGroupIndex()
    %elseif ISFIELD(rootSystem,"SelfVarGroupIndex")
        %return rootSystem.SelfVarGroupIndex[0]
    %else
        %return -1
    %endif
%endfunction

%% Function: SLibGetDoesSelfExist
%% Abstract:
%%   Forwarding function to see if self was created for a model
%%   Otherwise, returns false
%function SLibGetDoesSelfExist() void
    %assign selfCoderDataGroupVarGroupIndex = ...
        SLibGetSelfCoderDataGroupVarGroupIndex()
    %return selfCoderDataGroupVarGroupIndex != -1
%endfunction

%% Function SLibIsSynthesizedRTMEmpty
%% Abstract:
%%   Return true if self is synthesized but empty (i.e. no self var group is created)
%function SLibIsSynthesizedRTMEmpty()
    %assign isempty = TLC_FALSE
    %with ::CompiledModel
        %if SelfCoderDataGroupIndex != -1 && !SLibGetDoesSelfExist()
            %assign selfGroup = CoderDataGroup[SelfCoderDataGroupIndex]
            %assert selfGroup.IsSelf
            %assign isempty = selfGroup.IsSynthesized
        %endif
    %endwith
    %return isempty
%endfunction

%% Function SLibGetUseRTMcgType
%% Abstract:
%%   Return true if RTM is created in IR.
%%   RTM can be packaged as struct (multi-instance models) or asStruct is none (single-instance)
%function SLibGetUseRTMcgType()
    %if !ISFIELD(::CompiledModel, "DoesUseRTMcgType")
        %addtorecord ::CompiledModel DoesUseRTMcgType (SLibGetDoesSelfExist() || SLibIsSynthesizedRTMEmpty())
    %endif
    %return ::CompiledModel.DoesUseRTMcgType
%endfunction

%% Function: SLibIsSelfInPluggableInterface()
%% Abstract:
%%   useRTMcgType and base module uses pluggable interface
%function SLibIsSelfInPluggableInterface()
    %with ::CompiledModel
        %assign baseModule = RTWCGModules.RTWCGModule[System[GetBaseSystemIdx()].CGIRModuleIdx]
        %assign ret = SLibGetUseRTMcgType() && (baseModule.SimplifiedInterface || IsModelReferenceSimTarget()) && SLibIsSelfStructured()
    %endwith
    %return ret
%endfunction

%% Function SLibIsSelfInSimTarget()
%% Abstract:
%%   useRTMcgType and SimTarget
%function SLibIsSelfInSimTarget()
    %return SLibGetUseRTMcgType() && IsModelReferenceSimTarget()
%endfunction


%% Function: SLibGetDoesSelfHasCoderDataGroup
%% Abstract:
%%   Returns true if and only if Self has a Coder Data Group associated with it
%%   Otherwise, returns false.
%%   Note: Self always has a coder data group (synthesized or user defined) so we
%%   only detect if self exsists for a model
%function SLibGetDoesSelfHasCoderDataGroup() void
    %return SLibGetDoesSelfExist()
%endfunction

%% Function: SLibIsSelfUserDefined() void
%% Abstract:
%%   Returns true iff the user has mapped Self to a coder group
%function SLibIsSelfUserDefined() void
    %if SLibGetDoesSelfHasCoderDataGroup() && !SLibSynthesizedRTM()
        %return TLC_TRUE
    %endif

    %return TLC_FALSE
%endfunction

%% Function: SLibIsSelfStructured()
%% Abstract:
%%   Returns true iff Self coder group exists and it is packaged as struct
%function SLibIsSelfStructured() void
    %assign selfCoderGroupIndex = SLibGetSelfCoderDataGroupIndex()
    %if selfCoderGroupIndex >= 0
        %assign selfCoderGroup = ::CompiledModel.CoderDataGroup[selfCoderGroupIndex]
        %assert (ISFIELD(selfCoderGroup, "AsStructure"))
        %return SLibCoderGroupPackageAsStruct(selfCoderGroup)
    %endif

    %return TLC_FALSE
%endfunction

%% Function: SLibIsSelfImported() void
%% Abstract:
%%   Returns true iff Self coder group exists and it is of imported scope
%function SLibIsSelfImported() void
    %assign selfCoderGroupIndex = SLibGetSelfCoderDataGroupIndex()
    %if selfCoderGroupIndex >= 0
        %assign selfCoderGroup = ::CompiledModel.CoderDataGroup[selfCoderGroupIndex]
        %return selfCoderGroup.DataScope == "Imported"
    %endif

    %return TLC_FALSE
%endfunction

%% Function: SLibIsSelfUserDefinedAndStructured()
%% Abstract:
%%   Returns true iff the user has mapped Self to a coder group
%%   and that coder group has AsStructure != "None"
%function SLibIsSelfUserDefinedAndStructured() void
    %return SLibIsSelfUserDefined() && SLibIsSelfStructured()
%endfunction

%% Function: SLibGetSelfCoderDataGroupIndex
%% Abstract:
%%   Returns the index of the Coder Data Group corresponding to Self
%%   Returns -1 if there is no Coder Data Group associated with Self
%function SLibGetSelfCoderDataGroupIndex() void
    %if SLibGetDoesSelfHasCoderDataGroup()
        %assign selfCoderDataGroupVarGroupIndex = ...
            SLibGetSelfCoderDataGroupVarGroupIndex()
        %assign selfCoderDataGroupVarGroup = ...
            ::CompiledModel.VarGroups.VarGroup[selfCoderDataGroupVarGroupIndex]
        %assign selfCoderDataGroupIndex = selfCoderDataGroupVarGroup.CoderDataGroupIndex
        %assert selfCoderDataGroupIndex != -1
        %return selfCoderDataGroupIndex
    %else
        %return -1
    %endif
%endfunction

%% Function: SLibIsGroupSelfCoderGroup
%% Abstract:
%%  Is group synthesized RTm?
%function SLibIsGroupSelfCoderGroup(group) void
    %return group.IsSelf
%endfunction

%% Function: SLibIsSynthesizedRTM
%% Abstract:
%%  Is group synthesized RTm?
%function SLibIsSynthesizedRTM(group) void
    %return group.IsSelf && group.IsSynthesized
%endfunction

%% Function: SLibSynthesizedRTM
%% Abstract:
%%  Is RTM using a synthesized coder group?
%function SLibSynthesizedRTM() void
    %return SLibGetDoesSelfHasCoderDataGroup() && ...
        SLibIsSynthesizedRTM(::CompiledModel.CoderDataGroup[SLibGetSelfCoderDataGroupIndex()])
%endfunction

%% Function: SLibSuppressRTM
%% Abstract:
%%  When do we suppress Legacy RTM in TLC?
%function SLibSuppressRTM() void
    %return SLibGetUseRTMcgType() && ...
        !SLibSynthesizedRTM() && ...
        SLibGetDoesSelfHasCoderDataGroup()
%endfunction

%% Function: SLibIsSelfCoderGroupField
%% Abstract:
%%  Returns true iff the given self field is a pointer to coder group
%%
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function SLibIsSelfCoderGroupField(aSelfVarGroupElementIndex) void
    %assign selfVarGroupIndex = SLibGetSelfVarGroupIndex()
    %if selfVarGroupIndex == -1
        %return TLC_FALSE
    %endif

    %assign selfVarGroup = ::CompiledModel.VarGroups.VarGroup[selfVarGroupIndex]
    %if aSelfVarGroupElementIndex >= selfVarGroup.NumVarGroupElements
        %return TLC_FALSE
    %endif
    %assign selfVarGroupElement = selfVarGroup.VarGroupElements[aSelfVarGroupElementIndex]
    %assign idNumElement = IDNUM(selfVarGroupElement)
    %if (idNumElement[0] == "RCDG")
        %return TLC_TRUE
    %endif

    %return TLC_FALSE
%endfunction

%% Function: SLibGetCoderGroupIndexFromSelfElementIndex
%% Abstract:
%%  Parses the self element to get the coder group index.
%%  Returns -1 if can't find one.
%function SLibGetCoderGroupIndexFromSelfElementIndex(aSelfVarGroupElementIndex) void
    %if SLibIsSelfCoderGroupField(aSelfVarGroupElementIndex)
        %assign selfVarGroup = ::CompiledModel.VarGroups.VarGroup[SLibGetSelfVarGroupIndex()]
        %assign selfVarGroupElement = selfVarGroup.VarGroupElements[aSelfVarGroupElementIndex]
        %assign idNumElement = IDNUM(selfVarGroupElement)
        %return idNumElement[1]
    %endif

    %return -1
%endfunction

%% Function: SLibIsSelfVarGroupField
%% Abstract:
%%  Returns true iff the given self field is a pointer to coder group
%%
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function SLibIsSelfVarGroupField(aSelfVarGroupElementIndex) void
    %assign selfVarGroupIndex = SLibGetSelfVarGroupIndex()
    %if selfVarGroupIndex == -1
        %return TLC_FALSE
    %endif

    %assign selfVarGroup = ::CompiledModel.VarGroups.VarGroup[selfVarGroupIndex]
    %if aSelfVarGroupElementIndex >= selfVarGroup.NumVarGroupElements
        %return TLC_FALSE
    %endif
    %assign selfVarGroupElement = selfVarGroup.VarGroupElements[aSelfVarGroupElementIndex]
    %assign idNumElement = IDNUM(selfVarGroupElement)
    %if (idNumElement[0] == "VG")
        %return TLC_TRUE
    %endif

    %return TLC_FALSE
%endfunction

%% Function: SLibGetVarGroupIndexFromSelfElementIndex
%% Abstract:
%%  Parses the self element to get the coder group index.
%%  Returns -1 if can't find one.
%function SLibGetVarGroupIndexFromSelfElementIndex(aSelfVarGroupElementIndex) void
    %if SLibIsSelfVarGroupField(aSelfVarGroupElementIndex)
        %assign selfVarGroup = ::CompiledModel.VarGroups.VarGroup[SLibGetSelfVarGroupIndex()]
        %assign selfVarGroupElement = selfVarGroup.VarGroupElements[aSelfVarGroupElementIndex]
        %assign idNumElement = IDNUM(selfVarGroupElement)
        %return idNumElement[1]
    %endif

    %return -1
%endfunction

%% Function: SLibGetQualifiedRTMType
%% Abstract:
%%  Get the RTM or Coder Group Self type qualifier
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function SLibGetQualifiedRTMType() void
    %assign selfCoderGroupIndex = SLibGetSelfCoderDataGroupIndex()
    %if selfCoderGroupIndex != -1
        %assign selfCoderGroup = ::CompiledModel.CoderDataGroup[selfCoderGroupIndex]
        %assign typeQualifier = SLibTypeQualifierForGroup(selfCoderGroup)
        %return typeQualifier + " " + ::tSimStructType
    %endif

    %return ::tSimStructType
%endfunction

%% Function: SLibGetChildSelfCoderGroupIndex
%% Abstract:
%%   Returns the index for child self coder group in the block
%%   interface coder group record. If there is no such child
%%   self group, returns -1
%%
%%TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function SLibGetChildSelfCoderGroupIndex(mBlock) void
    %assign blockInterface = GetModelrefInterface(mBlock)
    %if ISFIELD(blockInterface, "CoderDataGroups")
        %assign childCoderGroupsRecord = blockInterface.CoderDataGroups.CoderDataGroup
        %assign numGroups = SIZE(childCoderGroupsRecord, 1)
        %foreach groupIndex = numGroups
            %if numGroups == 1
                %assign childCoderGroup = childCoderGroupsRecord
            %else
                %assign childCoderGroup = childCoderGroupsRecord[groupIndex]
            %endif

            %assign childCoderGroupIsSelf = ...
                ISFIELD(childCoderGroup, "IsSelf") && ...
                childCoderGroup.Depth == 0.0 && ...
                childCoderGroup.IsSelf
            %if childCoderGroupIsSelf
                %return groupIndex
            %endif
        %endforeach
    %endif

    %return -1
%endfunction

%% Function: SLibPassGlobalInstanceForBlocksSelf
%% Abstract:
%%   This function returns true if and only if we pass
%%   a global self instance for the child block's self.
%%   Note that we either pass global chilf self instances
%%   or access child self instance through self structure.
%%
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function SLibPassGlobalInstanceForBlocksSelf(aBlock) void
    %assert aBlock.Type == "ModelReference"

    %% Look for global self instance
    %assign childSelfCoderGroupIndex = SLibGetChildSelfCoderGroupIndex(aBlock)
    %if childSelfCoderGroupIndex != -1
        %assign blockInterface = GetModelrefInterface(aBlock)
        %assign childCoderGroupsRecord = blockInterface.CoderDataGroups.CoderDataGroup
        %assign numChildCoderGroups = SIZE(childCoderGroupsRecord, 1)
        %if numChildCoderGroups > 1
            %assign childSelfCoderGroup = childCoderGroupsRecord[childSelfCoderGroupIndex]
        %else
            %assign childSelfCoderGroup = childCoderGroupsRecord
        %endif
        %assign groupIndexWithChildSelfNameInCurrentModel = ...
            SLibPolymorphicRootCoderDataGroupIndex(childSelfCoderGroup.Name)
        %assign childSelfGroupNameRegisteredInCurrentModel = ...
            groupIndexWithChildSelfNameInCurrentModel != -1
        %assign childSelfGroupIsInParent = ...
            ISFIELD(childSelfCoderGroup, "AsStructure") && ...
            childSelfCoderGroup.AsStructure == "InParent"
        %assign groupWithChildSelfNameInCurrentModelIsAsStructureNone = ...
            childSelfGroupNameRegisteredInCurrentModel && ...
            ::CompiledModel.CoderDataGroup[groupIndexWithChildSelfNameInCurrentModel].AsStructure == "None" && ...
            !IsModelReferenceSimTarget()
        %if childSelfGroupIsInParent && ...
            (!childSelfGroupNameRegisteredInCurrentModel || ...
            groupWithChildSelfNameInCurrentModelIsAsStructureNone)
            %return TLC_TRUE
        %endif
    %endif

    %return TLC_FALSE
%endfunction

%% Function: SLibGetGlobalInstanceNameForBlocksSelf
%% Abstract:
%%   Returns the global self instance name for block's self
%%   if we use a global instance.
%function SLibGetGlobalInstanceNameForBlocksSelf(aBlock) void
    %assert SLibPassGlobalInstanceForBlocksSelf(aBlock)
    %return "&" + aBlock.Identifier
%endfunction

%function SLibDoesModelHaveMemSecForBanks() void
    %return (CGMODEL_ACCESS("CGModel.DoesModelHaveMemSecForBanks") > 0)
%endfunction

%% Function: FcnApplyMemSec ========================================================================
%% Abstract:
%%   Should memory sections be honored for the data structures of this model?
%function FcnApplyMemSec() void
    %% This Fcn controls whether Memory Sections
    %% are emitted or not based on whether there
    %% are memory sections registered in Dicty.
    %% So we need to add a way for it to return true for
    %% synthesized memory sections (task based partitioning).
    %% Here I chose the feature flag. Needs Refactoring.
    %return (SLibIsERTTarget() && ...
        !IsModelReferenceSimTarget() && ...
        SLibIsPragmaOnDecls() && ...
        (SLibAreInternalMemorySectionsDefined() || ...
        SLibIsCoderDictionaryActiveForDefaults() || ...
        (CGMODEL_ACCESS("CGModel.TaskBasedPartitionOfData") > 0) || ...
        SLibAutosarActive() || ...
        SLibDoesModelHaveMemSecForBanks()))
%endfunction

%% Function: FcnHandleNewLineForCodeInfo ===========================================================
%% Abstract:
%%   Handle new line in string and replace it with (\n) for codeinfo processing
%function FcnHandleNewLineForCodeInfo(aString) void
    %assign aString = FcnSanitizeUserString(aString)
    %if !ISEMPTY(aString)
        %assign aString = REGEXPREP(aString, ::NEWLINE, "\\\\n")
    %endif
    %return aString
%endfunction

%% Function: FcnHandleNewLineForMemSec =============================================================
%% Abstract:
%%   Handle new line characters (\n) in memory section statements and comments.
%function FcnHandleNewLineForMemSec(aString) void
    %assign aString = FcnSanitizeUserString(aString)
    %if !ISEMPTY(aString)
        %assign aString = REGEXPREP(aString, "\\\\n", ::NEWLINE)
    %endif
    %return aString
%endfunction

%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function SLibMultiInstance() void
    %if IsModelReferenceTarget()
        %return ::CompiledModel.OkToMultiInstanceModelref
    %else
        %return MultiInstanceERTCode
    %endif
%endfunction

%% Abstract:
%% Returns true if the resultant variant condition of the constant parameter vargroup
%% gets evaluated to TRUE. Uses VCService for the same through the TLC Bridge.
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tmg1317695_VC1.m
%function SLibSimplifyVariantCondition(cond)
    %return CGMODEL_ACCESS("CGModel.SimplifyVariantCondition", cond)
%endfunction

%function SLSimplifyCExprFromCCondition(cond)
    %return CGMODEL_ACCESS("CGModel.simplifyCExprFromCCondition", cond)
%endfunction

%% Abstract:
%% Is this a VariantControl with startup or runtime activation?
%function SLibIsVariantControlWithRuntimeSemantic(mdlParam)
    %assign modelPrmIdx = SLibGetModelParameterIndex(mdlParam)
    %return CGMODEL_ACCESS("CGModel.VariantControlIsStartupOrRuntime", modelPrmIdx)
%endfunction

%% Abstract:
%% Is the normal MATLAB variable used in context of code compile activation time?
%% Simulink.VariantControl is also treated as normal MATLAB variable when its
%% underlying value is not Simulink.Parameter
%function SLibIsNMVVariantControlWithCodeCompileVAT(mdlParam)
    %assign modelPrmIdx = SLibGetModelParameterIndex(mdlParam)
    %return CGMODEL_ACCESS("CGModel.VariantControlIsCodeCompile", modelPrmIdx)
%endfunction


%%Function: SLibGetMergedIfCondition
%% Abstract:
%% Returns merged unique if conditions by adding OR
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-codegen/localsGuarding/tmLG_switchAction.m
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc/tmsfun2.m
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tmg1265882_VC1.m
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tmConstBlockIOSubsystemVariant.m
%function SLibGetMergedIfCondition(vecConditions)
    %assign vecSize = SIZE(vecConditions, 1)
    %assign condition = ""
    %foreach idx = vecSize
        %assign currentCondition =  vecConditions[idx]
        %assign isRepated = 0
        %foreach idy = idx
            %if (idx != idy) && (vecConditions[idy] == currentCondition)
                %assign isRepated = 1
            %endif
        %endforeach
        %if isRepated == 0
            %if idx != 0
                %assign condition = condition + " || "
            %endif
            %assign currentCondSubstr = Substring(currentCondition,6, SIZE(currentCondition, 1) - 2)
            %assign condition = condition + "(" + currentCondSubstr + ")"
        %endif
    %endforeach
    %if vecSize > 0
        %assign condition = "\n #if %<condition> \n"
    %endif
    %return condition
%endfunction

%%Function: SLibCreateLocalVariableWithConditions
%% Abstract:
%% Adds If and endIf conditions to the passed variable
%function SLibCreateLocalVariableWithConditions(variable, ifCondition, endIfCondition)
    %return "%<ifCondition> %<variable> %<endIfCondition>"
%endfunction

%%DocFunction{Other Useful Functions}:  LibIsRecordMutiDimension =================
%% Abstract:
%% Returns if the record has multiple dimensions and preserves the array
%% dimensions in the generated code
%function LibIsRecordMultiDimension(record) void
    %return SLibIsContainerCGTypeND(record)
%endfunction

%% Abstract:
%% Is the parameter a variant parameter
%function SLibIsVariantParameter(mdlParam)
    %assign isVariantParam = TLC_FALSE
    %assign modelParamIdx = SLibGetModelParameterIndex(mdlParam)
    %assign isVariantParam = CGMODEL_ACCESS("CGModel.IsVariantParameter", modelParamIdx)
    %return isVariantParam
%endfunction

%% Abstract:
%% Is the normal MATLAB variable used in context of startup activation time
%% TopTester: test/toolbox/simulink/variants/var-startup/tEnumsWithStartup.m
%function SLibIsNMVAsVariantControlWithRuntimeSemantic(mdlParam)
    %assign modelPrmIdx = SLibGetModelParameterIndex(mdlParam)
    %return CGMODEL_ACCESS("CGModel.VariantControlIsStartup", modelPrmIdx)
%endfunction

%% Abstract:
%% Get the variant parameter choice value
%function SLibGetVariantParamValueForChoice(mdlParam, choiceIdx)
    %assign modelParamIdx = SLibGetModelParameterIndex(mdlParam)
    %if (modelParamIdx == -1 || !CGMODEL_ACCESS("CGModel.IsParameterSerializationEnabled", modelParamIdx))
        %assign parameterChoices = mdlParam.Choices
        %assign choice = parameterChoices.Choice[choiceIdx]
        %return choice.Value
    %endif

    %return CGMODEL_ACCESS("CGModel.GetParameterChoiceValue", modelParamIdx, choiceIdx)
%endfunction

%% Abstract:
%% Get the variant parameter choice value
%function SLibGeneratePPForParam(mdlParamIdx)
    %assign mdlParam = ::CompiledModel.ModelParameters.Parameter[mdlParamIdx]
    %assign isVariantParam = SLibIsVariantParameter(mdlParam)
    %assign generateChoices = CGMODEL_ACCESS("CGModel.GenerateParameterChoices")
    %assign isRLSConstant = ISFIELD(mdlParam, "RLSConstant")
    %assign shouldGeneratePP = isVariantParam && generateChoices && (!isRLSConstant)
    %return shouldGeneratePP
%endfunction

%%Function: SLibGetStructDefHeader =================
%% Abstract:
%%   Returns header for struct decleration.
%%
%function SLibGetStructDefHeader(idTag, id, align) void
    %assign position = structDAFlag.position
    %return CGMODEL_ACCESS("CGModel.getStructDefHeader", idTag, id, align, position)
%endfunction

%%Function: SLibGetStrucDefHeaderForHeaderFiles =====
%% Abstract:
%%   Retuns header for struct definition. If called
%%   for rapid accel and CPP target Lang, returns C
%%   style header. Used when defining structure in
%%   a header file. It is done this way because same
%%   header can be used in C and C++ compilation units.
%%   Refer to g2360489
%%
%function SLibGetStructDefHeaderForHeaderFiles(idTag, id, align) void
    %if ::GenCPP && ::isRAccel
        %return "typedef struct {"
    %else
        %return SLibGetStructDefHeader("", id, "")
    %endif
%endfunction

%%Function: SLibGetStrucDefHeaderForHeaderFiles =====
%% Abstract:
%%   Retuns tail part for struct definition. If called
%%   for rapid accel and CPP target Lang, returns C
%%   style header. Used when defining structure in
%%   a header file. It is done this way because same
%%   header can be used in C and C++ compilation units.
%%   Refer to g2360489
%%
%function SLibGetStructDefTailForHeaderFiles(id, align) void
    %if ::GenCPP && ::isRAccel
        %assign tail = " } " + id + ";"
        %return tail
    %else
        %return SLibGetStructDefTail(id, "")
    %endif
%endfunction

%%Function: SLibGetStructDefTail =================
%% Abstract:
%%   Returns tail for struct decleration.
%%
%function SLibGetStructDefTail(id, align) void
    %assign position = structDAFlag.position
    %return CGMODEL_ACCESS("CGModel.getStructDefTail", id, align, position)
%endfunction

%%Function: SLibIsRapidAccelDatasetFormat =============
%% Abstract:
%%   Returns if rapid accel and save format is dataset
%function SLibIsRapidAccelDatasetFormat() void
    %assign returnVal = TLC_FALSE
    %if ::isRAccel && ...
        ::CompiledModel.DataLoggingOpts.CompiledLoggingSaveFormat == "Dataset"
        %assign returnVal = TLC_TRUE
    %endif
    %return returnVal
%endfunction

%function SLibGetFormattedBlockPath(block) void
    %if ISFIELD(block, "GrSrc") && block.GrSrc[1] != -1
        %return SLibMangledGrBlockPath(block.GrSrc)
    %else
        %return LibMangledPathName(block.Name)
    %endif
%endfunction

%%Function: SLibGetVariantConditionCombineByAND =============
%% Abstract:
%%   combine two variant condition by AND
%%
%% TopTester: test/toolbox/simulink/variants/var-dsm-scoped/tScopedDSMBasic.m -testspec: TestPoint_mTopScopedDSM_SimplifyVC
%function SLibGetVariantConditionCombineByAND(firstVariantCond, secondVariantCond) void
    %assign netVariantCond = ""
    %if !ISEMPTY(firstVariantCond) && !ISEMPTY(secondVariantCond)
        %if ISEQUAL(firstVariantCond, secondVariantCond)
            %assign netVariantCond = firstVariantCond
        %else
            %assign netVariantCond = "(" + firstVariantCond + ") && (" + secondVariantCond + ")"
        %endif
    %elseif !ISEMPTY(firstVariantCond) && ISEMPTY(secondVariantCond)
        %assign netVariantCond = firstVariantCond
    %elseif ISEMPTY(firstVariantCond) && !ISEMPTY(secondVariantCond)
        %assign netVariantCond = secondVariantCond
    %endif
    %return SLSimplifyCExprFromCCondition(netVariantCond)
%endfunction

%%Function: SLibGetVariantConditionCombineByOR =============
%% Abstract:
%%   combine two variant condition by OR
%%
%function SLibGetVariantConditionCombineByOR(firstVariantCond, secondVariantCond) void
    %assign netVariantCond = ""
    %if !ISEMPTY(firstVariantCond) && !ISEMPTY(secondVariantCond)
        %if ISEQUAL(firstVariantCond, secondVariantCond)
            %assign netVariantCond = firstVariantCond
        %else
            %assign netVariantCond = "(" + firstVariantCond + ") || (" + secondVariantCond + ")"
        %endif
    %elseif ISEMPTY(firstVariantCond) || ISEMPTY(secondVariantCond)
        %assign netVariantCond = SLSimplifyCExprFromCCondition(netVariantCond)
    %endif
    %return SLSimplifyCExprFromCCondition(netVariantCond)
%endfunction

%endif %% _UTILLIB_
%% [EOF] utillib.tlc

/%  LocalWords:  SLib
 %/
