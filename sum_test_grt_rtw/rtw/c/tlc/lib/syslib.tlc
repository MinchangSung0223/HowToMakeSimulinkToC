%%
%% Copyright 1994-2024 The MathWorks, Inc.
%%
%% Abstract:
%%   This TLC library file contains all the code for generating system output
%%   code.
%%

%include "sysarglib.tlc"

%if EXISTS(::_SYSLIB_) == 0
%assign ::_SYSLIB_ = 1

%include "servicelib.tlc"
%include "systemslib.tlc"
%include "blkio_api.tlc"

%%---------------------------------------------------------------%
%% FunctionRecord - record used for defining function prototypes %
%%---------------------------------------------------------------%
%%
%% Create a record for defining function prototypes.  The identifiers of
%% FcnRec are used as follows
%%   Declaration:
%%   #if V == 1
%%   void foo(int_T tid);
%%   #endif
%%
%%   Call Syntax:
%%   #if V == 1
%%   foo(tid);
%%   #endif
%%   Name    = "foo"
%%   Returns = "void"
%%   Params  = "int_T tid"
%%   Args    = "tid"
%%   VariantIfCondition = "#if V == 1"
%%   VariantIfCondition = "#endif"


%assign FunctionRecord = FcnRec\
{\
    Name       "";\
    Returns    "";\
    Params     "";\
    CommonPrms "";\
    CommonArgs "";\
    ModuleIfCondition "";\
    ModuleEndIfCondition "";\
    FcnTIDCGVCEIfCondition "";\
    FcnTIDCGVCEEndIfCondition ""\
}

%% Function: FcnResetFunctionRecord ================================================================
%% Abstract:
%%    A routine to reset the function record. Variant conditions of these functions are
%%    also cached.
%%    ModuleIfCondition is the condition of the module where the function belongs to
%%    FcnTIDCGVCEIfCondition is the condition of the entry point function with a tid.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function FcnResetFunctionRecord() void
    %assign ::FcnRec.Name       = ""
    %assign ::FcnRec.Returns    = ""
    %assign ::FcnRec.Params     = ""
    %assign ::FcnRec.CommonPrms = ""
    %assign ::FcnRec.CommonArgs = ""
    %assign ::FcnRec.ModuleIfCondition = ""
    %assign ::FcnRec.ModuleEndIfCondition = ""
    %assign ::FcnRec.FcnTIDCGVCEIfCondition = ""
    %assign ::FcnRec.FcnTIDCGVCEEndIfCondition = ""
%endfunction

%% Function: FcnAddArgument ========================================================================
%% Abstract:
%%   Add an argument to the parameter and argument fields of the FcnRec
%%   record.
%%
%%   Arguments:
%%     type: the type for the argument
%%      var: the variable name for the argument
%% TopTester: test/toolbox/simulink/blocks/lib_Sources/Ground/rtw/tStringSupport.m
%%
%function FcnAddArgument(sysIdx, type, var, arg) void
    %if !WHITE_SPACE(::FcnRec.Params)
        %assign comma  = ", "
    %else
        %assign comma = ""
    %endif
    %assign dataDef = type + var
    %assign ::FcnRec.Params     = ::FcnRec.Params + comma + dataDef
    %assign ::FcnRec.CommonArgs = ::FcnRec.CommonArgs + comma + arg
    %<SLibAddFunctionParameterToCodeDescriptor(sysIdx, ::FcnRec, type, var, TLC_TRUE)>
%endfunction


%% Function: FcnAddArgumentWithCompilerAbstraction =================================================
%% Abstract:
%%   Add an argument to the parameter and argument fields of the FcnRec
%%   record with AUTOSAR compiler abstraction macros
%%
%%   Arguments:
%%     type: the type for the argument
%%      var: the variable name for the argument
%%
%function FcnAddArgumentWithCompilerAbstraction(sysIdx, isConst, datatype, isPtr, ptrIsConst, var, arg) void
    %if !WHITE_SPACE(::FcnRec.Params)
        %assign comma  = ", "
    %else
        %assign comma = ""
    %endif
    %assign dataDef = SLibAutosarCompilerAbstractionForDataDecl(isConst, datatype, isPtr, ptrIsConst, var, "DataAutomatic")
    %assign ::FcnRec.Params     = ::FcnRec.Params + comma + dataDef
    %assign ::FcnRec.CommonArgs = ::FcnRec.CommonArgs + comma + arg
    %<SLibAddFunctionParameterToCodeDescriptor(sysIdx, ::FcnRec, type, var, TLC_TRUE)>
%endfunction

%% Function: FcnAddParameter =======================================================================
%% Abstract:
%%   Add an argument definition to the parameter field of the FcnRec record.
%%
%%   Arguments:
%%     type: the type for the argument definition
%%      var: the variable name for the argument definition
%% TopTester: test/toolbox/simulink/variants/var-vss-outputwhenunconnected/tOutWhenUnconnected.m
%%
%function FcnAddParameter(sysIdx, type, var) void
    %if !WHITE_SPACE(::FcnRec.Params)
        %assign comma = ", "
    %else
        %assign comma = ""
    %endif
    %assign dataDef = type + var
    %assign ::FcnRec.Params = ::FcnRec.Params + comma + dataDef
    %<SLibAddFunctionParameterToCodeDescriptor(sysIdx, ::FcnRec, type, var, TLC_TRUE)>
%endfunction

%% Toptetser: test/toolbox/simulink/variants/var-vss-condexecuted/tMdlRefWithFcnOnDataAsVSSChoice.m
%%
%function FcnPrependParameter(sysIdx, type, var) void
    %if !WHITE_SPACE(::FcnRec.Params)
        %assign comma = ", "
    %else
        %assign comma = ""
    %endif
    %assign dataDef = type + var
    %assign ::FcnRec.Params = dataDef + comma + ::FcnRec.Params
    %<SLibAddFunctionParameterToCodeDescriptor(sysIdx, ::FcnRec, type, var, TLC_FALSE)>
%endfunction

%% Function: FcnAddParameterWithCompilerAbstraction ================================================
%% Abstract:
%%   Add an argument definition to the parameter field of the FcnRec record.
%%
%%   Arguments:
%%     type: the type for the argument definition
%%      var: the variable name for the argument definition
%%
%function FcnAddParameterWithCompilerAbstraction(sysIdx, isConst, datatype, isPtr, var) void
    %if !WHITE_SPACE(::FcnRec.Params)
        %assign comma = ", "
    %else
        %assign comma = ""
    %endif
    %assign dataDef = SLibAutosarCompilerAbstractionForDataDecl(isConst, datatype, isPtr, TLC_FALSE, var, "DataAutomatic")
    %assign ::FcnRec.Params = ::FcnRec.Params + comma + dataDef
    %<SLibAddFunctionParameterToCodeDescriptor(sysIdx, ::FcnRec, type, var, TLC_TRUE)>
%endfunction

%% Function: FcnPassCanonicalInputByPtr ============================================================
%% Abstract:
%%   Return whether a canonical input should be passed by pointer
%function FcnPassCanonicalInputByPtr(ci)
    %return ci.DeclareAsPointer == "yes"
%endfunction

%% Function: FcnPassCanonicalInputAsConst ==========================================================
%% Abstract:
%%   Return whether a canonical input should be passed using const
%%   qualifier
%% TopTester: test/toolbox/rtw/targets/ert/model2model/pir2engine/tPir2EngineLutGecks04.m
%%
%function FcnPassCanonicalInputAsConst(sysIdx, ci)
    %if !IsBaseSystem(System[sysIdx].ReusedParentSystemIdx) || (!SLibFcnProtoCtrlActive() && !GenerateClassInterface)
        %return FcnPassCanonicalInputByPtr(ci) || (LibGetRecordWidth(ci) > 1)
    %else
        %if ISFIELD(ci, "IsCustomConst")
            %return ci.IsCustomConst == "yes"
        %else
            %return TLC_FALSE
        %endif
    %endif
%endfunction

%function FcnPassExternalInputAsConst(ci)
    %if ISFIELD(ci, "IsCustomConst")
        %return ci.IsCustomConst == "yes"
    %else
        %return TLC_FALSE
    %endif
%endfunction

%% Function: FcnPassCanonicalOutputAsReference =====================================================
%% Abstract:
%%   Return whether a canonical output is passed by reference
%%   qualifier
%function FcnPassCanonicalOutputAsReference(co)
    %return co.DeclareAsReference == "yes"
%endfunction

%function SLibAccessThisArgGlobally(aArgDef, aFcnName) void
    %<SLibAccessThisSysFcnArgHelper(aArgDef, aFcnName, "Global", "", TLC_FALSE)>
    %<SLibAccessThisSysFcnArgHelper(aArgDef, aFcnName, "", "", TLC_FALSE)>
%endfunction

%% Function: SLibAccessMdlRefCanParam ==============================================================
%% Abstract:
%%   Markes the parameter argument for aPrmIdx as accessed in a given model
%%   reference base system function (aFcnName).
%%
%function SLibAccessMdlRefCanParam(aPrmIdx, aFcnName) void
    %if IsModelRefScalableBuild()
        %assign baseSystem = ::CompiledModel.System[GetBaseSystemIdx()]
        %with baseSystem.Interface
            %assert aPrmIdx < NumCanonicalPrmArgDefs
            %assign canParamRecord = CanonicalPrmArgDef[aPrmIdx]
            %<SLibAccessThisArgGlobally(canParamRecord, aFcnName)>
        %endwith
    %endif
%endfunction

%% Function: SLibAccessMdlRefGlobals ===============================================================
%% Abstract:
%%   This function marks model reference global argument definition records as
%%   accessed, based on the virtual argument list created in IR.
%%
%function SLibAccessMdlRefGlobals(aFcn) void
    %if !IsModelRefScalableBuild()
        %return
    %endif
    %assign baseSystem = ::CompiledModel.System[GetBaseSystemIdx()]
    %with baseSystem.Interface
        %assign fcnName = aFcn.Name
        %foreach argIdx=aFcn.NumArgs
            %if 2 == aFcn.ArgAccessed[argIdx]
                %assign idNum = SLibSafeIDNUM(aFcn.ArgSource, argIdx)
                %assign argSrc = idNum[0]
                %assign argSrcIdx = idNum[1]
                %switch argSrc
                  %case "I" %% canonical input
                    %assign canInputRecord = CanonicalInputArgDef[argSrcIdx]
                    %<SLibAccessThisArgGlobally(canInputRecord, fcnName)>
                    %break
                  %case "O" %% canonical output
                    %assign canOutputRecord = CanonicalOutputArgDef[argSrcIdx]
                    %<SLibAccessThisArgGlobally(canOutputRecord, fcnName)>
                    %break
                  %case "Y" %% root outport not being canonical output, occur in FPC only
                    %break
                  %case "Y" %% root outport not being canonical output, occur in FPC only
                    %break
                  %case "D" %% canonical dwork
                    %assign canDWorkRecord = CanonicalDWorkArgDef[argSrcIdx]
                    %<SLibAccessThisArgGlobally(canDWorkRecord, fcnName)>
                    %break
                  %case "P" %% canonical parameters
                    %assign canParamRecord = CanonicalPrmArgDef[argSrcIdx]
                    %<SLibAccessThisArgGlobally(canParamRecord, fcnName)>
                    %break
                  %case "RTM"
                    %<SLibAccessThisArgGlobally(RTMArgDef, fcnName)>
                    %break
                  %case "LB" %% block IO
                    %<SLibAccessThisArgGlobally(BlockIOArgDef, fcnName)>
                    %break
                  %case "LC" %% constat block IO
                    %<SLibAccessThisArgGlobally(ConstBlockIOArgDef, fcnName)>
                    %break
                  %case "LW" %% dwork
                    %<SLibAccessThisArgGlobally(DWorkArgDef, fcnName)>
                    %break
                  %case "LP"  %% parameter
                  %case "LCP" %% constant parameter
                  %case "LPI" %% const parameter with init
                    %<SLibAccessThisArgGlobally(ParameterArgDef, fcnName)>
                    %break
                  %case "LX" %% continues states
                    %<SLibAccessThisArgGlobally(ContStatesArgDef, fcnName)>
                    %break
                  %case "LDX" %% derivatives
                    %<SLibAccessThisArgGlobally(ContStatesDerivativeArgDef, fcnName)>
                    %break
                  %case "LXDI" %% continues state disabled
                    %<SLibAccessThisArgGlobally(ContStatesDisabledArgDef, fcnName)>
                    %break
                  %case "LXAT" %% continues state absolute tolerance
                    %<SLibAccessThisArgGlobally(ContStatesAbsoluteToleranceArgDef, fcnName)>
                    %break

                  %case "LXPTMIN" %% continues state perturb min
                    %<SLibAccessThisArgGlobally(ContStatesPerturbMinArgDef, fcnName)>
                    %break

                  %case "LXPTMAX" %% continues state perturb max
                    %<SLibAccessThisArgGlobally(ContStatesPerturbMaxArgDef, fcnName)>
                    %break

                  %case "LZ" %% non-sampled zero crossings
                    %<SLibAccessThisArgGlobally(ZCSVArgDef, fcnName)>
                    %break
                  %case "LZE" %% zero crossing events
                    %<SLibAccessThisArgGlobally(ZCEventArgDef, fcnName)>
                    %break
                  %case "LCDG"
                  %case "CPI"
                  %case "TID"
                  %case "X"
                  %case "U"
                  %case "Y"
                    %break
                  %default
                    %%START_ASSERT
                    %assign errTxt = "Unhandled argument type '%<argSrc>'."
                    %<LibBlockReportError([],errTxt)>
                    %break
                    %%END_ASSERT
                %endswitch
            %endif
        %endforeach
    %endwith
%endfunction

%% Function: SLibAccessArgGlobally =================================================================
%% Abstract:
%%   This function marks a argument of the current function as accessed
%%   globally.
%%
%function SLibAccessArgGlobally(arg, fcnName, accessTid, periodicRateGrouping) void
    %if periodicRateGrouping || SLibNonInlinedModelWideEventTID(accessTid)
        %<SLibAccessThisSysFcnArgHelper(arg, fcnName, "", accessTid, TLC_FALSE)>
        %<SLibAccessThisSysFcnArgHelper(arg, fcnName, "Global", accessTid, TLC_FALSE)>
    %else
        %<SLibAccessThisSysFcnArgHelper(arg, fcnName, "", "", TLC_FALSE)>
        %<SLibAccessThisSysFcnArgHelper(arg, fcnName, "Global", "", TLC_FALSE)>
    %endif
%endfunction

%% Function: SLibAccessArg =========================================================================
%% Abstract:
%%   This function marks a argument of the current function as accessed
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function SLibAccessArg(arg, fcnName, accessTid, periodicRateGrouping) void
    %if periodicRateGrouping || SLibNonInlinedModelWideEventTID(accessTid)
        %<SLibAccessThisSysFcnArgHelper(arg, fcnName, "", accessTid, TLC_FALSE)>
    %else
        %<SLibAccessThisSysFcnArgHelper(arg, fcnName, "", "", TLC_FALSE)>
    %endif
%endfunction

%% Function: FcnGetGroupArgDef
%% Abstract:
%%    Given a group index, returns the token "CoderDataGroup<x>ArgDef" where "x"
%%    is the group name
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function FcnGetGroupArgDef(groupIndex) void
    %assign group = ::CompiledModel.CoderDataGroup[groupIndex]
    %assign groupToken = "CoderDataGroup" + group.Name
    %assign argDef = %<groupToken + "ArgDef">
    %return argDef
%endfunction

%% Function: FcnIsUnCalledScopedSlFcn
%% Abstract:
%% Function determines if Simulink Function is uncalled Simulink Function
%% or not
%%
%function FcnIsUnCalledScopedSlFcn(thisSystem) void
    %if NumSimulinkFunctions == 0 || !CGMODEL_ACCESS("CGModel.System.IsModelScopedSLFcn", thisSystem.SystemIdx)
        %return TLC_FALSE
    %endif
    %assign fcnIdx = CGMODEL_ACCESS("CGModel.getSlFcnIdxForSystemIdx",thisSystem.SystemIdx)
    %if fcnIdx < 0
        %return TLC_FALSE
    %endif
    %assign fcn = SimulinkFunction[fcnIdx]
    %return fcn.IsCalledInThisModel=="no" || fcn.IsConstUncalledFunction =="yes"
%endfunction
%% Function: FcnIsSystemWithReturnValue
%% Abstract:
%% Function determines if Function is eligible for return value or not
%%
%function FcnIsSystemWithReturnValue(thisSystem, sysFcn, SLObjectType, portIdx) void
    %assign cTID = thisSystem.CurrentTID
    %return ISFIELD(thisSystem, "RTWSystemWithReturnValue") && ...
        EXISTS(portIdx) && !FcnIsUnCalledScopedSlFcn(thisSystem) && ...
        thisSystem.RTWSystemReturnArgIndex == portIdx && ...
        SLObjectType == "Outport" && ...
        (sysFcn == "OutputUpdate" || sysFcn == "Output") && ...
        (!SLibModelWideEventTID(cTID) || LibIsSingleRateSystem(thisSystem))
%endfunction
%% Function: FcnAddParametersAndReturn =============================================================
%% Abstract:
%%   This function adds the needed parameters and return to the function
%%   prototype, e.g. "u0, u1, localB, ..."
%%   refer to GetFunctionStr for the order of parameters.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%% TopTester: test/toolbox/simulink/variants/var-inline-general/tIVfcnCall_neg.m
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tMdlRefWithFcnOnDataAsVSSChoice.m
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%% TopTester: test/toolbox/simulink/blocks/tconcat.m
%% TopTester: test/toolbox/simulink/blocks/lib_Sources/Ground/rtw/tStringSupport.m
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tmVariantsRSim.m-tmg1078041_VC1.m
%% TopTester: test/toolbox/rtw/targets/ert/dynamicarrays/smoke/asml/tScheduler.m
%%
%function FcnAddParametersAndReturn(sysFcn, fcnName, sysIdx, isRGSLF) void
    %assign int32Type = LibGetDataTypeNameFromId(::CompiledModel.tSS_INT32)
    %assign booleanType = LibGetDataTypeNameFromId(::CompiledModel.tSS_BOOLEAN)
    %assign realType = LibGetDataTypeNameFromId(::CompiledModel.tSS_DOUBLE)
    %assign thisSystem = ::CompiledModel.System[sysIdx]
    %assign thisModule = ...
        ::CompiledModel.RTWCGModules.RTWCGModule[thisSystem.CGIRModuleIdx]
    %assign hasReusableInterface = thisModule.SimplifiedInterface || SLibGetUseRTMcgType()
    %assign cTID = thisSystem.CurrentTID
    %% For async rate grouping, want arg access tracked by TID, so set isRG to true
    %assign isRG = SLibSystemFcnPeriodicRateGrouping(thisSystem, sysFcn) || ...
        SLibIsExplicitTaskingExportFcnRateGrouping(sysFcn, cTID)

    %if (sysFcn == "OutputUpdate") && SLibFcnProtoCtrlActive() && ...
        IsModelReferenceBaseSys(thisSystem) && !SLibModelWideEventTID(cTID)

        %assign FPC = FcnGetFunctionPrototypeRecord()
    %else
        %assign FPC = []
    %endif
    %assign thisFcn  = []
    %assign isCPPDefaultClassForMdlrefRGOutput = TLC_FALSE
    %if sysFcn == "OutputUpdate" && ...
        GenerateClassInterface && ...
        !LibAsynchronousTriggeredTID(cTID) && ...
        IsModelReferenceBaseSys(thisSystem)  && ...
        !(LibAsynchronousTriggeredTID(cTID) || SLibExplicitPeriodicInExportFcnDiagram(cTID))

        %assign FPC = FcnGetRTWCPPStepPrototypeRecord()
        %assign isCPPDefaultClassForMdlrefRGOutput = SLibIsCPPModelRefStepVoidVoid()
    %endif
    %assign hasFPC = !ISEMPTY(FPC)

    %with thisSystem.Interface
        %%
        %% The following TLC code is used to create the agrument defintions for
        %% CGIR function arguments and transfer the CGIR argument tracking
        %% information to the legacy TLC tracking infrastructure.
        %%
        %%
        %% FPC uses a fixed argument set which doesn't need to be extended in TLC
        %% since the IR defenition is already complete. This is also true of
        %% rate grouped Simulink functions.
        %%
        %if (hasFPC && !isCPPDefaultClassForMdlrefRGOutput) || isRGSLF
            %assign skipCanInput = ...
                Vector(%<NumCanonicalInputArgDefs>) [1@%<NumCanonicalInputArgDefs>]
            %assign skipCanOutput = ...
                Vector(%<NumCanonicalOutputArgDefs>) [1@%<NumCanonicalOutputArgDefs>]
        %else
            %assign skipCanInput = ...
                Vector(%<NumCanonicalInputArgDefs>) [0@%<NumCanonicalInputArgDefs>]
            %assign skipCanOutput = ...
                Vector(%<NumCanonicalOutputArgDefs>) [0@%<NumCanonicalOutputArgDefs>]
        %endif
        %assign skipCanDWork = ...
            Vector(%<NumCanonicalDWorkArgDefs>) [0@%<NumCanonicalDWorkArgDefs>]
        %assign skipCanParam = ...
            Vector(%<NumCanonicalPrmArgDefs>) [0@%<NumCanonicalPrmArgDefs>]
        %assign skipRTM = SLibGenSubsysFcnAsClassMemFcn(thisSystem)
        %assign skipHStructArgs = LibSystemIsNonReusedFcn(thisSystem)
        %assign skipLocalB = skipHStructArgs || hasReusableInterface
        %assign skipLocalC = skipHStructArgs
        %assign skipLocalDW = skipHStructArgs || hasReusableInterface
        %assign skipLocalP = skipHStructArgs || hasReusableInterface
        %assign skipLocalX = skipHStructArgs
        %assign skipLocalXdot = skipHStructArgs
        %assign skipLocalXdis = skipHStructArgs
        %assign skipLocalXabstol = skipHStructArgs
        %assign skipLocalXperturbmin = skipHStructArgs
        %assign skipLocalXperturbmax = skipHStructArgs
        %assign skipLocalZCSV = skipHStructArgs
        %assign skipLocalZCE = skipHStructArgs || hasReusableInterface

        %assign skipLocalDataGroup = ...
            Vector(%<::CompiledModel.NumCoderDataGroups>) [%<skipHStructArgs>@%<::CompiledModel.NumCoderDataGroups>]

        %if ISFIELD(thisModule, "SystemFunctions") && ...
            ISFIELD(thisModule.SystemFunctions, fcnName)
            %assign fcnIndex = GETFIELD(thisModule.SystemFunctions, fcnName)
            %assign thisFcn  = thisModule.Function[fcnIndex]
            %% Cache the module condition of the function into the function record.
            %% Later this will be used to guard the function declaration and
            %% definition.
            %if ISFIELD(thisFcn, "ModuleIfCondition")

                %assign ::FcnRec.ModuleIfCondition = thisFcn.ModuleIfCondition
                %assign ::FcnRec.ModuleEndIfCondition = thisFcn.ModuleEndIfCondition

            %endif
            %% Cache the entry point function's variant condition into the function record.
            %% Later this will be used to guard the function declaration and definition.
            %if ISFIELD(thisFcn, "FcnTIDCGVCEIfCondition")

                %assign ::FcnRec.FcnTIDCGVCEIfCondition = thisFcn.FcnTIDCGVCEIfCondition
                %assign ::FcnRec.FcnTIDCGVCEEndIfCondition = thisFcn.FcnTIDCGVCEEndIfCondition

            %endif

            %%
            %% Subfunction are fully defined in IR and do not use this infrastructure
            %%
            %if fcnIndex >= thisModule.NumSubFunctions
                %assign cgirParams = REGEXPREP( thisFcn.ProtoType, "^[^\(]*\(", "")
                %if !ISEMPTY(cgirParams)
                    %if !WHITE_SPACE(::FcnRec.Params)
                        %assign ::FcnRec.Params = ::FcnRec.Params + "," + cgirParams
                    %else
                        %assign ::FcnRec.Params = ::FcnRec.Params + cgirParams
                    %endif
                    %if hasFPC && FPC.NumArgSpecData > 0 && ...
                        FPC.ArgSpecData[0].SLObjectType == "Outport" && ...
                        FPC.ArgSpecData[0].Category == "Value"
                        %assign portIdx = FPC.ArgSpecData[0].PortNum
                        %assign eo = ExternalOutputs.ExternalOutput[portIdx]
                        %assign dataType = SLibGetRecordDataTypeName(eo, "")
                        %assign ::FcnRec.Returns = dataType
                    %endif
                    %assign hasFPC = TLC_FALSE
                    %assign FPC = []
                %endif
            %endif
            %assert SIZE(thisFcn.ArgAccessed, 1) == thisFcn.NumArgs
            %assert SIZE(thisFcn.ArgSource, 1) == thisFcn.NumArgs
            %%
            %% Transfer the access flags from exported graphical functions to entry
            %% function model arguments, based on a call graph pattern
            %% (MdlRefChildFcnNames) that has been pre computed in IR.
            %%
            %foreach childFcnIdx=SIZE(thisFcn.MdlRefChildFcnNames, 1)
                %assign childFcnName = thisFcn.MdlRefChildFcnNames[childFcnIdx]
                %foreach canInpIdx = NumCanonicalInputArgDefs
                    %assign canInputRecord = CanonicalInputArgDef[canInpIdx]
                    %if SysFcnArgNeeded(childFcnName, canInputRecord, cTID, isRG)
                        %<SLibAccessArgGlobally(canInputRecord, sysFcn, cTID, isRG)>
                    %endif
                %endforeach
                %foreach canOutpIdx = NumCanonicalOutputArgDefs
                    %assign canOutputRecord = CanonicalOutputArgDef[canOutpIdx]
                    %if SysFcnArgNeeded(childFcnName, canOutputRecord, cTID, isRG)
                        %<SLibAccessArgGlobally(canOutputRecord, sysFcn, cTID, isRG)>
                    %endif
                %endforeach
                %foreach canDwIdx = NumCanonicalDWorkArgDefs
                    %assign canDWorkRecord = CanonicalDWorkArgDef[canDwIdx]
                    %if SysFcnArgNeeded(childFcnName, canDWorkRecord, cTID, isRG)
                        %<SLibAccessArgGlobally(canDWorkRecord, sysFcn, cTID, isRG)>
                    %endif
                %endforeach
                %foreach canPrmIdx = NumCanonicalPrmArgDefs
                    %assign canPrmRecord = CanonicalPrmArgDef[canPrmIdx]
                    %if SysFcnArgNeeded(childFcnName, canPrmRecord, cTID, isRG)
                        %<SLibAccessArgGlobally(canPrmRecord, sysFcn, cTID, isRG)>
                    %endif
                %endforeach
                %if SysFcnArgNeeded(childFcnName, RTMArgDef, cTID, isRG)
                    %<SLibAccessArgGlobally(RTMArgDef, sysFcn, cTID, isRG)>
                %endif
                %%
                %if SysFcnArgNeeded(childFcnName, BlockIOArgDef, cTID, isRG)
                    %<SLibAccessArgGlobally(BlockIOArgDef, sysFcn, cTID, isRG)>
                %endif
                %if SysFcnArgNeeded(childFcnName, ConstBlockIOArgDef, cTID, isRG)
                    %<SLibAccessArgGlobally(ConstBlockIOArgDef, sysFcn, cTID, isRG)>
                %endif
                %if SysFcnArgNeeded(childFcnName, DWorkArgDef, cTID, isRG)
                    %<SLibAccessArgGlobally(DWorkArgDef, sysFcn, cTID, isRG)>
                %endif
                %if SysFcnArgNeeded(childFcnName, ParameterArgDef, cTID, isRG)
                    %<SLibAccessArgGlobally(ParameterArgDef, sysFcn, cTID, isRG)>
                %endif
                %if SysFcnArgNeeded(childFcnName, ContStatesArgDef, cTID, isRG)
                    %<SLibAccessArgGlobally(ContStatesArgDef, sysFcn, cTID, isRG)>
                %endif
                %if SysFcnArgNeeded(childFcnName, ContStatesDerivativeArgDef, cTID, isRG)
                    %<SLibAccessArgGlobally(ContStatesDerivativeArgDef, sysFcn, cTID, isRG)>
                %endif
                %if SysFcnArgNeeded(childFcnName, ContStatesDisabledArgDef, cTID, isRG)
                    %<SLibAccessArgGlobally(ContStatesDisabledArgDef, sysFcn, cTID, isRG)>
                %endif
                %if SysFcnArgNeeded(childFcnName, ContStatesAbsoluteToleranceArgDef, cTID, isRG)
                    %<SLibAccessArgGlobally(ContStatesAbsoluteToleranceArgDef, sysFcn, cTID, isRG)>
                %endif

                %if SysFcnArgNeeded(childFcnName, ContStatesPerturbMinArgDef, cTID, isRG)
                    %<SLibAccessArgGlobally(ContStatesPerturbMinArgDef, sysFcn, cTID, isRG)>
                %endif

                %if SysFcnArgNeeded(childFcnName, ContStatesPerturbMaxArgDef, cTID, isRG)
                    %<SLibAccessArgGlobally(ContStatesPerturbMaxArgDef, sysFcn, cTID, isRG)>
                %endif

                %if SysFcnArgNeeded(childFcnName, ZCSVArgDef, cTID, isRG)
                    %<SLibAccessArgGlobally(ZCSVArgDef, sysFcn, cTID, isRG)>
                %endif
                %if SysFcnArgNeeded(childFcnName, ZCEventArgDef, cTID, isRG)
                    %<SLibAccessArgGlobally(ZCEventArgDef, sysFcn, cTID, isRG)>
                %endif
                %% Handling of data groups
                %foreach gIdx = ::CompiledModel.NumCoderDataGroups
                    %assign argDef = FcnGetGroupArgDef(gIdx)
                    %if SysFcnArgNeeded(sysFcn, argDef, cTID, isRG)
                        %<SLibAccessArgGlobally(argDef, sysFcn, cTID, isRG)>
                    %endif
                %endforeach

                %%
            %endforeach
            %%
            %foreach argIdx=thisFcn.NumArgs
                %if thisFcn.ArgAccessed[argIdx] > 0
                    %assign idNum = SLibSafeIDNUM(thisFcn.ArgSource, argIdx)
                    %assign argSrc = idNum[0]
                    %assign argSrcIdx = idNum[1]
                    %switch argSrc
                      %case "I" %% canonical input
                        %if 0 < NumCanonicalInputArgDefs && !isRGSLF %% CrossNoArgFcnBound
                            %assign skipCanInput[argSrcIdx] = 1
                            %assign canInputRecord = CanonicalInputArgDef[argSrcIdx]
                            %<SLibAccessArg(canInputRecord, sysFcn, cTID, isRG)>
                        %endif
                        %break
                      %case "O" %% canonical output
                        %if 0 < NumCanonicalOutputArgDefs && !isRGSLF %% CrossNoArgFcnBound
                            %assign skipCanOutput[argSrcIdx] = 1
                            %assign canOutputRecord = CanonicalOutputArgDef[argSrcIdx]
                            %<SLibAccessArg(canOutputRecord, sysFcn, cTID, isRG)>
                        %endif
                        %break
                      %case "D" %% canonical dwork
                        %if 0 < NumCanonicalDWorkArgDefs %% CrossNoArgFcnBound
                            %assign skipCanDWork[argSrcIdx] = 1
                            %assign canDWorkRecord = CanonicalDWorkArgDef[argSrcIdx]
                            %<SLibAccessArg(canDWorkRecord, sysFcn, cTID, isRG)>
                        %endif
                        %break
                      %case "P" %% canonical parameters
                        %if 0 < NumCanonicalPrmArgDefs && !isRGSLF %% CrossNoArgFcnBound
                            %assign skipCanParam[argSrcIdx] = 1
                            %assign canParamRecord = CanonicalPrmArgDef[argSrcIdx]
                            %<SLibAccessArg(canParamRecord, sysFcn, cTID, isRG)>
                        %elseif LibIsServer(thisSystem) || isRGSLF
                            %%
                            %% cache this parameter argument in model start
                            %%
                            %<SLibAccessMdlRefCanParam(argSrcIdx, "Start")>
                        %endif
                        %break
                      %case "RTM"
                        %assign skipRTM = 1
                        %break
                      %case "LCDG"
                        %% Here, argSrcIdx refers to the index of the coder data group
                        %if 0 == skipLocalDataGroup[argSrcIdx] %% CrossNoArgFcnBound
                            %assign skipLocalDataGroup[argSrcIdx] = 1
                            %assign argDef = FcnGetGroupArgDef(argSrcIdx)
                            %<SLibAccessArg(argDef, sysFcn, cTID, isRG)>
                        %endif
                        %break
                      %case "LB" %% block IO
                        %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                            %assign skipLocalB = 1
                            %<SLibAccessArg(BlockIOArgDef, sysFcn, cTID, isRG)>
                        %endif
                        %break
                      %case "LC" %% constat block IO
                        %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                            %assign skipLocalC = 1
                            %<SLibAccessArg(ConstBlockIOArgDef, sysFcn, cTID, isRG)>
                        %endif
                        %break
                      %case "LW" %% dwork
                        %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                            %assign skipLocalDW = 1
                            %<SLibAccessArg(DWorkArgDef, sysFcn, cTID, isRG)>
                        %endif
                        %break
                      %case "LP"  %% parameter
                      %case "LCP" %% constant parameter
                      %case "LPI" %% const parameter with init
                        %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                            %assign skipLocalP = 1
                            %<SLibAccessArg(ParameterArgDef, sysFcn, cTID, isRG)>
                        %endif
                        %break
                      %case "LX" %% continues states
                        %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                            %assign skipLocalX = 1
                            %<SLibAccessArg(ContStatesArgDef, sysFcn, cTID, isRG)>
                        %endif
                        %break
                      %case "LDX" %% derivatives
                        %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                            %assign skipLocalXdot = 1
                            %<SLibAccessArg(ContStatesDerivativeArgDef, sysFcn, cTID, isRG)>
                        %endif
                        %break
                      %case "LXDI" %% continues state disabled
                        %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                            %assign skipLocalXdis = 1
                            %<SLibAccessArg(ContStatesDisabledArgDef, sysFcn, cTID, isRG)>
                        %endif
                        %break
                      %case "LXAT" %% continues state absolute tolerance
                        %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                            %assign skipLocalXabstol = 1
                            %<SLibAccessArg(ContStatesAbsoluteToleranceArgDef, sysFcn, cTID, isRG)>
                        %endif
                        %break

                      %case "LXPTMIN" %% continues state perturb min
                        %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                            %assign skipLocalXperturbmin = 1
                            %<SLibAccessArg(ContStatesPerturbMinArgDef, sysFcn, cTID, isRG)>
                        %endif
                        %break

                      %case "LXPTMAX" %% continues state perturb max
                        %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                            %assign skipLocalXperturbmax = 1
                            %<SLibAccessArg(ContStatesPerturbMaxArgDef, sysFcn, cTID, isRG)>
                        %endif
                        %break


                      %case "LZ" %% non-sampled zero crossings
                        %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                            %assign skipLocalZCSV = 1
                            %<SLibAccessArg(ZCSVArgDef, sysFcn, cTID, isRG)>
                        %endif
                        %break
                      %case "LZE" %% zero crossing events
                        %if 0 == skipHStructArgs
                            %assign skipLocalZCE = 1
                            %<SLibAccessArg(ZCEventArgDef, sysFcn, cTID, isRG)>
                        %endif
                        %break
                      %case "CPI"
                      %case "TID"
                      %case "X"
                      %case "U"
                      %case "Y" %% root outport not being canonical output, occur in FPC only
                        %break
                      %default
                        %%START_ASSERT
                        %assign errTxt = "Unhandled argument type '%<argSrc>'."
                        %<LibBlockReportError([],errTxt)>
                        %break
                        %%END_ASSERT
                    %endswitch
                %endif
            %endforeach
        %endif

        %if !(GenerateClassInterface && SLibModelWideEventTID(cTID)) && ...
            (LibSystemIsReusedFcn(thisSystem) || ...
            (LibSystemIsNonReusedFcn(thisSystem) && ...
            ISFIELD(thisSystem,"RTWSystemCodeOptIntf")) || ...
            LibIsServer(thisSystem))
            %assign hasArgs = SLibRTWCPPClassPassesArgs(FPC)
            %assign useFPC = hasFPC && hasArgs
            %if !useFPC
                %assign numArgs = NumCanonicalInputArgDefs + NumCanonicalOutputArgDefs
            %else
                %assign numArgs = FPC.NumArgSpecData
            %endif
            %assign isISSReuseDiffNumIters = SLibGetIsForEachSSReuseWithDiffNumIters(thisSystem)

            %foreach argIdx = numArgs
                %if !useFPC
                    %if argIdx < NumCanonicalInputArgDefs
                        %assign portIdx = argIdx
                        %assign SLObjectType = "Inport"
                    %else
                        %assign portIdx = argIdx - NumCanonicalInputArgDefs
                        %assign SLObjectType = "Outport"
                    %endif
                %else
                    %assign portIdx = FPC.ArgSpecData[argIdx].PortNum
                    %assign SLObjectType = FPC.ArgSpecData[argIdx].SLObjectType
                %endif
                %%
                %% Canonical input argument
                %%
                %if SLObjectType == "Inport"
                    %if useFPC || ...
                        (!skipCanInput[portIdx] && ...
                        SysFcnArgNeeded(sysFcn, CanonicalInputArgDef[portIdx], cTID, isRG))
                        %assign skipThisArg = 0
                        %assign ci = CanonicalInputArgDef[portIdx]
                        %if !useFPC
                            %if ISFIELD(ci,"VarGroupIdx") && SLibGetDoesSelfExist() && SLibIsSelfStructured()
                                %% accessed through rtm make sure instance specific rtm is added to definition
                                %<SLibAccessArg(RTMArgDef,sysFcn, cTID, isRG)>
                            %endif
                            %if IDNUM(ci.SignalSrc[0])[0] == "F"
                                %assign skipThisArg = 1
                            %endif
                            %assign dataType = SLibGetRecordDataTypeName(ci, "")
                            %assign width = LibGetRecordWidth(ci)
                            %assign optWidth = LibOptionalVectorWidth(width)
                        %else
                            %assign ei = ExternalInputs.ExternalInput[portIdx]
                            %assign dataType = SLibGetRecordDataTypeName(ei, "")
                            %assign width = LibGetRecordWidth(ei)
                            %assign optWidth = LibOptionalVectorWidth(width)
                        %endif

                        %if skipThisArg==0
                            %if !useFPC
                                %assign passByPtr = FcnPassCanonicalInputByPtr(ci)
                                %assign passConst = FcnPassCanonicalInputAsConst(sysIdx, ci) || ...
                                    (GenerateClassInterface && IsModelReferenceBaseSys(thisSystem) && passByPtr && sysFcn == "Start")
                                %assign optConst = passConst ? "const " : ""
                                %assign optStar  = passByPtr ? "*" : ""
                                %if SLibGetCanIOIsVarDims(ci) || isISSReuseDiffNumIters && !ISEMPTY(optWidth)
                                    %% Always pass pointer for var-dims signal or Implicit Iterator
                                    %% subsystem reused for different number of iterations.
                                    %assign argDef = " %<LibGetRecordIdentifier(ci)>[]"
                                %else
                                    %assign argDef = "%<optStar>%<LibGetRecordIdentifier(ci)>%<optWidth>"
                                %endif
                            %else
                                %assign passByPtr = FPC.ArgSpecData[argIdx].Category == "Pointer" && width == 1
                                %% always pass dynamic matrix by reference
                                %assign isReference = (FPC.ArgSpecData[argIdx].Category == "Reference") || LibCGTypeIsCoderArray(ci.CGTypeIdx)
                                %assign qualifier = FPC.ArgSpecData[argIdx].Qualifier
                                %assign argDef = ""
                                %switch qualifier
                                  %case "none"
                                    %assign optConst = ""
                                    %if passByPtr
                                        %assign argDef = "*"
                                    %elseif isReference
                                        %assign argDef = "&"
                                    %endif
                                    %break
                                  %case "const"
                                    %assign optConst = "const "
                                    %assign argDef = ""
                                    %break
                                  %case "const *"
                                    %assign optConst = "const "
                                    %if LibGetRecordWidth(ei) == 1
                                        %assign argDef = "*"
                                    %endif
                                    %break
                                  %case "const * const"
                                    %assign optConst = "const "
                                    %if LibGetRecordWidth(ei) == 1
                                        %assign argDef = "*const "
                                    %endif
                                    %break
                                  %case "const &"
                                    %assign optConst = "const "
                                    %assign argDef = "&"
                                    %break
                                  %default
                                    %assign errTxt = "Unhandled qualifier"
                                    %<LibReportFatalError(errTxt)>
                                    %break
                                %endswitch

                                %if !ISEMPTY(optWidth) && isReference
                                    %assign argDef = ...
                                        "(%<argDef>%<FPC.ArgSpecData[argIdx].ArgName>)%<optWidth>"
                                %else
                                    %assign argDef = ...
                                        "%<argDef>%<FPC.ArgSpecData[argIdx].ArgName>%<optWidth>"
                                %endif
                            %endif
                            %if SLibAutosarCompilerAbstractionRequired()
                                %if SLibGetCanIOIsVarDims(ci) || isISSReuseDiffNumIters
                                    %assign argDef = "%<LibGetRecordIdentifier(ci)>[]"
                                %else
                                    %assign argDef = "%<LibGetRecordIdentifier(ci)>%<optWidth>"
                                %endif
                                %<FcnAddParameterWithCompilerAbstraction(sysIdx, passConst, dataType, passByPtr, argDef)>
                            %elseif dataType != "fcn_call"
                                %assign dataType = "%<optConst>%<dataType> "
                                %<FcnAddParameter(sysIdx, dataType, argDef)>
                            %endif
                        %endif
                        %% Add vardims argument for the canonical input
                        %<FcnAddNeededCanDimSizeDWForCanInp(sysFcn, sysIdx, portIdx, ...
                            skipCanDWork)>
                    %endif %% SysFcnArgNeeded

                    %%
                    %% Canonical output arguments
                %else
                    %if useFPC || ...
                        (!skipCanOutput[portIdx] && ...
                        SysFcnArgNeeded(sysFcn, CanonicalOutputArgDef[portIdx], cTID, isRG))
                        %if !useFPC
                            %assign       co = CanonicalOutputArgDef[portIdx]
                            %if ISFIELD(co,"VarGroupIdx") && SLibGetDoesSelfExist() && SLibIsSelfStructured()
                                %% accessed through rtm make sure instance specific rtm is added to definition
                                %<SLibAccessArg(RTMArgDef,sysFcn, cTID, isRG)>
                            %endif
                            %assign dataType = SLibGetRecordDataTypeName(co, "")
                            %assign   identi = LibGetRecordIdentifier(co)
                            %% Pass dynamic array by reference in output port
                            %assign isReference = LibCGTypeIsCoderArray(co.CGTypeIdx)
                            %assign  optStarOrRef = isReference ? " &" : ...
                                (LibGetRecordWidth(co) == 1 ? " *" : " ")
                            %assign optWidth = LibOptionalVectorWidth(LibGetRecordWidth(co))
                            %if SLibAutosarCompilerAbstractionRequired()
                                %if SLibGetCanIOIsVarDims(co) || isISSReuseDiffNumIters
                                    %% Always pass pointer for var-dims signal or Implicit Iterator
                                    %% subsystem reused for different number of iterations.
                                    %assign argDef = " " + identi + "[]"
                                %else
                                    %assign argDef = identi + optWidth
                                %endif
                                %<FcnAddParameterWithCompilerAbstraction(sysIdx, TLC_FALSE, dataType, (LibGetRecordWidth(co) == 1), argDef)>
                            %else
                                %if SLibGetCanIOIsVarDims(co) || isISSReuseDiffNumIters
                                    %% Always pass pointer for var-dims signal or Implicit Iterator
                                    %% subsystem reused for different number of iterations.
                                    %assign argDef = " " + identi + "[]"
                                %else
                                    %assign argDef = optStarOrRef + identi + optWidth
                                %endif
                                %<FcnAddParameter(sysIdx, dataType, argDef)>
                            %endif
                        %else
                            %assign eo = ExternalOutputs.ExternalOutput[portIdx]
                            %assign dataType = SLibGetRecordDataTypeName(eo, "")
                            %if FPC.ArgSpecData[argIdx].Category == "Value"
                                %assign ::FcnRec.Returns = dataType
                            %else
                                %assign   identi = FPC.ArgSpecData[argIdx].ArgName
                                %assign   isReference = (FPC.ArgSpecData[argIdx].Category == "Reference") || ...
                                    LibCGTypeIsCoderArray(eo.CGTypeIdx)
                                %assign   optStarOrRef = isReference ? " &" : ...
                                    (LibGetRecordWidth(eo) == 1 ? " *" : " ")
                                %assign optWidth = LibOptionalVectorWidth(LibGetRecordWidth(eo))
                                %if !ISEMPTY(optWidth) && isReference
                                    %assign argDef = "(" + optStarOrRef + identi +")" + optWidth
                                %else
                                    %assign argDef = optStarOrRef + identi + optWidth
                                %endif
                                %% SLibAutosarCompilerAbstractionRequired() not supported for FPC
                                %<FcnAddParameter(sysIdx, dataType, argDef)>
                            %endif
                        %endif
                        %% Add vardims argument for the canonical output
                        %% Function FinalizeDims and SetDims only need canonical dim-size
                        %% dwork. They don't need canonical output.
                        %<FcnAddNeededCanDimSizeDWForCanOut(sysFcn, sysIdx, portIdx, ...
                            skipCanDWork)>
                    %endif

                    %if !useFPC
                        %if FcnIsSystemWithReturnValue(thisSystem, sysFcn, SLObjectType, portIdx)
                            %assign dataType =SLibGetRecordDataTypeName(CanonicalOutputArgDef[portIdx],"")
                            %assign ::FcnRec.Returns = dataType
                        %endif
                    %endif

                %endif
            %endforeach

            %%
            %% Is a model reference scalable build - some args are accessed as globals
            %% Skip these args.
            %%
            %assign isScalableMRSys = ...
                IsModelReferenceBaseSys(thisSystem) && IsModelRefScalableBuild()

            %% Is a model reference build and in C++ encapsulation mode
            %assign isCPPEncapMdlRef = GenerateClassInterface && ...
                IsModelReferenceBaseSys(thisSystem)
            %%
            %% rtModel argument
            %%
            %if ISFIELD(thisModule,"SystemFunctions") && ISFIELD(thisModule.SystemFunctions, fcnName)
                %assign fcnIdx = thisModule.SystemFunctions.%<fcnName>
                %assign fcn = thisModule.Function[fcnIdx]
                %assign isOutlinedBlockFcn = fcn.IsOutlinedBlockFcn
            %else
                %assign isOutlinedBlockFcn = TLC_FALSE
            %endif
            %assign isServiceFcn = TLC_FALSE
            %% Simulink functions that are services have all their local vars defined in IR
            %% so no need to add them in TLC. Skip FcnCacheServiceFcnLocalVars for
            %% those service functions.
            %if !ISEMPTY(thisFcn) && thisFcn.IsServiceFcn && !SLibIsRateGroupedSLFcn(thisSystem, sysFcn, cTID)
                %<FcnCacheServiceFcnLocalVars(thisSystem, sysFcn, cTID, isRG)>
                %assign isServiceFcn = TLC_TRUE
            %endif
            %assign isMatchGrInterface = (LibSystemIsNonReusedFcn(thisSystem) && ...
                ISFIELD(thisSystem,"RTWSystemMatchGrInterface"))
            %if !isCPPEncapMdlRef && !(LibIsServer(thisSystem) && thisModule.SimplifiedInterface) && (skipRTM || (SysFcnArgNeeded(sysFcn, RTMArgDef, cTID, isRG) && !isMatchGrInterface))
                %if isScalableMRSys && !::CompiledModel.ModelRefSimpInterface
                    %if !isServiceFcn && (!SLibIsSelfInPluggableInterface())
                        %openfile localRTMVar
                        %assign rtmField = ".rtm"
                        %<::tSimStructType> *const %<::tSimStruct> = &(%<FcnGetSFcnDWorkIdentifier(thisSystem)>%<rtmField>);
                        %closefile localRTMVar
                        %<FcnCacheModelRefLocalVars(thisSystem, sysFcn, cTID, localRTMVar)>
                    %endif
                %elseif LibIsServer(thisSystem) && !thisModule.SimplifiedInterface && SLibIsSelfInSimTarget()
                    %openfile localRTMVar
                    %<::tSimStructType> *const %<::tSimStruct> = &(%<FcnGetSFcnDWorkRTM()>);
                    %closefile localRTMVar
                    %<LibAddToSystemField(thisSystem, "Cached%<sysFcn>%<cTID>LocalBO", localRTMVar)>
                %elseif !skipRTM && !isOutlinedBlockFcn
                    %if thisModule.SimplifiedInterface
                        %<FcnPrependParameter(sysIdx, ::tSimStructType, " *const %<SLibGetSimStruct()>")>
                    %else
                        %<FcnAddParameter(sysIdx, ::tSimStructType, " *const %<SLibGetSimStruct()>")>
                    %endif
                %endif
            %endif %% SysFcnArgNeeded
            %%
            %% Block IO argument
            %%
            %if !skipLocalB  && !isCPPEncapMdlRef && SysFcnArgNeeded(sysFcn, BlockIOArgDef, cTID, isRG)
                %assign dataType = FcnSysVarGroupType(thisSystem,"BlockIO") + " "
                %if !isScalableMRSys
                    %if SLibAutosarCompilerAbstractionRequired()
                        %assign dataType = FcnSysVarGroupType(thisSystem,"BlockIO")
                        %<FcnAddParameterWithCompilerAbstraction(sysIdx, TLC_FALSE, dataType, TLC_TRUE, "localB")>
                    %else
                        %<FcnAddParameter(sysIdx, dataType, "*localB")>
                    %endif
                %endif
            %endif %% SysFcnArgNeeded
            %%
            %% DataGroup arguments - only do this for non-model reference base systems
            %%
            %if !IsModelReferenceBaseSys(thisSystem) && !thisModule.SimplifiedInterface
                %foreach gIdx = ::CompiledModel.NumCoderDataGroups
                    %assign argDef = FcnGetGroupArgDef(gIdx)
                    %if !(skipLocalDataGroup[gIdx]) && !isCPPEncapMdlRef && SysFcnArgNeeded(sysFcn, argDef, cTID, isRG)
                        %assign group = ::CompiledModel.CoderDataGroup[gIdx]
                        %assign groupToken = "CoderDataGroup" + group.Name
                        %assign dataType = FcnSysVarGroupType(thisSystem, groupToken) + " "
                        %assign varGroupIdx = FcnSysVarGroupIndex(thisSystem, groupToken, 0)
                        %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
                        %assign varName = varGroup.LocalName

                        %if !isScalableMRSys
                            %if SLibAutosarCompilerAbstractionRequired()
                                %assign dataType = FcnSysVarGroupType(thisSystem, groupToken)
                                %<FcnAddParameterWithCompilerAbstraction(sysIdx, TLC_FALSE, dataType, TLC_TRUE, varName)>
                            %else
                                %assign localString = "*" + varName
                                %<FcnAddParameter(sysIdx, dataType, localString)>
                            %endif
                        %endif
                    %endif
                %endforeach
            %endif
            %%
            %% Constant block IO argument
            %%
            %if !skipLocalC && !isCPPEncapMdlRef && SysFcnArgNeeded(sysFcn, ConstBlockIOArgDef, cTID, isRG)
                %assert !isScalableMRSys
                %if SLibAutosarCompilerAbstractionRequired()
                    %assign dataType = FcnSysVarGroupType(thisSystem,"ConstBlockIO")
                    %<FcnAddParameterWithCompilerAbstraction(sysIdx, TLC_FALSE, dataType, TLC_TRUE, "localC")>
                %else
                    %assign dataType = FcnSysVarGroupType(thisSystem,"ConstBlockIO") + " "
                    %<FcnAddParameter(sysIdx, dataType, "*localC")>
                %endif
            %endif %% SysFcnArgNeeded
            %%
            %% DWork argument
            %%
            %if !skipLocalDW && !isCPPEncapMdlRef && SysFcnArgNeeded(sysFcn, DWorkArgDef, cTID, isRG)
                %assign varGroupType = FcnSysVarGroupType(thisSystem,"DWork")
                %if !isScalableMRSys
                    %if SLibAutosarCompilerAbstractionRequired()
                        %assign dataType = varGroupType
                        %<FcnAddParameterWithCompilerAbstraction(sysIdx, TLC_FALSE, dataType, TLC_TRUE, "localDW")>
                    %else
                        %assign dataType = varGroupType + " "
                        %<FcnAddParameter(sysIdx, dataType, "*localDW")>
                    %endif
                %endif
            %endif %% SysFcnArgNeeded
            %%
            %% Parameter H-Struct argument
            %%
            %assign isSysFcnArgNeeded = SysFcnArgNeeded(sysFcn, ParameterArgDef, cTID, isRG)
            %if !skipLocalP && isSysFcnArgNeeded
                %%
                %% Does a passthrough parameter structure argument exists ?
                %%
                %assert( !isScalableMRSys || IsModelReferenceInlineOffTarget())
                %if (InlineParameters != 0 && ParameterArgDef.PassthroughSystemIdx > -1)
                    %assign prmSysIdx = ParameterArgDef.PassthroughSystemIdx
                %else
                    %assign prmSysIdx = sysIdx
                %endif
                %assign numsys = GetNumSystemsForCodeGen()
                %if prmSysIdx < numsys-1 %% not the root system
                    %if SLibAutosarCompilerAbstractionRequired()
                        %assign dataType = FcnSysVarGroupType(System[prmSysIdx],"Parameter")
                        %<FcnAddParameterWithCompilerAbstraction(sysIdx, TLC_FALSE, dataType, TLC_TRUE, "localP")>
                    %else
                        %assign dataType = FcnSysVarGroupType(System[prmSysIdx],"Parameter") + " "
                        %<FcnAddParameter(sysIdx, dataType, "*localP")>
                    %endif
                %else
                    %%
                    %% The child function has the root parameter structure as
                    %% a passthrough argument
                    %%
                    %if SLibAutosarCompilerAbstractionRequired()
                        %assign dataType = ::tParametersType
                        %<FcnAddParameterWithCompilerAbstraction(sysIdx, TLC_FALSE, dataType, TLC_TRUE, LibGetParametersStruct())>
                    %elseif !(GenerateClassInterface && IsModelReferenceBaseSys(thisSystem))
                        %assign dataType = ::tParametersType + " "
                        %<FcnAddParameter(sysIdx, dataType, "*%<LibGetParametersStruct()>")>
                    %endif

                %endif
            %endif %% SysFcnArgNeeded
            %%
            %% Continuous States argument
            %%
            %if !skipLocalX && SysFcnArgNeeded(sysFcn, ContStatesArgDef, cTID, isRG)
                %assign dataType = isScalableMRSys ? "%<realType> " : ...
                    "%<FcnSysVarGroupType(thisSystem,"ContStates")> "
                %assign paramName= isScalableMRSys ? "*localX_" : "*localX"
                %assert !isCPPEncapMdlRef
                %<FcnAddParameter(sysIdx, dataType, paramName)>
                %if isScalableMRSys
                    %openfile localCStateVar
                    %assign varGroupType = FcnSysVarGroupType(thisSystem,"ContStates")
                    %<varGroupType> *localX = (%<varGroupType> *) localX_;
                    %closefile localCStateVar
                    %<FcnCacheModelRefLocalVars(thisSystem, sysFcn, cTID, localCStateVar)>
                %endif
            %endif
            %%
            %% Continuous States Derivative argument
            %%
            %if !skipLocalXdot && SysFcnArgNeeded(sysFcn, ContStatesDerivativeArgDef, cTID, isRG)
                %assign dataType = isScalableMRSys ? "%<realType> " : "%<FcnSysVarGroupType(thisSystem,"ContStatesDerivative")> "
                %assign paramName= isScalableMRSys ? "*localXdot_" : "*localXdot"
                %assert !isCPPEncapMdlRef
                %% SLibAutosarCompilerAbstraction not needed for continuous states
                %<FcnAddParameter(sysIdx, dataType, paramName)>
                %if isScalableMRSys
                    %openfile localCStateVar
                    %assign varGroupType = FcnSysVarGroupType(thisSystem,"ContStatesDerivative")
                    %<varGroupType> *localXdot = (%<varGroupType> *) localXdot_;
                    %closefile localCStateVar
                    %<FcnCacheModelRefLocalVars(thisSystem, sysFcn, cTID, localCStateVar)>
                %endif
            %endif
            %%
            %% Continuous States Disabled argument
            %%
            %if !skipLocalXdis && SysFcnArgNeeded(sysFcn, ContStatesDisabledArgDef, cTID, isRG)
                %assign dataType = isScalableMRSys ? "%<booleanType> " : "%<FcnSysVarGroupType(thisSystem,"ContStatesDisabled")> "
                %assign paramName= isScalableMRSys ? "*localXdis_" : "*localXdis"
                %assert !isCPPEncapMdlRef
                %% SLibAutosarCompilerAbstraction not needed for continuous states
                %<FcnAddParameter(sysIdx, dataType, paramName)>
                %if isScalableMRSys
                    %openfile localCStateVar
                    %assign varGroupType = FcnSysVarGroupType(thisSystem,"ContStatesDisabled")
                    %<varGroupType> *localXdis = (%<varGroupType> *) localXdis_;
                    %closefile localCStateVar
                    %<FcnCacheModelRefLocalVars(thisSystem, sysFcn, cTID, localCStateVar)>
                %endif
            %endif
            %%
            %% Continuous States Absolute Tolerance argument
            %%
            %if !skipLocalXabstol && SysFcnArgNeeded(sysFcn, ContStatesAbsoluteToleranceArgDef, cTID, isRG)
                %assign dataType = isScalableMRSys ? "%<realType> " : ...
                    "%<FcnSysVarGroupType(thisSystem,"ContStatesAbsoluteTolerance")> "
                %assign paramName= isScalableMRSys ? "*localXAbsTol_" : "*localXAbsTol"
                %assert !isCPPEncapMdlRef
                %% SLibAutosarCompilerAbstraction not needed for continuous states
                %<FcnAddParameter(sysIdx, dataType, paramName)>
                %if isScalableMRSys
                    %openfile localCStateVar
                    %assign varGroupType = FcnSysVarGroupType(thisSystem,"ContStatesAbsoluteTolerance")
                    %<varGroupType> *localXAbsTol = (%<varGroupType> *) localXAbsTol_;
                    %closefile localCStateVar
                    %<FcnCacheModelRefLocalVars(thisSystem, sysFcn, cTID, localCStateVar)>
                %endif
            %endif
            %%

            %% Continuous States Perturb Min argument
            %%
            %if !skipLocalXperturbmin && SysFcnArgNeeded(sysFcn, ContStatesPerturbMinArgDef, cTID, isRG)
                %assign dataType = isScalableMRSys ? "%<realType> " : ...
                    "%<FcnSysVarGroupType(thisSystem,"ContStatesPerturbMin")> "
                %assign paramName= isScalableMRSys ? "*localXPerturbMin_" : "*localXPerturbMin"
                %assert !isCPPEncapMdlRef
                %% SLibAutosarCompilerAbstraction not needed for continuous states
                %<FcnAddParameter(sysIdx, dataType, paramName)>
                %if isScalableMRSys
                    %openfile localCStateVar
                    %assign varGroupType = FcnSysVarGroupType(thisSystem,"ContStatesPerturbMin")
                    %<varGroupType> *localXPerturbMin = (%<varGroupType> *) localXPerturbMin_;
                    %closefile localCStateVar
                    %<FcnCacheModelRefLocalVars(thisSystem, sysFcn, cTID, localCStateVar)>
                %endif
            %endif

            %%
            %% Continuous States Perturb Max argument
            %%
            %if !skipLocalXperturbmax && SysFcnArgNeeded(sysFcn, ContStatesPerturbMaxArgDef, cTID, isRG)
                %assign dataType = isScalableMRSys ? "%<realType> " : ...
                    "%<FcnSysVarGroupType(thisSystem,"ContStatesPerturbMax")> "
                %assign paramName= isScalableMRSys ? "*localXPerturbMax_" : "*localXPerturbMax"
                %assert !isCPPEncapMdlRef
                %% SLibAutosarCompilerAbstraction not needed for continuous states
                %<FcnAddParameter(sysIdx, dataType, paramName)>
                %if isScalableMRSys
                    %openfile localCStateVar
                    %assign varGroupType = FcnSysVarGroupType(thisSystem,"ContStatesPerturbMax")
                    %<varGroupType> *localXPerturbMax = (%<varGroupType> *) localXPerturbMax_;
                    %closefile localCStateVar
                    %<FcnCacheModelRefLocalVars(thisSystem, sysFcn, cTID, localCStateVar)>
                %endif
            %endif
            %%



            %% ZcSignalValue  argument
            %%
            %if !skipLocalZCSV && SysFcnArgNeeded(sysFcn,ZCSVArgDef, cTID, isRG)
                %if SLibAutosarCompilerAbstractionRequired()
                    %assign dataType = isScalableMRSys ? realType : "%<FcnSysVarGroupType(thisSystem,"ZCSV")>"
                    %assign paramName= isScalableMRSys ? "localZCSV_" : "localZCSV"
                    %assert !isCPPEncapMdlRef
                    %<FcnAddParameterWithCompilerAbstraction(sysIdx, TLC_FALSE, dataType, TLC_TRUE, paramName)>
                %else
                    %assign dataType = isScalableMRSys ? "%<realType> " : "%<FcnSysVarGroupType(thisSystem,"ZCSV")> "
                    %assign paramName= isScalableMRSys ? "*localZCSV_" : "*localZCSV"
                    %assert !isCPPEncapMdlRef
                    %<FcnAddParameter(sysIdx, dataType, paramName)>
                %endif
                %if isScalableMRSys
                    %openfile localCStateVar
                    %assign varGroupType = FcnSysVarGroupType(thisSystem,"ZCSV")
                    %<varGroupType> *localZCSV = (%<varGroupType> *) localZCSV_;
                    %closefile localCStateVar
                    %<FcnCacheModelRefLocalVars(thisSystem, sysFcn, cTID, localCStateVar)>
                %endif
            %endif
            %%
            %% ZCEvent H-Struct argument
            %if !skipLocalZCE && !isCPPEncapMdlRef && SysFcnArgNeeded(sysFcn, ZCEventArgDef, cTID, isRG)
                %if !isScalableMRSys
                    %if SLibAutosarCompilerAbstractionRequired()
                        %assign dataType = FcnSysVarGroupType(thisSystem,"ZCEvent")
                        %<FcnAddParameterWithCompilerAbstraction(sysIdx, TLC_FALSE, dataType, TLC_TRUE, "localZCE")>
                    %else
                        %assign dataType = FcnSysVarGroupType(thisSystem,"ZCEvent") + " "
                        %<FcnAddParameter(sysIdx, dataType, "*localZCE")>
                    %endif
                %endif
            %endif %% SysFcnArgNeeded
            %%
            %% Coder Data Groups - add RTM to the interface
            %%
            %if IsModelReferenceBaseSys(thisSystem) && !SLibGetUseRTMcgType() && !isOutlinedBlockFcn
                %openfile coderDataGroupVar
                %foreach gIdx = ::CompiledModel.NumCoderDataGroups
                    %assign group = ::CompiledModel.CoderDataGroup[gIdx]
                    %if SLibAccessGroupThroughSelf(group)
                        %assign groupToken = "CoderDataGroup" + group.Name
                        %assign argDef = %<groupToken + "ArgDef">
                        %if SysFcnArgNeeded(sysFcn, argDef, cTID, isRG)
                            %assign varGroupIdx = FcnSysVarGroupIndex(System[sysIdx], groupToken, 0)
                            %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
                            %assign varGroupType = FcnSysVarGroupType(::CompiledModel.System[sysIdx], groupToken)
                            %assign varName = varGroup.LocalName
                            %<SLibTypeQualifierForGroup(group)> %<SLibCoderDataGroupType(group)> *%<varName> = %<SLibGetCoderDataGroupPointerFromRTM(group, 0)>;
                        %endif
                    %endif
                %endforeach
                %closefile coderDataGroupVar
                %if !ISEMPTY(coderDataGroupVar)
                    %<FcnCacheModelRefLocalVars(thisSystem, sysFcn, cTID, coderDataGroupVar)>
                %endif
            %endif
            %%
            %%
            %% Canonical Parameters
            %%
            %foreach argIdx=NumCanonicalPrmArgDefs
                %assign canPrmDef = CanonicalPrmArgDef[argIdx]
                %if !skipCanParam[argIdx] && SysFcnArgNeeded(sysFcn, canPrmDef, cTID, isRG)
                    %assign   identi = LibGetRecordIdentifier(canPrmDef)
                    %assign dataType = SLibGetRecordDataTypeName(canPrmDef, "")
                    %assign    width = LibBlockParameterWidth(canPrmDef)
                    %assign optWidth = LibOptionalVectorWidth(width)
                    %assign declAsPtr = canPrmDef.DeclareAsPointer == "yes"
                    %if SLibAutosarCompilerAbstractionRequired()
                        %assign optConst = ((width > 1) || declAsPtr)
                        %assign optStar  = declAsPtr
                        %assign argDef   = "%<identi>%<optWidth>"
                        %<FcnAddParameterWithCompilerAbstraction(sysIdx, optConst, dataType, optStar, argDef)>
                    %else
                        %assign optConst = ((width > 1) || declAsPtr)  ? "const " : ""
                        %assign dataType = "%<optConst>%<dataType> "
                        %assign optStar  = declAsPtr ? "*" : ""
                        %assign argDef   = "%<optStar>%<identi>%<optWidth>"
                        %<FcnAddParameter(sysIdx, dataType, argDef)>
                    %endif
                %endif %% SysFcnArgNeeded
            %endforeach %% argIdx=NumCanonicalPrmArgDefs
            %%
            %% CanonicalDWork
            %%
            %foreach argIdx = NumCanonicalDWorkArgDefs
                %% Canonical dimsize dwork has already beed added to the
                %% args following the corresponding canonical input/output
                %if !skipCanDWork[argIdx] && !SLibGetCanDWorkIsCanDimSizeDWork(argIdx)
                    %assign canDWork = CanonicalDWorkArgDef[argIdx]
                    %if SysFcnArgNeeded(sysFcn, canDWork, cTID, isRG)
                        %assign dwIdx    = canDWork.FirstSignalSrc %% global idx
                        %assign dwRec    = ::CompiledModel.DWorks.DWork[dwIdx]
                        %assign dwWidth  = SLibDWorkWidth(dwRec)
                        %assign dwId     = LibGetRecordIdentifier(canDWork)
                        %assign dataType = SLibGetRecordDataTypeName(dwRec, "")
                        %%
                        %% Example:
                        %%   Scalar signal: void foo(%<realType> *a)
                        %%   Wide signal:   void foo(%<realType> b[7])
                        %%
                        %if SLibAutosarCompilerAbstractionRequired()
                            %if dwWidth == 1
                                %assign   argDef = "%<dwId>"
                            %else
                                %assign   argDef = "%<dwId>[%<dwWidth>]"
                            %endif
                            %<FcnAddParameterWithCompilerAbstraction(sysIdx, TLC_FALSE, dataType, (dwWidth == 1), argDef)>
                        %else
                            %if dwWidth == 1
                                %assign   argDef = " *%<dwId>"
                            %else
                                %assign   argDef = " %<dwId>[%<dwWidth>]"
                            %endif
                            %<FcnAddParameter(sysIdx, dataType,argDef)>
                        %endif
                    %endif
                %endif %% if !SLibGetCanDWorkIsCanDimSizeDWork
            %endforeach
        %elseif SLibNeedHandleParallelForEachSS(thisSystem, sysFcn)
            %% Add argument (%<int32Type> rtSS_iter) for parallel ForEach Subsystem
            %assign dw = DWorks.DWork[IDNUM(thisSystem.IndexingSigSrc)[1]]
            %if dw.IsLocalScratchDWork == 1
                %assign argDef  = LibGetRecordIdentifier(dw)
                %assign dataType = SLibGetRecordDataTypeName(dw,"") + " "
                %<FcnAddParameter(sysIdx, dataType, argDef)>
            %endif
        %endif
    %endwith
%endfunction

%% Function: FcnGetSfcnFormDefine ==================================================================
%% Abstract:
%%   Return the # define that is needed in front of root model methods in
%%   S-function format
%%
%function FcnGetSfcnFormDefine(sysFcn) void
    %assign retVal = ""
    %switch sysFcn
      %case "Start"
        %assign retVal = "MDL_START"
        %break
      %case "Initialize"
        %assign retVal = "MDL_INITIALIZE_CONDITIONS"
        %break
      %case "Enable"
        %assign retVal = "RTW_GENERATED_ENABLE"
        %break
      %case "Disable"
        %assign retVal = "RTW_GENERATED_DISABLE"
        %break
      %case "Update"
        %assign retVal = "MDL_UPDATE"
        %break
      %case "Derivative"
        %assign retVal = "MDL_DERIVATIVES"
        %break
      %case "ForcingFunction"
        %assign retVal = "MDL_FORCINGFUNCTION"
        %break
      %case "MassMatrix"
        %assign retVal = "MDL_MASSMATRIX"
        %break
      %case "Projection"
        %assign retVal = "MDL_PROJECTION"
        %break
      %case "ZeroCrossing"
        %assign retVal = "MDL_ZERO_CROSSINGS"
        %break
      %default
        %assign retVal = ""
        %break
    %endswitch

    %return retVal
%endfunction %% FcnGetSfcnFormDefine


%% Function: FcnRewriteCast ========================================================================
%% Abstract: This function rewrites a C-style cast for C++ code generation, and
%%           return the original expression for C.
%%
%function FcnRewriteCast(aCast)
    %if ::GenCPP && !::Accelerator
        %return FcnReplaceCCastWithStaticCastForCPP(aCast)
    %else
        %return aCast
    %endif
%endfunction %% FcnRewriteCast

%% Function: FcnUseStaticStorageSpecifier ==========================================================
%% Abstract: Function to determine if static keyword should be prepended to
%%           a subsystem prototype.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function FcnUseStaticStorageSpecifier(system)
    %assign compactFileFormat = SLibIsCompactFileFormat()
    %assign isReusedLibraryFcn = LibSystemIsReusedLibraryFcn(system)
    %assign isExportedSlFcn = SLibIsModelScopedServer(system)
    %assign useStatic = compactFileFormat && ...
        (!LibSystemIsRoot(system) || !(IsModelReferenceBaseSys(system) && IsModelReferenceTarget())) && ...
        !IsModelReferenceTarget() && !LibIsGlobalServer(system) && ...
        !SLibGenSubsysFcnAsClassMemFcn(system) && !isReusedLibraryFcn && ...
        !::CompiledModel.ConfigSet.GenerateTestInterfaces && !isExportedSlFcn
    %return useStatic
%endfunction %% FcnUseStaticStorageSpecifier

%% Function: FcnUseExternStorageSpecifier ==========================================================
%% Abstract: Function to determine if extern keyword should be prepended to
%%           a subsystem prototype.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function FcnUseExternStorageSpecifier(system)
    %assign genClassMemFcn = SLibGenSubsysFcnAsClassMemFcn(system)
    %assign subsystemClass = FcnGenerateSubsystemAsClass(system)
    %assign useExtern = LibPreserveExternInFcnDecls() && ...
        (UsingMalloc == 0) && !genClassMemFcn && !subsystemClass
    %return useExtern
%endfunction %% FcnUseExternStorageSpecifier


%% Function: AppendStaticToReusableFcnsInCPP =======================================================
%% Abstract: Function to determine if static keyword should be prepended to
%%           a subsystem prototype in C++ targets
%function AppendStaticToReusableFcnsInCPP(system, fcnName)

    %if LibSystemIsRoot(system)
        %return TLC_FALSE
    %endif

    %assign genClassMemFcn = SLibGenSubsysFcnAsClassMemFcn(system)

    %% We don't care about non C++ targets
    %if !genClassMemFcn
        %return TLC_FALSE
    %endif

    %if !(LibSystemIsReusedFcn(system))
        %return TLC_FALSE
    %endif

    %assign modIdx = system.CGIRModuleIdx
    %assign module = ::CompiledModel.RTWCGModules.RTWCGModule[modIdx]

    %if FcnIsForbidStaticMemberDecl(module, fcnName)
        %return TLC_FALSE
    %endif

    %return TLC_TRUE
%endfunction %%AppendStaticToReusableFcnsInCPP


%% Function: FcnIsConstMemberMethod ================================================================
%% Abstract: Function to determine if const keyword should be appended to
%%           a function prototype in C++ class interface. This function only
%%           handles system functions, not sub-functions
%function FcnIsConstMemberMethod(system, fcnName)
    %if (!CGMODEL_ACCESS("CGModel.getConstMemberMethodsFeature"))
        %return TLC_FALSE
    %endif

    %% Don't add static and const on the same function. Prefer static
    %% over const
    %if AppendStaticToReusableFcnsInCPP(system, fcnName)
        %return TLC_FALSE
    %endif

    %assign modIdx = system.CGIRModuleIdx
    %assign module = ::CompiledModel.RTWCGModules.RTWCGModule[modIdx]

    %assign fcnIdx = -1
    %if ISFIELD(module, "SystemFunctions")
        %if ISFIELD(module.SystemFunctions, fcnName)
            %assign fcnIdx = GETFIELD(module.SystemFunctions, fcnName)
            %assign fcn = module.Function[fcnIdx]
            %if ISFIELD(fcn, "ConstMemberMethod") && fcn.ConstMemberMethod
                %return TLC_TRUE
            %endif
        %endif
    %endif
    %% If we are passed in the system function type, check that too
    %% eg. SystemInitialize, Output
    %if (fcnIdx == -1)
        %assign fcnIdx = FcnFindModuleFcnIdx(module, fcnName)
    %endif

    %if (fcnIdx == -1)
        %return TLC_FALSE
    %endif

    %assign fcn = module.Function[fcnIdx]
    %if ISFIELD(fcn, "ConstMemberMethod") && fcn.ConstMemberMethod
        %return TLC_TRUE
    %endif

    %return TLC_FALSE
%endfunction

%function FcnFindModuleFcnIdx(module, sysFcnType)
    %if sysFcnType == "Output" || sysFcnType == "Outputs" || sysFcnType == "OutputUpdate"
        %assign findOutput = FcnFindModuleFcnIdxHelper(module, "Output")
        %assign findOutputs = FcnFindModuleFcnIdxHelper(module, "Outputs")
        %assign findOutputUpdate = FcnFindModuleFcnIdxHelper(module, "OutputUpdate")
        %if (findOutput != -1)
            %return findOutput
        %endif
        %if (findOutputs != -1)
            %return findOutputs
        %endif
        %if (findOutputUpdate != -1)
            %return findOutputUpdate
        %endif
        %return -1
    %endif

    %return   FcnFindModuleFcnIdxHelper(module, sysFcnType)
%endfunction

%function FcnFindModuleFcnIdxHelper(module, sysFcnType)
    %assign fcnIdx = -1
    %if ISFIELD(module, "SystemFunctionTypes") && ISFIELD(module.SystemFunctionTypes, sysFcnType)
        %assign fcnIdx = GETFIELD(module.SystemFunctionTypes,sysFcnType)
    %endif
    %return fcnIdx
%endfunction

%function FcnRemoveConstFromPrototype(origConstFlag, system, sysFcn, fcnRecord, fieldName) void
    %%The function was originally marked const
    %% but after initializing some locals, it is no longer const
    %% and the prototype was already modified to contain const
    %assign needToRemoveConst = origConstFlag &&  !FcnIsConstMemberMethod(system, sysFcn) && FcnPrototypeEndsWithConst(fcnRecord.FcnPrototype)

    %if needToRemoveConst
        %assign constKeyword = ") const"
        %assign fcnRecord.FcnPrototype = STRREP(fcnRecord.FcnPrototype, constKeyword , ")")
        %assign fcnRecord.Open = STRREP(fcnRecord.Open, constKeyword, ")")
        %if LibIsSystemField(system, fieldName)
            %<LibSetSystemField(system, fieldName, fcnRecord)>
        %endif
    %endif
%endfunction

%% Function: SLibPackageSubsystemAsClass ===========================================================
%% Abstract: Function to determine if a reusable subssytem needs to
%%           be emitted as a class for C++ class interface
%function SLibPackageSubsystemAsClass(system)
    %assign modIdx = system.CGIRModuleIdx
    %assign module = ::CompiledModel.RTWCGModules.RTWCGModule[modIdx]
    %return ISFIELD(module, "PackageAsClass") && module.PackageAsClass
%endfunction


%% Function: FcnGetSubsystemFunctionSpecifier ======================================================
%% Abstract: Function to determine if we should add storage specifiers
%%           like static, extern, inline to the subsystem function
%function FcnGetSubsystemFunctionSpecifier(system, fcn)

    %assign genClassMemFcn = SLibGenSubsysFcnAsClassMemFcn(system)

    %% Cache extern only if the storage class is non-static
    %assign specifier = ""
    %if(CGMODEL_ACCESS("CGModel.AddStaticKeywordToFcn"))
        %if FcnUseStaticStorageSpecifier(system)
            %assign specifier = "static "
        %elseif FcnUseExternStorageSpecifier(system)
            %assign specifier = !genClassMemFcn ? "extern " : ""
        %endif
    %else
        %if FcnUseExternStorageSpecifier(system)
            %assign specifier = !genClassMemFcn ? "extern " : ""
        %endif
    %endif

    %if ISEMPTY(specifier) && ...
        (AppendStaticToReusableFcnsInCPP(system, fcn.Name) || ...
        FcnGenerateSubsystemClassStaticMethods(system))
        %assign specifier = "static "
    %endif

    %if(CGMODEL_ACCESS("CGModel.AddInlineKeywordToFcns", system.SystemIdx))
        %assign specifier = specifier + "inline "
    %endif
    %return specifier
%endfunction


%<LibAddToCompiledModel("SubsystemPrototypesCache", "")>
%% Function: LibCacheSubsystemPrototype ============================================================
%% Abstract:
%%   Cache a function prototype (in case the file splits)
%%
%%   Arguments:
%%     system: Refers to the system whose prototype we are caching
%%        fcn: Reference to a FcnRec (see top of file for definition of Record)
%%
%%
%%   Example:
%%         fcn.Returns = "real_T *"
%%         fcn.Name    = "foo"
%%         fcn.Params  = "int_T i"
%%
%%         caches: (in 'system.SystemFcnPrototype')
%%                C -
%%                 "extern real_T * foo(int_T i);"
%%
%%                Ada -
%%                  package system is
%%                    procedure system_output
%%                  end system
%%
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortFcnCall3.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%% Toptetser: test/toolbox/simulink/variants/var-inline-general/tIVfcnCall_neg.m
%%
%function LibCacheSubsystemPrototype(system,fcn) void

    %assign staticOrExternSpecifier = FcnGetSubsystemFunctionSpecifier(system, fcn)

    %assign sysFcnType = fcn.SysFcn
    %if (sysFcnType == "Initialize" || sysFcnType == "SystemInitialize" || sysFcnType == "SystemReset" ||sysFcnType == "Start" || sysFcnType == "Terminate")
        %assign msFcnType = "MemSecFuncInitTerm"
    %else
        %assign msFcnType = "MemSecFuncExecute"
    %endif

    %openfile ssp
    %% Guard the subsystem functions declaration with the variant conditions
    %% fcn is the function record here from which the variant condition can
    %% be queried.
    %<fcn.FcnTIDCGVCEIfCondition>
    %<fcn.ModuleIfCondition>
    %assign useIndividualMapping = TLC_FALSE
    %assign functionType = ""
    %assign functionId = "" %% Assume
    %if CGMODEL_ACCESS("CGModel.isIndividualFunctionMappingEnabled")
        %if IsModelReferenceTarget()
            %% Model Reference build
            %if (sysFcnType == "ModelInitialize") && TLC_FALSE
                %% Initialize function
                %% NOTE: Skip this (this is re-computed in formatmodelref.tlc)
                %assign functionType = "Initialize"
                %assign useIndividualMapping = TLC_TRUE
            %elseif (sysFcnType == "Terminate")
                %% Terminate function
                %assign functionType = "Terminate"
                %assign useIndividualMapping = TLC_TRUE
            %elseif (sysFcnType == "OutputUpdate") || (sysFcnType == "Output") || ...
                (sysFcnType == "Update")
                %if SLibExplicitTaskingTID(system.CurrentTID)
                    %if SLibResetOrResetWithInitEventTID(system.CurrentTID)
                        %% Reset function
                        %assign functionType = "Reset"
                        %assign functionId = SampleTime[system.CurrentTID].EventSourceName
                        %assign useIndividualMapping = TLC_TRUE
                    %elseif SLibIsRateGroupedSLFcn(system, sysFcnType, system.CurrentTID)
                        %% Global or Public Simulink Function in export function model
                        %assign functionType = "SimulinkFunction"
                        %assign functionId = SLibGetRateGroupedSimulinkFunctionName(system, sysFcnType, system.CurrentTID)
                        %assign useIndividualMapping = TLC_TRUE
                    %elseif !LibIsServer(system) && ...
                        SLibIsExplicitTaskingExportFcnRateGrouping(sysFcnType, system.CurrentTID)
                        %% Export or Async function
                        %% NOTE: SampleTime[tid].TaskName returns block name for export function,
                        %%  and full block path for async function
                        %assign functionType = "FcnCallInport"
                        %assign functionId = REGEXPREP( ...
                            SampleTime[system.CurrentTID].TaskName, ".*\/", "")
                        %assign useIndividualMapping = TLC_TRUE
                    %elseif SLibIsExplicitPartitioningTID(system.CurrentTID)
                        %% Partition via schedule editor
                        %if (sysFcnType == "OutputUpdate")
                            %assign functionType = "Step"
                        %elseif (sysFcnType == "Output")
                            %assign functionType = "Output"
                        %elseif (sysFcnType == "Update")
                            %assign functionType = "Update"
                        %endif
                        %assign functionId = system.CurrentTID
                        %assign useIndividualMapping = TLC_TRUE
                    %endif
                %else
                    %if !SLibIsExportFcnDiagram()
                        %if (LibIsGlobalServer(system) || SLibIsModelScopedServer(system))
                            %% Global or Exported Global Scoped Function in a rate-based model
                            %assign functionType = "SimulinkFunction"
                            %assign functionId = SLibGetSimulinkFunctionNameInNonExportFcnModel(system)
                            %assign useIndividualMapping = TLC_TRUE
                        %elseif IsModelReferenceBaseSys(system)
                            %% Implicit periodic functions
                            %% NOTE: Don't do any computation if the system does not correspond to the
                            %% root (for e.g. subsystem). For those cases, there is no corresponding
                            %% individual mapping, so compute memory sections the legacy way.
                            %if (sysFcnType == "OutputUpdate")
                                %assign functionType = "Step"
                            %elseif (sysFcnType == "Output")
                                %assign functionType = "Output"
                            %elseif (sysFcnType == "Update")
                                %assign functionType = "Update"
                            %endif
                            %assign functionId = system.CurrentTID
                            %assign useIndividualMapping = TLC_TRUE
                        %endif
                    %endif
                %endif
            %endif
        %else
            %% Top Model build
            %if (LibIsGlobalServer(system) || SLibIsModelScopedServer(system))
                %% Global or Exported Global Scoped Function in a rate-based model
                %assign functionType = "SimulinkFunction"
                %assign functionId = SLibGetSimulinkFunctionNameInNonExportFcnModel(system)
                %assign useIndividualMapping = TLC_TRUE
            %endif
        %endif
    %endif
    %if !GenerateClassInterface
        %if useIndividualMapping
            %<SLibGetFcnMemSecPragmaForFunction(fcn.Name, functionType, functionId,  "Pre")>\
        %else
            %<SLibGetFcnMemSecPragmaForSystemOnDecl(fcn.Name, msFcnType, "Pre", system)>\
        %endif
    %endif
    %<staticOrExternSpecifier>%<fcn.FcnPrototype>;
    %if !GenerateClassInterface
        %if useIndividualMapping
            %<SLibGetFcnMemSecPragmaForFunction(fcn.Name, functionType, functionId,  "Post")>\
        %else
            %<SLibGetFcnMemSecPragmaForSystemOnDecl(fcn.Name, msFcnType, "Post", system)>\
        %endif
    %endif
    %% Guard the subsystem functions declaration with the variant conditions
    %% fcn is the function record here from which the variant conditions can
    %% be queried.
    %<fcn.ModuleEndIfCondition>
    %<fcn.FcnTIDCGVCEEndIfCondition>

    %closefile ssp
    %% To avoid warnings, use a different name for the
    %% rtModel in the function declaration than in the
    %% function body.
    %if GenRTModel
        %assign rtm = " *%<::tSimStruct>"
        %assign lowerrtm = " *%<SLibGetSimStruct()>"
        %assign ssp = STRREP(ssp, rtm, lowerrtm)
    %endif
    %assign fileOwnerSystem = ::CompiledModel.System[system.FileNameOwnerIdx]
    %if IsModelRefScalableBuild() && IsModelReferenceBaseSys(system)
        %assert (system.FileNameOwnerIdx == system.SystemIdx)
        %if !GenerateClassInterface
            %<SLibPrintMREntryPointFcnDeclToHeaderFile(fileOwnerSystem, system, functionType, fcn, ssp)>\
        %endif
    %else
        %if SLibPackageSubsystemAsClass(system)
            %if !LibIsSystemField(system, "ClassMemberMethodPrototype")
                %<LibAddToSystem(system, "ClassMemberMethodPrototype", ssp)>
            %else
                %<LibAddToSystemField(system, "ClassMemberMethodPrototype", ssp)>
            %endif
        %elseif SLibGenSubsysFcnAsClassMemFcn(system)
            %% When in generating subsystem funcitons as C++ member function mode,
            %% system function prototoype cannot be put in the file owner subsystem, as they will
            %% need to be put into root_model.h
            %if (!LibIsServer(system)) || ...
                (FcnIsServerPublicAccess(system) && sysFcnType == "OutputUpdate" && ...
                SLibIsExportFcnDiagram() && ...
                !SLibModelWideEventTID(system.CurrentTID))
                %<LibAddToSystemField(system, "EncapSystemFcnPrototype", ssp)>
            %else
                %% SlFcn prototypes placed in System Member Prototypes will become private access methods
                %<LibAddToSystemField(system, "SystemMemberPrototype", ssp)>
            %endif
        %else
            %if LibIsServer(system)
                %if ((!LibIsGlobalServer(system)) || sysFcnType != "OutputUpdate") ...
                    || SLibResetOrResetWithInitEventTID(system.CurrentTID)
                    %% If it is a SL function but not a global SLFcn, or a global SLFcn, but fcnType != "OutputUpdate". Declarations need to
                    %% be in model.h (if model scoped) or model_private.h (if subsystem scoped). We cannot put them into fileOwnerSystem, as
                    %% it would mean the base system, and we cannot make SLFcn specific decisions.

                    %% If it is a Reset/ResetWithInit output function, put it into fileOwnerSystem, even the
                    %% simulink function is global. So the Reset/ResetWithInit function at the root level can
                    %% see the definition of the Reset/ResetWithInit inside the simulink function. see
                    %% g2066071.
                    %<LibAddToSystemField(system, "SystemFcnPrototype", ssp)>
                %endif
            %else
                %<SLibPrintSubsystemFcnDeclToHeaderFile(fileOwnerSystem, system, fcn, ssp)>\
            %endif
        %endif
    %endif

%endfunction %% LibCacheSubsystemPrototype

%% Function: LibDumpSystemPrototype ================================================================
%% Abstract:
%%   Place the system function prototypes in the output stream.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function LibDumpSystemPrototype(system) Output
    %assign systemFcnPrototype = LibGetSystemField(system,"SystemFcnPrototype")
    %if !WHITE_SPACE(systemFcnPrototype)
        %<systemFcnPrototype>\
    %endif
%endfunction %% LibDumpSystemPrototype

%% Function: SLibGetNeedLocalTIDFieldName ==========================================================
%% Abstract:
%%
%function SLibGetNeedLocalTIDFieldName(system, fcnType) void
    %return "NeedLocalTIDIn" + ...
        ((fcnType == "Outputs" || fcnType == "OutputUpdate") ? "Output" : fcnType)
%endfunction

%% Function: SLibSetNeedLocalTIDInSystem ===========================================================
%% Abstract:
%%
%function SLibSetNeedLocalTIDInSystem(system, fcnType) void
    %assign fieldName = SLibGetNeedLocalTIDFieldName(system, fcnType)
    %if ISFIELD(system, fieldName)
        %<SETFIELD(system, fieldName, TLC_TRUE)>
    %else
        %addtorecord system %<fieldName> TLC_TRUE
    %endif
%endfunction

%% Function: SLibGetNeedLocalTIDInSystem ===========================================================
%% Abstract:
%%
%function SLibGetNeedLocalTIDInSystem(system, fcnType)
    %assign fieldName = SLibGetNeedLocalTIDFieldName(system, fcnType)
    %if ISFIELD(system, fieldName)
        %return GETFIELD(system, fieldName)
    %else
        %return TLC_FALSE
    %endif
%endfunction

%% DocFunction{Other Useful Functions}: LibTIDInSystem =========================
%% Abstract:
%%    This function returns a tid if it is in the scope of a subsystem function
%%    and can be called before or during TLC generating code.
%%    It returns the tid argument name, if a tid is passed as argument in the
%%    system function scope.
%%
%%    If tid is not passed as argument in the scope, this function returns:
%%       1. '0' if model is single tasking,
%%       2. the tid value of the subsystem if the subsystem is single rate,
%%       3. returns a local tid variable name, if the subsystem is multirate.
%%          A local tid variable will be added to the subsystem code.
%%
%% Note:
%%    This function issue an error message, if it is called for a reusable
%%    subsystem whose instance run at different rate.
%%
%% Example:
%%    LibTIDInSystem(system, fcnType)
%%
%%    system  - is a record within the global ::CompiledModel record.
%%    fcnType - can be any of the following: 'Output','Update','Outputupdate'
%%
%function LibTIDInSystem(system, fcnType) void
    %assert (fcnType == "Output" || ...
        fcnType == "Update" || fcnType == "OutputUpdate")
    %if ::CompiledModel.NumSampleTimes == 1 || ...
        SLibSingleTasking()
        %return "0"
    %elseif LibIsSingleRateSystem(system)
        %assign tmpTid = FcnGetSubsystemTID(system, TLC_TRUE)
        %if tmpTid == -1
            %<SLibReportErrorWithIdAndArgs("RTW:tlc:ReuseOfDifferentRate", "%<system.Name>")>
        %else
            %return FcnGetSubsystemTID(system, TLC_TRUE)
        %endif
    %else
        %if IsModelReferenceBaseSys(system)
            %<SLibReportErrorWithIdAndArgs("RTW:tlc:IncorrectLibTIDCall", "%<system.Name>")>
        %else
            %<SLibSetNeedLocalTIDInSystem(system, fcnType)>
            %return ::tTID
        %endif
    %endif
%endfunction %% LibTIDInSystem

%% Function: SLibDumpLocalTidInSystem ==============================================================
%% Abstract:
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tvss_code_variants.m
%%
%function SLibDumpLocalTidInSystem(system, fcn)
    %assign intType = LibGetDataTypeNameFromId(::CompiledModel.tSS_INTEGER)
    %% Do need dump local tid is a subsystem for an async rate
    %% if the subsystem is not async the async rate. In this case,
    %% async code for this subsystem is going to be grouped in
    %% the async task entry functions. The code doesn't belong to
    %% this subsystem eventually.
    %if LibAsynchronousTriggeredTID(system.CurrentTID) && ...
        !SLibModelWideEventTID(system.CurrentTID) && ...
        system.CurrentTID != LibGetSubsystemTID(system,TLC_TRUE)
        %return ""
    %endif
    %assign needLocalTid = SLibGetNeedLocalTIDInSystem(system,fcn)
    %if fcn == "OutputUpdate"
        %assign needLocalTid = needLocalTid || ...
            SLibGetNeedLocalTIDInSystem(system,"Output") || ...
            SLibGetNeedLocalTIDInSystem(system,"Update")
    %endif
    %openfile tmpBuf
    %if needLocalTid && !LibSystemFcnNeedsTID(system, fcn)
        %% System need local tid value, but does not pass in tid arg
        %if SLibSingleTasking()
            %assign tidValue = 0
        %else
            %% CurrentTID is set only if the system generate rate grouping
            %% code. Otherwise, we need get tid value from system record directly.
            %assign tidValue =  !SLibSystemFcnPeriodicRateGrouping(system, fcn) ? ...
                FcnGetSubsystemTID(system,!LibIsSingleRateSystem(system)) : ...
                system.CurrentTID
        %endif
        %if ISEMPTY(tidValue)
            %<LibReportFatalError("TID value is empty")>
        %endif
        %assign scalarTokens = LibGetScalarDataInitTokens()
        %<intType> %<::tTID>%<scalarTokens[0]>%<tidValue>%<scalarTokens[1]>;
    %endif
    %closefile tmpBuf

    %return tmpBuf
%endfunction

%% Function: LibDumpFcnOpen ========================================================================
%% Abstract:
%%   Dump the opening (start) of the specified function (e.g. Output).
%%
%function LibDumpFcnOpen(system,function) Output
    %assign fcnInfo = LibGetFcnInfo(system, function, system.CurrentTID)
    %if fcnInfo.SfcnFormDefine != ""
        #define %<fcnInfo.SfcnFormDefine>
    %endif
    %<fcnInfo.Open>\
    %<SLibDumpLocalTidInSystem(system, function)>
%endfunction %% LibDumpFcnOpen

%% Function: LibDumpFcnBegin =======================================================================
%% Abstract:
%%   Dump the beginning of the function (e.g. Output) code.
%%
%function LibDumpFcnBegin(system,function) Output
    %assign fcnInfo = LibGetFcnInfo(system, function, system.CurrentTID)
    %<fcnInfo.Begin>\
%endfunction %%LibDumpFcnBegin

%% Function: LibDumpFcnClose =======================================================================
%% Abstract:
%%   Dump the closing of the specified function (e.g. Output).
%%
%function LibDumpFcnClose(system,function) Output
    %assign fcnInfo = LibGetFcnInfo(system, function, system.CurrentTID)
    %<fcnInfo.Close>\
%endfunction %% LibDumpFcnClose

%% Function: FcnSysFcnHasRTM =======================================================================
%% Abstract:
%%   Returns whether a system fcn needs the real time model as an arg
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function FcnSysFcnHasRTM(system, sysFcn) void
    %assign cTID = system.CurrentTID
    %assign isRG = SLibSystemFcnPeriodicRateGrouping(system, sysFcn)
    %with system.Interface
        %assign hasRTM = SysFcnArgNeeded(sysFcn, RTMArgDef, cTID, isRG) && ...
            LibSystemIsReusedFcn(system) && !LibSystemIsRoot(system)
    %endwith
    %return hasRTM
%endfunction

%% Function: FcnSysNeedAddRTMArg ===================================================================
%% Abstract:
%%     This function return true when the subsystem
%%     doesn't have rtm arg, but it must be added to arg list due to:
%%     1. S-Function target
%%     2. Malloc target (grt malloc) or ERT Multi-Instance,
%%        and system cross flag is true
%%        (Noreusable system in reusable system).
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function FcnSysNeedAddRTMArg(system, sysFcn) void
    %if FcnSysFcnHasRTM(system, sysFcn)
        %return TLC_FALSE
    %else
        %return (CodeFormat == "S-Function") || ...
            (system.CrossNoArgFcnBound && (UsingMalloc || (MultiInstanceERTCode && !GenerateClassInterface))) ...
            && !LibIsServer(system)
    %endif
%endfunction

%% Function: SLibIsFcnSubFunction(system, sysFcn) void
%% Abstract:
%%     This function returns true when sysFcn is a sub-function in system
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%%
%function SLibIsFcnSubFunction(system, sysFcn)
    %assign module = ::CompiledModel.RTWCGModules.RTWCGModule[system.CGIRModuleIdx]
    %assign isSubFunction = TLC_FALSE
    %if ISFIELD(module, "SystemFunctions") && ISFIELD(module.SystemFunctions, sysFcn)
        %assign fcnIdx = GETFIELD(module.SystemFunctions, sysFcn)
        %if fcnIdx < module.NumSubFunctions
            %assign isSubFunction = TLC_TRUE
        %endif
    %endif
    %return isSubFunction
%endfunction

%function FcnIsExportFcnMode(system, sysFcn, tid)
    %assign isRoot = (system.Type == "root") || IsModelReferenceBaseSys(system)
    %return ((sysFcn == "OutputUpdate") ||  (sysFcn == "Output")) && ...
        TYPE(tid) == "Number" && tid > 0 && ...
        ISFIELD(SampleTime[tid],"EntryFcnName") && ...
        !ISEMPTY(SampleTime[tid].EntryFcnName) && ...
        !SLibNonInlinedIRTEventTID(tid) && ...
        isRoot
%endfunction

%function FcnIsPrototypeConstructedInIR(system, sysFcn, tid)
    %assign isRateGroupedSLF = SLibIsRateGroupedSLFcn(system, sysFcn, tid)
    %assign isServiceFcn = SLibIsServiceFcn(system, sysFcn, tid)

    %return (FcnIsExportFcnMode(system, sysFcn, tid) && isRateGroupedSLF) || isServiceFcn

%endfunction

%% Function: SLibSystemFcnInfoRecord ===============================================================
%% Abstract:
%%   Returns the function info record for LibDefineSystemFcn.
%%   See LibDefineSystemFcn
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortFcnCall3.m
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%% TopTester: test/toolbox/simulink/variants/var-simfcns-inherit/tmWithCombSpecAndInherit_VC1.m
%% TopTester: test/toolbox/simulink/variants/var-normal-matlabvariable-support/tNormalMatlabVariable2.m
%% TopTester: test/toolbox/rtw/targets/AUTOSAR/Variants/dimensionVariants/tDimensionVariants.m
%% TopTester: test/toolbox/simulink/variants/modelVariants/tVariantsBasic.m
%% TopTester: test/toolbox/simulink/blocks/lib_MathOperations/Gain/rtw/tdtgain4.m
%% TopTester: test/toolbox/rtw/targets/AUTOSAR/Variants/inlineVariants/tInlineVariants10.m
%%
%function SLibSystemFcnInfoRecord(system, sysFcn) void
    %assign intType = LibGetDataTypeNameFromId(::CompiledModel.tSS_INTEGER)
    %<FcnResetFunctionRecord()>
    %assign getFcnNameFromFPC = TLC_FALSE
    %assign cppClassPreString = ""
    %% Try to get function name from FPC
    %if  IsModelReferenceBaseSys(system)
        %if (sysFcn == "OutputUpdate") && ...
            SLibFcnProtoCtrlActive()
            %assign FPC = FcnGetFunctionPrototypeRecord()
            %assign ::FcnRec.Name = FPC.FunctionName
            %assign getFcnNameFromFPC = TLC_TRUE
        %elseif (sysFcn == "Initialize") && ...
            SLibFcnProtoCtrlActive()
            %assign FPC = FcnGetFunctionPrototypeRecord()
            %assign ::FcnRec.Name = FPC.InitFunctionName
            %assign getFcnNameFromFPC = TLC_TRUE
        %elseif GenerateClassInterface
            %assign FPC = FcnGetRTWCPPStepPrototypeRecord()
            %assign cppClassPreString = CGMODEL_ACCESS("CGModel.getClassName") + "::"
            %if sysFcn == "OutputUpdate"
                %if ISFIELD(FPC,"FunctionName")
                    %if (!ISEMPTY(system.CurrentTID) && ISFIELD(SampleTime[system.CurrentTID],"EventSourceName"))
                        %% do nothing. function name will be determined later in this fcn
                    %elseif CGMODEL_ACCESS("CGModel.isCPPMappingEnabled")
                        %% do nothing. function name will be determined later in this fcn
                    %else
                        %assign getFcnNameFromFPC = TLC_TRUE
                        %if  CombineOutputUpdateFcns
                            %assign stepFcnName = FPC.FunctionName
                        %else
                            %% g2932018
                            %assign stepFcnName = "output"
                        %endif
                        %assign ::FcnRec.Name = cppClassPreString + stepFcnName
                    %endif
                %endif
            %elseif sysFcn == "Output"
                %% do nothing. function name will be determined later in this fcn
            %elseif sysFcn == "Update"
                %% do nothing. function name will be determined later in this fcn
            %elseif SLibIsExplicitTaskingExportFcnRateGrouping(sysFcn,system.CurrentTID)
                %% do nothing. function name will be determined later in this fcn
            %elseif sysFcn == "SystemInitialize"
                %% simplified function name for C++
                %assign getFcnNameFromFPC = TLC_TRUE
                %assign ::FcnRec.Name = cppClassPreString + "init"
            %elseif sysFcn == "SystemReset"
                %% simplified function name for C++
                %assign getFcnNameFromFPC = TLC_TRUE
                %assign ::FcnRec.Name = cppClassPreString + "reset"
            %elseif sysFcn == "Start"
                %% simplified function name for C++
                %assign getFcnNameFromFPC = TLC_TRUE
                %assign ::FcnRec.Name = cppClassPreString + "start"
            %elseif sysFcn == "Terminate"
                %% customized function name for C++
                %assign getFcnNameFromFPC = TLC_TRUE
                %if CGMODEL_ACCESS("CGModel.isCPPMappingEnabled")
                    %assign termFcnName = "%<CGMODEL_ACCESS("CGModel.getModelEntryFunctionName","Terminate", "")>"
                %else
                    %assign termFcnName = "terminate"
                %endif
                %assign ::FcnRec.Name = cppClassPreString + termFcnName
            %elseif sysFcn == "Enable"
                %% simplified function name for C++
                %assign getFcnNameFromFPC = TLC_TRUE
                %assign ::FcnRec.Name = cppClassPreString + "enable"
            %elseif sysFcn == "Disable"
                %% simplified function name for C++
                %assign getFcnNameFromFPC = TLC_TRUE
                %assign ::FcnRec.Name = cppClassPreString + "disable"
            %elseif sysFcn == "SetupRuntimeResources"
                %% simplified function name for C++
                %assign getFcnNameFromFPC = TLC_TRUE
                %assign ::FcnRec.Name = cppClassPreString + "setupruntimeresources"
            %elseif sysFcn == "CleanupRuntimeResources"
                %% simplified function name for C++
                %assign getFcnNameFromFPC = TLC_TRUE
                %assign ::FcnRec.Name = cppClassPreString + "cleanupruntimeresources"
            %elseif sysFcn == "Derivative"
                %% simplified function name for C++
                %assign getFcnNameFromFPC = TLC_TRUE
                %assign ::FcnRec.Name = cppClassPreString + "derivative"
            %endif
        %endif
    %endif


    %% get fcn name from system record.
    %assign fcnname = sysFcn + "Fcn"
    %assign sysIdx  = system.SystemIdx
    %assign isRoot  = (system.Type == "root")
    %assert(ISFIELD(system,fcnname))
    %assign fcnName = GETFIELD(system, fcnname)
    %assign modIdx = system.CGIRModuleIdx
    %% If the function is not been written a partial prototype through the
    %% emitter transform, then we cannot cache the variant conditions for
    %% those function in the emitter transform.
    %% For those categories of functions, use the module condition exposed
    %% to TLC through CGModel.
    %assign moduleCondition = CGMODEL_ACCESS("CGModel.GetModuleCondition", modIdx)
    %assign ownerModule = ::CompiledModel.RTWCGModules.RTWCGModule[modIdx]
    %if ISFIELD(ownerModule ,"SystemFunctions")  && ISFIELD(ownerModule.SystemFunctions, fcnName)
        %assign fcnIdx = ownerModule.SystemFunctions.%<fcnName>
        %assign fcn = ownerModule.Function[fcnIdx]
        %% Cache the module condition of the function into the function record.
        %% Later this will be used to guard the function declaration and
        %% definition.
        %if ISFIELD(fcn, "ModuleIfCondition")

            %assign ::FcnRec.ModuleIfCondition = fcn.ModuleIfCondition
            %assign ::FcnRec.ModuleEndIfCondition = fcn.ModuleEndIfCondition

        %endif
        %% Cache the entry point function's variant condition into the function record.
        %% Later this will be used to guard the function declaration and definition.
        %if ISFIELD(fcn, "FcnTIDCGVCEIfCondition")

            %assign ::FcnRec.FcnTIDCGVCEIfCondition = fcn.FcnTIDCGVCEIfCondition
            %assign ::FcnRec.FcnTIDCGVCEEndIfCondition = fcn.FcnTIDCGVCEEndIfCondition

        %endif

        %assign isOutlinedBlockFcn = fcn.IsOutlinedBlockFcn
    %else
        %assign isOutlinedBlockFcn = TLC_FALSE
    %endif
    %assign updateFcnRecName = TLC_TRUE
    %assign isRootOrMdlRefBaseSystem = isRoot || IsModelReferenceBaseSys(system)
    %assign isExternFcn = TLC_FALSE
    %assign isAsyncTriggered = TLC_FALSE
    %assign exportFcnMode = FcnIsExportFcnMode(system, sysFcn, system.CurrentTID)
    %if (exportFcnMode)
        %if LibAsynchronousTriggeredTID(system.CurrentTID) && isRootOrMdlRefBaseSystem
            %assign isAsyncTriggered = TLC_TRUE
        %endif
        %if !getFcnNameFromFPC
            %assign ::FcnRec.Name = cppClassPreString + SampleTime[system.CurrentTID].EntryFcnName
        %endif
        %if SLibIsExplicitTaskingExportFcnRateGrouping(sysFcn,system.CurrentTID) && GenerateClassInterface
            %assign FPC = FcnGetRTWCPPStepPrototypeRecord()
            %assign ::FcnRec.Name = cppClassPreString + SampleTime[system.CurrentTID].EntryFcnName
        %endif
        %% Added below check for test/toolbox/simulink/sampletimes/tSTO_ExportFcn -lvlTwo_Export_Periodic_FcnCall
        %if !SLibIsExportFcnDiagram() || !LibAsynchronousTriggeredTID(system.CurrentTID) || IsModelReferenceBaseSys(system)
            %assign fcnName = SampleTime[system.CurrentTID].EntryFcnName
        %endif
        %assign updateFcnRecName = TLC_FALSE
        %assign appendTIDToFcnName = TLC_FALSE
    %elseif SLibExplicitTaskingTID(system.CurrentTID)
        %if SLibNonInlinedIRTEventTID(system.CurrentTID) && ((sysFcn == "OutputUpdate") || (sysFcn == "Output"))
            %assign appendTIDToFcnName = TLC_FALSE

            %% If the subsystem is a single rate simulink function with only IRT
            %% rate, don't include reset id in the function name.
            %assign isSingleRateServer = LibIsServer(system) && LibIsSingleRateSystem(system)
            %if !isSingleRateServer
                %if isRootOrMdlRefBaseSystem
                    %assign fcnName = "%<::CompiledModel.SampleTime[system.CurrentTID].EntryFcnName>"
                %else
                    %assign fieldName = "ModelWideEventFcn" + "%<::CompiledModel.SampleTime[system.CurrentTID].EventSourceName>"
                    %if ISFIELD(system, "%<fieldName>") && !ISEMPTY(GETFIELD(system, "%<fieldName>"))
                        %assign fcnName = GETFIELD(system, "%<fieldName>")
                    %endif
                %endif
                %if IsModelReferenceBaseSys(system) && SLibFcnProtoCtrlActive()
                    %% For non-inlined irt (reset) don't use fpc, use the reset id instead.
                    %assign ::FcnRec.Name = fcnName
                %endif
            %endif

        %elseif SLibNonInlinedModelWideEventTID(system.CurrentTID)
            %assign appendTIDToFcnName = FcnSysModuleIsRateGrouping(system, sysFcn)
        %elseif LibAsynchronousTriggeredTID(system.CurrentTID)
            %% Async fcn-call system is single rate,
            %% Never append tid to fcn name
            %% However, for accelerator simulation, an empty update function
            %% will be generated. The Update function must have a TID appended
            %% to avaoid name clashes with the other update fucntions

            %% the async is the only runtime rates, and the other are all IRTs, never
            %% append tid to fcn name
            %assign isSingleAsync = TLC_TRUE
            %assign ssTaskToFirstTid = FcnGetSubsystemTaskToFirstTID(system)
            %foreach idx = SIZE(ssTaskToFirstTid, 1)
                %if ssTaskToFirstTid[idx] != system.CurrentTID && ...
                    !SLibInitResetTermEventTID(ssTaskToFirstTid[idx])
                    %assign isSingleAsync = TLC_FALSE
                    %break
                %endif
            %endforeach
            %assign isSingleAsyncUpdateInAccelOrRAccel = (sysFcn == "Update") && ...
                (Accelerator || isRAccel) && ...
                isSingleAsync

            %if ((sysFcn == "OutputUpdate") || (sysFcn == "Output") || !Accelerator) || ...
                isSingleAsyncUpdateInAccelOrRAccel
                %if SLibInitResetTermEventTID(system.CurrentTID) && !LibIsSingleRateSystem(system)
                    %assign appendTIDToFcnName = TLC_TRUE
                %else
                    %assign appendTIDToFcnName = TLC_FALSE
                %endif
            %else
                %assign appendTIDToFcnName = FcnSysModuleIsRateGrouping(system, sysFcn)
            %endif
        %else
            %% Append tid to fcn name if rate grouping
            %%
            %assign appendTIDToFcnName = SLibSystemFcnPeriodicRateGrouping(system, sysFcn)
            %if (Accelerator || isRAccel) && TYPE(system.CurrentTID) == "Number" && ...
                system.CurrentTID > 0 && system.CurrentTID < NumRuntimeExportedRates
                %assign isExternFcn = TLC_TRUE
            %endif
        %endif
    %elseif SLibIsPeriodicRateGrouping() || ...
        (IsModelReferenceTarget() && ::CompiledModel.SolverType == "VariableStep" && ...
        ::CompiledModel.HasPartitions == "yes" && ...
        ::CompiledModel.NumRuntimeExportedRates > 1)
        %% Append tid to fcn name if rate grouping
        %% For Parallel execution in rapid acceleration, mdlOutput and mdlUpdate function will be generated
        %% in raccel_parallel.tlc that will have calls to tid specific tid output/update functions (like MdlOutputTID1).
        %% Hence, we should set appendTIDToFcnName to true for this case.
        %if (Accelerator || isRAccel) && TYPE(system.CurrentTID) == "Number" && ...
            !CompiledModel.ParallelExecutionInRapidAccelerator
            %if system.Type == "root" && system.CurrentTID == 0
                %assign appendTIDToFcnName = TLC_FALSE
            %elseif system.CurrentTID < NumRuntimeExportedRates
                %assign appendTIDToFcnName = SLibSystemFcnPeriodicRateGrouping(system, sysFcn)
                %assign isExternFcn = TLC_TRUE
            %endif
        %else
            %assign appendTIDToFcnName = SLibSystemFcnPeriodicRateGrouping(system, sysFcn)
        %endif

        %if appendTIDToFcnName && ...
            ISEQUAL(SolverType, "FixedStep") && FixedStepOpts.TID01EQ
            %assign ssTid = LibGetSubsystemTID(system, TLC_FALSE)
            %if SIZE(ssTid, 1) == 1 && ssTid[0] == 0
                %assign appendTIDToFcnName = TLC_FALSE
            %endif
        %endif

        %% Continuous rate related fcn does not need tid in fcn name
        %if SLibContFcnPartitionGrouping(sysFcn) && ...
            SLibIsMappedInDeploymentDiagram(system)
            %assign appendTIDToFcnName = TLC_FALSE
        %endif

        %% For export function models, tid 0 functions should not be appended with TID
        %if appendTIDToFcnName && system.CurrentTID == 0 && SLibIsExportFcnDiagram()
            %assign appendTIDToFcnName = TLC_FALSE
        %endif
    %else
        %assign appendTIDToFcnName = TLC_FALSE
    %endif
    %if appendTIDToFcnName
        %assert !WHITE_SPACE(system.CurrentTID)

        %% We don't want function names to incorporate task names at least for
        %% now for parallel rapid accelerator. The output and update
        %% functions are generated in raccel_parallel.tlc that doesn't
        %% support function names with partition name and tid. For now
        %% function names will only have tid.
        %% For Model Reference we maintain the partition names for the base model
        %if SLibIsExplicitPartitioningTID(system.CurrentTID) && ...
            !(CompiledModel.ParallelExecutionInRapidAccelerator && !IsModelReferenceBaseSys(system))
            %% For explicit tasking models (other than export fcn) we want to adjust
            %% the function names to incorporate the task names. Eventually this should
            %% not include the TID, but more codegen support is needed before that can
            %% be enabled.
            %assign fcnName = SLibExplicitPartitioningSystemFcnName(fcnName, system.CurrentTID)
            %assign isExternFcn = TLC_TRUE
        %else
            %% The TIDn is always concatentated, even for tasked functions.
            %assign fcnName = "%<fcnName>TID%<system.CurrentTID>"
        %endif
    %endif

    %if !getFcnNameFromFPC && updateFcnRecName
        %assign ::FcnRec.Name = cppClassPreString + fcnName
    %elseif appendTIDToFcnName
        %% Append TID to output function for CPP class generation
        %assign ::FcnRec.Name = ::FcnRec.Name + "%<system.CurrentTID>"
    %endif

    %assign thisModule = ...
        ::CompiledModel.RTWCGModules.RTWCGModule[system.CGIRModuleIdx]

    %assign hasTIDArg = 0
    %assign hasCPIArg = 0
    %assign hasRTMArg = 0
    %assign isSysFcn = TLC_FALSE
    %if ISFIELD(thisModule, "SystemFunctions") && ...
        ISFIELD(thisModule.SystemFunctions, fcnName)
        %assign fcnIndex = GETFIELD(thisModule.SystemFunctions, fcnName)
        %assign thisFcn  = thisModule.Function[fcnIndex]
        %if ISFIELD(thisFcn, "ModuleIfCondition")

            %assign ::FcnRec.ModuleIfCondition = thisFcn.ModuleIfCondition
            %assign ::FcnRec.ModuleEndIfCondition = thisFcn.ModuleEndIfCondition

        %endif
        %% TopTester: test/toolbox/simulink/variants/var-general/tmMultiRateWithVariants.m
        %if ISFIELD(thisFcn, "FcnTIDCGVCEIfCondition")

            %assign ::FcnRec.FcnTIDCGVCEIfCondition = thisFcn.FcnTIDCGVCEIfCondition
            %assign ::FcnRec.FcnTIDCGVCEEndIfCondition = thisFcn.FcnTIDCGVCEEndIfCondition

        %endif

        %assign hasTIDArg = thisFcn.TIDArgIndex > -1
        %assign hasCPIArg = thisFcn.CPIArgIndex > -1
        %assign hasRTMArg = thisFcn.SimStructArgIndex > -1
        %assign isSysFcn = TLC_TRUE
    %endif

    %% If the system is reusable and it already has rtModel as an
    %% argument, don't add it again.
    %assign ResetInRootAccelRAccel = SLibResetOrResetWithInitEventTID(system.CurrentTID) && ...
        LibSystemIsRoot(system) && (Accelerator || isRAccel)

    %if (!hasRTMArg || exportFcnMode || ResetInRootAccelRAccel) && ...
        FcnSysNeedAddRTMArg(system, sysFcn)
        %if !FcnSysFcnHasRTM(system, sysFcn)
            %assign locSS = RTMGetModelSS()
            %if LibSystemIsRoot(system) && (CodeFormat == "S-Function")
                %<FcnAddArgument(sysIdx, ::tSimStructType + " *", locSS, locSS)>
            %else
                %<FcnAddArgument(sysIdx, ::tSimStructType + " *const ", locSS, locSS)>
            %endif
        %endif
    %endif

    %if !hasCPIArg && LibSystemFcnNeedsCPI(system,sysFcn)
        %if SLibAutosarCompilerAbstractionRequired()
            %<FcnAddArgumentWithCompilerAbstraction(sysIdx, TLC_FALSE, intType, TLC_FALSE, TLC_FALSE, ::tControlPortIdx, ...
                ::tControlPortIdx)>
        %else
            %<FcnAddArgument(sysIdx, "%<intType> ", ::tControlPortIdx, ...
                ::tControlPortIdx)>
        %endif
    %endif

    %if !hasTIDArg && !isAsyncTriggered && LibSystemFcnNeedsTID(system,sysFcn)
        %<SLibSetTIDAddedInTLC(system)>
        %if SLibAutosarCompilerAbstractionRequired()
            %<FcnAddArgumentWithCompilerAbstraction(sysIdx, TLC_FALSE, intType, TLC_FALSE, TLC_FALSE, ::tTID, tTID)>
        %else
            %<FcnAddArgument(sysIdx, "%<intType> ",::tTID, tTID)>
        %endif
    %endif

    %assign ::FcnRec.CommonPrms = ::FcnRec.Params

    %assign fcnPrototype = ""
    %assign fcnReturns = ""
    %assign isRateGroupedSLF = SLibIsRateGroupedSLFcn(system, sysFcn, system.CurrentTID)
    %assign isServiceFcn = SLibIsServiceFcn(system, sysFcn, system.CurrentTID)

    %assign protoTypeAlreadyConstructedInIR = FcnIsPrototypeConstructedInIR(system, sysFcn, system.CurrentTID)
    %if protoTypeAlreadyConstructedInIR
        %% A rate grouped Simulink function's prototype is fully defined
        %% in IR (with the exception of the C++ class name). So, use the
        %% IR defined prototype rather than discarding and recomputing it.
        %assign aFcnPrototype = SLibGetRateGroupedFcnPrototype(thisModule, system.CurrentTID)
        %% For the rate grouped simulink functions, use the module condition of the function
        %% cached into the aFcnprototype record and use it to guard the function declaration
        %% and definition.

        %if ISFIELD(aFcnPrototype, "ModuleIfCondition")

            %assign ::FcnRec.ModuleIfCondition = aFcnPrototype.ModuleIfCondition
            %assign ::FcnRec.ModuleEndIfCondition = aFcnPrototype.ModuleEndIfCondition

        %endif
        %% For the rate grouped simulink functions treated as subsystems, use the FcnTID variant condition
        %% of the function cached into the aFcnprototype record and use it to guard the function declaration
        %% and definition.
        %% Function {
        %% Name                      "mRefDSMSimulinkFcnSpecify_timestwo"
        %% IsExported                1
        %% IsRateGroupedSLFcn        1
        %% IsEntryPointSubFcn        1
        %% FunctionType              "Output"
        %% FcnTID                    1

        %if ISFIELD(aFcnPrototype, "FcnTIDCGVCEIfCondition")

            %assign ::FcnRec.FcnTIDCGVCEIfCondition = aFcnPrototype.FcnTIDCGVCEIfCondition
            %assign ::FcnRec.FcnTIDCGVCEEndIfCondition = aFcnPrototype.FcnTIDCGVCEEndIfCondition

        %endif

        %assign fcnName = aFcnPrototype.Name
        %assign fcnPrototype = aFcnPrototype.Prototype
        %assign cgirParams = aFcnPrototype.Params
        %assign fcnReturns = aFcnPrototype.Return
        %if !ISEMPTY(fcnName) && SLibAutosarCompilerAbstractionRequired()
            %% return type will be added later in this function
            %assign fcnPrototype = fcnName + "(" + cgirParams
            %assign ::FcnRec.Returns = fcnReturns
        %else
            %assign ::FcnRec.Returns = ""
        %endif
        %if !ISEMPTY(fcnName) && GenerateClassInterface
            %assign fcnPrototype = fcnReturns + " " + ::FcnRec.Name + "(" + cgirParams
        %endif
        %if (!GenerateClassInterface)
            %assign fcnPrototype = STRREP(fcnPrototype, "()", "(void)")
        %endif
        %if !isServiceFcn || !GenerateClassInterface || !IsModelReferenceBaseSys(system)
            %assign ::FcnRec.Params = cgirParams
        %endif
    %endif

    %% The rate grouped Simulink function's prototype is
    %% fully defined in IR. However, blockI/O and parameters are still
    %% using classic arg tracking. We still need to call FcnAddParametersAndReturn
    %% to handle those args. We can skip calling FcnAddParametersAndReturn
    %% if C++ is being generated since these are class members.
    %if !LibSystemIsInlined(system) && !isRoot && (!isRateGroupedSLF || !GenerateClassInterface)
        %<FcnAddParametersAndReturn(sysFcn, fcnName, sysIdx, isRateGroupedSLF)>
    %endif

    %if ISEMPTY(::FcnRec.Returns) && !isRateGroupedSLF && !isServiceFcn
        %assign ::FcnRec.Returns = "void"
    %endif

    %% non-inlined and non reused library subsystem functions can also be part of the
    %% model class; its prototype may or may not have a classname:: prefix
    %% depending on it is in the declaration position (in class) or definition
    %% position (in .cpp).
    %assign subsysFcnAsMemFcn = SLibGenSubsysFcnAsClassMemFcn(system)
    %assign optClassNamePrefix = ""
    %if subsysFcnAsMemFcn
        %assign className = CGMODEL_ACCESS("CGModel.getClassName")
        %assign optClassNamePrefix = className + "::"
    %endif

    %if ISEMPTY(optClassNamePrefix) && FcnGenerateSubsystemClassStaticMethods(system)
        %assign optClassNamePrefix = FcnGetSubsystemClassName(system) + "::"
    %endif

    %assign isSubFunction = SLibIsFcnSubFunction(system, sysFcn)
    %if (SLibIsMultiInstanceServer(system) || ...
        (thisModule.SimplifiedInterface && IsModelReferenceBaseSys(system) && !subsysFcnAsMemFcn)) ...
        && ISEMPTY(::FcnRec.Params) && !GenerateClassInterface && !isOutlinedBlockFcn && !isSubFunction
        %assign selfCoderGroupIdx = SLibGetSelfCoderDataGroupIndex()
        %assign selfCoderGroup = ::CompiledModel.CoderDataGroup[selfCoderGroupIdx]
        %assign constRTM = selfCoderGroup.IsMemorySectionConst ? "const " : ""
        %assign volatileRTM = selfCoderGroup.IsMemorySectionVolatile ? "volatile " : ""
        %assign ::FcnRec.Params = "%<constRTM>%<volatileRTM>%<tSimStructType> * const %<tSimStruct>"
    %endif

    %assign statQual = ""
    %if isRoot && RootBodyMthsStatic && !subsysFcnAsMemFcn && !exportFcnMode && !isExternFcn
        %assign statQual = "static "
    %endif

    %if(CGMODEL_ACCESS("CGModel.AddStaticKeywordToFcn"))
        %if FcnUseStaticStorageSpecifier(system)
            %assign statQual = "static "
        %endif
    %endif

    %% If generating C++ and the function isn't static (thus limiting visibility
    %% to a single file) then extern "C" it because it will be called from the
    %% static <target>_main.c file.
    %assign cppStorageClass = ""
    %if GenCPP && isRoot && (statQual == "") && !subsysFcnAsMemFcn && !Accelerator
        %assign cppStorageClass = ExternCPrefix + " "
    %endif

    %if (sysFcn == "Initialize" || sysFcn == "SystemInitialize" || sysFcn == "SystemReset" || sysFcn == "Start" || sysFcn == "Terminate")
        %assign msFcnType = "MemSecFuncInitTerm"
    %else
        %assign msFcnType = "MemSecFuncExecute"
    %endif

    %% Create function opening:
    %% pre-pragma + qualifiers + function prototype
    %% We need to add pre-processor conditionals into the record so that the callee knows
    %% about the pre-processor condition in prototype. Note that this record will go into
    %% "OutputUpdateFcnInfo"in system scope. The existsing 'SLibIfVariantConditionForm'
    %% doesn't return the pre-processor conditionals for export functions, so we have to
    %% use the root inport CGVCE (propagated variant condition) set for a particular TID.
    %% This information lives in function record and populated from root input function-call
    %% generator block.
    %openfile open
    %% Guard the export Functions with the FcnTID variant condition cached into the aFcnprototype
    %% record.
    %if exportFcnMode == 1 && !ISEMPTY(::FcnRec.FcnTIDCGVCEIfCondition)
        %<::FcnRec.FcnTIDCGVCEIfCondition>
    %endif

    %% Guard the Functions with the module variant condition cached into the aFcnprototype
    %% record.
    %if !ISEMPTY(::FcnRec.ModuleIfCondition)
        %<::FcnRec.ModuleIfCondition>
    %elseif !ISEMPTY(moduleCondition)
        %assign ::FcnRec.ModuleIfCondition = SLibIfVariantConditionForm(moduleCondition)
        %assign ::FcnRec.ModuleEndIfCondition = SLibEndIfVariantConditionForm(moduleCondition)
        %<SLibIfVariantConditionForm(moduleCondition)>
    %endif
    %assign useIndividualMapping = TLC_FALSE
    %assign functionType = ""
    %assign functionId = "" %% Assume
    %assign isPartitionOrImplicitStepOutputOrUpdateFcn = TLC_FALSE
    %if (GenerateClassInterface && CGMODEL_ACCESS("CGModel.isCPPMappingEnabled")) || ...
        (!GenerateClassInterface && CGMODEL_ACCESS("CGModel.isIndividualFunctionMappingEnabled"))
        %if IsModelReferenceTarget()
            %% Model Reference build
            %if (sysFcn == "ModelInitialize") && TLC_FALSE
                %% Initialize function
                %% NOTE: Skip this (this is re-computed in ertreg.tlc)
                %assign functionType = "Initialize"
                %assign useIndividualMapping = TLC_TRUE
            %elseif (sysFcn == "Terminate")
                %% Terminate function
                %assign functionType = "Terminate"
                %assign useIndividualMapping = TLC_TRUE
            %elseif (sysFcn == "OutputUpdate") || (sysFcn == "Output") || ...
                (sysFcn == "Update")
                %if SLibExplicitTaskingTID(system.CurrentTID)
                    %if SLibResetOrResetWithInitEventTID(system.CurrentTID)
                        %% Reset function
                        %assign functionType = "Reset"
                        %assign functionId = SampleTime[system.CurrentTID].EventSourceName
                        %assign useIndividualMapping = TLC_TRUE
                    %elseif SLibIsRateGroupedSLFcn(system, sysFcn, system.CurrentTID)
                        %% Global or Public Simulink Function in export function model
                        %assign functionType = "SimulinkFunction"
                        %assign functionId = SLibGetRateGroupedSimulinkFunctionName(system, sysFcn, system.CurrentTID)
                        %assign useIndividualMapping = TLC_TRUE
                    %elseif !LibIsServer(system) && ...
                        SLibIsExplicitTaskingExportFcnRateGrouping(sysFcn, system.CurrentTID)
                        %% Export or Async function
                        %% NOTE: SampleTime[tid].TaskName returns block name for export function,
                        %%  and full block path for async function
                        %assign functionType = "FcnCallInport"
                        %assign functionId = REGEXPREP( ...
                            SampleTime[system.CurrentTID].TaskName, ".*\/", "")
                        %assign useIndividualMapping = TLC_TRUE
                    %elseif SLibIsExplicitPartitioningTID(system.CurrentTID)
                        %% Partition via schedule editor
                        %if (sysFcn == "OutputUpdate")
                            %assign functionType = "Step"
                        %elseif (sysFcn == "Output")
                            %assign functionType = "Output"
                        %elseif (sysFcn == "Update")
                            %assign functionType = "Update"
                        %endif
                        %assign functionId = system.CurrentTID
                        %assign useIndividualMapping = TLC_TRUE
                        %assign isPartitionOrImplicitStepOutputOrUpdateFcn = TLC_TRUE
                    %endif
                %else
                    %if !SLibIsExportFcnDiagram()
                        %if (LibIsGlobalServer(system) || SLibIsModelScopedServer(system))
                            %% Global or Exported Global Scoped Function in a rate-based model
                            %assign functionType = "SimulinkFunction"
                            %assign functionId = SLibGetSimulinkFunctionNameInNonExportFcnModel(system)
                            %assign useIndividualMapping = TLC_TRUE
                        %elseif !LibIsServer(system) &&  IsModelReferenceBaseSys(system)
                            %% Implicit periodic functions
                            %% NOTE: Don't do any computation if the system does not correspond to the
                            %% root (for e.g. subsystem). For those cases, there is no corresponding
                            %% individual mapping, so compute memory sections the legacy way.
                            %if (sysFcn == "OutputUpdate")
                                %assign functionType = "Step"
                            %elseif (sysFcn == "Output")
                                %assign functionType = "Output"
                            %elseif (sysFcn == "Update")
                                %assign functionType = "Update"
                            %endif
                            %assign functionId = system.CurrentTID
                            %assign useIndividualMapping = TLC_TRUE
                            %assign isPartitionOrImplicitStepOutputOrUpdateFcn = TLC_TRUE
                        %endif
                    %endif
                %endif
            %endif
        %else
            %% Top Model build
            %if (LibIsGlobalServer(system) || SLibIsModelScopedServer(system))
                %% Global or Exported Global Scoped Function in a rate-based model
                %assign functionType = "SimulinkFunction"
                %assign functionId = SLibGetSimulinkFunctionNameInNonExportFcnModel(system)
                %assign useIndividualMapping = TLC_TRUE
            %endif
        %endif
    %endif

    %assign memSecUUID = ""
    %if useIndividualMapping
        %if ISEMPTY(functionType)
            %<LibReportFatalError("Unknown functionType for individual function mapping")>
        %endif
        %assign memSecUUID = SLibGetFcnMemSecUUIDForFunction(functionType, functionId)
        %if isPartitionOrImplicitStepOutputOrUpdateFcn && !SLibFcnProtoCtrlActive() && ...
            IsModelReferenceRTWTarget()
            %% Update function name using name stored in the mapping.
            %% Only needed for model reference output/update functions. Handling is
            %% done else where for other functions.
            %if GenerateClassInterface && !CombineOutputUpdateFcns && functionType == "Step"
                %assign functionType = "Output"
            %endif
            %assign fcnNameInMapping = CGMODEL_ACCESS("CGModel.getModelEntryFunctionName", "%<functionType>", "%<functionId>")
            %if ISEMPTY(fcnNameInMapping) && (functionType == "Output")
                %% In some scenarios (e.g. continuous sample time or states logging),
                %% model reference codegen can decide to split the step function into
                %% separate output/update functions. In this case, there is only one
                %% step function mapping, and this is where the registered function
                %% name for the output function is stored. Hence fetch the name from the
                %% step function mapping.
                %% Note that for these scenarios, there is no update function mapping.
                %% Hence the default name will be used for the update function name.
                %assign fcnNameInMapping = CGMODEL_ACCESS("CGModel.getModelEntryFunctionName", "Step", "%<functionId>")
            %endif
            %if !ISEMPTY(fcnNameInMapping)
                %assign ::FcnRec.Name = cppClassPreString + fcnNameInMapping
            %endif

        %endif
        %<SLibGetFcnMemSecPragmaForFunction(::FcnRec.Name, functionType, functionId,  "Pre")>\
    %else
        %<SLibGetFcnMemSecPragmaForSystem(::FcnRec.Name, msFcnType, "Pre", system)>\
    %endif

    %if ISEMPTY(fcnPrototype)
        %if ISEMPTY(::FcnRec.Params)
            %if !subsysFcnAsMemFcn
                %assign fcnPrototype = fcnPrototype + ::FcnRec.Name + "(void)"
            %else
                %% C++ conventions is not to use 'void' for empty param function prototype
                %assign fcnPrototype = fcnPrototype + ::FcnRec.Name + "()"
            %endif %% !subsysFcnAsMemFcn
        %else
            %assign fcnPrototype = ::FcnRec.Name + "(" + ::FcnRec.Params + ")"
        %endif %% ISEMPTY(::FcnRec.Params)
    %endif

    %% If the prototype is constructed in IR, the fcnPrototype
    %% will already have the trailing const, otherwise, add it here
    %if !protoTypeAlreadyConstructedInIR && FcnIsConstMemberMethod(system, fcnName)
        %assign fcnPrototype = fcnPrototype + " const"
    %endif

    %if SLibAutosarCompilerAbstractionRequired()
        %if SLibAutosarIsMultiRunnableFcn(::FcnRec.Name)
            %assign memclass = "FuncCalledByRTE"
        %else
            %assign memclass = "FuncInternal"
        %endif

        %<cppStorageClass> %<statQual> %<SLibAutosarCompilerAbstractionForFcnDeclRtnType(::FcnRec.Returns, memclass, memSecUUID)> %<optClassNamePrefix>%<fcnPrototype>
    %else
        %<cppStorageClass> %<statQual> %<::FcnRec.Returns> %<optClassNamePrefix>%<fcnPrototype>
    %endif
    {
        %closefile open

        %% Create function closing
        %openfile close
    }
    %if useIndividualMapping
        %<SLibGetFcnMemSecPragmaForFunction(::FcnRec.Name, functionType, functionId,  "Post")>\
    %else
        %<SLibGetFcnMemSecPragmaForSystem(::FcnRec.Name, msFcnType, "Post", system)>\
    %endif
    %% Guard the Functions with the module variant condition cached into the aFcnprototype
    %% record.
    %if !ISEMPTY(::FcnRec.ModuleIfCondition)
        %<::FcnRec.ModuleEndIfCondition>
    %elseif !ISEMPTY(moduleCondition)
        %assign ::FcnRec.ModuleEndIfCondition = SLibEndIfVariantConditionForm(moduleCondition)
        %<SLibEndIfVariantConditionForm(moduleCondition)>
    %endif
    %% Guard the export Functions with the FcnTID variant condition cached into the aFcnprototype
    %% record.
    %if exportFcnMode == 1 && !ISEMPTY(::FcnRec.FcnTIDCGVCEIfCondition)
        %<::FcnRec.FcnTIDCGVCEEndIfCondition>
    %endif

    %closefile close

    %assign begin = ""

    %%
    %% For root methods in S-function format, we may need a
    %% # define before the method. We cache that here
    %%
    %assign sfcnFormDefine = ""
    %if isRoot && (CodeFormat == "S-Function")
        %%
        %% For S-Function target (right click build), add
        %% '#define MDL_INITIALIZE_CONDITIONS' before root systemInitialize
        %% since S-Function block should have block initialize method
        %% instead of systemInitialize and systemReset.
        %%
        %if sysFcn == "SystemInitialize" && !Accelerator
            %assign sfcnFormDefine = FcnGetSfcnFormDefine("Initialize")
        %else
            %assign sfcnFormDefine = FcnGetSfcnFormDefine(sysFcn)
        %endif
    %endif

    %assign name = sysFcn + "FcnInfo"
    %if SLibAutosarCompilerAbstractionRequired()
        %if SLibAutosarIsMultiRunnableFcn(::FcnRec.Name)
            %assign memclass = "FuncCalledByRTE"
        %else
            %assign memclass = "FuncInternal"
        %endif

        %assign fcnPrototype = SLibAutosarCompilerAbstractionForFcnDeclRtnType(::FcnRec.Returns, memclass, memSecUUID) + " " + fcnPrototype
    %else
        %assign fcnPrototype = ::FcnRec.Returns + " " + fcnPrototype
    %endif

    %if ISEMPTY(::FcnRec.Returns)
        %if !ISEMPTY(fcnReturns)
            %assign ::FcnRec.Returns = fcnReturns
        %else
            %assign ::FcnRec.Returns = "void"
        %endif
    %endif
    %<SLibUpdateSymbolForFunction(fcnName, ::FcnRec.Returns, TLC_TRUE)>
    %createrecord %<name> \
    { \
        SysFcn         sysFcn; \
        Name           ::FcnRec.Name; \
        CGIRName       fcnName; \
        Returns        ::FcnRec.Returns;\
        Params         ::FcnRec.Params; \
        CommonPrms     ::FcnRec.CommonPrms; \
        CommonArgs     ::FcnRec.CommonArgs; \
        FcnPrototype   fcnPrototype; \
        SfcnFormDefine sfcnFormDefine; \
        ModuleIfCondition ::FcnRec.ModuleIfCondition; \
        ModuleEndIfCondition ::FcnRec.ModuleEndIfCondition; \
        FcnTIDCGVCEIfCondition ::FcnRec.FcnTIDCGVCEIfCondition; \
        FcnTIDCGVCEEndIfCondition ::FcnRec.FcnTIDCGVCEEndIfCondition; \
        Open           open; \
        Begin          begin; \
        Close          close \
    }
    %return %<name>
%endfunction

%function SLibSystemFcnIsExtern(system, tid, fcn) void
    %return SLibSystemIsModelEntryPoint(system, tid) && ...
        (fcn == "Output" || fcn == "OutputUpdate" || fcn == "UpdateContStates" || ...
        fcn == "Enable" || fcn == "Disable")
%endfunction

%% Function: SLibSystemFcnIsModelEntryPoint
%% TopTester: test/toolbox/simulink/variants/var-vss-sigobj/tVSSSigObj.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/rtw/targets/AUTOSAR/Variants/inlineVariants/tInlineVariants10.m
%%
%function SLibSystemIsModelEntryPoint(system, tid) void
    %assign retVal = TLC_FALSE
    %if LibSystemIsRoot(system)
        %if  SLibFcnProtoCtrlActive() || SLibAutosarActive() || ...
            SLibIsAsyncTaskOnlyModel()
            %assign retVal = TLC_FALSE
        %else
            %if SLibIsPeriodicRateGrouping()
                %if ISEQUAL(tid,"")
                    %if ISEQUAL(::CompiledModel.ConfigSet.HardwareBoard, "None")
                        %% when tid is empty, wrapper step function is not considered as a model entry point
                        %return TLC_FALSE
                    %else
                        %return (SLibNeedWrapperStepFcn()==1)
                    %endif
                %endif
                %if TYPE(tid) == "Number"
                    %% when tid is number
                    %if (tid == 0) && NumContStates > 0
                        %% solver always call rate grouped function if rate grouping is on
                        %return TLC_TRUE
                    %endif
                    %if !((tid == 1) && Tid01Eq) && ...
                        (!LibAsynchronousTriggeredTID(tid) || SLibNonInlinedModelWideEventTID(tid))
                        %return TLC_TRUE
                    %endif
                %endif
            %else
                %% nonperiodicRateGrouping return true when tid is empty (void mdl_step(void))
                %assign retVal = ISEQUAL(tid,"")
            %endif
        %endif
    %endif
    %return retVal
%endfunction

%% Function: SLibGetFcnInfoForFcnName ==============================================================
%% Abstract:
%%    Return fcnInfo record of the system and a given function name.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function SLibGetFcnInfoForFcnName(aSystem, aFcnName) void
    %assign fieldName = "CGIR_" + aFcnName + "_FcnInfo"
    %if LibIsSystemField(aSystem, fieldName)
        %return  LibGetSystemField(aSystem, fieldName)
    %endif
    %return ""
%endfunction

%function FcnPrototypeEndsWithConst(prototype)
    %assign stringToLookFor =  ") const"
    %assign endsWithConst = CGMODEL_ACCESS("String.find",prototype,stringToLookFor)
    %assign constMethod = (endsWithConst != -1)
    %return constMethod
%endfunction

%% Function: LibDefineSystemFcnForTID ==============================================================
%% Abstract:
%%   Cache a record in the system scope so that the subsystem block
%%   (who calls the function) knows the prototyped.
%%
%%   Arguments:
%%      system: Simulink system
%%      sysFcn: The system function to define
%%                  o Initialize
%%                  o Output
%%                  o Update
%%                  o OutputUpdate
%%                  o Derivative
%%                  o Enable
%%                  o Disable
%%      fcnRec: Reference to fcnRec (see top of file for definition of record)
%%
%%
%%   Example:
%%      %assign fcnRec.Name    = "foo"
%%      %assign fcnRec.Returns = "void"
%%      %assign fcnRec.Params  = "int_T tid"
%%      %assign fcnRec.Args    = "tid"
%%
%%      %<LibDefineSystemFcnForTID(system, "OutputUpdate", tid)>
%%
%%      Creates a function information record in the system scope:
%%
%%      System {
%%        :
%%        OutputUpdateFcnInfo {
%%          Name         "foo"
%%          Returns      "void"
%%          Params       "int_T tid"
%%          Args         "tid"
%%          fcnCall      "foo(tid)"
%%          fcnPrototype "void foo(int_T tid)"
%%       }
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants10.m
%% TopTester: test/toolbox/simulink/variants/var-inline-general/tIVfcnCall_neg.m
%%
%function LibDefineSystemFcnForTID(system, sysFcn,tid) void
    %assign system.CurrentTID = tid
    %assign isRateGrouping = SLibSystemFcnPeriodicRateGrouping(system, sysFcn) || ...
        (LibAsynchronousTriggeredTID(system.CurrentTID) && ...
        (sysFcn == "Output" || sysFcn == "Update" || sysFcn == "OutputUpdate"))
    %assign fcnRecord = SLibSystemFcnInfoRecord(system, sysFcn)

    %assign fieldName = "CGIR_" + fcnRecord.CGIRName + "_FcnInfo"
    %if !LibIsSystemField(system, fieldName)
        %<LibAddToSystem(system, fieldName, fcnRecord)>
    %elseif (TYPE(tid) == "Number" && tid < NumRuntimeExportedRates)
        %% Call it, just to get error message
        %<LibAddToSystem(system, fieldName, fcnRecord)>
    %else
        %assign needToStop = IsModelReferenceBaseSys(system) && ISEMPTY(tid) && ...
            (sysFcn == "Output" || sysFcn == "Update" || sysFcn == "OutputUpdate")
        %if needToStop
            %return
        %endif
    %endif

    %if isRateGrouping && TYPE(system.CurrentTID) == "Number"

        %% Record if we originally marked this function const
        %assign origConstFlag = FcnIsConstMemberMethod(system, sysFcn)

        %% Set up the global vars for this system and function, this
        %% is needed for nonreusable functions that live in reusable functions
        %assign globalVars = LibInitializeGlobalVars(system, sysFcn)

        %% If we made this function non-const after adding some global
        %% var initialization, strip out the const from the prototype
        %<FcnRemoveConstFromPrototype(origConstFlag, system, sysFcn, fcnRecord, fieldName)>

        %if SLibPartitionGroupingSystem(system)
            %assign pidVec =  SLibGetPidFromTid(system.CurrentTID)
            %foreach i = SIZE(pidVec, 1)
                %<LibSetSystemField(system, ...
                    "Cached%<sysFcn>%<system.CurrentTID>%<pidVec[i]>GlobalVars",  globalVars)>
                %<LibAddToSystem(system,...
                    "%<sysFcn>TID%<system.CurrentTID>PID%<pidVec[i]>FcnInfo", fcnRecord)>
            %endforeach
        %else
            %<LibSetSystemField(system, ...
                "Cached%<sysFcn>%<system.CurrentTID>GlobalVars",  globalVars)>
            %<LibAddToSystem(system,...
                "%<sysFcn>TID%<system.CurrentTID>FcnInfo", fcnRecord)>
        %endif
    %else
        %% Set up the global vars for this system and function, this
        %% is needed for nonreusable functions that live in reusable functions

        %assign origConstFlag = FcnIsConstMemberMethod(system, sysFcn)

        %assign globalVars = LibInitializeGlobalVars(system, sysFcn)

        %% If we made this function non-const after adding some global
        %% var initialization, strip out the const from the prototype
        %<FcnRemoveConstFromPrototype(origConstFlag, system, sysFcn, fcnRecord, fieldName)>

        %if !ISEMPTY(globalVars) && !WHITE_SPACE(globalVars)
            %<LibSetSystemField(system, "Cached"+sysFcn+"GlobalVars",  globalVars)>
        %endif
        %<LibAddToSystem(system, sysFcn + "FcnInfo", fcnRecord)>
    %endif

    %if LibSystemIsInlined(system)
        %% If inlining reassign Open and FcnCall
        %openfile declarebuf
        %<LibDumpSystemSSVars(system,sysFcn)>\
        %if isRateGrouping
            %<LibGetSystemLocalVars(system, sysFcn, system.CurrentTID)>
            %if sysFcn == "OutputUpdate"
                %<SLibGetFcnLocalVars(system, "Output", system.CurrentTID)>
                %assert ISEMPTY(SLibGetFcnLocalVars(system, "Update", system.CurrentTID))
            %else
                %<SLibGetFcnLocalVars(system, sysFcn, system.CurrentTID)>
            %endif
        %else
            %<LibGetSystemLocalVars(system, sysFcn, "")>
            %if sysFcn == "OutputUpdate"
                %<SLibGetFcnLocalVars(system, "Output", "")>
                %assert ISEMPTY(SLibGetFcnLocalVars(system, "Update", ""))
            %else
                %<SLibGetFcnLocalVars(system, sysFcn, "")>
            %endif
        %endif
        %closefile declarebuf
        %if LibSystemUserCodeIsEmpty(system,sysFcn,"Header") && ...
            WHITE_SPACE(declarebuf)
            %assign needOutputsBrace = 0
        %else
            %assign needOutputsBrace = 1
        %endif
        %if needOutputsBrace
            %assign fcnRecord.Open = "{\n"
            %assign fcnRecord.Begin = "\n"
            %assign fcnRecord.Close = "}\n"
        %else
            %assign fcnRecord.Open  = ""
            %assign fcnRecord.Begin = ""
            %assign fcnRecord.Close = ""
        %endif
    %else
        %if (system.Type != "root") && ...
            ((!LibSystemFcnIsEmptyHelper(system,sysFcn,tid)) || ...
            (system.Type == "function-call" && sysFcn == "OutputUpdate" && ...
            (ISEQUAL(tid,FcnGetSubsystemTID(system,TLC_TRUE))  || (GenerateClassInterface && !LibIsServer(system) && !SLibModelWideEventTID(tid) ))) || ...
            (SLibGenSubsysFcnAsClassMemFcn(system) && ...
            ISEQUAL(tid, "") && (!FcnSysModuleIsRateGrouping(system, sysFcn) || !SLibIsExportFcnDiagram()) && !LibSystemFcnIsEmpty(system, sysFcn)) || ...
            (sysFcn == "Terminate" && !LibSystemFcnIsEmpty(system, sysFcn) && IncludeMdlTerminateFcn))
            %% Only dump the prototype if the caller does not live
            %% in the same file or it is a Async sfcn.
            %assign isMdlRefBaseAndIsAsyncTID = ...
                IsModelReferenceBaseSys(system) && LibAsynchronousTriggeredTID(tid) && !SLibNonInlinedModelWideEventTID(tid)
            %% Need to delay the caching of the start fcn prototype until after output fcn
            %% has been processed. Output fcn can indicate the need for model params to be initialize
            %% in the start fcn. The prototype of the start fcn is formed by the need of those
            %% params. The prototype is later cached in commonbodlib.tlc
            %assign isMdlRefStart = IsModelReferenceBaseSys(system) && SLibIsExportFcnDiagram() && sysFcn == "Start"
            %assign simulinkFunctionPrototypeInModelHeader = SLibIsRateGroupedSLFcn(system, sysFcn, tid) && ...
                !SLibRateGroupedSimulinkFunctionNeedsDeclaration(system, sysFcn, tid)

            %if (!isMdlRefBaseAndIsAsyncTID || ...
                SLibIsExplicitTaskingExportFcnRateGrouping(sysFcn,tid) || ...
                simulinkFunctionPrototypeInModelHeader) && ...
                !SLibSystemFcnIsExtern(system, tid, sysFcn) && ...
                !isMdlRefStart
                %<LibCacheSubsystemPrototype(system,fcnRecord)>\
            %endif
        %endif
    %endif
    %assign system.CurrentTID = -1
%endfunction %% LibDefineSystemFcnForTID

%% Model reference base system has separate entry points for
%% tid 0 and 1, even if tid01eq.
%function FcnAddMdlRefTid1Interface(system, tid)
    %return ISEQUAL(tid,0) && ...
        ISEQUAL(::CompiledModel.SolverType, "FixedStep") && ...
        (LibGetTID01EQ() == 1) && ...
        IsModelReferenceBaseSys(system)
%endfunction

%% Function: LibDefineSystemFcn ====================================================================
%% Description:
%%   Call LibDefineSystemFcn to Cache record(s) in the system scope
%%   so that the subsystem block (who calls the function) knows
%%   the prototyped. When SLibSystemFcnPeriodicRateGrouping( is true, records are
%%   cached very each tid function call. If partition grouping is on,
%%   records are cached for each pair <tid, pid> function call.
%% TopTester: test/toolbox/rtw/targets/AUTOSAR/Variants/inlineVariants/tInlineVariants10.m
%% TopTester: test/toolbox/simulink/variants/var-simulinkfcns/tAutoInherit.m
%%
%function LibDefineSystemFcn(system, sysFcn) void
    %if sysFcn == "Output" || sysFcn == "Update" || ...
        sysFcn == "OutputUpdate" || ...
        (SLibContFcnPartitionGrouping(sysFcn) && ...
        SLibDeploymentDiagramIsMapped(system.SystemIdx))
        %assign ssTaskToFirstTid = FcnGetSubsystemTaskToFirstTID(system)
        %% Currently, we need to make sure that base system for mdlref gets
        %% tid 0 for argument tracking otherwise
        %% t/t/simulink/sltools/raccel/mg544769_raccell fails
        %if IsModelReferenceBaseSys(system) && ...
            (ISEMPTY(ssTaskToFirstTid) || ssTaskToFirstTid[0] != 0)
            %assign tid = FcnGetCodeCacheTid(system, sysFcn, 0)
            %<LibDefineSystemFcnForTID(system, sysFcn, tid)>
        %endif
        %foreach idx = SIZE(ssTaskToFirstTid, 1)
            %assign tid = FcnGetCodeCacheTid(system, sysFcn, ssTaskToFirstTid[idx])
            %% Reset, Terminate (in mdlrefsim), and reset with init event have no update functions.
            %% Do not cached continuous rate related fcn records if tid is not 0,
            %% we hit this because of the way we treat tid01eq in partition grouping.
            %if (SLibNonInlinedIRTEventTID(tid) && sysFcn == "Update") || ...
                (SLibContFcnPartitionGrouping(sysFcn) && tid != 0)
                %continue
            %endif
            %<LibDefineSystemFcnForTID(system, sysFcn,tid)>
            %if FcnAddMdlRefTid1Interface(system, tid)
                %<LibDefineSystemFcnForTID(system, sysFcn,1)>
            %endif
        %endforeach
    %else
        %<LibDefineSystemFcnForTID(system, sysFcn, "" )>
    %endif
%endfunction %% LibDefineSystemFcn

%% Function: LibGenSubsystemFcnCall ================================================================
%% Abstract:
%%   Generates a function call to a system.
%%
%% Arguments:
%%  outAndRuleIdx - a two-elements vector of string for actual arguments of output idx
%%                  and rule idx. use [] if the fcn is not SetDims fcn.
%%          canIO - a vector of strings for actual arguments of canonical I/O,
%%                  use [] normally works.
%%        fcnInfo - contains the function name and the type of the call
%%                  (e.g. "Start, Output, Update, ...")
%%   parentSysIdx - location of the system call
%%                  (Where the function is called)
%%         sysIdx - system to be called
%%    callSiteIdx - system instance to be used
%% TopTester: test/toolbox/rtw/targets/AUTOSAR/Variants/inlineVariants/tInlineVariants10.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%%
%function LibGenSubsystemFcnCall(canIO, fcnInfo, parentSysIdx, sysIdx, callSiteIdx) void
    %if ISEMPTY(fcnInfo)
        %return ""
    %endif
    %assign accessSysIdx = System[parentSysIdx].HStructDeclSystemIdx
    %assign genModelRef = ...
        IsModelReferenceTarget() && accessSysIdx == ::CompiledModel.NumSystems-1

    %assign addArgs = FcnGetAdditionalArgs(fcnInfo.CGIRName, canIO, ...
        fcnInfo.SysFcn, sysIdx, accessSysIdx, callSiteIdx, genModelRef, TLC_FALSE)
    %assign comArgs = fcnInfo.CommonArgs
    %assign cs = System[sysIdx].CallSites[callSiteIdx]
    %assign ssBlk = System[cs[2]].Block[cs[3]]
    %%
    %assign comma = (WHITE_SPACE(addArgs) || WHITE_SPACE(comArgs)) ? "" : ", "
    %%
    %% If one or more of arguments of a function that is passed by address
    %% is a expression, than the result of this expression has to be stored
    %% in a temporrary variable. The address of the temporary variable will
    %% than be passed as the argument of the function call.
    %%
    %if (fcnInfo.SysFcn == "OutputUpdate") && ...
        IsModelReferenceBaseSys(System[sysIdx]) && ...
        SLibFcnProtoCtrlActive()
        %assign FPC = FcnGetFunctionPrototypeRecord()
        %assign fcnName = FPC.FunctionName
    %else
        %assign fcnName = fcnInfo.Name
    %endif

    %if GenerateClassInterface && IsModelReferenceBaseSys(System[sysIdx])
        %% remove model class name specifier
        %assign p = CGMODEL_ACCESS("String.find", fcnName, "::")
        %if p >= 0
            %assign start = p + 2
            %assign length = SIZE(fcnName)[1] - start
            %assign fcnName = CGMODEL_ACCESS("String.substr", fcnName, start, length)
        %endif
    %endif

    %if FcnGenerateSubsystemClassStaticMethods(System[sysIdx])
        %assign fcnName = FcnGetSubsystemClassName(System[sysIdx]) + "::" + fcnName
    %endif

    %if ISFIELD(ssBlk, "%<fcnInfo.SysFcn>FcnCallCode")
        %assign fcnCallCode = GETFIELD(ssBlk, "%<fcnInfo.SysFcn>FcnCallCode")
        %assign fcnCall = ""
        %openfile fcnCall
        {
            %<fcnCallCode.localPrmDecl>
            %<fcnCallCode.localExpr>
            %<fcnName>(%<comArgs>%<comma>%<addArgs>);
        }
        %closefile fcnCall
        %return fcnCall
    %else
        %return "%<fcnName>(%<comArgs>%<comma>%<addArgs>)"
    %endif
%endfunction

%% Function: FcnGetCanDWorkArg =====================================================================
%% Abstract:
%%   Returns a canonical dwork argument for a give argument index, callsite,
%%   access system index and callsite index.
%%
%function FcnGetCanDWorkArg(sysFcn, cs, argIdx, sysIdx, accessSysIdx, callSiteIdx) void
    %%
    %assign parent = System[sysIdx]
    %%
    %% Get the reused function or root
    %%
    %assign callerHStSystem = SLibCallerHStuctDeclSystem(parent, callSiteIdx)
    %assign dwArg = ""
    %assign ssBlk = System[cs[2]].Block[cs[3]]

    %with parent
        %assign cTID = FcnGetCurrentAccessTid()
    %endwith

    %assign accessSystem = ::CompiledModel.System[accessSysIdx]

    %if sysIdx == accessSysIdx
        %% For code reuse of multi-mode enable/trigger subsystems,
        %% function FinalizeDims is not called by its parent
        %% subsystem. It is called by its output function.
        %% In the output function, local reference of the canonical
        %% dwork for current dimensions should be used to call the
        %% function FinalizeDims
        %%
        %% Also, output function may also call its enable function
        %% for the same type subsystems
        %%
        %assert (sysFcn == "FinalizeDims" || sysFcn == "Enable")
        %assert (parent.HStructDeclSystemIdx == sysIdx)
        %assert (callSiteIdx == 0)
        %%
        %% idNum[0] == "dp"
        %%
        %% we want to access a formal argument at the callsite
        %% of sysIdx being called by itself, dp0 tells that it
        %% is the 1st dwork argument of the parent reusable
        %% subsystem, and it is passed in as the argIdx'th
        %% argument of sysIdx.
        %%
        %% the same is true for "D" and "d".
        %%
        %assign canDWorkArgDef = ...
            parent.Interface.CanonicalDWorkArgDef[argIdx]
        %assign dwArg = LibGetRecordIdentifier(canDWorkArgDef)
        %<SLibAccessArgHelper(canDWorkArgDef, "",cTID)>
        %if parent.CrossNoArgFcnBound
            %<SLibAccessArgHelper(canDWorkArgDef, "Global",cTID)>
            %assign dwArg = canDWorkArgDef.GlobalIdentifier
        %endif
    %else
        %assign arg    = ssBlk.CallSiteInfo.CanonicalDWorkArg[argIdx]
        %assign argSrc = arg.SignalSrc %% Di, di or dpi
        %assign idNum  = IDNUM(argSrc)
        %%
        %assert (idNum[0] == "D" || idNum[0] == "d" || idNum[0] == "dp" || idNum[0] == "db")
        %%
        %%
        %assign callerSysIdx = cs[0]
        %assign cross        = System[callerSysIdx].CrossNoArgFcnBound
        %if idNum[0] == "dp" %% uses relative idx
            %assert (callerHStSystem.Type != "Root")
            %%
            %if callerHStSystem.SystemIdx < accessSysIdx
                %assign parentNonReuseSysIdx = System[parent.CallSites[callSiteIdx][0]].ReusedParentSystemIdx
                %assign nonreuseCallerSysIdx = System[parentNonReuseSysIdx].CallSites[cs[1]]
                %assign dwArg = FcnGetCanDWorkArg(sysFcn, nonreuseCallerSysIdx,  idNum[1], ...
                    parentNonReuseSysIdx, accessSysIdx, cs[1])
            %else
                %%
                %% If the callerHStSystem is a hidden system for
                %% Implicit Iterator Subsystem, it might not have
                %% Interface.CanonicalDWorkArgDef field because it might be
                %% inlined.
                %%
                %assign localSystem = SLibCallerReusedParentSystem(parent, callSiteIdx)
                %assign callerDWork = ...
                    localSystem.Interface.CanonicalDWorkArgDef[idNum[1]]
                %assign dwArg   = LibGetRecordIdentifier(callerDWork)
                %<SLibAccessArgHelper(callerDWork, "",cTID)>
                %if cross
                    %<SLibAccessArgHelper(callerDWork, "Global",cTID)>
                    %assign dwArg = callerDWork.GlobalIdentifier
                %endif
            %endif
        %elseif idNum[0] == "db" %% access buried DWork
            %if callerHStSystem.SystemIdx != accessSysIdx
                %% For dwork in hidden system for Implicit Iterator Subsystem,
                %% callerHStSystem is not accessSys.
                %assign localSystem = SLibCallerReusedParentSystem(parent, callSiteIdx)
                %assert(localSystem.SystemIdx == accessSysIdx)
            %endif
            %assign dworkAndRec = FcnGetDworkAndRec(argSrc)
            %assign dwRec = dworkAndRec.DWorkRec
            %assign dwArg = ...
                "&" + ...
                FcnCGIRCGVarHelper(dwRec.VarGroupIdx[0], dwRec.VarGroupIdx[1], ...
                cross, accessSysIdx, SLibDWorkWidth(dwRec), "", -1, ...
                "", 0, TLC_FALSE)
        %elseif idNum[0] == "D" || idNum[0] == "d" %% global or local access
            %assign dworkAndRec = FcnGetDworkAndRec(argSrc)
            %assign dwRec       = dworkAndRec.DWorkRec
            %% temporary work around for g494342

            %if idNum[0] == "D" || dwRec.StorageClass != "Auto"
                %% Example,
                %%   Scalar: foo(&DWork.a)
                %%   Wide:   foo(&DWork.b[0])
                %%
                %% if dwork belongs to ExternalInputSize
                %% vargroup, it is actually not a DWork.
                %% this only happens for "D" case, not for
                %% "d", "dp" and "db".
                %assign dwRec = ::CompiledModel.DWorks.DWork[idNum[1]]

                %if !ISFIELD(dwRec, "VarGroupIdx")
                    %assign isPointer = dwRec.StorageClass == "ImportedExternPointer" && LibGetRecordWidth(dwRec) == 1
                    %assign dwArg = FcnCGIRSimpleCGVarHelper(dwRec.Identifier, ...
                        isPointer, %<LibGetRecordWidth(dwRec)>, "", -1, "", 0, TLC_TRUE)
                %elseif LibGetVarGroupCategory(dwRec.VarGroupIdx[0]) == "ExternalInputSize"
                    %if CodeFormat == "S-Function" && !Accelerator
                        %assign memberIdx = dwRec.VarGroupIdx[1]
                        %assign cgTypeIdx = SLibCGVarGroupMemberCGTypeIdx(...
                            dwRec.VarGroupIdx[0], ...
                            memberIdx)
                        %assign dwArg = "&" + FcnCGIRSFcnSizeVarHelper("ssGetCurrentInputPortDimensions", ...
                            TLC_FALSE, "const", ...
                            cgTypeIdx, memberIdx, %<LibGetRecordWidth(dwRec)>, "", "", 0)
                    %else
                        %assign varGroup = ...
                            ::CompiledModel.VarGroups.VarGroup[dwRec.VarGroupIdx[0]]
                        %assign memberIdx = dwRec.VarGroupIdx[1]
                        %assign portVarName = FcnSLibCGIRGetVarGroupMemberName(dwRec.VarGroupIdx[0], memberIdx)
                        %assign identifier = varGroup.Name + "." + portVarName
                        %assign dwArg = FcnCGIRSimpleCGVarHelper(identifier, ...
                            TLC_FALSE, %<LibGetRecordWidth(dwRec)>, "", -1, "", 0, TLC_TRUE)
                    %endif
                %else
                    %assign dwArg = SLibGetGlobalDWorkAddr(idNum[1], cross)
                %endif
            %else %% "d", Auto storage class
                %assert idNum[0] == "d"
                %% Example,
                %%   Scalar: foo(&localDW->a)
                %%   Wide:   foo(localDW->b)
                %%
                %%  If the caller is crossing a function boundary, use
                %%  the global variable instead of localDW.
                %assign dwRec = ::CompiledModel.DWorks.DWork[idNum[1]]
                %assign dwId  = LibGetRecordIdentifier(dwRec)
                %assign dwWidth = SLibDWorkWidth(dwRec)
                %%
                %if cross || callerHStSystem.StandaloneSubsystem
                    %if cross
                        %assert !callerHStSystem.StandaloneSubsystem
                        %<SLibAccessArgHelper(accessSystem.Interface.DWorkArgDef, "Global",...
                            cTID)>
                        %assign acc = "->"
                    %else
                        %assign acc = "."
                    %endif
                    %assign dWIdent = FcnSysVarGroupNonreusedName(accessSystem,"DWork")
                    %if dwWidth == 1
                        %assign dwArg = "&" + dWIdent + acc + dwId
                    %else
                        %assign dwArg = dWIdent + acc + dwId
                    %endif
                %else
                    %if !(GenerateClassInterface && IsModelReferenceBaseSys(callerHStSystem))
                        %if dwWidth == 1
                            %assign dwArg  = "&localDW->" + dwId
                        %else
                            %assign dwArg  = "localDW->" + dwId
                        %endif
                    %else
                        %%%% must be C++ encap. MdlRef and calling the subsys fcn
                        %%%% from the model reference hidden base subsystem
                        %assert IsModelReferenceRTWTarget()
                        %if dwWidth == 1
                            %assign dwArg  = "&(%<::tDWork>." + dwId + ")"
                        %else
                            %assign dwArg  = "%<::tDWork>." + dwId
                        %endif
                    %endif %% !(GenerateClassInterface && IsModelReferenceBaseSys(parent))
                %endif
                %<SLibAccessArgHelper(callerHStSystem.Interface.DWorkArgDef,"",...
                    cTID)>
            %endif
        %endif
    %endif
    %return dwArg
%endfunction

%% Function: FcnGetCanDWorkArgs ====================================================================
%% Abstract:
%%
%% Arguments:
%%         sysIdx   - system function to call
%%    callSiteIdx   - system instance to call
%%     accessSysIdx - location of the system call. This can be a function
%%                    or reusable function.
%% Note: If the subsystem is using one of its CanonicalDWork,
%%       and the subsystem is in a reusable function, it must mark
%%       the corresponding reusable function arg as Accessed.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%% TopTester :test/toolbox/simulink/variants/var-export-fcns/tExportFcnsWithInlineVariants.m
%%
%function FcnGetCanDWorkArgs(sysFcn, sysIdx, accessSysIdx, callSiteIdx, ...
    currentTID, isPeriodicRateGrouping, skipCanDWork) void
    %assign thisSystem = ::CompiledModel.System[sysIdx]
    %assign cs    = thisSystem.CallSites[callSiteIdx]
    %assign args  = ""
    %assign comma = ""
    %assign errTxt = "Invalid SignalSrc for CanonicalDWork."
    %assign isTestInterface = ...
        ::CompiledModel.ConfigSet.GenerateTestInterfaces && ...
        ISFIELD(thisSystem, "GenerateReusableWrapper") && ...
        GETFIELD(thisSystem, "GenerateReusableWrapper")

    %with thisSystem.Interface
        %foreach argIdx = NumCanonicalDWorkArgDefs
            %%
            %% Canonical DWorks has already been added in IR
            %%
            %if skipCanDWork[argIdx]
                %continue
            %endif
            %%
            %% Canonical dimsize dwork has already been added to args when
            %% canonical input(s) and output(s) are processed
            %%
            %if SLibGetCanDWorkIsCanDimSizeDWork(argIdx)
                %continue
            %endif

            %assign canDWork = CanonicalDWorkArgDef[argIdx]
            %if SysFcnArgNeeded(sysFcn, canDWork, currentTID, isPeriodicRateGrouping)
                %if isTestInterface && ISFIELD(canDWork, "SSGraphicalAPIReference")
                    %assign grDS = canDWork.SSGraphicalAPIReference
                    %assign args = args + comma + grDS.Name
                    %assign comma = ", "
                %else
                    %assign args = args + comma + ...
                        FcnGetCanDWorkArg(sysFcn, cs, argIdx, sysIdx, accessSysIdx, callSiteIdx)
                    %assign comma = ", "
                %endif %% if ConfigSet.GenerateTestInterfaces
            %endif %% if SysFcnArgNeeded
        %endforeach %% argIdx
        %%
    %endwith %% thisSystem.Interface
    %return args
%endfunction %% FcnGetCanDWorkArgs

%% Function: SLibGetCallSitePrmArg =================================================================
%% Abstract:
%%   Returns the parameter argument for a given callsite and parmeter index.
%% tOPTESTER: test/toolbox/simulink/blocks/tconcat.m
%%
%function SLibGetCallSitePrmArg(cs, childPrmIdx) void
    %if System[cs[0]].NumChildPrmArgs == 0
        %return SLibGetCallSitePrmArg(System[cs[0]].CallSites[cs[1]], childPrmIdx)
    %else
        %return System[cs[0]].ChildPrmArg[childPrmIdx]
    %endif
%endfunction %% SLibGetCallSitePrmArg

%% FunctionGetChildPrmArgFromParent  ===========================================
%% Abstract:
%%   This function, for a system's canonical parameter, returns the
%%   corresponding ChildPrmArg of the parent system. If the parent system
%%   itself is a reusable function and has the parameter as a canonical param
%%   then the function seeks the true parent of the system. The true parent
%%   system defines the actual address or value (in case of inlined) of a
%%   canonical parameter. The true parent's ChildPrmArg contains the actual
%%   address/value of the parameter
%%   For generating test interfaces, we need the actual value/address of a
%%   canonical parameter instead of its canonical argument string.
%%
%%  cs: CallSite of the system
%%  childPrmIdx: Index of the ChildPrmArg in the system
%%
%function FunctionGetChildPrmArgFromParent(cs, childPrmIdx) void
    %assign prm = SLibGetCallSitePrmArg(cs, childPrmIdx)
    %if prm.ASTNode.Op == "M_CANPRM_ID"
        %% Canonical param - Top-level Parent defines the memory/value
        %assign sysCS  = System[cs[0]].CallSites[cs[1]]
        %assign ssBlk  = System[sysCS[2]].Block[sysCS[3]]
        %assign argIdx = prm.ASTNode.CanonicalPrmArgDefIdx
        %if ssBlk.CallSiteInfo.NumCanonicalPrmArgs > 0
            %assign childPrmIdx = ...
                ssBlk.CallSiteInfo.CanonicalPrmArg[argIdx].ChildPrmArgIdx
        %endif
        %% Recurse to get to the top level parent (true parent)
        %assign prm   = FunctionGetChildPrmArgFromParent(sysCS, childPrmIdx)
    %endif
    %return prm
%endfunction

%% Function: SLibGetHStructWithLocalScopeSystemIdx =================================================
%% Abstract:
%%   Return the reusable parent system index for a given system index.
%%
%function SLibGetHStructWithLocalScopeSystemIdx(sysIdx)
    %return ::CompiledModel.System[sysIdx].ReusedParentSystemIdx
%endfunction

%% Function: FcnGetCanonicalOutput =================================================================
%% Abstract:
%%   Returns the canonical output argument (string) for a given canonical
%%   output index.
%%
%function FcnGetCanonicalOutput(accessSysIdx, aCallSite, coIdx) void
    %assign   systemIdx = aCallSite[0]
    %assign callsiteIdx = aCallSite[1]
    %assign returnVal = ""
    %with ::CompiledModel
        %assign ssBlk = System[aCallSite[2]].Block[aCallSite[3]]
        %assign system = System[systemIdx]
        %assign sysCurrentTid = system.CurrentTID
        %assign system.CurrentTID = CurrentTID %% set system current tid to context current tid
        %with system
            %assign     cross = CrossNoArgFcnBound
            %assign hStrucIdx = SLibGetHStructWithLocalScopeSystemIdx(systemIdx)
            %with ssBlk %% subsystem block
                %assign co = CallSiteInfo.CanonicalOutputArg[coIdx]
                %assign idnum = IDNUM(co.SignalSrc[0])
                %assign oldBlockIdx1 = ssBlk.BlockIdx[1]
                %assign ssBlk.BlockIdx[1] = accessSysIdx
                %if hStrucIdx < accessSysIdx && idnum[0] == "y"
                    %assign cs = System[systemIdx].CallSites[callsiteIdx]
                    %assign returnVal = FcnGetCanonicalOutput(accessSysIdx, cs, idnum[1])
                %else
                    %% canonical output, if is scalar, must pass by addr.
                    %assign returnVal = FcnGetCanonicalArg(co, 0, cross, TLC_TRUE)
                %endif
                %assign ssBlk.BlockIdx[1] = oldBlockIdx1
            %endwith
        %endwith %% System[sysIdx]
        %assign system.CurrentTID = sysCurrentTid
    %endwith
    %return returnVal
%endfunction

%% Function: FcnGetCanonicalInput ==================================================================
%% Abstract:
%%   Returns the canonical input argument (string) for a given canonical
%%   input index.
%%
%function FcnGetCanonicalInput(accessSysIdx, aCallSite, ciIdx) void
    %assign   systemIdx = aCallSite[0]
    %assign callsiteIdx = aCallSite[1]
    %assign returnVal = ""
    %with ::CompiledModel
        %assign ssBlk = System[aCallSite[2]].Block[aCallSite[3]]
        %assign system = System[systemIdx]
        %assign sysCurrentTid = system.CurrentTID
        %assign system.CurrentTID = CurrentTID %% set system current tid to context current tid
        %with system
            %assign     cross = CrossNoArgFcnBound
            %assign hStrucIdx = SLibGetHStructWithLocalScopeSystemIdx(systemIdx)
            %with ssBlk %% subsystem block
                %assign ci = CallSiteInfo.CanonicalInputArg[ciIdx]
                %assign idnum = IDNUM(ci.SignalSrc[0])
                %assert idnum[0] != "F"
                %assign oldBlockIdx1 = ssBlk.BlockIdx[1]
                %assign ssBlk.BlockIdx[1] = accessSysIdx
                %if hStrucIdx < accessSysIdx && (idnum[0] == "u" || idnum[0] == "y")
                    %assign cs = System[systemIdx].CallSites[callsiteIdx]
                    %if idnum[0] == "u"
                        %assign returnVal = ...
                            FcnGetCanonicalInput(accessSysIdx, cs, idnum[1])
                    %else
                        %assign returnVal = ...
                            FcnGetCanonicalOutput(accessSysIdx, cs, idnum[1])
                    %endif
                %else
                    %assign ssBlkSysIdx = LibBlockParamSetting("Subsystem", "SystemIdx")
                    %if LibGetRecordWidth(ci) == 1 && SLibGetISSCanInputIter(ssBlkSysIdx, ciIdx)
                        %% If the canonical input is for an Implicit Iterator subsystem and it is
                        %% a scalar, the scalar signal needs to be returned as reference.
                        %assign returnVal = FcnGetCanonicalArg(ci, 0, cross, TLC_TRUE)
                    %else
                        %assign useAddr =  (ci.DeclareAsPointer == "yes")
                        %assign returnVal = FcnGetCanonicalArg(ci, 0, cross, useAddr)
                    %endif
                %endif
                %assign ssBlk.BlockIdx[1] = oldBlockIdx1
            %endwith
            %assign system.CurrentTID = sysCurrentTid
        %endwith %% System[sysIdx]
    %endwith
    %return returnVal
%endfunction


%% Function: FcnGetArgForType ======================================================================
%% Abstract:
%%   This function generates the argument needed in for a system function
%%   call based on argument type, e.g. DWork or BlockIO. This is used by
%%   function FcnGetAdditionalArgs
%%
%% Arguments:
%%  argType      - The type of the argument, e.g. "DWork", "BlockIO"
%%  mdlrefArg    - The string used for model reference, e.g. "&(dw->rtb)"
%%  localArg     - The string for argument passed through parent system
%%                 e.g. "localB"
%%  sysIdx       - system function to call
%%  callSiteIdx  - system instance to call
%%  accessSysIdx - location of the system call
%%  cTID         - current tid
%%
%function FcnGetArgForType(argType, mdlrefArg, localArg, sysIdx, callSiteIdx, accessSysIdx)
    %%
    %% If a system function (e.g. "Start") calls a function of the
    %% same system (e.g. "Enable"), it has to pass the structured arguments
    %% without adding a substructure element
    %%

    %assign thisSystem = ::CompiledModel.System[sysIdx]
    %with thisSystem
        %assign cTID = FcnGetCurrentAccessTid()
    %endwith

    %assign genModelRef = IsModelReferenceTarget() && accessSysIdx == NumSystems-1

    %if genModelRef
        %assign arg =  mdlrefArg
    %elseif LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx)
        %assign arg = localArg
        %assign retAccessHelper = SLibAccessArgHelper(%<argType>ArgDef,"",cTID)
        %<retAccessHelper>
    %else
        %assign cs = thisSystem.CallSites[callSiteIdx]
        %assign cross = ::CompiledModel.System[cs[0]].CrossNoArgFcnBound
        %assign varGroupIdx = FcnSysVarGroupIndex(thisSystem, argType, callSiteIdx)
        %assign parentVarGroupIdx = SLibVarGroupParentIndex(varGroupIdx)
        %assign identiPath = SLibCGIRVarGroupPath(parentVarGroupIdx, accessSysIdx, cross)
        %assign indenti = SLibVarGroupName(varGroupIdx)

        %if SLibGetSubsystemIsForEachSS(System[cs[0]])
            %% Callsite is For Each Subsystem
            %assign arg = SLibGetIndexedArgForForEachSS(parentVarGroupIdx, identiPath, indenti, cs, accessSysIdx, sysIdx)
        %elseif SLibIsMatrixVarGroupForIIS(sysIdx, argType)
            %% This subsystem is code reuse For Each subsystem
            %assert SLibGetSubsystemIsForEachSS(thisSystem)
            %assign arg = "%<identiPath>%<indenti>"
        %else
            %assign arg = "&%<identiPath>%<indenti>"
        %endif
    %endif

    %return arg

%endfunction

%% Function: FcnGetModelRefInput ===================================================================
%% Abstract:
%%   Returns the model reference s-function input argument.
%%
%function FcnGetModelRefInput(thisSystem, argIdx) void
    %assign ci = thisSystem.Interface.CanonicalInputArgDef[argIdx]
    %assign passByRef = LibGetRecordWidth(ci) > 1 || ci.DeclareAsPointer == "yes"
    %assign ptr = passByRef ? "" : "*"
    %return ptr + "InPort_%<argIdx>"
%endfunction %% FcnGetModelRefInput

%% Function: FcnGetModelRefOutput ==================================================================
%% Abstract:
%%   Returns the model reference s-function output argument.
%%
%function FcnGetModelRefOutput(argIdx) void
    %return "OutPort_%<argIdx>"
%endfunction %% FcnGetModelRefOutput

%% Function: FcnGetModelRefParameter ===============================================================
%% Abstract:
%%   Generate parameter argument as "ParamArg_#" for model reference s-function.
%%
%function FcnGetModelRefParameter(thisSystem, argIdx) void
    %assign expr = "ParamArg_%<argIdx>"
    %assign canPrmArgDef = thisSystem.Interface.CanonicalPrmArgDef[argIdx]
    %assign isStruct = SLibDeclareDataAsPointer(canPrmArgDef.OriginalDataTypeIdx)
    %if (1 == LibGetRecordWidth(canPrmArgDef)) && (isStruct==TLC_FALSE)
        %return expr + "[0]"
    %endif
    %return expr
%endfunction %% FcnGetModelRefParameter

%function FcnGetModelRefRtm(thisSystem) void
    %return "&(dw->rtm)"
%endfunction

%% Function: FcnGetModelRefBlockIOArg ==============================================================
%% Abstract:
%%   Returns the model reference s-function block IO argument.
%%
%function FcnGetModelRefBlockIOArg() void
    %if !SLibGetUseRTMcgType()
        %return "&(dw->rtb)"
    %else
        %return "&(dw->rtm.blockIO)"
    %endif
%endfunction %% FcnGetModelRefBlockIOArg

%% Function: FcnGetModelRefConstBlockIOArg =========================================================
%% Abstract:
%%   Returns the model reference s-function constant block IO argument.
%%
%function FcnGetModelRefConstBlockIOArg() void
    %return "rtc_" + ::CompiledModel.Name
%endfunction %% FcnGetModelRefConstBlockIOArg

%% Function: FcnGetModelRefDWorkArg ================================================================
%% Abstract:
%%   Returns the model reference s-function dwork argument.
%%
%function FcnGetModelRefDWorkArg() void
    %if !SLibGetUseRTMcgType()
        %return "&(dw->rtdw)"
    %else
        %return "&(dw->rtm.dwork)"
    %endif
%endfunction %% FcnGetModelRefDWorkArg


%% Function: FcnGetModelRefContStatesArg ===========================================================
%% Abstract:
%%   Returns the model reference s-function continues states argument.
%%
%function FcnGetModelRefContStatesArg() void
    %return "rtx"
%endfunction %% FcnGetModelRefContStatesArg

%% Function: FcnGetModelRefDerivativesArg ==========================================================
%% Abstract:
%%   Returns the model reference s-function derivatives argument.
%%
%function FcnGetModelRefDerivativesArg() void
    %return "rtxdot"
%endfunction %% FcnGetModelRefDerivativesArg

%% Function: FcnGetModelRefContStatesDisabledArg ===================================================
%% Abstract:
%%   Returns the model reference s-function continues states disabled argument.
%%
%function FcnGetModelRefContStatesDisabledArg() void
    %return "rtxdis"
%endfunction %% FcnGetModelRefContStatesDisabledArg

%% Function: FcnGetModelRefContStatesAbsTolArg =====================================================
%% Abstract:
%%   Returns the model reference s-function continues states absolute tolerance
%%   argument.
%%
%function FcnGetModelRefContStatesAbsTolArg() void
    %return "rtxAbsTol"
%endfunction %% FcnGetModelRefContStatesAbsTolArg


%% Function: FcnGetModelRefContStatesPerturbMinArg =================================================
%% Abstract:
%%   Returns the model reference s-function continues states perturb min
%%   argument.
%%
%function FcnGetModelRefContStatesPerturbMinArg() void
    %return "rtxPerturbMin"
%endfunction %% FcnGetModelRefContStatesPerturbMinArg

%% Function: FcnGetModelRefContStatesPerturbMaxArg =================================================
%% Abstract:
%%   Returns the model reference s-function continues states perturb max
%%   argument.
%%
%function FcnGetModelRefContStatesPerturbMaxArg() void
    %return "rtxPerturbMax"
%endfunction %% FcnGetModelRefContStatesPerturbMaxArg

%% Function: FcnGetModelRefNSZCArg =================================================================
%% Abstract:
%%   Returns the model reference s-function non-sampled zero crossings argument.
%%
%function FcnGetModelRefNSZCArg() void
    %return "rtzcsv"
%endfunction %% FcnGetModelRefNSZCdArg

%% Function: FcnGetModelRefZCEArg ==================================================================
%% Abstract:
%%   Returns the model reference s-functionzero crossing events argument.
%%
%function FcnGetModelRefZCEArg() void
    %return "&(dw->rtzce)"
%endfunction %% FcnGetModelRefZCEdArg

%function FcnAddExternCPrefixStart() void
    %if ::GenCPP
        %return "#ifdef __cplusplus \n" + ::ExternCPrefix + "{ \n #endif\n"
    %endif
%endfunction

%function FcnAddExternCPrefixEnd() void
    %if ::GenCPP
        %return "#ifdef __cplusplus \n } \n #endif\n"
    %endif
%endfunction


%% Function: FcnGetAdditionalArgs ==================================================================
%% Abstract:
%%   This function generates the arguments needed in for a system function
%%   call. Refer to GetFunctionStr for the order of parameters.
%%
%% Arguments:
%%  outAndRuleIdx - a two-elements vector of string for actual arguments
%%                  of output idx and rule idx. use [] if the fcn is not
%%                  SetDims fcn.
%%         argVec - a vector of strings for actual arguments (default is [])
%%         sysIdx - system function to call
%%    callSiteIdx - system instance to call
%%     accessSysIdx - location of the system call
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tvss_code_variants.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants3.m
%% TopTester: test/toolbox/simulink/variants/var-export-fcns/tExportFcnsWithInlineVariants.m
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortHighlight.m
%% TopTester: test/toolbox/simulink/variants/var-inline-general/tVariantsAndSubmodels.m
%% TopTester: test/toolbox/rtw/targets/AUTOSAR/Variants/dimensionVariants/tDimensionVariants2.m
%%
%function FcnGetAdditionalArgs(fcnName, argVec, sysFcn, sysIdx, accessSysIdx, callSiteIdx, genModelRef, rtmNeeded) void
    %%
    %% CallSite is misleading in this context. The callsite vector is
    %% defines the memory instances of the function and is
    %% equal to the number of reused instances of a system.
    %%
    %assign thisSystem = ::CompiledModel.System[sysIdx]
    %assign modIdx = thisSystem.CGIRModuleIdx
    %assign thisModule = ::CompiledModel.RTWCGModules.RTWCGModule[modIdx]
    %assign hasSimplifiedInterface = thisModule.SimplifiedInterface
    %assign isRateGroupedSLF = thisSystem.IsRateGroupedSLFcn
    %assign cs = thisSystem.CallSites[callSiteIdx]
    %assign args = ""

    %with thisSystem
        %assign cTID = FcnGetCurrentAccessTid()
    %endwith

    %% The function caller could be in a different TID to call the
    %% ModelWideEvent (i.e,ResetWithInit)
    %if (sysFcn == "Output" || sysFcn == "OutputUpdate") && ...
        ISFIELD(thisModule, "SystemFunctions") && ...
        ISFIELD(thisModule.SystemFunctions, fcnName)
        %assign fcnIndex = GETFIELD(thisModule.SystemFunctions, fcnName)
        %assign thisFcn  = thisModule.Function[fcnIndex]
        %assign fcnTid = thisFcn.FcnTID
        %if SLibResetOrResetWithInitEventTID(fcnTid) || SLibParameterChangeEventTID(fcnTid)
            %assign cTID = fcnTid
        %endif
    %endif


    %assign isRG = SLibSystemFcnPeriodicRateGrouping(thisSystem, sysFcn)
    %with thisSystem.Interface
        %assign comma = ""
        %assign ssBlk = System[cs[2]].Block[cs[3]]

        %% We need to reset this so we will use the correct
        %% Interface when accessing canonical inputs and outputs.
        %% See the function SLibGetSourceRecordAndMapInfo in blkiolib.tlc
        %% NOTE: we reset this back after canonical inputs/outputs below.
        %assign saveMe = ssBlk.BlockIdx[1]
        %assign ssBlk.BlockIdx[1] = accessSysIdx

        %%
        %% The following TLC code is used to prune the CGIR function call
        %% arguments and transfer the CGIR argument tracking
        %% information to the legacy TLC tracking infrastructure.
        %%
        %assign skipCanInput = ...
            Vector(%<NumCanonicalInputArgDefs>) [0@%<NumCanonicalInputArgDefs>]
        %assign skipCanOutput = ...
            Vector(%<NumCanonicalOutputArgDefs>) [0@%<NumCanonicalOutputArgDefs>]
        %assign skipCanDWork = ...
            Vector(%<NumCanonicalDWorkArgDefs>) [0@%<NumCanonicalDWorkArgDefs>]
        %assign skipCanParam = ...
            Vector(%<NumCanonicalPrmArgDefs>) [0@%<NumCanonicalPrmArgDefs>]

        %assign skipRTM = SLibGenSubsysFcnAsClassMemFcn(thisSystem)
        %assign skipHStructArgs = LibSystemIsNonReusedFcn(thisSystem)
        %assign skipLocalB = skipHStructArgs || hasSimplifiedInterface
        %assign skipLocalC = skipHStructArgs
        %assign skipLocalDW = skipHStructArgs || hasSimplifiedInterface
        %assign skipLocalP = skipHStructArgs || hasSimplifiedInterface
        %assign skipLocalX = skipHStructArgs
        %assign skipLocalXdot = skipHStructArgs
        %assign skipLocalXdis = skipHStructArgs
        %assign skipLocalXabstol = skipHStructArgs
        %assign skipLocalXperturbmin = skipHStructArgs
        %assign skipLocalXperturbmax = skipHStructArgs
        %assign skipLocalZCSV = skipHStructArgs
        %assign skipLocalZCE = skipHStructArgs || hasSimplifiedInterface

        %assign skipLocalDataGroup = ...
            Vector(%<::CompiledModel.NumCoderDataGroups>) [%<skipHStructArgs>@%<::CompiledModel.NumCoderDataGroups>]

        %if isRateGroupedSLF && Accelerator
            %% Rate grouped Simulink functions are defined in the root module. Need to get
            %% the Function record from root. FcnGetAdditionalArgs is only
            %% invoked during Accel code gen to create a call to the smiulink function.
            %% (A call to the SLF is not emitted for RTW code gen.)
            %assign rootSystem = ::CompiledModel.System[NumSystems-1]
            %assign rootModIdx = rootSystem.CGIRModuleIdx
            %assign rootModule = ::CompiledModel.RTWCGModules.RTWCGModule[rootModIdx]
            %assign fncExistsInSystem = ISFIELD(rootModule, "SystemFunctions") && ...
                ISFIELD(rootModule.SystemFunctions, fcnName)
            %if fncExistsInSystem
                %assign fcnIndex = GETFIELD(rootModule.SystemFunctions, fcnName)
                %assign thisFcn  = rootModule.Function[fcnIndex]
            %endif
            %% Canonical I/O and RTM are handled in IR. Setting needArgs to false and
            %% skipRTM to true will prevent adding these args twice. The only args
            %% that do not get handled in IR are canonical parameters so we
            %% still need to execute the following loop through args.
            %assign needArgs = TLC_FALSE
            %assign skipRTM = 1
        %else
            %assign fncExistsInSystem = ISFIELD(thisModule, "SystemFunctions") && ...
                ISFIELD(thisModule.SystemFunctions, fcnName)
            %assign fcnIndex = GETFIELD(thisModule.SystemFunctions, fcnName)
            %assign thisFcn  = thisModule.Function[fcnIndex]
            %if thisModule.AccessesArgsGlobally && !thisModule.NeedsSimStruct
                %assign skipRTM = 1
            %endif
            %assign needArgs = LibSystemIsReusedFcn(thisSystem) || ...
                (LibSystemIsNonReusedFcn(thisSystem) && ...
                ISFIELD(thisSystem,"RTWSystemCodeOptIntf")) || ...
                LibIsServer(thisSystem)
        %endif

        %if fncExistsInSystem
            %if genModelRef
                %foreach argIdx = SIZE(argVec, 1)
                    %assign args = args + comma + argVec[argIdx]
                    %assign comma = ", "
                %endforeach
            %endif
            %assert genModelRef || SIZE(argVec, 1) == thisFcn.NumArgs
            %assert SIZE(thisFcn.ArgAccessed, 1) == thisFcn.NumArgs
            %assert SIZE(thisFcn.ArgSource, 1) == thisFcn.NumArgs
            %foreach argIdx=thisFcn.NumArgs
                %assign idNum = SLibSafeIDNUM(thisFcn.ArgSource, argIdx)
                %assign argSrc = idNum[0]
                %assign argSrcIdx = idNum[1]
                %if thisFcn.ArgAccessed[argIdx] || (GenerateClassInterface && argSrc == "LCDG")
                    %switch argSrc
                      %case "I" %% canonical input
                        %if 0 < NumCanonicalInputArgDefs %% CrossNoArgFcnBound
                            %if needArgs
                                %if genModelRef
                                    %assign args = args + comma + ...
                                        FcnGetModelRefInput(thisSystem, argSrcIdx)
                                %else
                                    %assign args = args + comma + argVec[argIdx]
                                %endif
                                %assign comma = ", "
                            %endif
                            %assign skipCanInput[argSrcIdx] = 1
                        %endif
                        %break
                      %case "O" %% canonical output
                        %if 0 < NumCanonicalOutputArgDefs %% CrossNoArgFcnBound
                            %if needArgs
                                %if genModelRef
                                    %assign args = args + comma + ...
                                        FcnGetModelRefOutput(argSrcIdx)
                                %else
                                    %assign args = args + comma + argVec[argIdx]
                                %endif
                                %assign comma = ", "
                            %endif
                            %assign skipCanOutput[argSrcIdx] = 1
                        %endif
                        %break
                      %case "D" %% canonical dwork
                        %if 0 < NumCanonicalDWorkArgDefs %% CrossNoArgFcnBound
                            %if genModelRef
                                %assert ISFIELD(thisFcn, "Association")
                                %assert SIZE(thisFcn.Association, 1) == thisFcn.NumArgs
                                %assign dimsIdNum = SLibSafeIDNUM(thisFcn.Association, argIdx)
                                %assign dimsSrc = dimsIdNum[0]
                                %assign dimsSrcIdx = dimsIdNum[1]
                                %assert "I" == dimsSrc || "O" == dimsSrc
                                %assign prefix = (("I" == dimsSrc) ? "In" : "Out")
                                %assign args = args + comma + ...
                                    FcnGetModelRefDWork(prefix, dimsSrcIdx, argSrcIdx)
                            %else
                                %assign args = args + comma + argVec[argIdx]
                            %endif
                            %assign comma = ", "
                            %assign skipCanDWork[argSrcIdx] = 1
                        %endif
                        %break
                      %case "P" %% canonical parameter
                        %if 0 < NumCanonicalPrmArgDefs %% CrossNoArgFcnBound
                            %if genModelRef
                                %assign args = args + comma + ...
                                    FcnGetModelRefParameter(thisSystem, argSrcIdx)
                            %else
                                %assign args = args + comma + argVec[argIdx]
                            %endif
                            %assign comma = ", "
                            %assign skipCanParam[argSrcIdx] = 1
                        %endif
                        %break
                      %case "RTM"
                        %if 0 == skipRTM
                            %if GenerateClassInterface
                                %if argVec[argIdx] != "getRTM()"
                                    %assign args = args + comma + RTMGetModelSS()
                                %else
                                    %assign args = args + comma + argVec[argIdx]
                                %endif
                            %elseif genModelRef && !IsModelRefScalableBuild()
                                %assign args = args + comma + ...
                                    FcnGetModelRefRtm(thisSystem)
                            %else
                                %assign args = args + comma + argVec[argIdx]
                            %endif
                            %assign comma = ", "
                            %assign skipRTM = 1
                        %endif
                        %break
                      %case "LCDG"
                        %% Here, argSrcIdx refers to the index of the coder data group
                        %if 0 == skipLocalDataGroup[argSrcIdx] %% CrossNoArgFcnBound
                            %if genModelRef
                                %assign args = args + comma + FcnGetModelRefBlockIOArg()
                            %else
                                %assign args = args + comma + argVec[argIdx]
                            %endif
                            %assign comma = ", "
                            %assign skipLocalDataGroup[argSrcIdx] = 1
                        %endif
                        %break
                      %case "LB" %% block IO
                        %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                            %if genModelRef
                                %assign args = args + comma + FcnGetModelRefBlockIOArg()
                            %else
                                %assign args = args + comma + argVec[argIdx]
                            %endif
                            %assign comma = ", "
                            %assign skipLocalB = 1
                        %endif
                        %break
                      %case "LC" %% constat block IO
                        %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                            %if genModelRef
                                %assign args = args + comma + FcnGetModelRefConstBlockIOArg()
                            %else
                                %assign args = args + comma + argVec[argIdx]
                            %endif
                            %assign comma = ", "
                            %assign skipLocalC = 1
                        %endif
                        %break
                      %case "LW" %% dwork
                        %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                            %if genModelRef
                                %assign args = args + comma + FcnGetModelRefDWorkArg()
                            %else
                                %assign args = args + comma + argVec[argIdx]
                            %endif
                            %assign comma = ", "
                            %assign skipLocalDW = 1
                        %endif
                        %break
                      %case "LP"  %% parameter
                      %case "LCP" %% constant parameter
                      %case "LPI" %% const parameter with init
                        %assert !genModelRef
                        %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                            %assign args = args + comma + argVec[argIdx]
                            %assign comma = ", "
                            %assign skipLocalP = 1
                        %endif
                        %break
                      %case "LX" %% continues states
                        %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                            %if genModelRef
                                %assign args = args + comma + FcnGetModelRefContStatesArg()
                            %else
                                %assign args = args + comma + argVec[argIdx]
                            %endif
                            %assign comma = ", "
                            %assign skipLocalX = 1
                        %endif
                        %break
                      %case "LDX" %% derivatives
                        %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                            %if genModelRef
                                %assign args = args + comma + FcnGetModelRefDerivativesArg()
                            %else
                                %assign args = args + comma + argVec[argIdx]
                            %endif
                            %assign comma = ", "
                            %assign skipLocalXdot = 1
                        %endif
                        %break
                      %case "LXDI" %% continues state disabled
                        %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                            %if genModelRef
                                %assign args = ...
                                    args + comma + FcnGetModelRefContStatesDisabledArg()
                            %else
                                %assign args = args + comma + argVec[argIdx]
                            %endif
                            %assign comma = ", "
                            %assign skipLocalXdis = 1
                        %endif
                        %break
                      %case "LXAT" %% continues state absolute tolerance
                        %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                            %if genModelRef
                                %assign args = ...
                                    args + comma + FcnGetModelRefContStatesAbsTolArg()
                            %else
                                %assign args = args + comma + argVec[argIdx]
                            %endif
                            %assign comma = ", "
                            %assign skipLocalXabstol = 1
                        %endif
                        %break

                      %case "LXPTMIN" %% continues state perturb min
                        %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                            %if genModelRef
                                %assign args = ...
                                    args + comma + FcnGetModelRefContStatesPerturbMinArg()
                            %else
                                %assign args = args + comma + argVec[argIdx]
                            %endif
                            %assign comma = ", "
                            %assign skipLocalXperturbmin = 1
                        %endif
                        %break

                      %case "LXPTMAX" %% continues state perturb max
                        %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                            %if genModelRef
                                %assign args = ...
                                    args + comma + FcnGetModelRefContStatesPerturbMaxArg()
                            %else
                                %assign args = args + comma + argVec[argIdx]
                            %endif
                            %assign comma = ", "
                            %assign skipLocalXperturbmax = 1
                        %endif
                        %break


                      %case "LZ" %% non-sampled zero crossings
                        %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                            %if genModelRef
                                %assign args = args + comma + FcnGetModelRefNSZCArg()
                            %else
                                %assign args = args + comma + argVec[argIdx]
                            %endif
                            %assign comma = ", "
                            %assign skipLocalZCSV = 1
                        %endif
                        %break
                      %case "LZE" %% zero crossing events
                        %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                            %if genModelRef
                                %assign args = args + comma + FcnGetModelRefZCEArg()
                            %else
                                %assign args = args + comma + argVec[argIdx]
                            %endif
                            %assign comma = ", "
                            %assign skipLocalZCE = 1
                        %endif
                        %break
                      %case "CPI"
                      %case "TID"
                        %if !genModelRef
                            %assign args = args + comma + argVec[argIdx]
                            %assign comma = ", "
                        %endif
                        %break
                      %case "X"
                        %if !genModelRef
                            %assign args = args + comma + argVec[argIdx]
                            %assign comma = ", "
                        %endif
                        %break
                      %case "U"
                      %case "Y"
                        %if !thisSystem.CrossNoArgFcnBound
                            %assign args = args + comma + argVec[argIdx]
                            %assign comma = ", "
                        %endif
                        %break
                      %default
                        %%START_ASSERT
                        %assign errTxt = "Unhandled argument type '%<argSrc>'."
                        %break
                        %%END_ASSERT
                    %endswitch
                %endif
            %endforeach
        %endif

        %%
        %% Only reused systems get arguments (except for elapased time)
        %%
        %if needArgs
            %assign isTestInterface = ...
                ::CompiledModel.ConfigSet.GenerateTestInterfaces && ...
                ISFIELD(thisSystem, "GenerateReusableWrapper") && ...
                GETFIELD(thisSystem, "GenerateReusableWrapper")

            %%
            %% Canonical input argument
            %%
            %foreach argIdx=thisSystem.Interface.NumCanonicalInputArgDefs
                %assign canIn = thisSystem.Interface.CanonicalInputArgDef[argIdx]
                %if !skipCanInput[argIdx] && ...
                    SysFcnArgNeeded(sysFcn, canIn, cTID, isRG)
                    %%
                    %if isTestInterface && ISFIELD(canIn, "SSGraphicalAPIReference")
                        %assign grIn = canIn.SSGraphicalAPIReference
                        %assign args = "%<args>%<comma>%<grIn.SLName>"
                        %assign comma = ", "
                    %elseif LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx)
                        %assign args = "%<args>%<comma>%<LibGetRecordIdentifier(canIn)>"
                        %assign comma = ", "
                        %<SLibAccessArgHelper(canIn,"",cTID)>
                    %else
                        %with System[cs[0]]
                            %assign cross = CrossNoArgFcnBound
                            %with ssBlk %% subsystem block
                                %assign skipThisArg = 0
                                %if IDNUM(canIn.SignalSrc[0])[0] == "F"
                                    %assign skipThisArg = 1
                                %endif
                                %if skipThisArg == 0
                                    %if genModelRef
                                        %assign args = args + comma + ...
                                            FcnGetModelRefInput(thisSystem, argIdx)
                                    %else
                                        %assign args = args + comma + ...
                                            FcnGetCanonicalInput(accessSysIdx, cs, argIdx)
                                    %endif
                                    %assign comma = ", "
                                %endif
                            %endwith %% subsystem block
                        %endwith %% thisSystem
                    %endif %%LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx)

                    %% Add vardims argument for the canonical input
                    %assign res = FcnGetAdditionalCanDimSizeDWForCanInp(sysFcn, sysIdx, ...
                        accessSysIdx, callSiteIdx, argIdx, comma, args, skipCanDWork)
                    %assign comma = res[0]
                    %assign args  = res[1]
                %endif %% SysFcnArgNeeded

            %endforeach %% argIdx=NumCanonicalInputArgDefs
            %%
            %% Canonical output argument
            %%
            %foreach argIdx=thisSystem.Interface.NumCanonicalOutputArgDefs
                %assign canOut = thisSystem.Interface.CanonicalOutputArgDef[argIdx]
                %if !skipCanOutput[argIdx] && SysFcnArgNeeded(sysFcn, canOut, cTID, isRG)
                    %%
                    %if isTestInterface && ISFIELD(canOut, "SSGraphicalAPIReference")
                        %assign grOut = canOut.SSGraphicalAPIReference
                        %assign args = "%<args>%<comma>%<grOut.SLName>"
                    %else
                        %if LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx)
                            %assign isReference = FcnPassCanonicalOutputAsReference(canOut)
                            %if IsModelReferenceBaseSys(thisSystem) && ...
                                (SLibFcnProtoCtrlActive() || GenerateClassInterface) && ...
                                canOut.DeclareAsPointer == "no" && ...
                                (canOut.PassByReturn == "yes" || isReference) && ...
                                sysFcn != "Output" && sysFcn != "OutputUpdate"
                                %%root output is return-by-value, needs to get its address
                                %assign args = "%<args>%<comma>&%<LibGetRecordIdentifier(canOut)>"
                            %else
                                %assign args = "%<args>%<comma>%<LibGetRecordIdentifier(canOut)>"
                            %endif
                            %<SLibAccessArgHelper(canOut,"",cTID)>
                        %elseif genModelRef
                            %assign args = args + comma + FcnGetModelRefOutput(argIdx)
                        %else
                            %assign args = args + comma + ...
                                FcnGetCanonicalOutput(accessSysIdx, cs, argIdx)
                        %endif %%LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx)
                    %endif %% ConfigSet.GenerateTestInterfaces
                    %assign   comma = ", "

                    %%
                    %% Add vardims argument for the canonical output
                    %assign res = FcnGetAdditionalCanDimSizeDWForCanOut(sysFcn, sysIdx, ...
                        accessSysIdx, callSiteIdx, argIdx, comma, args, skipCanDWork)
                    %assign comma = res[0]
                    %assign args  = res[1]
                %endif %% SysFcnArgNeeded
                %%
            %endforeach %% argIdx=NumCanonicalOutputArgDefs
            %%
            %% Reset the BlockIdx, see comment above.
            %assign ssBlk.BlockIdx[1] = saveMe
            %assign isScalableMRSys = IsModelReferenceBaseSys(thisSystem) && IsModelRefScalableBuild()
            %%
            %% rtModel argument
            %%
            %assign isMatchGrInterface = (LibSystemIsNonReusedFcn(thisSystem) && ...
                ISFIELD(thisSystem,"RTWSystemMatchGrInterface"))
            %if !skipRTM && ((SysFcnArgNeeded(sysFcn, RTMArgDef, cTID, isRG) && !isMatchGrInterface) || rtmNeeded) && !isScalableMRSys
                %if genModelRef
                    %assign args = "%<args>%<comma>&(dw->rtm)"
                %else
                    %assign accessSystem = ::CompiledModel.System[accessSysIdx]
                    %assign rtmArg = FcnUpdateRTModelInterfaceArg(accessSystem, GetSimStructExpr(accessSystem, SLibGetSimStruct()))
                    %if thisModule.SimplifiedInterface
                        %assign args = "%<rtmArg>%<comma>%<args>"
                    %else
                        %assign args = "%<args>%<comma>%<rtmArg>"
                    %endif
                %endif
                %assign comma = ", "
                %assign callerHStSystem = ...
                    SLibCallerHStuctDeclSystem(thisSystem, callSiteIdx)
                %<SLibAccessArgHelper(callerHStSystem.Interface.RTMArgDef,"",cTID)>
            %endif
            %assign isCPPEncapMdlRef = GenerateClassInterface && IsModelReferenceBaseSys(thisSystem)
            %%
            %% Block IO argument
            %%
            %if !skipLocalB && !isScalableMRSys && !isCPPEncapMdlRef && SysFcnArgNeeded(sysFcn, BlockIOArgDef, cTID, isRG)
                %assign arg = FcnGetArgForType("BlockIO", ...
                    FcnGetModelRefBlockIOArg(), "localB", sysIdx, callSiteIdx, accessSysIdx)
                %assign args = "%<args>%<comma>%<arg>"
                %assign comma = ", "
            %endif
            %%
            %% DataGroup arguments. For model reference, we're using localGroup<Name>
            %% to hold the pointer from RTM and pass that down into subfunctions. For
            %% access by the model reference root system, access will be through RTM.
            %foreach gIdx = ::CompiledModel.NumCoderDataGroups
                %assign argDef = FcnGetGroupArgDef(gIdx)
                %assign group = ::CompiledModel.CoderDataGroup[gIdx]
                %assign groupAccessedThroughRTM = ...
                    IsModelReferenceBaseSys(System[sysIdx]) && ...
                    SLibAccessGroupThroughSelf(group)
                %if !(skipLocalDataGroup[gIdx]) && ...
                    !isScalableMRSys && ...
                    !GenerateClassInterface && ...
                    !groupAccessedThroughRTM && ...
                    SysFcnArgNeeded(sysFcn, argDef, cTID, isRG) && ...
                    !hasSimplifiedInterface
                    %assign groupToken = "CoderDataGroup" + group.Name
                    %assign varGroupIdx = FcnSysVarGroupIndex(thisSystem, groupToken, callSiteIdx)
                    %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
                    %assign varName = varGroup.LocalName
                    %assign arg = FcnGetArgForType(groupToken, ...
                        varName, varName, sysIdx, callSiteIdx, accessSysIdx)
                    %assign args = "%<args>%<comma>%<arg>"
                    %assign comma = ", "
                %endif
            %endforeach
            %%
            %% Constant block IO argument
            %%
            %if !skipLocalC && !isCPPEncapMdlRef && SysFcnArgNeeded(sysFcn, ConstBlockIOArgDef, cTID, isRG)
                %%
                %% If a system function (e.g. "Start") calls a function of the
                %% same system (e.g. "Enable"), it has to pass the structured arguments
                %% without adding a substructure element
                %%
                %assert !isScalableMRSys
                %if genModelRef
                    %assign args = args + comma + FcnGetModelRefConstBlockIOArg()
                %elseif LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx)
                    %assign args = "%<args>%<comma>localC"
                    %<SLibAccessArgHelper(ConstBlockIOArgDef,"",cTID)>
                %else
                    %assign cross = ::CompiledModel.System[cs[0]].CrossNoArgFcnBound
                    %assign varGroupIdx = ...
                        FcnSysVarGroupIndex(thisSystem, "ConstBlockIO", callSiteIdx)
                    %assign parentVarGroupIdx = SLibVarGroupParentIndex(varGroupIdx)
                    %assign identiPath = SLibCGIRVarGroupPath(parentVarGroupIdx, ...
                        accessSysIdx, cross)
                    %assign indenti = SLibVarGroupName(varGroupIdx)
                    %assign dataType = FcnSysVarGroupType(thisSystem,"ConstBlockIO")
                    %assign cast = "(" + dataType + "*)"
                    %assign argStr = cast + "&%<identiPath>%<indenti>"
                    %assign argStr = FcnReplaceCCastWithStaticCastForCPP(argStr)
                    %assign args = "%<args>%<comma>%<argStr>"
                %endif
                %assign comma = ", "
            %endif
            %%
            %% DWork IO argument
            %%
            %if !skipLocalDW && SysFcnArgNeeded(sysFcn, DWorkArgDef, cTID, isRG) && !isScalableMRSys && !isCPPEncapMdlRef
                %assign arg = FcnGetArgForType("DWork", FcnGetModelRefDWorkArg(), ...
                    "localDW", sysIdx, callSiteIdx, accessSysIdx)
                %assign args = "%<args>%<comma>%<arg>"
                %assign comma = ", "
            %endif
            %%
            %% Parameter H-Struct argument
            %%
            %assign isSysFcnArgNeeded = SysFcnArgNeeded(sysFcn, ParameterArgDef, cTID, isRG)
            %if !skipLocalP && isSysFcnArgNeeded
                %assert !isScalableMRSys
                %if !genModelRef
                    %%
                    %% Does a passthrough parameter structure argument exists ?
                    %%
                    %if InlineParameters != 0 && ParameterArgDef.PassthroughSystemIdx > -1
                        %%
                        %% Get the parent callsite vector (pcs)
                        %%
                        %assign pcs = thisSystem.CallSites[0]
                        %%
                        %% Mark the parents parameter structure argument as accessed
                        %%
                        %assign csPrmArgDef = System[pcs[0]].Interface.ParameterArgDef
                        %assign prmAccessSysIdx = ParameterArgDef.PassthroughSystemIdx
                        %<SLibAccessArgHelper(System[pcs[0]].Interface.ParameterArgDef,"",cTID)>
                        %<SLibAccessArgHelper(System[prmAccessSysIdx].Interface.ParameterArgDef,"",cTID)>
                        %%
                        %if prmAccessSysIdx == NumSystems-1
                            %if !GenerateClassInterface
                                %assign args = "%<args>%<comma>%<LibGetParametersStruct()>"
                            %else
                                %if accessSysIdx == NumSystems-1
                                    %assign args = "%<args>%<comma>&%<LibGetParametersStruct()>"
                                %else
                                    %assign args = "%<args>%<comma> %<LibGetParametersStruct()>"
                                %endif
                            %endif
                        %elseif LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx) || ...
                            csPrmArgDef.PassthroughSystemIdx == prmAccessSysIdx
                            %%
                            %% - not called by a parent system (e.g. enable in start)
                            %% - parent has the same pass through system index
                            %%
                            %assign args = "%<args>%<comma>localP"
                            %<SLibAccessArgHelper(ParameterArgDef,"",cTID)>
                        %else
                            %assign cast = "(" + FcnSysVarGroupType(thisSystem,"Parameter") + " *)"
                            %assign varGroupIdx = ...
                                FcnSysVarGroupIndex(thisSystem, "Parameter", callSiteIdx)
                            %assign parentVarGroupIdx = SLibVarGroupParentIndex(varGroupIdx)
                            %assign cross = ::CompiledModel.System[cs[0]].CrossNoArgFcnBound
                            %assign identiPath = SLibCGIRVarGroupPath(parentVarGroupIdx, ...
                                csPrmArgDef.PassthroughSystemIdx, cross)
                            %assign indenti = SLibVarGroupName(varGroupIdx)
                            %assign args = "%<args>%<comma>%<cast> &%<identiPath>%<indenti>"
                        %endif
                    %elseif LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx)
                        %assign args = "%<args>%<comma>localP"
                        %<SLibAccessArgHelper(ParameterArgDef,"",cTID)>
                    %else %% normal parameter structure argument
                        %assign cast = "(" + FcnSysVarGroupType(thisSystem,"Parameter") + " *)"
                        %assign varGroupIdx = ...
                            FcnSysVarGroupIndex(thisSystem, "Parameter", callSiteIdx)
                        %assign parentVarGroupIdx = SLibVarGroupParentIndex(varGroupIdx)
                        %assign cross = ::CompiledModel.System[cs[0]].CrossNoArgFcnBound
                        %assign identiPath = SLibCGIRVarGroupPath(parentVarGroupIdx, ...
                            accessSysIdx, cross)
                        %assign indenti = SLibVarGroupName(varGroupIdx)
                        %assign args = "%<args>%<comma>%<cast> &%<identiPath>%<indenti>"
                    %endif
                %endif
                %assign comma = ", "
            %endif
            %%
            %% CState argument
            %%
            %if !skipLocalX && SysFcnArgNeeded(sysFcn, ContStatesArgDef, cTID, isRG)
                %assign arg = FcnGetArgForType("ContStates", ...
                    FcnGetModelRefContStatesArg(), "localX", sysIdx, ...
                    callSiteIdx, accessSysIdx)
                %assign args = "%<args>%<comma>%<arg>"
                %assign comma = ", "
            %endif
            %%
            %% CState Derivative argument
            %%
            %if !skipLocalXdot && SysFcnArgNeeded(sysFcn, ContStatesDerivativeArgDef, cTID, isRG)
                %assign arg = FcnGetArgForType("ContStatesDerivative", ...
                    FcnGetModelRefDerivativesArg(), "localXdot", sysIdx, ...
                    callSiteIdx, accessSysIdx)
                %assign args = "%<args>%<comma>%<arg>"
                %assign comma = ", "
            %endif
            %%
            %% CState Disabled argument
            %%
            %if !skipLocalXdis && SysFcnArgNeeded(sysFcn, ContStatesDisabledArgDef, cTID, isRG)
                %assign arg = FcnGetArgForType("ContStatesDisabled", ...
                    FcnGetModelRefContStatesDisabledArg(), "localXdis", sysIdx, ...
                    callSiteIdx, accessSysIdx)
                %assign args = "%<args>%<comma>%<arg>"
                %assign comma = ", "
            %endif
            %%
            %% CState Absolute Tolerance argument
            %%
            %if !skipLocalXabstol && SysFcnArgNeeded(sysFcn, ContStatesAbsoluteToleranceArgDef, cTID, isRG)
                %assign arg = FcnGetArgForType("ContStatesAbsoluteTolerance", ...
                    FcnGetModelRefContStatesAbsTolArg(), "localXAbsTol", sysIdx, ...
                    callSiteIdx, accessSysIdx)
                %assign args = "%<args>%<comma>%<arg>"
                %assign comma = ", "
            %endif
            %%

            %% CState Perturb Min argument
            %%
            %if !skipLocalXperturbmin && SysFcnArgNeeded(sysFcn, ContStatesPerturbMinArgDef, cTID, isRG)
                %assign arg = FcnGetArgForType("ContStatesPerturbMin", ...
                    FcnGetModelRefContStatesPerturbMinArg(), "localXPerturbMin", sysIdx, ...
                    callSiteIdx, accessSysIdx)
                %assign args = "%<args>%<comma>%<arg>"
                %assign comma = ", "
            %endif
            %%

            %% CState Perturb Max argument
            %%
            %if !skipLocalXperturbmax && SysFcnArgNeeded(sysFcn, ContStatesPerturbMaxArgDef, cTID, isRG)
                %assign arg = FcnGetArgForType("ContStatesPerturbMax", ...
                    FcnGetModelRefContStatesPerturbMaxArg(), "localXPerturbMax", sysIdx, ...
                    callSiteIdx, accessSysIdx)
                %assign args = "%<args>%<comma>%<arg>"
                %assign comma = ", "
            %endif
            %%

            %% Non Sampled Zero Crossing argument
            %%
            %if !skipLocalZCSV && SysFcnArgNeeded(sysFcn, ZCSVArgDef, cTID, isRG)
                %assign arg = FcnGetArgForType("ZCSV", FcnGetModelRefNSZCArg(), ...
                    "localZCSV", sysIdx, callSiteIdx, accessSysIdx)
                %assign args = "%<args>%<comma>%<arg>"
                %assign comma = ", "
            %endif
            %%
            %% ZCEvent argument
            %%
            %if !skipLocalZCE && !GenerateClassInterface && SysFcnArgNeeded(sysFcn, ZCEventArgDef, cTID, isRG) && !isScalableMRSys
                %assign arg = FcnGetArgForType("ZCEvent", FcnGetModelRefZCEArg(), ...
                    "localZCE", sysIdx, callSiteIdx, accessSysIdx)
                %assign args = "%<args>%<comma>%<arg>"
                %assign comma = ", "
            %endif
            %%
            %% Canonical parameters
            %%
            %foreach argIdx=NumCanonicalPrmArgDefs
                %assign argDef = CanonicalPrmArgDef[argIdx]
                %if !skipCanParam[argIdx] && SysFcnArgNeeded(sysFcn, argDef, cTID, isRG)
                    %assign prmWidth = LibGetRecordWidth(argDef)

                    %if !genModelRef
                        %assign childPrmIdx = ...
                            ssBlk.CallSiteInfo.CanonicalPrmArg[argIdx].ChildPrmArgIdx
                        %%
                        %if isTestInterface
                            %% Called by Test interface. Get information about parent Child Prm
                            %assign prm = FunctionGetChildPrmArgFromParent(cs, childPrmIdx)
                        %else
                            %assign prm = SLibGetCallSitePrmArg(cs, childPrmIdx)
                        %endif
                        %%
                    %endif

                    %%
                    %% If one or more of arguments of a function that is passed by address
                    %% is a expression, than the result of this expression has to be stored
                    %% in a temporrary variable. The address of the temporary variable will
                    %% than be passed as the argument of the function call.
                    %%
                    %assign ref = ""
                    %if genModelRef
                        %% Generating S-Function for model-reference.
                        %% Always generate parameter argument as "ParamArg_#"
                        %assign expr = FcnGetModelRefParameter(thisSystem, argIdx)
                    %elseif LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx)
                        %assign expr = LibGetRecordIdentifier(argDef)
                        %<SLibAccessArgHelper(argDef,"",cTID)>
                    %elseif prmWidth > 1
                        %if LibBlockParameterIsExpression(prm)
                            %assign ref = "&"
                            %if !ISFIELD(ssBlk, "%<sysFcn>FcnCallCode")
                                %addtorecord ssBlk %<sysFcn>FcnCallCode ...
                                    { localPrmDecl ""; localExpr ""}
                            %endif
                            %assign dataType = SLibGetRecordDataTypeName(argDef, "")
                            %assign  fcnCode = ssBlk.%<sysFcn>FcnCallCode
                            %assign     iden = LibGetRecordIdentifier(argDef)
                            %if !isTestInterface
                                %% Add parameter declaration if not called by test interface
                                %% The canonical parameter identifier is dangerous to reuse so massage it. See g612025.
                                %assign iden_tmp = "%<iden>"
                                %assign iden_tmp[2] = "e"
                                %assign iden = iden_tmp
                                %assign fcnCode.localPrmDecl = fcnCode.localPrmDecl + ...
                                    "%<dataType> %<iden>[%<prmWidth>];\n"
                            %endif  %% ! isTestInterface
                            %assign expr = "%<iden>[0]"
                            %assign rolledExpr = ""
                            %openfile rolledExpr
                            %roll idx=[0:%<prmWidth-1>],lcv=RollThreshold,ssBlk,"Roller",""
                                %<iden>[%<lcv == "" ? idx : lcv>] = ...
                                    %<FcnGenParamExprWithCast("", accessSysIdx, cs[0], cs, prm, lcv, "", idx)>;
                            %endroll

                            %closefile rolledExpr
                            %if !isTestInterface
                                %% Add localExpr if not called by interface
                                %assign fcnCode.localExpr = fcnCode.localExpr + rolledExpr
                            %endif
                        %elseif prm.ASTNode.IsNonTerminal == 0 && ...
                            prm.ASTNode.Op == "M_CANPRM_ID"
                            %assign ref = "&"
                            %assign expr = FcnGenParamExprWithCast("", accessSysIdx, cs[0], cs, prm, "", "", "")
                        %else
                            %assign prmSize = SLibGetSizeOfValueFromParamRec(prm)
                            %assign nRows   = prmSize[0]
                            %if nRows == 1
                                %assign expr = FcnBlockParameterAddr(prm, "", "", 0, 0, TLC_FALSE)
                            %else
                                %assign expr = ...
                                    FcnBlockMatrixParameterAddr(prm, "", "", 0, "", "", 0, TLC_FALSE)
                            %endif
                        %endif
                    %else
                        %assign expr = FcnGenParamExprWithCast("", accessSysIdx, cs[0], cs, prm, "", "", "")
                        %if argDef.DeclareAsPointer == "yes"
                            %assign expr = "(%<expr>)"
                            %assign ref  = "&"
                        %endif
                    %endif
                    %assign args = "%<args>%<comma>%<ref>%<expr>"
                    %assign comma = ", "
                %endif %% SysFcnArgNeeded
            %endforeach %% argIdx=NumCanonicalPrmArgDefs
            %%
            %% Canonical DWork argument
            %%
            %assign canDWork = FcnGetCanDWorkArgs(sysFcn, sysIdx, ...
                accessSysIdx, callSiteIdx, cTID, isRG, skipCanDWork)
            %if canDWork != ""
                %assign args = "%<args>%<comma>%<canDWork>"
                %assign comma = ", "
            %endif
        %endif %% LibSystemIsReusedFcn(thisSystem)
    %endwith %% thisSystem.Interface

    %return args
%endfunction %% FcnGetAdditionalArgs

%% Function: LibIsPassThroughSubsystemCall =========================================================
%% Abstract:
%%    The parent has the same pass through system index as the caller.
%%
%function LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx)
    %return ::CompiledModel.System[sysIdx].HStructDeclSystemIdx == accessSysIdx
%endfunction

%% Function: LibGetFcnCallISR ======================================================================
%% Abstract:
%%    For use by inlined S-Functions with function call outputs. Returns a
%%    function call string with a ISR (interupt service routine) compatible
%%    interface.
%%    This library function should be used to a attach the generated code
%%    of a Simulink function call subsystem to a ISR.
%%
%function LibGetFcnCallISR(ssBlock, portEl, tidVal) void
    %return SLibGetFcnEventType(ssBlock, portEl, tidVal, "ISR", "OutputUpdate")
%endfunction

%% Function: LibGetFcnCallFNI ======================================================================
%% Abstract:
%%    For use by inlined S-Functions with function call outputs. Returns a
%%    function call string with a FNI (forced non-inlined) compatible
%%    interface.
%%
%function LibGetFcnCallFNI(ssBlock, portEl, tidVal) void
    %return SLibGetFcnEventType(ssBlock, portEl, tidVal, "FNI", "OutputUpdate")
%endfunction

%% Function: LibGetFcnInitializeFNI ================================================================
%% Abstract:
%%    For use by inlined S-Functions with function call outputs. Returns a
%%    function call string with a FNI (forced non-inlined) compatible
%%    interface.
%%
%function LibGetFcnInitializeFNI(ssBlock, portEl, tidVal) void
    %return SLibGetFcnEventType(ssBlock, portEl, tidVal, "FNI", "Initialize")
%endfunction

%% Function: LibGetFcnSystemResetFNI ===============================================================
%% Abstract:
%%    For use by inlined S-Functions with function call outputs. Returns a
%%    function call string with a FNI (forced non-inlined) compatible
%%    interface.
%%
%function LibGetFcnSystemResetFNI(ssBlock, portEl, tidVal) void
    %return SLibGetFcnEventType(ssBlock, portEl, tidVal, "FNI", "SystemReset")
%endfunction

%% Function: LibGetFcnEnableFNI ====================================================================
%% Abstract:
%%    For use by inlined S-Functions with function call outputs. Returns a
%%    function call string with a FNI (forced non-inlined) compatible
%%    interface.
%%
%function LibGetFcnEnableFNI(ssBlock, portEl, tidVal) void
    %return SLibGetFcnEventType(ssBlock, portEl, tidVal, "FNI", "Enable")
%endfunction

%% Function: LibGetFcnDisableFNI ===================================================================
%% Abstract:
%%    For use by inlined S-Functions with function call outputs. Returns a
%%    function call string with a FNI (forced non-inlined) compatible
%%    interface.
%%
%function LibGetFcnDisableFNI(ssBlock, portEl, tidVal) void
    %return SLibGetFcnEventType(ssBlock, portEl, tidVal, "FNI", "Disable")
%endfunction

%% Function: SLibGenerateISRStubs ==================================================================
%% Abstract:
%%    This function is called by SLibGetBodyOutputUpdateFcnCache in
%%    commonbodlib.tlc in order to generate the function call stubs with a
%%    ISR (interupt service routine) compatible interface.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function SLibGenerateISRStubs(fcnCallSys) void
    %assign tmpBuffer = ""
    %assign sysFcnPrototype = ""

    %if LibIsSystemField(fcnCallSys, "NumISROutputUpdateCallSites")
        %assign NumISRCallSites = ...
            LibGetSystemField(fcnCallSys, "NumISROutputUpdateCallSites")
        %assign     ISRCallSite = ...
            LibGetSystemField(fcnCallSys, "ISROutputUpdateCallSite")
        %openfile tmpBuffer
        %foreach idx=NumISRCallSites
            %assign  fcnName = ISRCallSite[idx][0]
            %assign   sysIdx = ISRCallSite[idx][1]
            %assign    csIdx = ISRCallSite[idx][2]
            %assign   portEl = ISRCallSite[idx][3]
            %assign   tidVal = ISRCallSite[idx][4]
            %assign callSite = ::CompiledModel.System[sysIdx].CallSites[csIdx]
            %assign  ssBlock = ::CompiledModel.System[callSite[2]].Block[callSite[3]]

            /*
            * Interrupt service routine (ISR) function call stub
            * for '%<ssBlock.Name>'
            */
            void %<fcnName>(void) {
                %if FcnSubsystemIsAsycnTopSS(fcnCallSys)
                    %<SLibDumpOutputUpdateCodeForAsyncTid(fcnCallSys.CurrentTID)>
                %elseif LibIsSystemField(fcnCallSys,"CallerBlkIdx")
                    %assign callerBlkIdx = LibGetSystemField(fcnCallSys,"CallerBlkIdx")
                    %if callerBlkIdx[0] > 0
                        %assign sfcnBlk = System[callerBlkIdx[0]].Block[callerBlkIdx[2]]
                        %<LibBlockExecuteFcnCall(sfcnBlock, portEl)>
                    %else
                        %<SLibCallFCSS(sysIdx,csIdx,NumSystems-1,portEl,tidVal,0,"OutputUpdate")>
                    %endif
                %else
                    %<SLibCallFCSS(sysIdx,csIdx,NumSystems-1,portEl,tidVal,0,"OutputUpdate")>
                %endif
            }
            %assign sysFcnPrototype = sysFcnPrototype + ...
                "%<LibExternInFcnDecls()>void %<fcnName>(void);\n"
        %endforeach
        %closefile tmpBuffer
        %if !SLibGenSubsysFcnAsClassMemFcn(::CompiledModel.System[sysIdx])
            %assign fileSysIdx = ::CompiledModel.System[sysIdx].FileNameOwnerIdx
            %assign fileOwner  = ::CompiledModel.System[fileSysIdx]
            %<LibAddToSystemField(fileOwner, "SystemFcnPrototype", sysFcnPrototype)>
        %else
            %% When in generating subsystem funcitons as C++ member function mode,
            %% system function prototoype cannot be put in the file owner subsystem, as they will
            %% need to be put into root_model.h
            %<LibAddToSystemField(::CompiledModel.System[sysIdx], "EncapSystemFcnPrototype", sysFcnPrototype)>
        %endif
    %endif

    %return tmpBuffer
%endfunction %% SLibGenerateISRStubs

%function FcnGetFNIRTModelArgName()
    %assign locSS = RTMGetModelSS()
    %if GenRTModel
        %assign isGlobal = TLC_TRUE
        %assign isFixed = TLC_FALSE
        %assign locSS = LibRequestID(locSS, isGlobal, isFixed)
    %endif
    %return locSS
%endfunction

%% Function: FcnGenerateFNIStubsForFcn =============================================================
%% Abstract:
%%    This function is called by SLibGetBodyOutputUpdateFcnCache in
%%    commonbodlib.tlc in order to generate the function call stubs with a
%%    FNI (forced non-inlined) compatible interface.
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc/tVariantSource3.m
%%
%function FcnGenerateFNIStubsForFcn(fcnCallSys, fcnType) void
    %assign booleanType = LibGetDataTypeNameFromId(::CompiledModel.tSS_BOOLEAN)
    %assign intType = LibGetDataTypeNameFromId(::CompiledModel.tSS_INTEGER)
    %assign tmpBuffer = ""
    %assign sysFcnPrototype = ""

    %if LibIsSystemField(fcnCallSys, "NumFNI%<fcnType>CallSites")
        %assign NumFNICallSites = ...
            LibGetSystemField(fcnCallSys, "NumFNI%<fcnType>CallSites")
        %assign     FNICallSite = ...
            LibGetSystemField(fcnCallSys, "FNI%<fcnType>CallSite")
        %openfile tmpBuffer
        %foreach idx=NumFNICallSites
            %assign   fcnName = FNICallSite[idx][0]
            %assign    sysIdx = FNICallSite[idx][1]
            %assign     csIdx = FNICallSite[idx][2]
            %assign    portEl = FNICallSite[idx][3]
            %assign    tidVal = FNICallSite[idx][4]
            %assign blkSysIdx = FNICallSite[idx][5]
            %assign    blkIdx = FNICallSite[idx][6]
            %assign   emitted = FNICallSite[idx][7]
            %assign isRateGroupedSLFInAccel = Accelerator ...
                && fcnCallSys.IsRateGroupedSLFcn == TLC_TRUE && fcnType == "OutputUpdate"
            %if isRateGroupedSLFInAccel
                %% Rate grouped Simulink functions exist in the root module. So need to
                %% get the FcnInfo from root.
                %assign rateGroupedSLFSystem = System[NumSystems-1]
                %assign  fcnInfo = LibGetFcnInfo(rateGroupedSLFSystem, "Output", fcnCallSys.CurrentTID)
            %else
                %assign  fcnInfo = ...
                    LibGetFcnInfo(fcnCallSys, fcnType, fcnCallSys.CurrentTID)
            %endif
            %assign cgirName = fcnInfo.CGIRName
            %assign calleeSystem = ::CompiledModel.System[sysIdx]
            %assign callSite = calleeSystem.CallSites[csIdx]
            %assign  ssBlock = ::CompiledModel.System[callSite[2]].Block[callSite[3]]
            %assign sfcnBlock = ::CompiledModel.System[blkSysIdx].Block[blkIdx]
            %assign modIdx = ::CompiledModel.RTWCGModules.NumRTWCGModules-1
            %assign fcnIdx = ::CompiledModel.RTWCGModules.TestInterfaceFcnIdx
            %assign argVec = []

            %if emitted == 1
                %continue
            %else
                %assign FNICallSite[idx][7] = 1
                %<LibSetSystemField(fcnCallSys, "FNI%<fcnType>CallSite", FNICallSite)>
            %endif

            %with sfcnBlock
                %if SLibTLCSystemFcnCallExists(fcnType, sysIdx, csIdx, modIdx, fcnIdx)
                    %assign callInfo = ...
                        SLibTLCSystemFcnCallInfo(fcnType, sysIdx, csIdx, modIdx, fcnIdx)
                    %assign argVec = callInfo.Args
                    %assign cgirName = callInfo.Name
                %endif
            %endwith

            %<SLibUpdateLocalSymbolTableForFile(SLibGetFullFileNameForSystemCode("sys_fcn_defn", sysIdx), ...
                SLibGetFcnDefinitionRTMSymbolName())>
            %assign  locSS = FcnGetFNIRTModelArgName()
            %assign  argDefs = ::tSimStructType + " *const " + locSS
            %assign  rtmUnused = 1
            %assign  cpiUnused = 0
            %assign  tidUnused = 0
            %if SLibAutosarCompilerAbstractionRequired()
                %assign dataDef = SLibAutosarCompilerAbstractionForDataDecl(...
                    TLC_FALSE, intType, TLC_FALSE, TLC_FALSE, ::tControlPortIdx, ...
                    "DataAutomatic")
                %assign argDefs = argDefs + ", " + dataDef
            %else
                %assign argDefs = argDefs + ", %<intType> " + ::tControlPortIdx
            %endif
            %if !LibSystemFcnNeedsCPI(fcnCallSys, fcnType)
                %assign  cpiUnused = 1
            %endif

            %% If the system function doesn't have TID, then add it to the
            %% stub since the stub has an expected interface including the TID
            %if SLibAutosarCompilerAbstractionRequired()
                %assign dataDef = SLibAutosarCompilerAbstractionForDataDecl(...
                    TLC_FALSE, intType, TLC_FALSE, TLC_FALSE, ::tTID, "DataAutomatic")
                %assign argDefs = argDefs + ", " + dataDef
            %else
                %assign argDefs = argDefs + ", %<intType> " + ::tTID
            %endif
            %if !LibSystemFcnNeedsTID(fcnCallSys, fcnType)
                %assign  tidUnused = 1
            %endif

            %%
            %% To avoid warnings, use a different name for the
            %% rtModel in the function declaration than in the
            %% function body.
            %%
            %if GenRTModel
                %assign          rtm = " *%<locSS>"
                %assign     lowerrtm = " *rtm"
                %assign lowerArgDefs = STRREP( argDefs, rtm, lowerrtm)
            %else
                %assign lowerArgDefs = argDefs
            %endif

            /*
            * Forced non-inlined (FNI) function call stub
            * for '%<ssBlock.Name>'
            */
            %% Model Reference must supply boolean return argument to satisfy
            %% fcnCallSys macro
            %% g2156214: change return type from %<booleanType> to %<intType>
            %% to remove GCC8.3 cast warnings when register fcnCallFNI
            %assign retArg = intType
            %<SLibIfSystemVariantCondition(fcnCallSys)>
            %<retArg> %<fcnName>(%<argDefs>) {
                %% Make the smarts for whether or not to call the initialize
                %% function based on state reset here, so the caller (e.g. Stateflow
                %% or rt_EnableSys can be blissfully and generically unaware of it
                %% (at runtime)

                %assign fcnCode = ""
                %openfile fcnCode
                %assign callerSfcnBlk = ""
                %if LibIsSystemField(fcnCallSys,"CallerBlkIdx")
                    %assign callerBlkIdx = LibGetSystemField(fcnCallSys,"CallerBlkIdx")
                    %if callerBlkIdx[0] > 0
                        %assign callerSfcnBlk = System[callerBlkIdx[0]].Block[callerBlkIdx[2]]
                        %assign callerSfcnBlkEl = LibGetSystemField(fcnCallSys,"CallerBlkPortEl")
                    %endif
                %endif

                %if  !ISEMPTY(callerSfcnBlk) && ...
                    LibBlockGetNumFcnCallOutputDsts(callerSfcnBlk) > 1
                    %% If this callerSfcnBlk has multiple destination, checking the emptyness of
                    %% this one destination system is not sufficient. In this case, be conservative,
                    %% assume at least one destination subsystems is not empty.
                    %assign systemFcnIsEmpty = TLC_FALSE
                %else
                    %if fcnType == "OutputUpdate" || ...
                        fcnType == "Output" || fcnType == "Update"
                        %if isRateGroupedSLFInAccel
                            %% Sometimes the CurrentTID for root is not set. We should
                            %% set it to the passed in TID (tidVal) in order to ensure
                            %% we are looking at the right Output function in root when
                            %% we call LibSystemFcnIsEmptyForTID.
                            %assign oldTidVal = rateGroupedSLFSystem.CurrentTID
                            %assign rateGroupedSLFSystem.CurrentTID = tidVal
                            %assign systemFcnIsEmpty = ...
                                LibSystemFcnIsEmptyForTID(rateGroupedSLFSystem, fcnType)
                            %assign rateGroupedSLFSystem.CurrentTID = oldTidVal
                        %else
                            %assign systemFcnIsEmpty = ...
                                LibSystemFcnIsEmptyForTID(fcnCallSys, fcnType)
                        %endif
                    %else
                        %assign systemFcnIsEmpty = ...
                            LibSystemFcnIsEmpty(fcnCallSys, fcnType)
                    %endif
                %endif
                %%

                %if IsModelReferenceSimTarget() && (fcnType == "Enable")
                    %% The Enable Function must call the Initialize function because
                    %% simulation doesn't cache away the Initialize function pointer
                    %if !LibSystemFcnIsEmpty(fcnCallSys, "SystemReset")
                        %if !ISEMPTY(callerSfcnBlk)
                            %assign numfcncalloutputdsts = LibBlockGetNumFcnCallOutputDsts(callerSfcnBlk)
                            %foreach fcIdx = numfcncalloutputdsts
                                %assign blockToCall = ...
                                    sfcnBlock.SFcnSystemOutputCall[fcIdx].BlockToCall
                                %assign calledBlock = ...
                                    ::CompiledModel.System[blockToCall[0]].Block[blockToCall]
                                %with sfcnBlock
                                    %assign initFNI = LibGetFcnSystemResetFNI(calledBlock,0,tidVal)
                                %endwith
                                %assign rtmUnused = 0
                                %<initFNI>(%<locSS>, %<::tTID>, %<::tControlPortIdx>);
                            %endforeach
                        %else
                            %with sfcnBlock
                                %assign initFNI = LibGetFcnSystemResetFNI(ssBlock,portEl,tidVal)
                            %endwith
                            %assign rtmUnused = 0
                            %<initFNI>(%<locSS>, %<::tTID>, %<::tControlPortIdx>);
                        %endif
                    %endif
                %endif
                %assign initiateFcnCall = !systemFcnIsEmpty && ...
                    (fcnType != "SystemReset" || fcnCallSys.TriggerBlkReset)
                %if initiateFcnCall
                    %if isRateGroupedSLFInAccel
                        %assign calleeModIdx = rateGroupedSLFSystem.CGIRModuleIdx
                    %else
                        %assign calleeModIdx = calleeSystem.CGIRModuleIdx
                    %endif
                    %assign calleeModule = ...
                        ::CompiledModel.RTWCGModules.RTWCGModule[calleeModIdx]
                    %if ISFIELD(calleeModule, "SystemFunctions") && ...
                        ISFIELD(calleeModule.SystemFunctions, cgirName)
                        %assign fcnIndex  = GETFIELD(calleeModule.SystemFunctions, cgirName)
                        %assign calleeFcn = calleeModule.Function[fcnIndex]

                        %foreach argIdx=calleeFcn.NumArgs
                            %if calleeFcn.ArgAccessed[argIdx] > 0
                                %assign idNum = SLibSafeIDNUM(calleeFcn.ArgSource, argIdx)
                                %assign argSrc = idNum[0]
                                %switch argSrc
                                  %case "RTM"
                                    %%if GenRTModel
                                    %%assign argVec[argIdx] = "rtm"
                                    %%else
                                    %assign argVec[argIdx] = locSS
                                    %%endif
                                    %if calleeSystem.CrossNoArgFcnBound == 0
                                        %assign rtmUnused = 0
                                    %endif
                                    %break
                                  %case "CPI"
                                    %assign argVec[argIdx] = ::tControlPortIdx
                                    %if calleeSystem.CrossNoArgFcnBound  == 0
                                        %assign cpiUnused = 0
                                    %endif
                                    %break
                                  %case "TID"
                                    %assign argVec[argIdx] = ::tTID
                                    %if calleeSystem.CrossNoArgFcnBound  == 0
                                        %assign tidUnused = 0
                                    %endif
                                    %break
                                  %default
                                    %break
                                %endswitch
                            %endif %% !calleeFcn.ArgAccessed[argIdx]
                        %endforeach %%  argIdx=calleeFcn.NumArgs
                    %endif %% ISFIELD(calleeModule, "SystemFunctions")

                    %if FcnSubsystemIsAsycnTopSS(fcnCallSys) && fcnType == "OutputUpdate"
                        %<SLibDumpOutputUpdateCodeForAsyncTid(fcnCallSys.CurrentTID)>
                    %elseif !ISEMPTY(callerSfcnBlk)
                        %<SLibBlockExecuteSysFcn(callerSfcnBlk, callerSfcnBlkEl, fcnType)>
                    %else
                        %assign addArgs = FcnGetAdditionalArgs(cgirName, argVec, ...
                            fcnType, sysIdx, ::CompiledModel.NumSystems-1, csIdx, TLC_FALSE, TLC_FALSE)
                        %if !WHITE_SPACE(fcnInfo.CommonArgs) && !WHITE_SPACE(addArgs)
                            %assign addArgs = ", " + addArgs
                        %endif
                        %if !EXISTS(callInfo.OpeningTraceComment)
                            %<fcnInfo.Name>(%<fcnInfo.CommonArgs>%<addArgs>);
                        %else
                            %% add traceability comment to the function call site
                            %<callInfo.OpeningTraceComment>%<fcnInfo.Name>%<callInfo.ClosingTraceComment>(%<fcnInfo.CommonArgs>%<addArgs>);

                        %endif



                    %endif
                %endif

                %if 1 == rtmUnused
                    %<SLibUnusedParameter(locSS)>
                %endif
                %if 1 == cpiUnused
                    %<SLibUnusedParameter(::tControlPortIdx)>
                %endif
                %if 1 == tidUnused
                    %<SLibUnusedParameter(::tTID)>
                %endif
                %closefile fcnCode
                %<fcnCode>
                return (1);
            }
            %<SLibEndIfSystemVariantCondition(fcnCallSys)>
            %assign sysFcnPrototype = sysFcnPrototype + ...
                "%<LibExternInFcnDecls()>%<retArg> %<fcnName>(%<lowerArgDefs>);\n"
        %endforeach
        %closefile tmpBuffer

        %if !SLibGenSubsysFcnAsClassMemFcn(::CompiledModel.System[sysIdx])
            %assign fileSysIdx = ::CompiledModel.System[sysIdx].FileNameOwnerIdx
            %assign fileOwner  = ::CompiledModel.System[fileSysIdx]
            %<LibAddToSystemField(fileOwner, "SystemFcnPrototype", sysFcnPrototype)>
        %else
            %% When in generating subsystem funcitons as C++ member function mode,
            %% system function prototoype cannot be put in the file owner subsystem, as they will
            %% need to be put into root_model.h
            %<LibAddToSystemField(::CompiledModel.System[sysIdx], "EncapSystemFcnPrototype", sysFcnPrototype)>
        %endif
    %endif

    %return tmpBuffer
%endfunction %% end: FcnGenerateFNIStubsForFcn

%% Function: SLibGenerateFNIStubs ==================================================================
%% Abstract:
%%    This function is called by SLibGetBodyOutputUpdateFcnCache in
%%    commonbodlib.tlc in order to generate the function call stubs with a
%%    FNI (forced non-inlined) compatible interface.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function SLibGenerateFNIStubs(fcnCallSys) void
    %openfile tmpBuf
    %<FcnGenerateFNIStubsForFcn(fcnCallSys, "OutputUpdate")>\
    %<FcnGenerateFNIStubsForFcn(fcnCallSys, "SystemReset")>\
    %<FcnGenerateFNIStubsForFcn(fcnCallSys, "Enable")>\
    %<FcnGenerateFNIStubsForFcn(fcnCallSys, "Disable")>\
    %closefile tmpBuf
    %return tmpBuf
%endfunction

%% Function: SLibGetFcnEventType ===================================================================
%% Abstract:
%%      This function is called by LibGetFcnCallISR and LibGetFcnCallFNI. It
%%      attaches additional information to the system instance recode that is
%%      used to generate to generate the function call stubs.
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc/tVariantSource3.m
%%
%function SLibGetFcnEventType(fcnCallDst, portEl, tidVal, fcnCallType, fcnType) void
    %if fcnCallDst.Type == "SubSystem"
        %with fcnCallDst
            %assign bType  = (Type == "SubSystem") ? "Subsystem" : ""
            %assign sysIdx = LibBlockParamSetting(bType, "SystemIdx")
        %endwith

        %assign        csIdx = fcnCallDst.CallSiteIdx
        %assign   fcnCallSys = ::CompiledModel.System[sysIdx]
        %if ISFIELD(fcnCallSys, "%<fcnType>Fcn")
            %assign      fcnName = fcnCallSys.%<fcnType>Fcn + fcnCallType
            %assign    fieldName = fcnCallType + fcnType + "CallSite"
            %assign numFieldName = "Num" + fcnCallType + fcnType + "CallSites"

            %if csIdx > 0 || portEl > 0
                %assign  fcnName = fcnName + "_%<csIdx>_%<portEl>"
            %endif

            %assign thisSytemIdx = BlockIdx[0]
            %assign thisBlockIdx = BlockIdx[2]

            %assign callSite = [%<fcnName>, %<sysIdx>, %<csIdx>, ...
                %<portEl>, %<tidVal>, %<thisSytemIdx>, %<thisBlockIdx>, 0]
            %if !LibIsSystemField(fcnCallSys, numFieldName)
                %assign callSite = Matrix (1,8) [[%<callSite>];]
                %<LibAddToSystem(fcnCallSys, numFieldName, 1)>
                %<LibAddToSystem(fcnCallSys, fieldName, callSite)>
            %else
                %assign  fcnExists = 0
                %assign  numFields = LibGetSystemField(fcnCallSys, numFieldName)
                %assign fieldValue = LibGetSystemField(fcnCallSys, fieldName)
                %foreach idx=numFields
                    %if fieldValue[idx][0] == fcnName
                        %assign  fcnExists = 1
                        %break
                    %endif
                %endforeach
                %if !fcnExists
                    %<LibAddToSystemField(fcnCallSys, numFieldName, 1)>
                    %<LibAddToSystemField(fcnCallSys, fieldName, callSite)>
                %endif
            %endif
            %return fcnName
        %else
            %return ""
        %endif
    %else
        %assert fcnCallDst.Type == "ModelReference"

        %% Check that this is being called from the right scope so we can
        %% correctly get the right fcn-call input on the Model block.
        %if !EXISTS(FcnPortIdx)
            %if fcnType == "OutputUpdate"
                %assign tlcFcnName = "LibGetFcnCall%<fcnCallType>"
            %else
                %assign tlcFcnName = "LibGetFcn%<fcnType>%<fcnCallType>"
            %endif
            %<SLibReportErrorWithIdAndArgs("RTW:tlc:SFcnSystemOutputCallOutOfScope", tlcFcnName)>
        %endif

        %assign fcnName = ""
        %if FcnPortIdx >= fcnCallDst.NumDataInputPorts && fcnType == "OutputUpdate" && ...
            ISFIELD(fcnCallDst.ParamSettings, "ModelEventPortNames")
            %assign eventPortIdx = FcnPortIdx - fcnCallDst.NumDataInputPorts
            %assign eventPortName = fcnCallDst.ParamSettings.ModelEventPortNames[eventPortIdx]
            %assign fcnName = "%<fcnCallDst.ParamSettings.ReferencedModelName>_%<fcnCallDst.Identifier>_%<eventPortName>_w"
            %assign TID = SLibGetFcnCallDstTID(fcnCallDst, FcnPortIdx)
            %assign isAsync = TLC_TRUE
            %assign groupIndex = -1
        %else
            %assign fcnCallInfo = SLibGetModelBlockFcnCallInputInfo(fcnCallDst, FcnPortIdx, fcnType)
            %if !ISEMPTY(fcnCallInfo)
                %assign fcnName = "%<fcnCallInfo.TaskName>_w"
                %assign TID = SLibGetFcnCallDstTID(fcnCallDst, FcnPortIdx)
                %assign isAsync = fcnCallInfo.isAsync
                %assign groupIndex = fcnCallInfo.FcnCallPortGroupIndex
            %endif
        %endif

        %if !ISEMPTY(fcnName)
            %if !ISFIELD(fcnCallDst, "WrapperFcns")
                %addtorecord fcnCallDst WrapperFcns {}
            %endif
            %addtorecord fcnCallDst.WrapperFcns %<fcnType> ...
                {FcnName fcnName; ...
                FcnPortIdx FcnPortIdx; ...
                TID TID; ...
                isAsync isAsync; ...
                FcnCallPortGroupIndex groupIndex}
        %endif

        %return fcnName
    %endif
%endfunction

%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc/tmMultiRateAsyncTask_VC1.m
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tMdlRefWithFcnOnDataAsVSSChoice.m
%%
%function SLibGetFcnCallDstTID(dstBlock, dstPort)
    %if dstBlock.Type == "SubSystem"
        %return LibGetSubsystemBlkTIDForTask(dstBlock, TLC_TRUE)
    %else
        %assert dstBlock.Type == "ModelReference"
        %with dstBlock
            %if LibBlockInputSignalSampleTimeIndexExists(dstBlock)
                %assign tid = LibBlockInputSignalSampleTimeIndex(dstPort)
            %else
                %assign tid = TID
            %endif
        %endwith

        %return tid
    %endif
%endfunction

%% DocFunction{Other Useful Functions}: LibBlockExecuteFcnCall =================
%% Abstract:
%%   For use by inlined S-Functions to call fcn-call system output function.
%%   Returns a string to either call function-call subsystem output function
%%   with the appropriate number of arguments or the generate the subsystem output
%%   code right there (inlined).
%%
%% Example:
%%   %foreach callIdx = NumSFcnSysOutputCallDsts
%%       %if LibIsEqual(SFcnSystemOutputCall[callIdx].BlockToCall, "unconnected")
%%          %continue
%%       %endif
%%       %% call the downstream system
%%       %<LibBlockExecuteFcnCall(block, callIdx)>\
%%    %endforeach
%%
%%  Consider using this function to replace LibBlockExecuteFcnCall and LibCallFCSS.
%%  These two function are also used by inline S-Function with function call output
%%  function. However, LibExecuteFcnCall and LibCallFCSS works only if fcn-call
%%  doesn't branch, can't handle fcn-call branches. LibBlockExecuteFcnCall works for
%%  both cases
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc/tVariantSource3.m
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tMdlRefWithFcnOnDataAsVSSChoice.m
%%
%function LibBlockExecuteFcnCall(sfcnBlock, callIdx) void
    %% Get the starting index of corresponding SFcnSystemOutputCall record first
    %% e.g.
    %%   'sfcnBlock' outputs 3 elements
    %%   The 1st element calls 2 function-call destinations: {'AAA', 'BBB'}
    %%   The 2nd element is unconnected: {'unconnected'}
    %%   The 3rd element calls 3 function-call destinations: {'CCC', 'DDD', 'EEE'}
    %%
    %%   Then it has a flat list of 'SFcnSystemOutputCall' records:
    %%   SFcnSystemOutputCall[0] --> 'AAA'
    %%   SFcnSystemOutputCall[1] --> 'BBB'
    %%   SFcnSystemOutputCall[2] --> 'unconnected'
    %%   SFcnSystemOutputCall[3] --> 'CCC'
    %%   SFcnSystemOutputCall[4] --> 'DDD'
    %%   SFcnSystemOutputCall[5] --> 'EEE'
    %%
    %%   The 'SFcnSystemOutputCallMappingInfo' has 3 records, each mapped to one
    %%   output element of 'sfcnBlock':
    %%   SFcnSystemOutputCallMappingInfo[0].StartingIdx   = 0
    %%   SFcnSystemOutputCallMappingInfo[0].NumOfCalledFC = 2
    %%   SFcnSystemOutputCallMappingInfo[1].StartingIdx   = 2
    %%   SFcnSystemOutputCallMappingInfo[1].NumOfCalledFC = 1
    %%   SFcnSystemOutputCallMappingInfo[2].StartingIdx   = 3
    %%   SFcnSystemOutputCallMappingInfo[2].NumOfCalledFC = 3
    %%
    %%   When passing a 'callIdx' of 2, we should be able to get the starting
    %%   index in the list of 'SFcnSystemOutputCall' records, which is 3.
    %assign recIdx = sfcnBlock.SFcnSystemOutputCallMappingInfo[callIdx].StartingIdx

    %% Using the example shown above, given the starting index of 3, we should
    %% be able to get the first function-call destination block, which is 'CCC'.
    %assign dstSSBlk = LibGetFcnCallBlock(sfcnBlock, recIdx)

    %if LibIsEqual(dstSSBlk, "")
        %return "" %% Do nothing if the function-call signal is not connected
    %endif
    %with sfcnBlock
        %assign tidVal = ParamSettings.SampleTimesToSet[0][1]
        %% Get called block's function-call input port element index
        %assign fcInpPortEl = SFcnSystemOutputCall[recIdx].FcnPortElement
        %% Get number of called blocks
        %assign nCalledFC = SFcnSystemOutputCallMappingInfo[callIdx].NumOfCalledFC
        %assign dstBlkTid = SLibGetFcnCallDstTID(dstSSBlk, ...
            SFcnSystemOutputCall[recIdx].FcnPortIdx)
    %endwith

    %if FcnBlkIsAsyncTopSfcn(sfcnBlock)
        %assert !IsModelReferenceTarget()
        %% Output element of the S-function block
        %assign sfcnOutputEl   = sfcnBlock.SFcnSystemOutputCall[recIdx].OutputElement
        %assign tidFromSfcnBlk = FcnGetAsyncTidFromSfcnBlk(sfcnBlock, sfcnOutputEl)

        %assert LibAsynchronousTriggeredTID(tidFromSfcnBlk)
        %assert LibAsynchronousTriggeredTID(dstBlkTid)

        %openfile codeForAsyncTid
        %if !ISFIELD(sfcnBlock, "GenCodeForTopAsyncSS")
            %addtorecord sfcnBlock GenCodeForTopAsyncSS TLC_FALSE
        %endif
        %if sfcnBlock.GenCodeForTopAsyncSS
            %% Second time parse the async sfcn TLC file.
            %if tidFromSfcnBlk == dstBlkTid
                %% If the sfcn block is the top sfcn of the rate, the sfcn
                %% will be reponsible to generate task entry fcn. Get the
                %% code that is rate grouped with the async rate at root level
                %% so that code can be dumped in task entry fcn.
                {
                    %if SLibIsMappedSystemInDeploymentDiagram(sfcnBlock.BlkSysIdx)
                        %assign ssIdx = sfcnBlock.BlkSysIdx
                        %<SLibDumpOutputUpdateCodeForAsyncTidInSS(ssIdx, dstBlkTid)>
                    %else
                        %<SLibDumpOutputUpdateCodeForAsyncTid(dstBlkTid)>
                    %endif
                }
            %else
                %% If the sfcn block is not the tops sfcn of the rate,
                %% call task entry fcn for the rate. This sfcn block is
                %% no repsonsible to generate the function body.
                %%
                %<RTWCGBlockExecuteAsyncEntryFcn(fcInpPortEl, dstBlkTid)>
            %endif
        %else
            %% First time parse the async sfcn TLC file.
            %% Generate code body. The code will be rate grouped
            %% in parent system.
            %<SLibExecuteFcnCallGeneralHelper(sfcnBlock, recIdx, nCalledFC, tidVal)>
        %endif
        %closefile codeForAsyncTid
        %return codeForAsyncTid
    %else
        %openfile retBuf
        %if !ISEQUAL(sfcnBlock.TID, dstBlkTid) && LibAsynchronousTriggeredTID(dstBlkTid)
            %% Destination block has different sample time and it is a union sample time.
            %% Call the task entry fcn of the union sample time.
            %%  %assert Sampletime[dstBlkTid].IsUnionTs == "yes"
            %<RTWCGBlockExecuteAsyncEntryFcn(fcInpPortEl, dstBlkTid)>
        %else
            %<SLibExecuteFcnCallGeneralHelper(sfcnBlock, recIdx, nCalledFC, tidVal)>
        %endif
        %closefile retBuf
        %return retBuf
    %endif
%endfunction %% end: LibBlockExecuteFcnCall

%% DocFunction{Other Useful Functions}: LibBlockExecuteFcnEnable =================
%% Abstract:
%%   For use by inlined S-Functions to call fcn-call system enable function.
%%   Returns a string to either call function-call subsystem enable function
%%   with the appropriate number of arguments or the generate the subsystem enable
%%   code right there (inlined).
%%
%% Example:
%%   %foreach callIdx = NumSFcnSysOutputCallDsts
%%       %if LibIsEqual(SFcnSystemOutputCall[callIdx].BlockToCall, "unconnected")
%%          %continue
%%       %endif
%%       %% call the downstream system
%%       %<LibBlockExecuteFcnEnable(block, callIdx)>\
%%    %endforeach
%%
%%  Consider using this function to replace LibBlockExecuteFcnEnable and LibEnableFCSS.
%%  These two function are also used by inline S-Function with function call enable
%%  function. However, LibExecuteFcnEnable and LibEnableFCSS works only if fcn-call
%%  doesn't branch, can't handle fcn-call branches. LibBlockExecuteFcnEnable works for
%%  both cases
%%
%function LibBlockExecuteFcnEnable(sfcnBlock, callIdx)
    %return SLibBlockExecuteFcnEnableDisableHelper(sfcnBlock, callIdx, TLC_TRUE)
%endfunction

%% DocFunction{Other Useful Functions}: LibBlockExecuteFcnDisable =================
%% Abstract:
%%   For use by inlined S-Functions to call fcn-call system disable function.
%%   Returns a string to either call function-call subsystem disable function
%%   with the appropriate number of arguments or the generate the subsystem disable
%%   code right there (inlined).
%%
%% Example:
%%   %foreach callIdx = NumSFcnSysOutputCallDsts
%%       %if LibIsEqual(SFcnSystemOutputCall[callIdx].BlockToCall, "unconnected")
%%          %continue
%%       %endif
%%       %% call the downstream system
%%       %<LibBlockExecuteFcnDisable(block, callIdx)>\
%%    %endforeach
%%
%%  Consider using this function to replace LibBlockExecuteFcnDisable and LibDisableFCSS.
%%  These two function are also used by inline S-Function with function call disable
%%  function. However, LibExecuteFcnDisable and LibDisableFCSS works only if fcn-call
%%  doesn't branch, can't handle fcn-call branches. LibBlockExecuteFcnDisable works for
%%  both cases
%%
%function LibBlockExecuteFcnDisable(sfcnBlock, callIdx)
    %return SLibBlockExecuteFcnEnableDisableHelper(sfcnBlock, callIdx, TLC_FALSE)
%endfunction

%% SLibBlockExecuteFcnEnableDisableHelper ======================================
%% Abstract:
%%     Helper function for LibBlockExecuteFcnEnable & LibBlockExecuteFcnDisable
%%     When enableFcn == TLC_TRUE, generate enable function; otherwise, generate
%%     disable function.
%function SLibBlockExecuteFcnEnableDisableHelper(sfcnBlock, callIdx, enableFcn)
    %openfile retBuf
    %assign recIdx    = sfcnBlock.SFcnSystemOutputCallMappingInfo[callIdx].StartingIdx
    %assign nCalledFC = sfcnBlock.SFcnSystemOutputCallMappingInfo[callIdx].NumOfCalledFC

    %foreach fcIdx = nCalledFC
        %assign dstSSBlk = LibGetFcnCallBlock(sfcnBlock, recIdx)

        %if !LibIsEqual(dstSSBlk, "") %% Ignore unconnected function-call signal
            %with sfcnBlock
                %assign tidVal = ParamSettings.SampleTimesToSet[0][1]
                %assign fcInpPortEl  = SFcnSystemOutputCall[recIdx].FcnPortElement
                %assign fcInpPortIdx = SFcnSystemOutputCall[recIdx].FcnPortIdx
            %endwith

            %if enableFcn == TLC_TRUE %% Generate enable function
                %<SLibExecuteFcnEnableHelper(dstSSBlk, fcInpPortEl, fcInpPortIdx, tidVal,TLC_FALSE)>
            %else %% Generate disable function
                %<SLibExecuteFcnDisableHelper(dstSSBlk, fcInpPortEl, fcInpPortIdx, tidVal,TLC_FALSE)>
            %endif
        %endif

        %assign recIdx = recIdx + 1 %% Update the record index
    %endforeach
    %closefile retBuf

    %return retBuf
%endfunction

%function SLibBlockExecuteFcnInit(sfcnBlock, callIdx)
    %with sfcnBlock
        %assign recIdx    = SFcnSystemOutputCallMappingInfo[callIdx].StartingIdx
        %assign nCalledFC = SFcnSystemOutputCallMappingInfo[callIdx].NumOfCalledFC
        %assign tidVal = ParamSettings.SampleTimesToSet[0][1]
        %assign portEl = SFcnSystemOutputCall[recIdx].FcnPortElement
    %endwith

    %openfile retBuf
    %foreach fcIdx = nCalledFC
        %assign dstSSBlk = LibGetFcnCallBlock(sfcnBlock, recIdx)

        %if !LibIsEqual(dstSSBlk, "") %% Ignore unconnected function-call signal
            %<SLibExecuteFcnInitHelper(dstSSBlk, portEl, tidVal,TLC_FALSE)>
        %endif

        %assign recIdx = recIdx + 1 %% Update the record index
    %endforeach
    %closefile retBuf

    %return retBuf
%endfunction

%function SLibBlockExecuteSysFcn(sfcnBloc, callIdx, fcnType)
    %openfile retBuf
    %switch(fcnType)
      %case "OutputUpdate"
        %<LibBlockExecuteFcnCall(sfcnBloc, callIdx)>
        %break
      %case "Initialize"
        %<SLibBlockExecuteFcnInit(sfcnBloc, callIdx)>
        %break
      %case "Enable"
        %<LibBlockExecuteFcnEnable(sfcnBloc, callIdx)>
        %break
      %case "Disable"
        %<LibBlockExecuteFcnDisable(sfcnBloc, callIdx)>
        %break
      %default
        %<SLibReportErrorWithIdAndArgs("RTW:tlc:InvalidFcnType", fcnType)>
        %break
    %endswitch
    %closefile retBuf

    %return retBuf
%endfunction


%function SLibReportObsoleteFcnCallAPI(OldFcnName, NewFcnName, system)
    %<SLibReportErrorWithIdAndArgs("RTW:tlc:ObsoleteFcnCall", ...
        ["%<OldFcnName>", "%<system.Name>", "%<NewFcnName>"])>
%endfunction

%function GetInstanceIndexOfModelBlock(modelBlkId)
    %%if the current block is model reference Compiled model should have
    %%model reference field
    %assert ISFIELD(::CompiledModel,"ModelReferenceBlocks")
    %assign mdlRefBlks = ::CompiledModel.ModelReferenceBlocks

    %% get all model blocks instances and
    %% find current model block instance
    %foreach rowIdx = SIZE(mdlRefBlks,0)
        %assign mdlRefInfo = mdlRefBlks[rowIdx]
        %assign bIdx = mdlRefInfo[1]
        %if bIdx == modelBlkId
            %return mdlRefInfo[2]
        %endif
    %endforeach
%endfunction

%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc/tVariantSource3.m
%%
%function SLibExecuteFcnCallGeneralHelper(sFcnBlock, recStartingIdx, nCalledFC, tidVal) void
    %assign recIdx = recStartingIdx
    %openfile buffer
    %foreach fcIdx = nCalledFC
        %assign blockToCall   = sFcnBlock.SFcnSystemOutputCall[recIdx].BlockToCall
        %assign sysIdx        = blockToCall[0]
        %assign blkIdx        = blockToCall[1]
        %assign calledBlock   = ::CompiledModel.System[sysIdx].Block[blkIdx]
        %assign calledBlockSys = sysIdx
        %% For getting the correct system for the calledBlock, which will have a CallSiteInfo,
        %% use that record to get the System index to get the correct module index.
        %%  TopTester: test/toolbox/simulink/variants/var-defaultvariant/t_mg1170693.m
        %%  TopTester: test/toolbox/simulink/variants/var-inline-vsrc/tmLG_async_interrupt.m
        %%
        %% For example, an async block in the root module calling a function subsystem in the
        %% child module. We have to get the module index of the function call subsystem to
        %% correctly guard the calls site or else it will cause build issues.
        %if ISFIELD(calledBlock,"CallSiteInfo") && ISFIELD(calledBlock.CallSiteInfo, "SystemIdx")
            %assign calledBlockSys = calledBlock.CallSiteInfo.SystemIdx
        %endif
        %assign modIdx = ::CompiledModel.System[calledBlockSys].CGIRModuleIdx
        %assign moduleCondition = CGMODEL_ACCESS("CGModel.GetModuleCondition", modIdx)
        %with sFcnBlock
            %% Get called block's function-call input port element index
            %assign fcInpPortEl = SFcnSystemOutputCall[recIdx].FcnPortElement
            %assign fcPortIdx   = SFcnSystemOutputCall[recIdx].FcnPortIdx
            %assign subsysFcnCall = SLibExecuteFcnCallHelper(calledBlock, fcInpPortEl, ...
                fcPortIdx, tidVal, TLC_FALSE)
        %endwith

        %if (calledBlock.Type == "ModelReference")
            %% TopTester: test/toolbox/simulink/variants/var-general/tVariantGecks8.m -testspec:TestPoint_vssWithExpFcnMdl1
            %assign instIdx = GetInstanceIndexOfModelBlock(blkIdx)
            %assign vcRecord = SLibMdlRefNetInlineVariantPreprocessorCondition(sysIdx, instIdx, blkIdx)
            %assign ifCond =  vcRecord.ifCond
            %assign endIfCond = vcRecord.endIfCond
            %<SLibWrapBody(ifCond, subsysFcnCall, endIfCond)>
        %else
            %% wrap the call site of the function with the module condition
            %assign ifCond = SLibIfVariantConditionForm(moduleCondition)
            %assign endIfCond = SLibEndIfVariantConditionForm(moduleCondition)
            %<SLibWrapBody(ifCond, subsysFcnCall, endIfCond)>
        %endif


        %assign recIdx = recIdx + 1 %% Update the record index
    %endforeach
    %closefile buffer
    %return buffer
%endfunction

%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tMdlRefWithFcnOnDataAsVSSChoice.m
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc/tVariantSource3.m
%%
%function SLibExecuteFcnCallHelper(fcnCallDstBlock, portEl, portIdx, tidVal,checkUsage) void
    %assign isSubsystem = (fcnCallDstBlock.Type == "SubSystem")

    %if isSubsystem
        %with fcnCallDstBlock
            %assign bType  = (Type == "SubSystem") ? "Subsystem" : ""
            %assign sysIdx = LibBlockParamSetting(bType, "SystemIdx")
        %endwith

        %if checkUsage && ISFIELD(System[sysIdx],"IsBranchedSys")
            %<SLibReportObsoleteFcnCallAPI("LibExecuteFcnCall","LibBlockExecuteFcnCall",System[sysIdx])>
        %endif

        %if checkUsage && FcnSubsystemIsAsycnTopSS(System[sysIdx])
            %assign ssBlkTid = LibGetSubsystemBlkTIDForTask(fcnCallDstBlock, TLC_TRUE)
            %assert LibAsynchronousTriggeredTID(ssBlkTid)
            %assign topAsyncSfcn =  FcnGetTaskTopSfcnBlock(ssBlkTid)

            %if ISEMPTY(topAsyncSfcn) || !topAsyncSfcn.AsyncSfcn
                %% If the sfcn block is not the tops sfcn of the rate,
                %% call task entry fcn for the rate. This sfcn block is
                %% no repsonsible to generate the function body.
                %%
                %<RTWCGBlockExecuteAsyncEntryFcn(portEl,ssBlkTid)>
            %else
                %assign el = SampleTime[ssBlkTid].AsyncSfcnBlkElm
                %return LibBlockExecuteFcnCall(topAsyncSfcn,el)
            %endif
        %else
            %assign        csIdx = fcnCallDstBlock.CallSiteIdx
            %assign           cs = System[sysIdx].CallSites[csIdx]
            %assign accessSysIdx = System[cs[0]].HStructDeclSystemIdx
            %assign      fciCont = SLibIsFcnCallerContinuous(tidVal)
            %return SLibCallFCSS(sysIdx, csIdx, accessSysIdx, ...
                portEl, tidVal, fciCont, "OutputUpdate")
        %endif
    %else
        %assert (fcnCallDstBlock.Type == "ModelReference")
        %if checkUsage && (portIdx == -1)
            %<SLibReportObsoleteFcnCallAPI("LibExecuteFcnCall", ...
                "LibBlockExecuteFcnCall", fcnCallDstBlock)>
        %endif

        %with System[fcnCallDstBlock.BlockIdx[0]]
            %with fcnCallDstBlock
                %return CallModelBlockAsyncFcnCallInput(fcnCallDstBlock, portIdx, tidVal, ...
                    "OutputUpdate")
            %endwith
        %endwith
    %endif
%endfunction

%% DocFunction{Other Useful Functions}: LibExecuteFcnCall ======================
%% Abstract:
%%   For use by inlined S-Functions with function call outputs. Returns a
%%   string to either call function-call subsystem with the appropriate number
%%   of arguments or the generate the subsystem's code right there (inlined).
%%
%% Example:
%%   %foreach fcnCallIdx = NumSFcnSysOutputCallDsts
%%       %% call the downstream system
%%       %with SFcnSystemOutputCall[fcnCallIdx]
%%         %% skip unconnected function call outputs
%%         %if ISEQUAL(BlockToCall, "unconnected")
%%           %continue
%%         %endif
%%         %assign sysIdx = BlockToCall[0]
%%         %assign blkIdx = BlockToCall[1]
%%         %assign ssBlock = System[sysIdx].Block[blkIdx]
%%         %<LibExecuteFcnCall(ssBlock, FcnPortElement, ...
%%                             ParamSettings.SampleTimesToSet[0][1])>\
%%       %endwith
%%     %endforeach
%%
%%     BlockToCall and FcnPortElement are elements of the SFcnSystemOutputCall
%%     record.
%%
%function LibExecuteFcnCall(ssBlock, portEl, tidVal) void
    %return SLibExecuteFcnCallHelper(ssBlock, portEl, -1, tidVal,TLC_TRUE)
%endfunction

%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc/tVariantSource3.m
%%
%function  SLibExecuteFcnEnableHelper(fcnCallBlock, portEl, fcnPort, tidVal,checkUsage)
    %assign isSubsystem = (fcnCallBlock.Type == "SubSystem")

    %if isSubsystem
        %with fcnCallBlock
            %assign bType  = (Type == "SubSystem") ? "Subsystem" : ""
            %assign sysIdx = LibBlockParamSetting(bType, "SystemIdx")
        %endwith

        %if checkUsage && ISFIELD(System[sysIdx],"IsBranchedSys")
            %<SLibReportObsoleteFcnCallAPI("LibExecuteFcnEnable","LibBlockExecuteFcnEnable",System[sysIdx])>
        %endif

        %assign        csIdx = fcnCallBlock.CallSiteIdx
        %assign           cs = System[sysIdx].CallSites[csIdx]
        %assign accessSysIdx = System[cs[0]].HStructDeclSystemIdx
        %assign      fciCont = SLibIsFcnCallerContinuous(tidVal)
        %openfile tmpBuf
        %with fcnCallBlock
            %assign bType = (Type == "SubSystem") ? "Subsystem" : ""
            %assign swe   = LibBlockParamSetting(bType, "StatesWhenEnabling")
        %endwith

        %if swe == "reset"
            %openfile initBuffer
            %<SLibCallFCSS(sysIdx, csIdx, accessSysIdx, ...
                portEl, tidVal, fciCont, "SystemReset")>
            %closefile initBuffer
            %if !WHITE_SPACE(initBuffer)
                %if ProtectCallInitFcnTwice
                    /* protect against calling initialize function twice at startup */
                    if (!(%<LibIsFirstInitCond()>)) {
                        %<initBuffer>\
                    }
                %else
                    %<initBuffer>\
                %endif
            %endif
        %endif
        %<SLibCallFCSS(sysIdx, csIdx, accessSysIdx, ...
            portEl, tidVal, fciCont, "Enable")>
        %closefile tmpBuf
        %return tmpBuf
    %else
        %if checkUsage && (fcnPort == -1)
            %<SLibReportObsoleteFcnCallAPI("LibExecuteFcnEnable","LibBlockExecuteFcnEnable", fcnCallBlock)>
        %endif
        %with System[fcnCallBlock.BlockIdx[0]]
            %with fcnCallBlock
                %assign retBuf = CallModelBlockAsyncFcnCallInput(fcnCallBlock, fcnPort, tidVal, "Enable")
            %endwith
        %endwith
    %endif
    %return retBuf
%endfunction


%% DocFunction{Other Useful Functions}: LibExecuteFcnEnable ===================
%% Abstract:
%%   For use by inlined S-Functions with function call outputs. Returns a
%%   string to either call function-call subsystem with the appropriate number
%%   of arguments or the generate the subsystem's code right there (inlined).
%%
%% Example:
%%   %foreach fcnCallIdx = NumSFcnSysOutputCallDsts
%%       %% call the downstream system
%%       %with SFcnSystemOutputCall[fcnCallIdx]
%%         %% skip unconnected function call outputs
%%         %if ISEQUAL(BlockToCall, "unconnected")
%%           %continue
%%         %endif
%%         %assign sysIdx = BlockToCall[0]
%%         %assign blkIdx = BlockToCall[1]
%%         %assign ssBlock = System[sysIdx].Block[blkIdx]
%%         %<LibExecuteFcnCall(ssBlock, FcnPortElement, ...
%%                             ParamSettings.SampleTimesToSet[0][1])>\
%%       %endwith
%%     %endforeach
%%
%%     BlockToCall and FcnPortElement are elements of the SFcnSystemOutputCall
%%     record.
%%
%function LibExecuteFcnEnable(ssBlock, portEl, tidVal) void
    %return  SLibExecuteFcnEnableHelper(ssBlock, portEl, -1, tidVal,TLC_TRUE)
%endfunction

%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc/tVariantSource3.m
%%
%function SLibExecuteFcnDisableHelper(fcnCallBlock, portEl, fcnPort, tidVal,checkUsage)
    %assign isSubsystem = (fcnCallBlock.Type == "SubSystem")

    %if isSubsystem
        %with fcnCallBlock
            %assign bType  = (Type == "SubSystem") ? "Subsystem" : ""
            %assign sysIdx = LibBlockParamSetting(bType, "SystemIdx")
        %endwith

        %if checkUsage && ISFIELD(System[sysIdx],"IsBranchedSys")
            %<SLibReportObsoleteFcnCallAPI("LibExecuteFcnDisable","LibBlockExecuteFcnDisable",System[sysIdx])>
        %endif

        %assign        csIdx = fcnCallBlock.CallSiteIdx
        %assign           cs = System[sysIdx].CallSites[csIdx]
        %assign accessSysIdx = System[cs[0]].HStructDeclSystemIdx
        %assign      fciCont = SLibIsFcnCallerContinuous(tidVal)
        %openfile tmpBuf
        %<SLibCallFCSS(sysIdx, csIdx, accessSysIdx, ...
            portEl, tidVal, fciCont, "Disable")>
        %closefile tmpBuf
        %return tmpBuf
    %else
        %if checkUsage && (fcnPort == -1)
            %<SLibReportObsoleteFcnCallAPI("LibExecuteFcnDisable","LibBlockExecuteFcnDisable",fcnCallBlock)>
        %endif
        %with System[fcnCallBlock.BlockIdx[0]]
            %with fcnCallBlock
                %assign retBuf = CallModelBlockAsyncFcnCallInput(fcnCallBlock, fcnPort, tidVal, "Disable")
            %endwith
        %endwith
    %endif
    %return retBuf
%endfunction

%% DocFunction{Other Useful Functions}: LibExecuteFcnDisable ===================
%% Abstract:
%%   For use by inlined S-Functions with function call outputs. Returns a
%%   string to either call function-call subsystem with the appropriate number
%%   of arguments or the generate the subsystem's code right there (inlined).
%%
%% Example:
%%   %foreach fcnCallIdx = NumSFcnSysOutputCallDsts
%%       %% call the downstream system
%%       %with SFcnSystemOutputCall[fcnCallIdx]
%%         %% skip unconnected function call outputs
%%         %if ISEQUAL(BlockToCall, "unconnected")
%%           %continue
%%         %endif
%%         %assign sysIdx = BlockToCall[0]
%%         %assign blkIdx = BlockToCall[1]
%%         %assign ssBlock = System[sysIdx].Block[blkIdx]
%%         %<LibExecuteFcnCall(ssBlock, FcnPortElement, ...
%%                             ParamSettings.SampleTimesToSet[0][1])>\
%%       %endwith
%%     %endforeach
%%
%%     BlockToCall and FcnPortElement are elements of the SFcnSystemOutputCall
%%     record.
%%
%function LibExecuteFcnDisable(ssBlock, portEl, tidVal) void
    %return SLibExecuteFcnDisableHelper(ssBlock, portEl, -1, tidVal,TLC_TRUE)
%endfunction


%function SLibExecuteFcnInitHelper(ssBlock, portEl, tidVal,checkUsage)
    %with ssBlock
        %assign bType  = (Type == "SubSystem") ? "Subsystem" : ""
        %assign sysIdx = LibBlockParamSetting(bType, "SystemIdx")
    %endwith

    %assert !(checkUsage && ISFIELD(System[sysIdx],"IsBranchedSys"))

    %assign        csIdx = ssBlock.CallSiteIdx
    %assign           cs = System[sysIdx].CallSites[csIdx]
    %assign accessSysIdx = System[cs[0]].HStructDeclSystemIdx
    %assign      fciCont = SLibIsFcnCallerContinuous(tidVal)
    %openfile tmpBuf
    %<SLibCallFCSS(sysIdx, csIdx, accessSysIdx, ...
        portEl, tidVal, fciCont, "Initialize")>
    %closefile tmpBuf
    %return tmpBuf
%endfunction

%% DocFunction{Other Useful Functions}: LibCallFCSS ============================
%% Abstract:
%%   For use by inlined S-Functions with function call outputs. Returns a
%%   string to either call function-call subsystem with the appropriate number
%%   of arguments or the generate the subsystem's code right there (inlined).
%%
%%   Note:
%%     Used by inlined S-functions to make a function-call, LibCallFCSS
%%     returns the call to the function-call subsystem with the appropriate
%%     number of arguments or the inlined code.  An S-function can execute
%%     a function-call subsystem only via its first output port.
%%
%%     See the SFcnSystemOutputCall record in the model.rtw file.
%%
%%     The return string is determined by the current code format.
%%
%%   Example:
%%     %foreach fcnCallIdx = NumSFcnSysOutputCallDsts
%%       %% call the downstream system
%%       %with SFcnSystemOutputCall[fcnCallIdx]
%%         %% skip unconnected function call outputs
%%         %if ISEQUAL(BlockToCall, "unconnected")
%%           %continue
%%         %endif
%%         %assign sysIdx = BlockToCall[0]
%%         %assign blkIdx = BlockToCall[1]
%%         %assign ssBlock = System[sysIdx].Block[blkIdx]
%%         %assign sysToCall = System[ssBlock.ParamSettings.SystemIdx]
%%         %<LibCallFCSS(sysToCall, tSimStruct, FcnPortElement, ...
%%           ParamSettings.SampleTimesToSet[0][1])>\
%%       %endwith
%%     %endforeach
%%
%%     BlockToCall and FcnPortElement are elements of the SFcnSystemOutputCall
%%     record.
%%
%%     System is a record within the global ::CompiledModel record.
%%
%function LibCallFCSS(system, simObject, portEl, tidVal) void
    %assign       sysIdx = system.SystemIdx
    %if !EXISTS(BlockToCall)
        %if EXISTS(SFcnSystemOutputCall)
            %assign BlockToCall = SFcnSystemOutputCall[0].BlockToCall
        %else
            %<SLibReportErrorWithIdAndArgs("RTW:tlc:IncorrectLibFcnCall", "LibCallFCSS")>
        %endif
    %endif
    %if ISFIELD(System[sysIdx],"IsBranchedSys")
        %<SLibReportObsoleteFcnCallAPI("LibCallFCSS","LibBlockExecuteFcnCall",system)>
    %endif

    %if FcnSubsystemIsAsycnTopSS(system)
        %assign sysTid = LibGetSubsystemTID(system, TLC_TRUE)
        %assert LibAsynchronousTriggeredTID(sysTid)
        %assign topAsyncSfcn =  FcnGetTaskTopSfcnBlock(sysTid)
        %if ISEMPTY(topAsyncSfcn)
            %% If the sfcn block is not the tops sfcn of the rate,
            %% call task entry fcn for the rate. This sfcn block is
            %% no repsonsible to generate the function body.
            %%
            %return RTWCGBlockExecuteAsyncEntryFcn(portEl,sysTid)
        %else
            %assign el = SampleTime[sysTid].AsyncSfcnBlkElm
            %return LibBlockExecuteFcnCall(topAsyncSfcn,el)
        %endif
    %else
        %assign      ssBlock = System[BlockToCall[0]].Block[BlockToCall[1]]
        %assign        csIdx = ssBlock.CallSiteIdx
        %assign           cs = system.CallSites[csIdx]
        %assign accessSysIdx = System[cs[0]].HStructDeclSystemIdx
        %assign      fciCont = SLibIsFcnCallerContinuous(tidVal)
        %return SLibCallFCSS(sysIdx, csIdx, accessSysIdx, portEl, tidVal, fciCont, "OutputUpdate")
    %endif
%endfunction %% LibCallFCSS

%% Function: FcnGenerateOpenFCSSInitialize =========================================================
%% Abstract:
%%     This function generates the opening guard around calling the enable
%%     function for a function-call subsystem.  If setMode is true, we set the
%%     specfied mode to enabled, otherwise we do not set the mode vector.
%%     Currently, since Initialize is called before Enable, Initialize does not
%%     set the mode, but Enable does set the mode.
%%
%function FcnGenerateOpenFCSSInitialize(ssBlock) void
    %with ssBlock
        %assign numModes = ModeVector[0]
        %assign tmpBuffer = ""
        %if numModes > 1
            %openfile tmpBuffer
            CondStates enableState = SUBSYS_DISABLED;
            %foreach mIdx = numModes
                %assign blockMode = LibBlockMode("", "", mIdx)
                if (((CondStates) %<blockMode>) != SUBSYS_DISABLED) {
                    enableState = (CondStates) %<blockMode>;
                }
            %endforeach
            if (enableState == SUBSYS_DISABLED) {
                %closefile tmpBuffer
        %endif
    %endwith
    %return tmpBuffer
%endfunction

%% Function: FcnGenerateCloseFCSSInitialize ========================================================
%% Abstract:
%%    This function generates the closing guard around calling the enable
%%    function for a function-call subsystem.
%%
%function FcnGenerateCloseFCSSInitialize(ssBlock) void
    %with ssBlock
        %assign numModes = ModeVector[0]
        %assign tmpBuffer = ""
        %if numModes > 1
            %openfile tmpBuffer
        }
        %closefile tmpBuffer
        %endif
    %endwith
    %return tmpBuffer
%endfunction

%% Function: FcnGenerateOpenFCSSEnable =============================================================
%% Abstract:
%%    This function generates the opening guard around calling the enable
%%    function for a function-call subsystem.  If setMode is true, we set the
%%    specfied mode to enabled, otherwise we do not set the mode vector.
%%    Currently, since Initialize is called before Enable, Initialize does not
%%    set the mode, but Enable does set the mode.
%%
%function FcnGenerateOpenFCSSEnable(ssBlock, portEl) void
    %with ssBlock
        %assign numModes = ModeVector[0]
        %assign tmpBuffer = ""
        %if numModes > 1
            %openfile tmpBuffer
            {
                CondStates enableState = SUBSYS_DISABLED;
                %foreach mIdx = numModes
                    %assign blockMode = LibBlockMode("", "", mIdx)
                    if (((CondStates) %<blockMode>) != SUBSYS_DISABLED) {
                        enableState = (CondStates) %<blockMode>;
                    }
                %endforeach
                %<LibBlockMode(portEl, "", "")> = SUBSYS_ENABLED;
                if (enableState == SUBSYS_DISABLED) {
                    %closefile tmpBuffer
        %elseif numModes == 1
            %openfile tmpBuffer
            %<LibBlockMode(portEl, "", "")> = SUBSYS_ENABLED;
            %closefile tmpBuffer
        %endif
    %endwith
    %return tmpBuffer
%endfunction

%% Function: FcnGenerateCloseFCSSEnable ============================================================
%% Abstract:
%%    This function generates the closing guard around calling the enable
%%    function for a function-call subsystem.
%%
%function FcnGenerateCloseFCSSEnable(ssBlock) void
    %with ssBlock
        %assign numModes = ModeVector[0]
        %assign tmpBuffer = ""
        %if numModes > 1
            %openfile tmpBuffer
        }
    }
    %closefile tmpBuffer
        %endif
    %endwith
    %return tmpBuffer
%endfunction

%% DocFunction{Other Useful Functions}: LibEnableFCSS =========================
%% Abstract:
%%   For use by inlined S-Functions with function call outputs. Returns a
%%   string to either call the enable method for a function-call subsystem
%%   or generate the subsystem's enable code inline (as well as initialize
%%   code if the subsystem resets states on reset).
%%
%%   Note:
%%     An S-function can execute a function-call subsystem only via its
%%     first output port.
%%
%%     See the SFcnSystemOutputCall record in the model.rtw file.
%%
%%     The return string is determined by the current code format.
%%
%%   Example:
%%     %foreach fcnCallIdx = NumSFcnSysOutputCallDsts
%%       %% call the downstream system
%%       %with SFcnSystemOutputCall[fcnCallIdx]
%%         %% skip unconnected function call outputs
%%         %if ISEQUAL(BlockToCall, "unconnected")
%%           %continue
%%         %endif
%%         %assign sysIdx = BlockToCall[0]
%%         %assign blkIdx = BlockToCall[1]
%%         %assign ssBlock = System[sysIdx].Block[blkIdx]
%%         %assign sysToCall = System[ssBlock.ParamSettings.SystemIdx]
%%         %<LibEnableFCSS(sysToCall, tSimStruct, FcnPortElement, ...
%%           ParamSettings.SampleTimesToSet[0][1])>\
%%       %endwith
%%     %endforeach
%%
%%     BlockToCall and FcnPortElement are elements of the SFcnSystemOutputCall
%%     record.
%%
%%     System is a record within the global ::CompiledModel record.
%%
%function LibEnableFCSS(system, simObject, portEl, tidVal) void
    %assign sysIdx = system.SystemIdx
    %if !EXISTS(BlockToCall)
        %if EXISTS(SFcnSystemOutputCall)
            %assign BlockToCall = SFcnSystemOutputCall[0].BlockToCall
        %else
            %<SLibReportErrorWithIdAndArgs("RTW:tlc:IncorrectLibFcnCall", "LibEnableFCSS")>
        %endif
    %endif
    %if ISFIELD(System[sysIdx],"IsBranchedSys")
        %<SLibReportObsoleteFcnCallAPI("LibEnableFCSS","LibBlockExecuteFcnEnable",system)>
    %endif
    %assign      ssBlock = System[BlockToCall[0]].Block[BlockToCall[1]]
    %assign        csIdx = ssBlock.CallSiteIdx
    %assign           cs = system.CallSites[csIdx]
    %assign accessSysIdx = System[cs[0]].HStructDeclSystemIdx
    %assign      fciCont = SLibIsFcnCallerContinuous(tidVal)
    %openfile tmpBuf
    %if ssBlock.ParamSettings.StatesWhenEnabling == "reset"
        %openfile initBuffer
        %<SLibCallFCSS(sysIdx, csIdx, accessSysIdx, portEl, tidVal, fciCont, "SystemReset")>
        %closefile initBuffer
        %if !WHITE_SPACE(initBuffer)
            %if ProtectCallInitFcnTwice
                /* protect against calling initialize function twice at startup */
                if (!(%<LibIsFirstInitCond()>)) {
                    %<initBuffer>\
                }
            %else
                %<initBuffer>\
            %endif
        %endif
    %endif
    {
        %<SLibCallFCSS(sysIdx, csIdx, accessSysIdx, portEl, tidVal, fciCont, "Enable")>
    }
    %closefile tmpBuf
    %return tmpBuf
%endfunction %% LibEnableFCSS


%% Function: FcnGenerateOpenFCSSDisable ============================================================
%% Abstract:
%%    This function generates the opening guard around calling the disable
%%    function for a function-call subsystem.
%%
%function FcnGenerateOpenFCSSDisable(ssBlock, portEl) void
    %with ssBlock
        %assign numModes = ModeVector[0]
        %assign tmpBuffer = ""
        %if numModes > 1
            %openfile tmpBuffer
            {
                CondStates enableState = SUBSYS_DISABLED;
                %<LibBlockMode(portEl, "", "")> = SUBSYS_DISABLED;
                %foreach mIdx = numModes
                    %assign blockMode = LibBlockMode("", "", mIdx)
                    if (((CondStates) %<blockMode>) != SUBSYS_DISABLED) {
                        enableState = (CondStates) %<blockMode>;
                    }
                %endforeach
                if (enableState == SUBSYS_DISABLED) {
                    %closefile tmpBuffer
        %elseif numModes == 1
            %openfile tmpBuffer
            %<LibBlockMode(portEl, "", "")> = SUBSYS_DISABLED;
            %closefile tmpBuffer
        %endif
    %endwith
    %return tmpBuffer
%endfunction

%% Function: FcnGenerateCloseFCSSDisable ===========================================================
%% Abstract:
%%    This function generates the closing guard around calling the disable
%%    function for a function-call subsystem.
%%
%function FcnGenerateCloseFCSSDisable(ssBlock) void
    %with ssBlock
        %assign numModes = ModeVector[0]
        %assign tmpBuffer = ""
        %if numModes > 1
            %openfile tmpBuffer
        }
    }
    %closefile tmpBuffer
        %endif
    %endwith
    %return tmpBuffer
%endfunction

%% DocFunction{Other Useful Functions}: LibDisableFCSS =========================
%% Abstract:
%%   For use by inlined S-Functions with function call outputs. Returns a
%%   string to either call the disable method for a function-call subsystem
%%   or generate the subsystem's disable code inline.
%%
%%   Note:
%%     An S-function can execute a function-call subsystem only via its
%%     first output port.
%%
%%     See the SFcnSystemOutputCall record in the model.rtw file.
%%
%%     The return string is determined by the current code format.
%%
%%   Example:
%%     %foreach fcnCallIdx = NumSFcnSysOutputCallDsts
%%       %% call the downstream system
%%       %with SFcnSystemOutputCall[fcnCallIdx]
%%         %% skip unconnected function call outputs
%%         %if ISEQUAL(BlockToCall, "unconnected")
%%           %continue
%%         %endif
%%         %assign sysIdx = BlockToCall[0]
%%         %assign blkIdx = BlockToCall[1]
%%         %assign ssBlock = System[sysIdx].Block[blkIdx]
%%         %assign sysToCall = System[ssBlock.ParamSettings.SystemIdx]
%%         %<LibDisableFCSS(sysToCall, tSimStruct, FcnPortElement, ...
%%           ParamSettings.SampleTimesToSet[0][1])>\
%%       %endwith
%%     %endforeach
%%
%%     BlockToCall and FcnPortElement are elements of the SFcnSystemOutputCall
%%     record.
%%
%%     System is a record within the global ::CompiledModel record.
%%
%function LibDisableFCSS(system, simObject, portEl, tidVal) void
    %assign       sysIdx = system.SystemIdx
    %if !EXISTS(BlockToCall)
        %if EXISTS(SFcnSystemOutputCall)
            %assign BlockToCall = SFcnSystemOutputCall[0].BlockToCall
        %else
            %<SLibReportErrorWithIdAndArgs("RTW:tlc:IncorrectLibFcnCall", "LibDisableFCSS")>
        %endif
    %endif
    %if ISFIELD(System[sysIdx],"IsBranchedSys")
        %<SLibReportObsoleteFcnCallAPI("LibDisableFCSS","LibBlockExecuteFcnDisable",system)>
    %endif
    %assign      ssBlock = System[BlockToCall[0]].Block[BlockToCall[1]]
    %assign        csIdx = ssBlock.CallSiteIdx
    %assign           cs = system.CallSites[csIdx]
    %assign accessSysIdx = System[cs[0]].HStructDeclSystemIdx
    %assign      fciCont = SLibIsFcnCallerContinuous(tidVal)
    %openfile tmpBuf
    %<SLibCallFCSS(sysIdx, csIdx, accessSysIdx, portEl, tidVal, fciCont, "Disable")>
    %closefile tmpBuf
    %return tmpBuf
%endfunction %% LibDisableFCSS

%% Function: SLibIsFcnCallerContinuous =============================================================
%% Abstract:
%%    This function determines if calling s-function block has a continous
%%    sample time.
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc/tVariantSource3.m
%%
%function SLibIsFcnCallerContinuous (tid)
    %%
    %assign tidVal = %<tid>
    %if TYPE(tidVal) == "Number" && tidVal >= 0
        %assign fciST = ::CompiledModel.SampleTime[tidVal].PeriodAndOffset[0]
        %assign fciOF = ::CompiledModel.SampleTime[tidVal].PeriodAndOffset[1]
        %return (fciST == 0.0 && fciOF == 0.0)
    %else
        %return TLC_FALSE
    %endif
%endfunction

%% Function: SLibCallFCSS ==========================================================================
%% Abstract:
%%     This function is called by LibCallFCSS and LibExecuteFcnCall
%%     and friends
%%     It either returns the generated code for inlined
%%     or a function call to a non-inlined fuction call subsystem.
%%
%%     See LibCallFCSS and LibExecuteFcnCall for further documentation.
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc/tVariantSource3.m
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tmg1396738_inlined_VC1.m
%%
%function SLibCallFCSS(sysIdx, csIdx, accessSysIdx, portEl, tidVal, fciCont, ...
    callType) void
    %assign intType = LibGetDataTypeNameFromId(::CompiledModel.tSS_INTEGER)
    %assign      fcnCallSys = ::CompiledModel.System[sysIdx]
    %assign accelGuardStart = ""
    %assign   accelGuardEnd = ""

    %assign fcnCallSys.CurrentTID = FcnGetSubsystemCodeBufTID(fcnCallSys)

    %if fciCont && fcnCallSys.RunFcnCallSSInMinorStep == "yes"
        %assign fciCont = 0
        %%
        %% For Simulink accelerator, do not execute function-call subsystem
        %% code when a function-call initiator is continuous (e.g., an async ISR
        %% pseudo source) and we are in the Simulink consistency check stage.
        %%
        %if Accelerator || IsModelReferenceSimTarget ()
            %assign accelGuardStart = "if (!%<RTMSolverAssertCheck()>) {"
            %assign accelGuardEnd   = "}"
        %endif
    %endif

    %assign inlinedFCSS = LibSystemIsInlined(fcnCallSys)

    %% Return nothing if empty
    %if LibSystemFcnIsEmptyForTID(fcnCallSys,callType)
        %assign fcnCallSys.CurrentTID = -1
        %return ""
    %endif
    %%
    %% 1. S-Function always have SimStruct.
    %% 2. RealTime only has SimStruct if it is forced to be a function call
    %%    (because it has a non-inlined s-function calling it)
    %% 3. Embedded-C never needs SimStruct.
    %%
    %assign argList = []
    %assign numArgs = 0
    %if Accelerator && LibAsynchronousTriggeredTID(tidVal)
        %% Accelerator does not maintain timing information for
        %% asynchronous tasks, asynchronous task should use
        %% base rate timing information. See g313672
        %assign tidVal = 0
    %endif
    %assign fcnInfo = LibGetFcnInfo(fcnCallSys, callType, fcnCallSys.CurrentTID)
    %if (inlinedFCSS)
        %%
        %if FcnSysNeedAddRTMArg(fcnCallSys, callType)
            %assign simObject = SLibGetSimStruct()
            %if RTMGetModelSS() != simObject
                %assign argList = argList + ...
                    "%<::tSimStructType> *const %<RTMGetModelSS()> = %<simObject>"
                %assign numArgs = numArgs + 1
            %endif
        %endif
        %if LibSystemFcnNeedsCPI(fcnCallSys,callType)
            %assign argList = argList + "%<intType> %<::tControlPortIdx> = %<portEl>"
            %assign numArgs = numArgs + 1
        %endif
        %if LibSystemFcnNeedsTID(fcnCallSys,callType)
            %assign argList = argList + "%<intType> %<::tTID> = %<tidVal>"
            %assign numArgs = numArgs + 1
        %endif
    %else
        %assign cgirName = fcnInfo.CGIRName

        %% Non-inlined FCSS
        %assign calleeModIdx = fcnCallSys.CGIRModuleIdx
        %assign calleeModule = ::CompiledModel.RTWCGModules.RTWCGModule[calleeModIdx]

        %assign hasTIDArg = 0
        %assign hasCPIArg = 0
        %assign hasRTMArg = 0

        %if ISFIELD(calleeModule, "SystemFunctions") && ...
            ISFIELD(calleeModule.SystemFunctions, cgirName)
            %assign fcnIdx = GETFIELD(calleeModule.SystemFunctions, cgirName)
            %assign calleeFcn = calleeModule.Function[fcnIdx]
            %assign hasTIDArg = calleeFcn.TIDArgIndex > -1
            %assign hasCPIArg = calleeFcn.CPIArgIndex > -1
            %assign hasRTMArg = calleeFcn.SimStructArgIndex > -1
        %endif

        %if !hasRTMArg && FcnSysNeedAddRTMArg(fcnCallSys, callType)
            %assign simObject = SLibGetSimStruct()
            %assign argList = argList + "%<simObject>"
            %assign numArgs = numArgs + 1
        %endif
        %if !hasCPIArg && LibSystemFcnNeedsCPI(fcnCallSys, callType)
            %assign argList = argList + "%<portEl>"
            %assign numArgs = numArgs + 1
        %endif
        %if !hasTIDArg && LibSystemFcnNeedsTID(fcnCallSys, callType)
            %assign argList = argList + "%<tidVal>"
            %assign numArgs = numArgs + 1
        %endif
    %endif
    %%
    %assign cgirName = fcnInfo.CGIRName
    %assign fcnCallSysFcn = fcnInfo.Name
    %% Dump the args array to a string
    %assign args = ""
    %%
    %% We first try call a function call subsystem within the given context
    %% (call outputs from outputs).
    %%
    %assign argVec = []
    %assign modIdx = ::CurrentModuleIdx
    %assign fcnIdx = ::CurrentFunctionIdx
    %if SLibTLCSystemFcnCallExists(callType, sysIdx, csIdx, modIdx, fcnIdx)
        %assign callInfo = ...
            SLibTLCSystemFcnCallInfo(callType, sysIdx, csIdx, modIdx, fcnIdx)
        %assign argVec = callInfo.Args
        %assign cgirName = callInfo.Name
    %else
        %%
        %% If the context is unknown, we dispach the function call
        %% to use global argument references.
        %%
        %assign modIdx = ::CompiledModel.RTWCGModules.NumRTWCGModules-1
        %assign fcnIdx = ::CompiledModel.RTWCGModules.TestInterfaceFcnIdx

        %if SLibTLCSystemFcnCallExists(callType, sysIdx, csIdx, modIdx, fcnIdx)
            %assign callInfo = ...
                SLibTLCSystemFcnCallInfo(callType, sysIdx, csIdx, modIdx, fcnIdx)
            %assign argVec = callInfo.Args
            %assign cgirName = callInfo.Name
        %endif
    %endif
    %openfile callBuffer
    %if inlinedFCSS
        %assign needBrace = (numArgs > 0)
        %if (needBrace > 0)
            {
        %endif
        %if (numArgs > 0)
            %foreach argIdx = numArgs
                %<argList[argIdx]>;
            %endforeach
        %endif
        %assign fcnCache = "SLibGetBody%<callType>FcnCache"
        %assign fcnCacheBuf = %<fcnCache>(fcnCallSys)
        %if fciCont
            if (%<RTMIs("MajorTimeStep")>) {
                %<fcnCacheBuf>
            }
        %else
            %<accelGuardStart>
            %<fcnCacheBuf>
            %<accelGuardEnd>
        %endif
        %if (needBrace > 0)
        }
        %endif
    %else
        %assign comma = ""
        %if (numArgs > 0)
            %foreach argIdx = numArgs
                %assign args = args + comma + argList[argIdx]
                %assign comma = ", "
            %endforeach
        %endif
        %assign addArgs = FcnGetAdditionalArgs(cgirName, argVec, callType, ...
            sysIdx, accessSysIdx, csIdx, TLC_FALSE, TLC_FALSE)
        %if !WHITE_SPACE(addArgs)
            %assign args = args + comma + addArgs
        %endif

        %if fciCont
            if (%<RTMIs("MajorTimeStep")>) {
                %if !EXISTS(callInfo.OpeningTraceComment)
                    %<fcnCallSysFcn>(%<args>);
                %else
                    %% add traceability comment to the function call site
                    %<callInfo.OpeningTraceComment>%<fcnCallSysFcn>%<callInfo.ClosingTraceComment>(%<args>);
                %endif
            }
        %else
            %<accelGuardStart>
            %if !EXISTS(callInfo.OpeningTraceComment)
                %<fcnCallSysFcn>(%<args>);
            %else
                %% add traceability comment to the function call site
                %<callInfo.OpeningTraceComment>%<fcnCallSysFcn>%<callInfo.ClosingTraceComment>(%<args>);
            %endif
            %<accelGuardEnd>
        %endif
    %endif %% inlinedFCSS
    %closefile callBuffer
    %assign fcnCallSys.CurrentTID = -1
    %if !WHITE_SPACE(callBuffer)
        %return callBuffer
    %else
        %return ""
    %endif
%endfunction %% SLibCallFCSS

%<LibAddToCompiledModel("LibTID01Eq_Seen", 0)>
%% Function: LibTID01Eq ============================================================================
%% Abstract:
%%      Return 1 if TID 0 and 1 are equivalent tasks, otherwise return 0.
%%
%%      Note:  This function is left for backward compatibility only.  Use
%%             ::CompiledModel.FixedStepOpts.TID01EQ instead of this
%%             function.  This function may produce incorrect results due
%%             to round-off errors.
%%
%function LibTID01Eq() void
    %if !LibTID01Eq_Seen
        %assign ::CompiledModel.LibTID01Eq_Seen = 1
        %<SLibReportWarningWithId("RTW:tlc:DetectLibTID01Eq")>
    %endif
    %if NumSynchronousSampleTimes > 1
        %assign periodTID0 = SampleTime[0].PeriodAndOffset[0]
        %assign periodTID1 = SampleTime[1].PeriodAndOffset[0]
        %assign stepSize = FixedStepOpts.FixedStep
        %if periodTID0 == 0.0 && (stepSize == periodTID1)
            %return 1
        %endif
    %endif
    %return 0
%endfunction

%with ::CompiledModel
    %assign RootSystemTasks = []
    %foreach tidIdx = NumRuntimeExportedRates
        %assign RootSystemTasks = RootSystemTasks + tidIdx
    %endforeach
    %assign ::CompiledModel = ::CompiledModel + RootSystemTasks
%endwith

%% Function: LibSystemTasks ========================================================================
%% Abstract:
%%   LibSystemTasks returns a vector containing the subsystem's TIDs.
%%
%%   Note, for convenience, the model tasks are group in a vector named
%%   RootSystemTasks and attached to ::CompiledModel
%%
%function LibSystemTasks(system) void
    %if system.Type == "root"
        %return ::CompiledModel.RootSystemTasks
    %endif
    %assign sysIdx  = system.CallSites[0][2]
    %assign blkIdx  = system.CallSites[0][3]
    %assign ssBlock = ::CompiledModel.System[sysIdx].Block[blkIdx]
    %if TYPE(ssBlock.SubsystemTID) == "Vector"
        %return ssBlock.SubsystemTID
    %else
        %return [%<ssBlock.SubsystemTID>]
    %endif
%endfunction

%% Function: LibTasksEqual =========================================================================
%% Abstract:
%%   Determine if all specified tasks are equal (i.e. have the same TID)
%%
%%   Arguments:
%%      taskVector: Vector of TIDs
%%
%%
%function LibTasksEqual(taskVector) void
    %assign task = taskVector[0]
    %foreach idx = SIZE(taskVector, 1) - 1
        %if !ISEQUAL(taskVector[idx+1], task)
            %return 0
        %endif
    %endforeach
    %return 1
%endfunction

%% Function: LibIsRateTransitionBlock ==============================================================
%% Abstract:
%%      LibIsRateTransitionBlock returns one if a block is being used as a rate
%%      transition and zero otherwise. The build-in unit delay and zoh
%%      block can be rate transition blocks. S-function blocks can also
%%      be rate transition blocks if they specify the SS_OPTION to do so.
%%
%function LibIsRateTransitionBlock(system, block)
    %if !LibIsSingleRateSystem(system) && SIZE(TID,1) == 1 && ...
        EXISTS(SampleTimeIdx)
        %if (TID != SampleTimeIdx)
            %return 1
        %endif
    %endif
    %return 0
%endfunction


%% Function: FcnERTIsSampleHitInMain ===============================================================
%% Abstract
%%   Called by FcnGenerateTidGuardOpenCodeInMain for ERT code format.
%%
%% NOTE: This function is similar to FcnERTIsSampleHit function except for the
%% MajorTimeStep check (since this code will be in main.c)
%function FcnERTIsSampleHitInMain(tid) void
    %assert SLibIsERTCodeFormat() && !IsModelReferenceTarget()
    %if LibAsynchronousTriggeredTID(tid) && GenRTModel
        %% Generated code allways rate group async task
        %% code. LibIsSampleHit(asyncTid) is not neccessary
        %% for async code. It always returns true
        %return "1"
    %endif
    %if !SLibSingleTasking()
        %% Multitasking
        %if Tid01Eq && ISEQUAL(tid,1) && !avoidTid01HitCheckOptimization
            %if SLibIsPeriodicRateGrouping()
                %return "1"
            %else
                %return "%<LibTID()> == 0"
            %endif
        %else
            %return "%<LibTID()> == %<tid>"
        %endif
    %elseif ISEQUAL(tid,0)
        %% Singletasking and tid==0; base rate always runs
        %return "1"
    %elseif NumContStates > 0
        %% Singletasking, need task counter
        %if RTMTaskCountersIsReqFcn()
            %assign taskCountStr = RTMGet("TaskCounters") + "." + ...
                SLibERTMultiRateCounterField(tid) + " == 0"
            %return "%<taskCountStr>"
        %else
            %return "1"
        %endif
    %elseif Tid01Eq && ISEQUAL(tid,1) && !avoidTid01HitCheckOptimization
        %return "1"
    %else
        %% Otherwise
        %if RTMTaskCountersIsReqFcn()
            %return RTMGet("TaskCounters") + "." + ...
                SLibERTMultiRateCounterField(tid) + ...
                " == 0"
        %else
            %return "1"
        %endif
    %endif
%endfunction


%% Function: FcnERTsSampleHit ======================================================================
%% Abstract
%%   Called by LibIsSampleHit for ERT code format.  Not to be call directly.
%% TopTester: test/toolbox/simulink/blocks/lib_Discrete/DiscreteTimeIntegrator/rtw/tdintegrt.m
%% TopTester: test/toolbox/simulink/variants/var-vss-general/tMdlrefToVSS.m
%% TopTester: test/toolbox/simulink/blocks/CPPCodeGen/tsmlk_core_cpp_coverage.m
%% TopTester: test/toolbox/simulink/variants/var-general/tTypesToPrivate.m
%%
%function FcnERTIsSampleHit(tid) void
    %assign modIdx = ::CurrentModuleIdx
    %if modIdx > -1
        %assign thisModule = ::CompiledModel.RTWCGModules.RTWCGModule[modIdx]
        %assign thisSystem = ::CompiledModel.System[thisModule.CGSystemIdx]
        %if LibIsSingleRateSystem(thisSystem)
            %return "1"
        %endif
    %endif

    %% Export Function does not need local tid as each entry point is explicitly
    %% scheduled. g1735899
    %if !SLibSingleTasking() && !SLibIsExportFcnDiagram() && ...
        (ISEQUAL(SolverType, "FixedStep") || SLibIsExplicitPartitioningTID(tid))
        %% Multitasking
        %if Tid01Eq && ISEQUAL(tid,1) && !avoidTid01HitCheckOptimization
            %if NumContStates > 0 || IsModelReferenceTarget()
                %if SLibIsPeriodicRateGrouping()
                    %return "%<RTMIs("MajorTimeStep")>"
                %else
                    %return "%<RTMIs("MajorTimeStep")> && \n" + "%<LibTID()> == 0"
                %endif
            %else
                %if SLibIsPeriodicRateGrouping()
                    %return "1"
                %else
                    %return "%<LibTID()> == 0"
                %endif
            %endif
        %else
            %return "%<LibTID()> == %<tid>"
        %endif
    %elseif ISEQUAL(tid,0)
        %% Singletasking and tid==0; base rate always runs
        %return "1"
    %elseif IsModelReferenceTarget()
        %assert ::CompiledModel.NumRuntimeExportedRates > 1
        %assert TYPE(tid) == "Number" && tid > 0
        %assign ans = ""
        %if Tid01Eq && ISEQUAL(tid,1) && !avoidTid01HitCheckOptimization
            %assert LibIsContinuous(0)
            %assign ans = "%<RTMIs("MajorTimeStep")>"
        %else
            %if LibIsContinuous(0)
                %assign ans = "%<RTMIs("MajorTimeStep")> && "
            %endif
            %assign ans = "%<ans>%<RTMIsSampleHit(tid)>"
        %endif
        %return ans
    %elseif NumContStates > 0
        %% Singletasking, need MajorStepGuard + task counter
        %if RTMTaskCountersIsReqFcn()
            %assign taskCountStr = RTMGet("TaskCounters") + "." + ...
                SLibERTMultiRateCounterField(tid) + " == 0"
            %return "%<RTMIs("MajorTimeStep")> &&\n" + "%<taskCountStr>"
        %else
            %return "%<RTMIs("MajorTimeStep")>"
        %endif
    %elseif Tid01Eq && ISEQUAL(tid,1) && !avoidTid01HitCheckOptimization
        %return "1"
    %else
        %% Otherwise
        %if RTMTaskCountersIsReqFcn()
            %return RTMGet("TaskCounters") + "." + ...
                SLibERTMultiRateCounterField(tid) + ...
                " == 0"
        %else
            %return "1"
        %endif
    %endif
%endfunction

%% Function: LibIsSampleHit ========================================================================
%% Abstract:
%%   LibIsSampleHit returns the appropriate TID scope given that the tid is
%%
%%   Discrete:   ssIsSampleHit(S, %<tid>, tid)
%%   Continuous: ssIsContinuousTask(S, tid)
%%
%%   This function cannot be called with a TID that is neither
%%   discrete nor continuous.
%%
%%   S-function blocks should not use this function directly. They should
%%   instead use LibIsSFcnSampleHit().
%%
%%   Arguments:
%%      tid: Global integer task identifier (TID) of block
%%       or
%%      tid: String indicating that you are accessing discrete tasks
%%           using an indexing array.  This form is useful when looping
%%           over the sample times.  String indexing for ERT code format
%%           is supplied for backwards compatibility, however, results
%%           in inefficient code.
%%
%%   Returns:
%%      Non-ERT code formats:
%%
%%      One of the following sample hit macros:
%%
%%      rtmIsSampleHit(S, %<tid>, tid)  for a discrete TID
%%      rtmIsContinuousTask(S, tid)     for a continuous TID
%%
%%      ERT code format:
%%
%%      Appropriate tid check (e.g., tid == 0)
%%
%% TopTester: test/toolbox/simulink/blocks/CPPCodeGen/tsmlk_core_cpp_coverage.m
%% TopTester: test/toolbox/simulink/variants/var-general/tTypesToPrivate.m
%% TopTester: test/toolbox/simulink/variants/var-vss-general/tMdlrefToVSS.m
%% TopTester: test/toolbox/simulink/blocks/lib_Discrete/DiscreteTimeIntegrator/rtw/tdintegrt.m
%% TopTester: test/toolbox/simulink/blocks/tconcat.m
%%
%function LibIsSampleHit(tid) void
    %% See Also:
    %%      LibIsSFcnSampleHit
    %%
    %if LibAsynchronousTriggeredTID(tid) && GenRTModel
        %% Generated code allways rate group async task
        %% code. LibIsSampleHit(asyncTid) is not neccessary
        %% for async code. It always returns true
        %return "1"
    %endif
    %if TYPE(tid) == "String"
        %if LibTriggeredTID(tid) || tid == "constant"
            %<SLibReportErrorWithIdAndArgs("RTW:tlc:InvalidTID", tid)>
        %endif
        %if SLibIsERTCodeFormat()
            %return FcnERTIsSampleHit(tid)
        %else
            %return RTMIsSampleHit(tid)
        %endif
    %else
        %if TYPE(tid) == "Number" && tid < 0
            %<SLibReportErrorWithIdAndArgs("RTW:tlc:InvalidTID", tid)>
        %endif
        %if SLibIsERTCodeFormat()
            %return FcnERTIsSampleHit(tid)
        %endif
        %assign period = ::CompiledModel.SampleTime[tid].PeriodAndOffset[0]
        %assign offset = ::CompiledModel.SampleTime[tid].PeriodAndOffset[1]
        %if period == 0.0 && offset == 0.0
            %return RTMIsContinuousTask()
        %else
            %return RTMIsSampleHit(tid)
        %endif
    %endif
%endfunction %% LibIsSampleHit


%% Function: LibIsSpecialSampleHit =================================================================
%% Abstract:
%%   LibIsSpecialSampleHit returns the appropriate special sample hit macro.
%%
%%   S-function blocks should not use this function directly. They should
%%   instead use LibIsSFcnSpecialSampleHit().
%%   (See the Simulink Coder documentation for more
%%   information about multi-tasking models.)
%%
%%   Arguments:
%%      sti: Sample time index of block (only relevant for Zero-Order Hold and
%%           Unit Delay blocks). The sample time index is the index of the
%%           slower sample time.
%%      tid: task identifier (TID) of block.  The TID is the index of the task
%%           with the faster sample time.
%%
%%   Returns:
%%      Non-ERT: rtmIsSpecialSampleHit(rtM,a,b,tid)
%%      ERT    : Appropriate rate interaction flag
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/simulink/variants/var-export-fcns/tExportFcnsWithInlineVariants.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tvss_code_variants.m
%%
%function LibIsSpecialSampleHit(sti, tid) void
    %% See Also:
    %%      LibIsSFcnSpecialSampleHit
    %%
    %if SLibIsERTCodeFormat()
        %if SLibSingleTasking()
            %assign ::CompiledModel.RequireMultiRateSampleHits = 1
            %return LibIsSampleHit(%<sti>)
        %else
            %<SLibSetNeedRateInteraction(sti,tid)>
            %if IsModelReferenceTarget()
                %assign returnVal =  RTMIsSpecialSampleHit(%<sti>, %<tid>)
            %elseif SuppressMultiTaskScheduler  || ...
                (UseTargetTaskScheduler() && !SLibSingleTasking())
                %assign returnVal = ...
                    "%<RTMGet("PerTaskSampleHits") + "." + ...
                    SLibERTMultiRateTimingField(sti,tid)> == 1"
                %% Base system update need maintain SpecialSampleHit flags
                %assign baseSystem =  System[GetBaseSystemIdx()]
                %<SLibAccessThisSysFcnArgHelper(baseSystem.Interface.RTMArgDef,"Update","",tid, TLC_TRUE)>
            %else
                %assign returnVal = ...
                    "%<RTMGet("PerTaskSampleHits") + "." + ...
                    SLibERTMultiRateTimingField(sti,tid)>"
            %endif
            %if (NumContStates > 0) && ISEQUAL(%<tid>, 0)
                %assign returnVal = "%<RTMIs("MajorTimeStep")>" + " && " + returnVal
            %endif
            %return returnVal
        %endif
    %else
        %return RTMIsSpecialSampleHit(%<sti>, %<tid>)
    %endif
%endfunction

%<LibAddToCompiledModel("BlockInstanceDataCache", 0)>
%% Function: LibGenerateBlockInstanceData ==========================================================
%% Abstract:
%%   LibCacheBlockInstanceData generates the data allocation code for
%%   each block in a Simulink system.  This function updates
%%   the global variable, ::CompiledModel.BlockInstanceDataCache.
%% TopTester: test/toolbox/simulink/variants/var-vss-sigobj/tVSSSigObj.m
%%
%function LibCacheBlockInstanceData() void
    %assign rootSystem = System[NumSystems-1]
    %openfile buffer
    %with rootSystem
        %foreach blkIdx = NumBlocks
            %openfile tmpBuffer
            %<GENERATE(Block[blkIdx], "BlockInstanceData", rootSystem)>\
            %closefile tmpBuffer
            %if WHITE_SPACE(tmpBuffer) == 0
                {
                    %<tmpBuffer>\
                }
            %endif
        %endforeach
    %endwith
    %closefile buffer
    %assign ::CompiledModel.BlockInstanceDataCache = buffer
%endfunction

%% Function: LibBlockInstanceDataIsEmpty ===========================================================
%% Abstract:
%%   LibBlockInstanceDataIsEmpty determines if there is any block instance
%%   data for this model.  It returns one if the cache is only white space
%%   and zero otherwise.
%%
%%   Returns:
%%      1 if ::CompiledModel.BlockInstanceDataCache is only white space
%%      0 otherwise
%%
%function LibBlockInstanceDataIsEmpty() void
    %<LibTrapCacheAssert(BlockInstanceDataCache)>
    %return WHITE_SPACE(BlockInstanceDataCache)
%endfunction

%% Function: LibDumpBlockInstanceData ==============================================================
%% Abstract:
%%   LibDumpBlockInstanceData outputs the current block instance data
%%   cache to the output buffer.  The data cache that is output is
%%   stored in ::CompiledModel.BlockInstanceDataCache.
%% TopTester: test/toolbox/simulink/variants/var-vss-sigobj/tVSSSigObj.m
%%
%function LibDumpBlockInstanceData() Output
    %<LibTrapCacheAssert(BlockInstanceDataCache)>
    %if !WHITE_SPACE(BlockInstanceDataCache)

        /* block instance data */
        %<BlockInstanceDataCache>
    %endif
    %<SLibResetTLCGlobal("BlockInstanceDataCache")>\
%endfunction


%%------------------------------%
%% End of function library code %
%%------------------------------%

%% Function: SLibSetSkipInitializationFlag =========================================================
%% Abstract:
%%   Low level function used by discrete integrator and unit-delay block to
%%   avoid re-initializing memory to zero.  This function is called in
%%   BlockInstanceSetup.  When the parameter is scalar, initialization
%%   requirements are determined up front (once).  If there is no initial
%%   value parameter, call this function with [] for the param.
%% TopTester: test/toolbox/simulink/blocks/CPPCodeGen/tsmlk_core_cpp_coverage.m
%%
%function SLibSetSkipInitializationFlag(system,block,param) void
    %if ISEMPTY(param)
        %<SETFIELD(block, "SkipInitialization", ...
            !SLibXBInitRequired(system,block,[],"","",0))>
    %else
        %if system.StatesCanReset == "no" && !FcnParamInitRequired(param, -1)
            %<SETFIELD(block,"SkipInitialization",1)>
        %else
            %<SETFIELD(block,"SkipInitialization",0)>
        %endif
    %endif
%endfunction


%% Function: SLibXBInitRequired ====================================================================
%% Abstract:
%%   Whenever possible, avoid re-initializing the states and block outputs to
%%   zero since they are initialized to zero in the model's registration
%%   function.  Initialization is necessary in the following cases:
%%
%%   1) The code will roll (to avoid an empty for-loop).
%%   2) The code is located inside the system's initialize function (the
%%      states must re-initialize whenever the system enables).
%%   3) Initial condition (IC) value is not zero or not empty
%%
%%   This check will not be necessary when state and block outputs
%%   initialization is changed from run-time to static initialization.
%%
%% Note:
%%      Always returns true if the parameter is complex or the code format
%%      is other than Embedded-C.
%%
%%
%%   Arguments:
%%      system: Reference to a Simulink system
%%      block:  Reference to a block
%%      param:  Parameter (If there is no initial value parameter, call
%%              this function with [] for the param)
%%      ucv:    User control variable string
%%      lcv:    Loop control variable string
%%      idx:    Index into parameter vector
%%
%%   Returns:
%%      1 if initialization of states and block outputs is required
%%      0 otherwise
%%
%% TopTester: test/toolbox/simulink/blocks/CPPCodeGen/tsmlk_core_cpp_coverage.m
%%
%function SLibXBInitRequired(system, block, param, ucv, lcv, idx) void

    %if system.StatesCanReset == "yes"
        %return 1
    %else
        %return !ISEMPTY(param) && SLibParamInitRequired(param,ucv,lcv,idx)
    %endif

%endfunction


%% Function: SLibParamInitRequired =================================================================
%% Abstract:
%%   Whenever possible, avoid re-initializing parameters to zero since they
%%   are initialized to zero in the model's registration function.
%%   Parameter initialization (on it's own without enable and reset
%%   considerations) is necessary in the following cases:
%%
%%   1) The code will roll (to avoid an empty for-loop).
%%   2) Initial condition (IC) value is not zero.
%%
%% Note:
%%   Always returns true if the parameter is complex or the code format
%%   is other than Embedded-C.
%%
%%   Arguments:
%%      param:  Parameter
%%      ucv:    User control variable string
%%      lcv:    Loop control variable string
%%      idx:    Index into parameter vector
%%
%%   Returns:
%%      1 if initialization is required
%%      0 otherwise
%%
%%
%function SLibParamInitRequired(param, ucv, lcv, idx) void

    %% If we are initializing any of the elements in the array (checked by SkipInitialization)
    %% then we need to initialize all of the elements if rolling.
    %% Otherwise, check this element to see if it needs to be initialized.
    %if ((SLibGetWidthOfValueFromParamRec(param) > 1) && (ucv != "" || lcv != ""))
        %return 1
    %else
        %return FcnParamInitRequired(param, idx)
    %endif
%endfunction


%% Function: FcnParamInitRequired ==================================================================
%% Abstract:
%%   Helper function; use idx == -1 to check all the elements
%% TopTester: test/toolbox/simulink/blocks/CPPCodeGen/tsmlk_core_cpp_coverage.m
%%
%function FcnParamInitRequired(param, idx) void

    %assign prmValue = SLibGetValueFromParamRec(param, TLC_TRUE)
    %assign nRows = SIZE(prmValue,0)
    %assign nCols = SIZE(prmValue,1)
    %assign width = nRows * nCols

    %if !SLibIsERTTarget()
        %return 1
    %endif

    %assign ASTNode = param.ASTNode

    %switch (ASTNode.Op)
      %case "SL_INLINED"
      %case "SL_CALCULATED"
        %% if the parameter is inlined or calculated, it is a candidate for
        %% the optimization
        %assign complex = SLibGetASTNodeIsComplex(ASTNode)

        %if complex
            %return 1
        %endif

        %assign dtype = SLibGetASTNodeDataTypeId(ASTNode)
        %% Can use param.Value in following line
        %% since param.Value == ModelParameter.Value
        %if TYPE(idx) == "Number" && idx == -1
            %foreach idx2 = width
                %assign icValue = SLibParameterValue(prmValue, dtype, complex, 0, idx2)
                %if !ISEQUAL(icValue,0)
                    %return 1
                %endif
            %endforeach
        %else
            %assign icValue = SLibParameterValue(prmValue, dtype, complex, 0, idx)
            %if !ISEQUAL(icValue,0)
                %return 1
            %endif
        %endif

        %break

      %default
        %% if the parameter is tunable or not inlined, don't optimize away
        %% initialization
        %return 1
        %break
    %endswitch

    %return 0
%endfunction


%% =============================================================================
%% Enable subsystems use the ssIsFirstInitCond macro to determine time zero.
%% In order to optionally generate the boolean in the ERT real-time object,
%% we track the usage of this macro with LibIsFirstInitCond().
%%

%<LibAddToCompiledModel("IsFirstInitCondMacroUsed", 0)>
%% Function: SLibGetIsFirstInitCondAccessed ========================================================
%% Abstract:
%%   SLibGetIsFirstInitCondAccessed returns the value of the global flag
%%   ::CompiledModel.IsFirstInitCondMacroUsed.
%%
%function SLibGetIsFirstInitCondAccessed() void
    %return IsFirstInitCondMacroUsed
%endfunction


%% Function: SLibIsFirstInitCond ===================================================================
%% Abstract:
%%   Implements LibIsFirstInitCond. This bypasses the ExportFunctionsMode
%%   check. This bypass is generally not safe except to implement enabling
%%   semantics.  The following 'positive' case is safe if the call is made
%%   during the Initialize (or Start, although superfluous) function since
%%   the initCondFlag is still maintained properly in the model Initialize
%%   (and Start) functions when ExportFunctionsMode==1:
%%     if(%<LibIsFirstInitCond>) { ... }
%%   The following 'negative' case is safe only if guarded by:
%%     %if ProtectCallInitFcnTwice
%%        if(!%<LibIsFirstInitCond) {...}
%%     %endif
%%
%function SLibIsFirstInitCond() void
    %assign ::CompiledModel.IsFirstInitCondMacroUsed = 1
    %return RTMIs("FirstInitCond")
%endfunction

%% DocFunction{Other Useful Functions}: LibIsFirstInitCond =====================
%% Abstract:
%%   LibIsFirstInitCond returns generated code intended for placement in
%%   the initialization function.  This code determines, during run-time,
%%   whether the initialization function is being called for the first time.
%%
%%   This function also sets a flag to determine if the first-initialize-condition
%%   flag is needed.
%%
%%   This function is the TLC version of the SimStruct macro: ssIsFirstInitCond
%%
%function LibIsFirstInitCond() void
    %if ExportFunctionsMode == 1
        %<SLibReportErrorWithId("RTW:tlc:FirstInitInExpFcn")>
    %endif
    %return SLibIsFirstInitCond()
%endfunction




%% Function: SLibCallerHStuctDeclSystem ============================================================
%% Abstract:
%%     return root or callers' HStructDeclSystem (caller's reused parent)
%%
%function SLibCallerHStuctDeclSystem(system, callSiteIdx) void

    %assign parentIdx = system.CallSites[callSiteIdx][0]
    %assign rSysIdx   = ::CompiledModel.System[parentIdx].HStructDeclSystemIdx
    %assign parent    = ::CompiledModel.System[rSysIdx]

    %return parent

%endfunction %% SLibCallerHStuctDeclSystem

%% Function: SLibCallerReusedParentSystem ==========================================================
%% Abstract:
%%     return root or callers' ReusedParentSystemIdx
%%
%function SLibCallerReusedParentSystem(system, callSiteIdx) void

    %assign parentIdx = system.CallSites[callSiteIdx][0]
    %assign rSysIdx   = ::CompiledModel.System[parentIdx].ReusedParentSystemIdx

    %return ::CompiledModel.System[rSysIdx]

%endfunction %% SLibCallerHStuctDeclSystem

%% Function: SLibResetNextVHTDueToEnable ===========================================================
%% Abstract:
%%   This method is called by a block's private enable method to properly
%%   handle variable sample time inside an enabled subsystem.
%%   The subsystem will be calling BdSystemOutput before the sampleHit
%%   vector is updated so we need to set the block's entry to true to
%%   make sure it gets to run its output function in the next opportunity
%%
%function SLibResetNextVHTDueToEnable(block) void
    %assign tid = block.VarTsTID
    %if IsModelReferenceForASimstructBasedTarget()
        %assign idx = %<tid>
    %else
        %assign idx = CAST("Number", ::CompiledModel.SampleTime[tid].PeriodAndOffset[1])
    %endif
    %openfile buffer
    /* Force a sample hit at this major time step */
    %if IsModelReferenceForASimstructBasedTarget()
        %<FcnGenSpecialAccess(FcnInferredSystemAndAccessRTMArgDef(), "SampleHit", "set", 2, ...
            ["%<tid>", "0"], "1", SLibGetSimStruct())>;
    %else
        %<RTMuSetIdxed("SampleHit", tid, 1)>;
    %endif
    %<RTMuSetIdxed("TaskTime", tid, LibGetT())>;
    %<RTMuSetIdxed("VarNextHitTime", "%<idx>", LibGetT())>;
    %closefile buffer
    %return buffer
%endfunction %% SLibResetNextVHTDueToEnable

%% Function: SLibFcnComputeInput ===================================================================
%% Abstract:
%%    This function is used by blocks that conditionally need their inputs,
%%    e.g., switch block. This function generates output code for the
%%    conditionally executed subsystem driving the specified input.
%%
%function SLibFcnComputeInput(block, portIdx) Output
    %assign sysToCall   = SLibBlockSystemToCallForInput(portIdx)
    %assign sysIdx      = sysToCall[0]
    %assign callSiteIdx = sysToCall[1]
    %if sysIdx >= 0
        %assign ss = ::CompiledModel.System[sysIdx]
        %if !LibSystemFcnIsEmpty(ss, "Output")
            %<LibGenSystemFcnCall(ss, "Output", callSiteIdx)>\
        %endif
    %endif
%endfunction %%SLibFcnComputeInput

%% Function: SLibFcnComputeOutput ==================================================================
%% Abstract:
%%    This function is used by blocks that conditionally call their outputs,
%%    This function generates output code for the conditionally executed
%%    subsystem driven by the specified output port.
%%
%function SLibFcnComputeOutput(block, portIdx) Output
    %assign sysToCall   = SLibBlockSystemToCallForOutput(portIdx)
    %assign sysIdx      = sysToCall[0]
    %assign callSiteIdx = sysToCall[1]
    %if sysIdx >= 0
        %assign ss = ::CompiledModel.System[sysIdx]
        %if !LibSystemFcnIsEmpty(ss, "Output")
            %<LibGenSystemFcnCall(ss, "Output", callSiteIdx)>\
        %endif
    %endif
%endfunction %%SLibFcnComputeOutput

%% Function: SLibZeroOutDerivativesForSystemAndModelRef ============================================
%% Abstract:
%%   This function will geenrate the code to zero out the derivatives
%%   in a conditionally executed subsystem. Note it is
%%   the callers responsibility to declare the loop index i and
%%   the double pointer dx.
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tmDemoSubsysFcncall5_VC1.m
%%
%function SLibZeroOutDerivativesForSystemAndModelRef(ssBlock,system) Output
    %assign realType = LibGetDataTypeNameFromId(::CompiledModel.tSS_DOUBLE)

    %%  %assign idx = system.Interface.ContStatesArgDef.FirstLocation
    %with  ssBlock
        %if ssBlock.Type == "ModelReference"
            %assign cStates = ssBlock.ParamSettings.systemContStates
        %else
            %assign cStates = LibBlockParamSetting("Subsystem", "SystemContStates")
        %endif
    %endwith
    %assign ncStates = cStates[0]
    %if (ncStates == 0)
        %return
    %endif
    %assign idx = cStates[1]
    %assign cs = ::CompiledModel.ContStates.ContState[idx]
    %assign blkIdx = cs.SigSrc[2]
    %assign isMdlRef = FcnOwnerBlkType(cs) == "ModelReference"
    %assign varGroupIdx = cs.VarGroupIdx[2]
    %assign cross = system.CrossNoArgFcnBound
    %assign blockPath = SLibCGIRVarGroupPath( ...
        varGroupIdx, system.HStructDeclSystemIdx, cross)

    %% Cstates for model reference block is stored in a structure
    %assign dxId = "%<blockPath>%<cs.Identifier>"

    %if ncStates > 1
        %if isMdlRef
            dx = (%<realType> *) &(%<dxId>);
        %elseif  cs.Width >1
            dx = &(%<dxId>[0]);
        %else
            dx = &(%<dxId>);
        %endif
        %assign dxZeroUpperLimitPlus1 = ncStates
        for (i=0; i < %<dxZeroUpperLimitPlus1>; i++) {
            dx[i] = 0.0;
        }
    %else
        %if  isMdlRef
            %assign scalarTokens = LibGetScalarDataInitTokens()
            {
                %<realType> *dx%<scalarTokens[0]>(%<realType> *) &(%<dxId>)%<scalarTokens[1]>;
                (*dx) = 0.0;
            }
        %else
            %<dxId> = 0.0;
        %endif
    %endif
%endfunction

%% Function: SLibZeroOutZcSignalsForSystemAndModelRef ==============================================
%% Abstract:
%%   This function will generate the code to zero out the zcSignals
%%   in a conditionally executed subsystem.
%% for adzc
%function SLibZeroOutZcSignalsForSystemAndModelRef(ssBlock,system) Output
    %assign intType = LibGetDataTypeNameFromId(::CompiledModel.tSS_INTEGER)
    %assign realType = LibGetDataTypeNameFromId(::CompiledModel.tSS_DOUBLE)
    %with ssBlock
        %if ssBlock.Type == "ModelReference"
            %assign nNSZC = ssBlock.NumNonsampledZCs
        %else
            %assign nNSZC = LibBlockParamSetting("Subsystem", "NumNonsampledZCs")
        %endif
    %endwith
    %if (nNSZC == 0)
        %return
    %endif

    %assert((SolverType == "VariableStep") || SLibGetIsFixedStepZeroCrossingEnabled())
    %% This is not done before and happend to be ok becuase the zcsWith
    %% of modelref zcSignal is always 1. even so, the pointer is not casted.
    %% Need to handle model reference block as what has been done in
    %% SLibZeroOutDerivativesForSystemAndModelRef function
    %% assert(!IsModelReferenceTarget())

    %with ssBlock
        %if ssBlock.Type == "ModelReference"
            %assign idx = ssBlock.ParamSettings.BlkZcRecOffset
            %assign nZCs = ssBlock.ParamSettings.NumZcSignalEls
        %else
            %assign idx  =  LibBlockParamSetting("Subsystem", "BlkZcRecOffset")
            %assign nZCs =  LibBlockParamSetting("Subsystem", "NumZcSignalEls")
        %endif
    %endwith

    %assign blkZcRec = ::CompiledModel.ZcRec.BlkZcRec[idx]
    %assign isMdlRef = FcnOwnerBlkType(blkZcRec) == "ModelReference"
    %assign idxVec = SLibGetSystemAndCallSideIndex(blkZcRec)
    %assign cross  = system.CrossNoArgFcnBound
    %assign sysIdx = idxVec[0]
    %assign  csIdx = idxVec[1]
    %assign varGroupIdx = FcnSysVarGroupIndex(System[sysIdx], ...
        "ZCSV", csIdx)
    %assign blockPath = SLibCGIRVarGroupPath...
        (varGroupIdx, system.HStructDeclSystemIdx, cross)
    %assign zcSignalInfo = blkZcRec.ZcSignalInfo[0]
    %assign name = FcnGetZCSignalCGVarName(zcSignalInfo)
    %assign scalarTokens = LibGetScalarDataInitTokens()
    %if nZCs > 1
        %% handle model reference case
        %if isMdlRef
            %<realType>* zcsv%<scalarTokens[0]>(%<realType>*)&(%<blockPath>%<name>)%<scalarTokens[1]>;
        %elseif zcSignalInfo.Width > 1
            %<realType>* zcsv%<scalarTokens[0]>&(%<blockPath>%<name>[0])%<scalarTokens[1]>;
        %else
            %<realType>* zcsv%<scalarTokens[0]>&(%<blockPath>%<name>)%<scalarTokens[1]>;
        %endif
        %<intType> i;
        %assign dxZeroUpperLimitPlus1 = nZCs
        for (i=0; i < %<dxZeroUpperLimitPlus1>; i++) {
            zcsv[i] = 0.0;
        }
    %else
        %if  isMdlRef
            %<realType> *zcsv%<scalarTokens[0]>(%<realType> *) &(%<blockPath>%<name>)%<scalarTokens[1]>;
            (*zcsv) = 0.0;
        %else
            %<blockPath>%<name> = 0.0;
        %endif
    %endif
%endfunction


%% Function SLibSetStatesDisabledForSubsystemAndModelRef ===========================================
%% Abstract:
%%   This function generates code to set the system states to the value
%%   passed
%% TopTester: test/toolbox/simulink/variants/var-vss-general/tMdlrefToVSS.m
%%
%function SLibSetStatesDisabledForSubsystemAndModelRef(ssBlock,system,value) Output
    %assign booleanType = LibGetDataTypeNameFromId(::CompiledModel.tSS_BOOLEAN)
    %with  ssBlock
        %if ssBlock.Type == "ModelReference"
            %assign cStates = ssBlock.ParamSettings.systemContStates
        %else
            %assign cStates = LibBlockParamSetting("Subsystem", "SystemContStates")
        %endif
    %endwith
    %assign ncStates = cStates[0]
    %if (ncStates == 0)
        %return
    %endif

    %assign idx = cStates[1]
    %assign cs = ::CompiledModel.ContStates.ContState[idx]
    %assign varGroupIdx = cs.VarGroupIdx[1]
    %assign cross = system.CrossNoArgFcnBound
    %assign blockPath = SLibCGIRVarGroupPath( ...
        varGroupIdx, system.HStructDeclSystemIdx, cross)

    %% LibGenMemFcnCall() eventually calls replaceCCastWithStaticCastFcn(),
    %% It parses the input to find the conversion type. For memset(),
    %% prepend (void *) so that, it ends up as conversion type.
    %% g2421028
    %assign conversionType = ""
    %if GenCPP && isRAccel
        %assign conversionType = "(void *)"
    %endif

    %if ncStates > 1
        %if FcnOwnerBlkType(cs) == "ModelReference"
            %assign blk = System[cs.SigSrc[0]].Block[cs.SigSrc[2]]
            %assign intrf = GetModelrefInterface(blk)
            %assign mdlRefCsWith  = CAST("Number", %<intrf.xOptWidth>)
            %assign isArray = mdlRefCsWith > 1
        %else
            %assign isArray = cs.Width > 1
        %endif
        %if isArray >1
            (void) %<LibGenMemFcnCall("memset", ...
                "%<conversionType>&(%<blockPath>%<cs.Identifier>[0])", value, ...
                "%<ncStates>*sizeof(%<booleanType>)")>;
        %else
            (void) %<LibGenMemFcnCall("memset", ...
                "%<conversionType>&(%<blockPath>%<cs.Identifier>)", value, ...
                "%<ncStates>*sizeof(%<booleanType>)")>;
        %endif
    %else
        (void) %<LibGenMemFcnCall("memset", ...
            "%<conversionType>&(%<blockPath>%<cs.Identifier>)", value, ...
            "%<ncStates>*sizeof(%<booleanType>)")>;
    %endif
%endfunction

%% Function: SLibUnusedParameter ===================================================================
%%
%function SLibUnusedParameter(param)
    %if IsModelReferenceTarget()
        %openfile retBuf
        (void) (%<param>);
        %closefile retBuf
    %else
        %openfile retBuf
        %<LibGenUnusedParamFcnCall("RT_UNUSED_PARAMETER", "%<param>")>;
        %closefile retBuf
    %endif
    %return retBuf
%endfunction

%% Function : FcnGenerateSubsystemAsClass =========================================================
%% Should we generate a subsystem class for this compiled system?
%function FcnGenerateSubsystemAsClass(system)

    %if !(LibSystemIsReusedFcn(system))
        %return TLC_FALSE
    %endif

    %assign modIdx = system.CGIRModuleIdx
    %assign module = ::CompiledModel.RTWCGModules.RTWCGModule[modIdx]

    %return ISFIELD(module,"PackageAsClass") && module.PackageAsClass

%endfunction

%% Function : FcnGenerateSubsystemClassStaticMethods=========================================================
%% If the subsystem is being generated as a class, should the
%% individual subsystem methods be generated as static methods?
%function FcnGenerateSubsystemClassStaticMethods(system)
    %% If the subsystem isn't being generated as a class,
    %% return early
    %if (!FcnGenerateSubsystemAsClass(system))
        %return TLC_FALSE
    %endif

    %return CGMODEL_ACCESS("CGModel.getEmitStaticMethodsForSubsystemClass")
%endfunction

%function FcnGetSubsystemClassName(system)
    %assert(FcnGenerateSubsystemAsClass(system))
    %return CGMODEL_ACCESS("CGModel.getSystemClassName", system.SystemIdx)
%endfunction

%% Function: SLibGenSubsysFcnAsClassMemFcn =========================================================
%%  Should a subsystem function be generated as a member function
%%  in the model class?
%function SLibGenSubsysFcnAsClassMemFcn(system)
    %% If the subsystem is generating its own class, subsystem
    %% functions cannot be part of the model class
    %assign subsystemClass = FcnGenerateSubsystemAsClass(system)

    %assign result = GenerateClassInterface && ...
        !IsModelReferenceBaseSys(system) && ...
        (LibSystemIsNonReusedFcn(system) || LibSystemIsReusedFcn(system)) && ...
        !LibSystemIsReusedLibraryFcn(system) && ...
        !subsystemClass

    %return result
%endfunction %% SLibGenSubsysFcnAsClassMemFcn

%% Function: SLibGetAlignmentSyntax ================================================================
%%  Should a non-reusable subsystem function be generated as a member function
%%  in the model class?
%function SLibGetAlignmentSyntax(mdlName, symbol, dataType, align, alignType)
    %assert (align > 0)
    %assign ret = ""
    %assign das = FEVAL("rtwprivate", "da_syntax", mdlName, symbol, dataType, align, alignType)
    %if !ISEMPTY(das.err)
        %openfile errMsg
        %<das.err>
        %closefile errMsg
        %<SLibReportErrorWithIdAndArgs("RTW:tlc:GenericMsg", errMsg)>
    %else
        %assign ret = das.syntax
    %endif
    %return ret

%endfunction

%% Function: SLibDumpPublicServerInterfaces ========================================================
%% Abstract:
%% TopTester: test/toolbox/simulink/variants/var-inline-general/twipervariant.m
%% TopTester: test/toolbox/simulink/variants/var-simulinkfcns/tAutoInherit.m
%% TopTester: test/toolbox/simulink/variants/var-vss-sigobj/tVSSSigObj.m
%%
%function SLibDumpPublicServerInterfaces() void
    %if Accelerator || IsModelReferenceSimTarget() || isRAccel || SLibAutosarActive()
        %return
    %endif
    %with ::CompiledModel
        %if NumSimulinkFunctions == 0
            %return
        %endif

        %% Perform error checking
        %createrecord serverInterface { NumberOfServers 0 }
        %assign numFunctionsInThisModel = 0
        %foreach fcnIdx = NumSimulinkFunctions
            %assign fcn = SimulinkFunction[fcnIdx]
            %if SLibSimulinkFunctionNeedsDeclaration(fcn)
                %assign numFunctionsInThisModel = numFunctionsInThisModel + 1
                %assign proto = SLibDeclareSimulinkFunction(fcn, TLC_TRUE, TLC_TRUE)
                %createrecord fcnRec { ...
                    serverName "" ...
                    model "" ...
                    definedInThisModel TLC_FALSE ...
                    fcnIdx -1 ...
                    serverPrototype "" ...
                    headerFileName ""}
                %if ::GenerateClassInterface && (fcn.FullPathToFunction == "P")
                    %assign className = CGMODEL_ACCESS("CGModel.getClassName")
                    %assign theClassName = className
                    %assign fcnRec.serverName = theClassName + "::" + fcn.CGFunctionName
                %else
                    %assign fcnRec.serverName = fcn.CGFunctionName
                %endif
                %assign fcnRec.model = ::CompiledModel.Name
                %assign fcnRec.fcnIdx = fcnIdx
                %assign fcnRec.definedInThisModel = fcn.IsDefinedInThisModel == "yes"
                %assign fcnRec.serverPrototype = proto
                %assign fcnRec.headerFileName = CGMODEL_ACCESS("FileRepository.getHeaderFileForFunctionName", fcn.CGFunctionName)
                %addtorecord serverInterface FunctionRecord %<fcnRec>
            %endif
        %endforeach

        %% It is possible that all the functions in the model are private,
        %% for example, they are all utility functions for DES or Messages.
        %% In this case, return early to simplify subsequent logic.
        %if numFunctionsInThisModel == 0
            %return
        %endif

        %assert ::CompiledModel.GenUtilsSrcInSharedLocation == 1

        %assign serverInterface.NumberOfServers = numFunctionsInThisModel
        %assign result = FEVAL("rtwprivate", "addServerFunctionsToSCM", "%<LocalSharedCodeManagerFile>", serverInterface)
        %if !ISEMPTY(result.code)
            %if result.code == "ERROR"
                %<LibReportFatalError(result.message)>
            %elseif result.code == "WARNING"
                %<LibReportWarning(result.message)>
            %endif
        %endif

        %% Write out headers
        %% For sure if the header file doesn't exist, generate it.
        %foreach fcnIdx = NumSimulinkFunctions
            %assign fcn = SimulinkFunction[fcnIdx]
            %if SLibSimulinkFunctionNeedsDeclaration(fcn) && !(GenerateClassInterface && fcn.FullPathToFunction != "G")
                %assign fileName = getGlobalSimulinkFunctionHeaderFileName(fcn.CGFunctionName)
                %if FILE_EXISTS(fileName + ".h") == 0 || fcn.IsDefinedInThisModel == "yes"
                    %assign fcn.WriteHeaderFile = "yes"
                %endif
            %endif
        %endforeach

        %% Then also write out ones that need to be updated
        %assign writeHeaderFileFcnIdx = result.writeHeaderFileFcnIdx
        %assign numHdrFiles = SIZE(writeHeaderFileFcnIdx, 1)
        %foreach fcnIdx = numHdrFiles
            %assign fcn = SimulinkFunction[writeHeaderFileFcnIdx[fcnIdx]]
            %assign fcn.WriteHeaderFile = "yes"
        %endforeach

        %% Now write them out
        %foreach fcnIdx = NumSimulinkFunctions
            %assign fcn = SimulinkFunction[fcnIdx]
            %if SLibAutosarActive() && fcn.IsDefinedInThisModel == "no" && ...
                !IsModelReferenceTarget()
                %% Skip generating header file for AUTOSAR targets if:
                %% (a) The function is not defined in this model, that is, the model only
                %% contains the function-caller block.
                %% (b) The model is not a referenced model
                %% The model where the function is defined will be responsible for
                %% generating the header file. If such a model does not exist, then
                %% no header file will get generated.
                %continue
            %endif

            %if SLibSimulinkFunctionNeedsDeclaration(fcn) && !(GenerateClassInterface && fcn.FullPathToFunction != "G")
                %if CGMODEL_ACCESS("FileRepository.getEnableFileControlForSimulinkFcns")
                    %assign fullFileName = CGMODEL_ACCESS("FileRepository.getHeaderFileForFunctionName", fcn.CGFunctionName)
                    %assign baseFileName = CGMODEL_ACCESS("FileRepository.getFilePartsFromFileName", fullFileName, "BaseFileName")
                    %assign fileName = "%<::CompiledModel.RTWInfoMatFile.sharedSourcesDir>%<baseFileName>"
                %else
                    %assign baseFileName = fcn.CGFunctionName
                    %assign fileName = "%<::CompiledModel.RTWInfoMatFile.sharedSourcesDir>%<fcn.CGFunctionName>"
                %endif

                %if fcn.WriteHeaderFile == "yes"
                    %if !ISFIELD(::CompiledModel, "RTWInfoMatFile")
                        %<LoadRTWInfoMatFileforTLC()>
                    %endif
                    %assign proto = SLibDeclareSimulinkFunction(fcn, TLC_FALSE, TLC_FALSE)
                    %openfile includeBuf
                    %if LibUseOldFilePackagingInfrastructure()
                        /* Shared type includes */
                        %<LibEmitPlatformTypeIncludes()>
                    %endif
                    %if SLibNeedSimStructArgForSimulinkFunction(fcn)
                        #include "simstruc.h"
                    %endif
                    %<LibPushEmptyStackSharedUtils()>
                    %assign multiWord = TLC_FALSE

                    %foreach idx = SIZE(fcn.SymbDimsHeaderFiles, 1)
                        %assign header = fcn.SymbDimsHeaderFiles[idx]
                        %if header[0] == "<" || header[0] == "\""
                            %<LibAddtoSharedUtilsIncludes(header)>
                        %else
                            %assign header = "\"" + header + "\""
                            %<LibAddtoSharedUtilsIncludes(header)>
                        %endif
                    %endforeach
                    %foreach idx = SIZE(fcn.ArgTypeIds, 1)
                        %assign dtId = fcn.ArgTypeIds[idx]
                        %assign header = LibHeaderForDataTypeIdx(dtId)
                        %if !ISEMPTY(header)
                            %<LibAddtoSharedUtilsIncludes(header)>
                        %elseif LibIsDataTypeMultiWordFixpt(dtId)
                            %assign multiWord = TLC_TRUE
                        %endif
                    %endforeach
                    %if multiWord
                        #include "%<SLibCoderMultiwordTypesFilename()>"
                    %endif
                    %if LibIsHalfPrecisionUsed()
                        #include "%<SLibCoderHalfTypeHdrFilename()>"
                    %endif
                    %if SLibDeclareImageTypeUsage()
                        #include "%<SLibCoderImageTypeHdrFilename()>"
                    %endif

                    %assign sharedTypesHeaders = LibPopStackSharedUtilsIncludes()
                    %foreach idx = SIZE(sharedTypesHeaders, 1)
                        #include %<sharedTypesHeaders[idx]>
                    %endforeach

                    %% include Compiler.h to define AUTOSAR compiler abstraction macros
                    %if SLibAutosarCompilerAbstractionRequired()
                        #include "Compiler.h"
                    %endif
                    %closefile includeBuf

                    %openfile fcnSignature
                    %assign isGlobalFcn = (fcn.IsExtern == "yes")
                    %if isGlobalFcn
                        %<FcnAddExternCPrefixStart()>
                    %endif
                    %if (fcn.IsVariantSimulinkFunction == "yes")
                        %if !isGlobalFcn
                            %assign variantCondition = fcn.VariantCondition
                            %assign ifCond = SLibIfVariantConditionForm(variantCondition)
                            %assign ifEndCond = SLibEndIfVariantConditionForm(variantCondition)
                        %endif
                        %% Do not guard function declaration if public Simulink Function with declaration in the shared folder.
                        %% TopTester: test/toolbox/simulink/variants/var-simulinkfcns/tmLatchInputFromServer1_VC1.m
                        %if !isGlobalFcn
                            %<ifCond>
                        %endif
                        %if !GenerateClassInterface
                            %if CGMODEL_ACCESS("CGModel.isIndividualFunctionMappingEnabled")
                                %<SLibGetFcnMemSecPragmaForFunction(fcn.CGFunctionName, "SimulinkFunction", fcn.Name,  "Pre")>\
                            %else
                                %<SLibGetFcnMemSecPragmaOnDecl(fcn.CGFunctionName, "MemSecFuncExecute", "Pre")>\
                            %endif
                        %endif
                        %<proto>
                        %if !GenerateClassInterface
                            %if CGMODEL_ACCESS("CGModel.isIndividualFunctionMappingEnabled")
                                %<SLibGetFcnMemSecPragmaForFunction(fcn.CGFunctionName, "SimulinkFunction", fcn.Name,  "Post")>\
                            %else
                                %<SLibGetFcnMemSecPragmaOnDecl(fcn.CGFunctionName, "MemSecFuncExecute", "Post")>\
                            %endif
                        %endif
                        %if !isGlobalFcn
                            %<ifEndCond>
                        %endif
                    %else
                        %if !GenerateClassInterface
                            %if CGMODEL_ACCESS("CGModel.isIndividualFunctionMappingEnabled")
                                %<SLibGetFcnMemSecPragmaForFunction(fcn.CGFunctionName, "SimulinkFunction", fcn.Name,  "Pre")>\
                            %else
                                %<SLibGetFcnMemSecPragmaOnDecl(fcn.CGFunctionName, "MemSecFuncExecute", "Pre")>\
                            %endif
                        %endif
                        %<proto>
                        %if !GenerateClassInterface
                            %if CGMODEL_ACCESS("CGModel.isIndividualFunctionMappingEnabled")
                                %<SLibGetFcnMemSecPragmaForFunction(fcn.CGFunctionName, "SimulinkFunction", fcn.Name,  "Post")>\
                            %else
                                %<SLibGetFcnMemSecPragmaOnDecl(fcn.CGFunctionName, "MemSecFuncExecute", "Post")>\
                            %endif
                        %endif
                    %endif
                    %if isGlobalFcn
                        %<FcnAddExternCPrefixEnd()>
                    %endif

                    %closefile fcnSignature
                    %openfile bannerBuf
                    /*
                    * %<fileName>.h
                    *
                    %<SLibCommonUtilHeaderInfo()>\
                    */
                    %closefile bannerBuf
                    %assign file = LibCreateSourceFileAtPath("Header","Simulink",fileName,baseFileName)
                    %<SLibSetModelFileAttribute(file, "Group", "utility")>
                    %if LibUseOldFilePackagingInfrastructure()
                        %<LibSetSourceFileSection(file, "Includes", includeBuf)>
                    %endif
                    %<LibSetSourceFileSection(file, "Functions", fcnSignature)>
                    %<LibSetSourceFileSection(file, "Banner", bannerBuf)>
                    %<SLibSetModelFileIndent(file, TLC_TRUE)>
                    %<SLibSetModelFileShared(file, TLC_TRUE)>
                %else
                    %<SLibAddGeneratedFileToList(fileName+".h", "utility", "header","")>
                %endif
            %endif
        %endforeach

    %endwith
%endfunction

%function SLibIsModelTypesModelClassNamespace()
    %return CGMODEL_ACCESS("CGModel.IsModelTypesModelClassNamespace")
%endfunction

%function SLibGetModelTypesNamespacePrefix()
    %return CGMODEL_ACCESS("CGModel.GetSystemTypesNamespacePrefix", GetBaseSystemIdx())
%endfunction

%function SLibIsSystemTypesModelClassNamespace(system)
    %% We need to account for inlined subsystems inside RLS. Inlined Subsystems
    %% only have one callsite
    %assign instanceIdx = 0
    %if LibSystemIsInlined(system) && LibSystemIsContainedWithinReusedLibraryFcn(system.SystemIdx,instanceIdx)
        %return TLC_FALSE
    %endif
    %return CGMODEL_ACCESS("CGModel.IsSystemTypesModelClassNamespace", system.SystemIdx)
%endfunction

%function SLibGetSystemTypesNamespacePrefix(system)
    %return CGMODEL_ACCESS("CGModel.GetSystemTypesNamespacePrefix", system.SystemIdx)
%endfunction

%function SLibCacheCPPEncapModelData(field, buffer) void
    %if !ISFIELD(::CompiledModel, "CPPEncapModelData")
        %createrecord dataRec { %<field> buffer }
        %<LibAddToCompiledModel("CPPEncapModelData", dataRec)>
    %elseif !ISFIELD(::CompiledModel.CPPEncapModelData, field)
        %addtorecord ::CompiledModel.CPPEncapModelData %<field> buffer
    %else
        %assign ::CompiledModel.CPPEncapModelData.%<field> = ::CompiledModel.CPPEncapModelData.%<field> + buffer
    %endif
%endfunction

%function SLibGetModuleFileNameOwnerSystemIdx(moduleIdx) void
    %assign module = ::CompiledModel.RTWCGModules.RTWCGModule[moduleIdx]
    %return ::CompiledModel.System[module.CGSystemIdx].FileNameOwnerIdx
%endfunction

%function SLibAddToSystemFieldMRSystemFcnPrototype(system, fileOwnerSystem, ssp) void
    %if !LibIsSystemField(system, "MRSystemFcnPrototype")
        %<LibAddToSystem(fileOwnerSystem, "MRSystemFcnPrototype", ssp)>
    %else
        %<LibAddToSystemField(fileOwnerSystem, "MRSystemFcnPrototype", ssp)>
    %endif
%endfunction

%function SLibPrintMREntryPointFcnDeclToHeaderFile(fileOwnerSystem, system, functionType, fcn, fcnDeclBuffer) void
    %openfile tmpBuffer
    %if SLibGetEnableFileControlForEntryPointFcns()
        %if functionType == "SimulinkFunction"
            %<fcnDeclBuffer>
            %closefile tmpBuffer
            %if system.FileNameOwnerIdx == system.SystemIdx
                %<SLibAddToSystemFieldMRSystemFcnPrototype(system, fileOwnerSystem, tmpBuffer)>
            %endif
            %return
        %endif

        %if fcn.SysFcn == "OutputUpdate" || fcn.SysFcn == "Output" || fcn.SysFcn == "Update"
            %if SLibFCTInfoStoredUsingFcnName(system.CurrentTID)
                %<SLibPrintEntryPointFcnToFileUsingFcnName(fcn.Name, fcnDeclBuffer, "Declaration")>
            %else
                %if fcn.SysFcn == "OutputUpdate" || fcn.SysFcn == "Output"
                    %<SLibPrintEntryPointFcnToFile("OutputFcn", "Header", system.CurrentTID, fcn.Name, fcnDeclBuffer, "Declaration")>\
                %endif

                %if fcn.SysFcn == "Update"
                    %<SLibPrintEntryPointFcnToFile("UpdateFcn", "Header", system.CurrentTID, fcn.Name, fcnDeclBuffer, "Declaration")>\
                %endif
            %endif

        %else
            %<fcnDeclBuffer>
        %endif
    %else
        %<fcnDeclBuffer>
    %endif
    %closefile tmpBuffer

    %<SLibAddToSystemFieldMRSystemFcnPrototype(system, fileOwnerSystem, tmpBuffer)>
%endfunction

%function SLibPrintSubsystemFcnDeclToHeaderFile(fileOwnerSystem, system, fcn, fcnDeclBuffer) void
    %% For entry point functions built in a model reference target, print declaration to the FCT files
    %if IsRemoveHideChildFeatureOn() && ...
        CGMODEL_ACCESS("CGModel.isSysFcnHiddenFromParent", system.SystemIdx) && ...
        CGMODEL_ACCESS("CGModel.dumpSysCodeIntoModelFile", system.SystemIdx)
        %assign headerFile = SLibGetFullFileNameForCode("mdl_priv_constParam_decl")
    %else
        %assign headerFile = SLibGetSystemHeaderFileName(fileOwnerSystem)
    %endif

    %assign sourceFile = ""
    %assign declDeps = []
    %assign defnDeps = []
    %openfile tmpBuffer
    %if SLibGetEnableFileControlForEntryPointFcns() && (IsModelReferenceTarget() && IsModelReferenceBaseSys(system))
        %if SLibFcnBufferContainsRTM(fcnDeclBuffer)
            %<SLibUpdateSymbolForFunction(fcn.CGIRName, SLibGetFcnDeclarationRTMSymbolName(), TLC_TRUE)>
        %endif

        %if fcn.SysFcn == "OutputUpdate" || fcn.SysFcn == "Output"
            %if SLibFCTInfoStoredUsingFcnName(system.CurrentTID)
                %<SLibPrintEntryPointFcnToFileUsingFcnName(fcn.Name, fcnDeclBuffer, "Declaration")>
                %assign headerFile = CGMODEL_ACCESS("FileRepository.getHeaderFileForFunctionName", fcn.Name)
                %assign sourceFile = CGMODEL_ACCESS("FileRepository.getSourceFileForFunctionName", fcn.Name)
            %else
                %<SLibPrintEntryPointFcnToFile("OutputFcn", "Header", system.CurrentTID, fcn.Name, fcnDeclBuffer, "Declaration")>\
                %assign headerFile = GetEntryPointFcnMappedFile("OutputFcn", "Header", system.CurrentTID)
                %assign sourceFile = GetEntryPointFcnMappedFile("OutputFcn", "Source", system.CurrentTID)
            %endif
        %else
            %<fcnDeclBuffer>
        %endif
    %else
        %<fcnDeclBuffer>
    %endif
    %closefile tmpBuffer

    %% For reusable subsystem function, add declaration to "SystemFcnPrototype" of the "fileOwnerSystem"
    %<LibAddToSystemField(fileOwnerSystem, "SystemFcnPrototype", tmpBuffer)>
    %<SLibAddEntryToFunctionTable(fcn.Name, headerFile, sourceFile, declDeps, defnDeps)>
%endfunction

%function getGlobalSimulinkFunctionHeaderFileName(fcnName)
    %assign fileName = ""
    %if CGMODEL_ACCESS("FileRepository.getEnableFileControlForSimulinkFcns")
        %assign fullFileName = CGMODEL_ACCESS("FileRepository.getHeaderFileForFunctionName", fcnName)
        %assign baseFileName = CGMODEL_ACCESS("FileRepository.getFilePartsFromFileName", fullFileName, "BaseFileName")
        %assign fileName = ::CompiledModel.RTWInfoMatFile.sharedSourcesDir + baseFileName
    %else
        %assign fileName = ::CompiledModel.RTWInfoMatFile.sharedSourcesDir + fcnName
    %endif
    %return fileName
%endfunction

%function LibBlockExecuteFcnCallWrapper(systemIdx, blockIdx, callIdx) void
    %assign sfnBlock = ::CompiledModel.System[systemIdx].Block[blockIdx]
    %return LibBlockExecuteFcnCall(sfnBlock, callIdx)
%endfunction

%endif %% _SYSLIB_

%% [EOF] syslib.tlc
