%% ============================================================================
%% File : setuplib.tlc
%%
%% Abstract:
%%   This file includes a number of functions that are called from commonsetup
%%   to setup various TLC globals and ::CompiledModel fields. The functions
%%   help setup:
%%   o Basic global defaults
%%   o Default settings for various code-generation fields on ::CompiledModel
%%   o Memory allocation and data-visibility flags for the different code
%%     formats
%%   o Variables for keeping track of the headers and sources
%%   o Variables for keeping track of Identifiers common to all code formats
%%   o Variables for keeping track of Identifiers that depend on the
%%     specific code format
%%   o Variables for keeping track of function names
%%   o Variables for supporting datatypes
%%   o Variables that pertian to specific code formats
%%   o Variables pertaining to logging
%%   o Variables for supporting Ada math and block code
%%   o Variables for setting up C-APIs to track block IO and run-time params
%%
%%   Additionally, the file also contains a function that validates the
%%   ::CompiledModel by checking if:
%%   o Datatypes have been set up
%%   o Model has no Algebraic Loops
%%
%%
%% Copyright 1994-2023 The MathWorks, Inc.
%%
%% ============================================================================

%include "utillib.tlc"

%if EXISTS(_SETUPLIB_) == 0
%assign _SETUPLIB_ = 1

%function isGRTMallocOnERT() void
    %return SLibIsERTCodeFormat() && UsingMalloc
%endfunction

%% Function: SLibSetupBasicDefaults ================================================================
%% Abstract:
%%   Set up defaults for basic code generation options. These need to be setup
%%   even before we begin loading funclib.tlc.
%%
%function SLibSetupBasicDefaults() void
    %%
    %% Set language
    %%
    %language "C"

    %%
    %% Matrix Dimensions
    %%
    %assign ::matrixDimensionThreshhold = 2

    %%
    %% Invalid Counter
    %%
    %assign ::INVALID_COUNTER = -1

    %%
    %% Invalid Buffer
    %%
    %assign ::INVALID_BUFFER = -1

    %assign ::UseNonFiniteLiterals = TLC_FALSE
    %assign ::NonFinitesGenerated = TLC_FALSE

    %%
    %% Generate C++, compute extern "c" prefix,
    %% and compute prefix for previously externed symbols
    %%
    %assign ::GenCPP = ...
        (ISFIELD(::CompiledModel.ConfigSet, "TargetLang") && ...
        (::CompiledModel.ConfigSet.TargetLang=="C++"))

    %% TODO g2673744: code to be updated when we support C++ standards beyond CP11
    %assign ::GenCPP11 = ::GenCPP && ...
        CGMODEL_ACCESS("CGModel.getCpp11Extensions") > 0 && ...
        CGMODEL_ACCESS("CGModel.getLangStd") == "ISO_C++11"

    %if (::GenCPP11 == TLC_TRUE || CGMODEL_ACCESS("CGModel.getLangStd") == "ISO_C") ...
        && SLibSupportNonfiniteLiterals()
        %assign ::UseNonFiniteLiterals = TLC_TRUE
    %endif

    %if ::GenCPP
        %assign ::ExternCPrefix = "extern \"C\""
    %else
        %assign ::ExternCPrefix = ""
    %endif

    %assign ::LangFileExt = CGMODEL_ACCESS("CGModel.getLangFileExt")

    %assign ::EmulationHWComment = ""

    %% Determine if a memset to zero function is registered in the TFL
    %% This will be used to avoid the lookup in the future if one is not registered
    %assign ::Memset2Zero = FEVAL("rtwprivate","rtw_tfl_query_memset2zero", ::CompiledModel.Name)

    %%
    %% MatFileLogging comes early as possible
    %assign ::MatFileLogging = ::CompiledModel.ConfigSet.MatFileLogging

    %% AnyCross will be set to true if we encounter any
    %% subsystems with the CrossNoArgFcnBound flag set.
    %% We initialize it to false here and set it to true if
    %% we see a "Cross" system while walking the systems
    %% during the SLibGenBodyCache phase. We use it later on
    %% when generating code in one of the "isRequired" functions
    %% (see rtmisreqfcns.tlc for the use of this flag)
    %assign ::AnyCross = TLC_FALSE

    %% ThisSubsysCross will be temporarily set to true by
    %% FcnGenerateSubFcnBody while generating a "cross" subsystem
    %assign ::ThisSubsysCross = TLC_FALSE

    %% This global variable is for the purpose of avoiding
    %% the System.CurrentTID approach used for argument tracking.
    %assign ::GlobalCurrentTID = []

    %% This global variable indicates if we are currently generating
    %% code for a subfunction
    %assign ::GlobalGeneratingSubFunctions = TLC_FALSE

    %% These globals indicate the current module, system and function index
    %assign ::CurrentModuleIdx = -1
    %assign ::CurrentFunctionIdx = -1
    %assign ::CurrentSystemIdx = -1
    %% Indicate the current TLC Block function that is executed, in order call
    %% the correct TLC interface functions
    %assign ::CurrentBlockFcnIdx = -1

    %assign ::CurrentUtilsIncludesIdx = ""

    %% Indicate the file that the current buffer is emitted to.
    %assign ::CurrentBufferFileName = ""

    %% Clean up our comments in generate code to aline with the change from 'Auto' for storage class to 'default'
    %assign ChangeAutoForStorageClassToDefaultInComments = CGMODEL_ACCESS("CodeGenComments.AutoToDefault")
    %assign ::AutoOrDefaultStorageClass = ""
    %if ChangeAutoForStorageClassToDefaultInComments > 0
        %assign ::AutoOrDefaultStorageClass = "default"
    %else
        %assign ::AutoOrDefaultStorageClass = "auto"
    %endif

%endfunction %% SLibSetupBasicDefaults

%% Function: SLibERTFeatureSetup ===================================================================
%% Abstract:
%%   Assert that feature settings are consistent with target settings
%%   (i.e., a feature is not inappropriately enabled).  If inconsistent,
%%   Simulink is out of sync with codegen and the build must be terminated.
%%
%function SLibERTFeatureSetup() void

    %if !EXISTS(::initializeExportedCSCWithSymbolicDimsFeat)
        %assign ::initializeExportedCSCWithSymbolicDimsFeat = CGMODEL_ACCESS("CGModel.getInitializeExportedCSCWithSymbolicDimsFeat")
    %endif

    %assign ::ConfigSet = ::CompiledModel.ConfigSet

    %if !EXISTS(IgnoreCustomStorageClasses)
        %assign ::IgnoreCustomStorageClasses = ConfigSet.IgnoreCustomStorageClasses
    %endif
    %<LibAddToCompiledModel("ConstructErtModelArgs","")>
    %<LibAddToCompiledModel("DestructErtModelArgs","")>
    %<LibAddToCompiledModel("IgnoreCustomStorageClasses",IgnoreCustomStorageClasses)>

    %<LibAddToCompiledModel("GenerateCodeInterfaceReport", TLC_FALSE)>

    %if !EXISTS(IncludeMdlTerminateFcn)
        %assign ::IncludeMdlTerminateFcn = ConfigSet.IncludeMdlTerminateFcn || SLibIsExportFcnDiagram()
    %endif
    %<LibAddToCompiledModel("IncludeMdlTerminateFcn",IncludeMdlTerminateFcn)>

    %if !EXISTS(CombineOutputUpdateFcns)
        %assign ::CombineOutputUpdateFcns = ConfigSet.CombineOutputUpdateFcns
    %endif
    %<LibAddToCompiledModel("CombineOutputUpdateFcns",CombineOutputUpdateFcns)>

    %if !EXISTS(GRTInterface)
        %assign ::GRTInterface = ConfigSet.GRTInterface
    %endif
    %<LibAddToCompiledModel("GRTInterface",GRTInterface)>

    %if !EXISTS(UseMemberFunctionsForRTM)
        %assign ::UseMemberFunctionsForRTM = ShouldUseMemberFunctionsForRTM()
    %endif

    %if !EXISTS(SuppressErrorStatus)
        %assign ::SuppressErrorStatus = ConfigSet.SuppressErrorStatus
    %endif
    %<LibAddToCompiledModel("SuppressErrorStatus",SuppressErrorStatus)>

    %if !EXISTS(ZeroExternalMemoryAtStartup)
        %assign ::ZeroExternalMemoryAtStartup = ConfigSet.ZeroExternalMemoryAtStartup
    %endif
    %<LibAddToCompiledModel("ZeroExternalMemoryAtStartup",ZeroExternalMemoryAtStartup)>

    %if !EXISTS(ZeroInternalMemoryAtStartup)
        %assign ::ZeroInternalMemoryAtStartup = ConfigSet.ZeroInternalMemoryAtStartup
    %endif
    %<LibAddToCompiledModel("ZeroInternalMemoryAtStartup",ZeroInternalMemoryAtStartup)>

    %if !EXISTS(InitFltsAndDblsToZero)
        %assign ::InitFltsAndDblsToZero = ConfigSet.InitFltsAndDblsToZero
    %endif
    %<LibAddToCompiledModel("InitFltsAndDblsToZero",InitFltsAndDblsToZero)>

    %if !EXISTS(ForceBlockIOInitOptimize)
        %assign ::ForceBlockIOInitOptimize = ConfigSet.ForceBlockIOInitOptimize
    %endif
    %<LibAddToCompiledModel("ForceBlockIOInitOptimize",ForceBlockIOInitOptimize)>

    %if !EXISTS(InsertBlockDesc)
        %assign ::InsertBlockDesc = ConfigSet.InsertBlockDesc
    %endif
    %<LibAddToCompiledModel("InsertBlockDesc",InsertBlockDesc)>

    %if !EXISTS(InsertPolySpaceComments)
        %assign ::InsertPolySpaceComments = ConfigSet.InsertPolySpaceComments
    %endif
    %<LibAddToCompiledModel("InsertPolySpaceComments",InsertPolySpaceComments)>

    %if !SLibIsDeploymentDiagramType()
        %if !EXISTS(SFDataObjDesc)
            %assign ::SFDataObjDesc = ConfigSet.SFDataObjDesc
        %endif
        %<LibAddToCompiledModel("SFDataObjDesc",SFDataObjDesc)>
    %endif

    %if !EXISTS(SimulinkDataObjDesc)
        %assign ::SimulinkDataObjDesc = ConfigSet.SimulinkDataObjDesc
    %endif
    %<LibAddToCompiledModel("SimulinkDataObjDesc",SimulinkDataObjDesc)>

    %if !EXISTS(ERTCustomFileBanners)
        %assign ::ERTCustomFileBanners = ConfigSet.ERTCustomFileBanners
    %endif
    %% Model Reference Sim Target does not use the Custom File Banners
    %if IsModelReferenceSimTarget()
        %assign ::ERTCustomFileBanners = TLC_FALSE
    %endif
    %<LibAddToCompiledModel("ERTCustomFileBanners",ERTCustomFileBanners)>

    %if !SLibIsDeploymentDiagramType()
        %if !EXISTS(DefineNamingRule)
            %assign ::DefineNamingRule = ConfigSet.DefineNamingRule
        %endif
        %<LibAddToCompiledModel("DefineNamingRule",DefineNamingRule)>
    %endif

    %if !SLibIsDeploymentDiagramType()
        %if !EXISTS(SignalNamingRule)
            %assign ::SignalNamingRule = ConfigSet.SignalNamingRule
        %endif
        %<LibAddToCompiledModel("SignalNamingRule",SignalNamingRule)>
    %endif

    %if !SLibIsDeploymentDiagramType()
        %if !EXISTS(ParamNamingRule)
            %assign ::ParamNamingRule = ConfigSet.ParamNamingRule
        %endif
        %<LibAddToCompiledModel("ParamNamingRule",ParamNamingRule)>
    %endif

    %if !EXISTS(InlinedPrmAccess)
        %assign ::InlinedPrmAccess = ConfigSet.InlinedPrmAccess
    %endif
    %<LibAddToCompiledModel("InlinedPrmAccess",InlinedPrmAccess)>

    %if !EXISTS(GenerateSampleERTMain)
        %assign ::GenerateSampleERTMain = ConfigSet.GenerateSampleERTMain
    %endif
    %<LibAddToCompiledModel("GenerateSampleERTMain",GenerateSampleERTMain)>

    %if !EXISTS(OverrideSampleERTMain)
        %assign ::OverrideSampleERTMain = TLC_FALSE
    %endif
    %<LibAddToCompiledModel("OverrideSampleERTMain",OverrideSampleERTMain)>

    %if !EXISTS(MultiInstanceERTCode)
        %assign ::MultiInstanceERTCode = ConfigSet.MultiInstanceERTCode
    %endif
    %<LibAddToCompiledModel("MultiInstanceERTCode",MultiInstanceERTCode)>

    %if !EXISTS(PurelyIntegerCode)
        %assign ::PurelyIntegerCode = ConfigSet.PurelyIntegerCode
    %endif
    %<LibAddToCompiledModel("PurelyIntegerCode",PurelyIntegerCode)>

    %if !EXISTS(SupportNonFinite)
        %assign ::SupportNonFinite = ConfigSet.SupportNonFinite
    %endif
    %<LibAddToCompiledModel("SupportNonFinite",SupportNonFinite)>

    %if !EXISTS(SupportComplex)
        %assign ::SupportComplex = ConfigSet.SupportComplex
    %endif
    %<LibAddToCompiledModel("SupportComplex",SupportComplex)>

    %if !EXISTS(SupportContinuousTime)
        %assign ::SupportContinuousTime = ConfigSet.SupportContinuousTime
    %endif
    %<LibAddToCompiledModel("SupportContinuousTime",SupportContinuousTime)>

    %if !EXISTS(SupportNonInlinedSFcns)
        %assign ::SupportNonInlinedSFcns = ConfigSet.SupportNonInlinedSFcns
    %endif
    %<LibAddToCompiledModel("SupportNonInlinedSFcns",SupportNonInlinedSFcns)>

    %if !SLibIsDeploymentDiagramType()
        %if !EXISTS(NoFixptDivByZeroProtection)
            %assign ::NoFixptDivByZeroProtection = ConfigSet.NoFixptDivByZeroProtection
        %endif
        %<LibAddToCompiledModel("NoFixptDivByZeroProtection",NoFixptDivByZeroProtection)>
    %endif

    %if !EXISTS(CustomSymbolStrGlobalVar)
        %assign ::CustomSymbolStrGlobalVar = ConfigSet.CustomSymbolStrGlobalVar
    %endif
    %<LibAddToCompiledModel("CustomSymbolStrGlobalVar",CustomSymbolStrGlobalVar)>

    %if !EXISTS(CustomSymbolStrType)
        %assign ::CustomSymbolStrType = ConfigSet.CustomSymbolStrType
    %endif
    %<LibAddToCompiledModel("CustomSymbolStrType",CustomSymbolStrType)>

    %if !EXISTS(CustomSymbolStrField)
        %assign ::CustomSymbolStrField = ConfigSet.CustomSymbolStrField
    %endif
    %<LibAddToCompiledModel("CustomSymbolStrField",CustomSymbolStrField)>

    %if !EXISTS(CustomSymbolStrFcn)
        %assign ::CustomSymbolStrFcn = ConfigSet.CustomSymbolStrFcn
    %endif
    %<LibAddToCompiledModel("CustomSymbolStrFcn",CustomSymbolStrFcn)>

    %if !EXISTS(CustomSymbolStrBlkIO)
        %assign ::CustomSymbolStrBlkIO = ConfigSet.CustomSymbolStrBlkIO
    %endif
    %<LibAddToCompiledModel("CustomSymbolStrBlkIO",CustomSymbolStrBlkIO)>

    %if !EXISTS(CustomSymbolStrTmpVar)
        %assign ::CustomSymbolStrTmpVar = ConfigSet.CustomSymbolStrTmpVar
    %endif
    %<LibAddToCompiledModel("CustomSymbolStrTmpVar",CustomSymbolStrTmpVar)>

    %if !EXISTS(CustomSymbolStrMacro)
        %assign ::CustomSymbolStrMacro = ConfigSet.CustomSymbolStrMacro
    %endif
    %<LibAddToCompiledModel("CustomSymbolStrMacro",CustomSymbolStrMacro)>

    %if !EXISTS(ReqsInCode)
        %assign ::ReqsInCode = ConfigSet.ReqsInCode
    %endif
    %<LibAddToCompiledModel("ReqsInCode",ReqsInCode)>

    %if !EXISTS(ProdEqTarget)
        %assign ::ProdEqTarget = ConfigSet.ProdEqTarget
    %endif
    %<LibAddToCompiledModel("ProdEqTarget",ProdEqTarget)>

    %if !EXISTS(PortableWordSizes)
        %assign ::PortableWordSizes = ConfigSet.PortableWordSizes
    %endif
    %<LibAddToCompiledModel("PortableWordSizes",PortableWordSizes)>

    %assign HardwareBoardNone = ISEQUAL(::CompiledModel.ConfigSet.HardwareBoard,"None")
    %if !SLibIsERTTarget() && !GRTInterface && !SLibSingleTasking() && HardwareBoardNone
        %% Turn ON InlineSetEventsForThisBaseRateFcn for non-ERT targets with
        %% simplified call interface.
        %% However, do not turn ON InlineSetEventsForThisBaseRateFcn for the
        %% targets that use ert.tlc and have a target-specific scheduler (for
        %% which SLibIsERTTarget=false and HardwareBoardNone=false).
        %assign ::InlineSetEventsForThisBaseRateFcn = TLC_TRUE
    %elseif !EXISTS(InlineSetEventsForThisBaseRateFcn)
        %assign ::InlineSetEventsForThisBaseRateFcn = TLC_FALSE
    %endif
    %<LibAddToCompiledModel("InlineSetEventsForThisBaseRateFcn", InlineSetEventsForThisBaseRateFcn)>

    %if (!SLibIsERTTarget() || SLibAutosarActive()) && !GRTInterface && !SLibSingleTasking() && HardwareBoardNone
        %% Turn ON SuppressMultiTaskScheduler for non-ERT targets with simplified
        %% call interface
        %% However, do not turn ON SuppressMultiTaskScheduler for the targets
        %% that use ert.tlc and have a target-specific scheduler (for which
        %% SLibIsERTTarget=false and HardwareBoardNone=false).
        %assign ::SuppressMultiTaskScheduler = TLC_TRUE
    %else
        %if !EXISTS(SuppressMultiTaskScheduler)
            %assign ::SuppressMultiTaskScheduler = TLC_FALSE
        %else
            %assign ::SuppressMultiTaskScheduler = SuppressMultiTaskScheduler && !SLibSingleTasking()
        %endif
    %endif
    %<LibAddToCompiledModel("SuppressMultiTaskScheduler",SuppressMultiTaskScheduler)>

    %%
    %% ERT: suppress the model_SetEventsForThisBaseRate function
    %%
    %if !EXISTS(SuppressSetEventsForThisBaseRateFcn)
        %assign ::SuppressSetEventsForThisBaseRateFcn = 0
    %endif
    %if IsModelReferenceTarget()
        %assign ::SuppressSetEventsForThisBaseRateFcn = 1
    %endif
    %<LibAddToCompiledModel("SuppressSetEventsForThisBaseRateFcn",...
        SuppressSetEventsForThisBaseRateFcn)>

    %if !EXISTS(GenerateClassInterface)
        %assign ::GenerateClassInterface = CGMODEL_ACCESS("CGModel.generateClassInterface")
    %endif

    %if GenerateClassInterface
        %assert GenCPP
        %assert MultiInstanceERTCode

        %if EXISTS(ExportFunctionsMode) && ExportFunctionsMode != 0
            %<SLibReportErrorWithId("RTW:tlc:NoCppExportFcn")>
        %endif
    %endif

    %if !EXISTS(ERTMainAccess)
        %assign ::ERTMainAccess = TLC_FALSE
    %endif

    %if ::CombineOutputUpdateFcns == 1 && ...
        (::CompiledModel.ConfigSet.MatFileLogging || ...
        EXISTS(ExtMode) && ExtMode == 1)
        %assign ::IncludeLoggingInstrumentation = TLC_TRUE
    %else
        %assign ::IncludeLoggingInstrumentation = TLC_FALSE
    %endif

    %assign usingMalloc = 0
    %% Setup the UsingMalloc
    %if ISFIELD(::CompiledModel,"RTWGenSettings")

        %if ISFIELD(::CompiledModel.RTWGenSettings,"UsingMalloc")
            %if ::CompiledModel.RTWGenSettings.UsingMalloc == "yes"
                %assign usingMalloc = 1
            %endif
        %endif
    %endif
    %if ISFIELD(::CompiledModel.ConfigSet,"GenerateAllocFcn") && ...
        ::CompiledModel.ConfigSet.GenerateAllocFcn == TLC_TRUE
        %assign usingMalloc = 1
        %if !MultiInstanceERTCode
            %<SLibReportErrorWithId("RTW:tlc:AllocFcnMultiInstance")>
        %endif
    %endif
    %assign ::UsingMalloc = usingMalloc
    %<LibAddToCompiledModel("UsingMalloc", UsingMalloc)>


    %if (!ZeroInternalMemoryAtStartup) && UsingMalloc
        %<SLibReportWarningWithId("RTW:tlc:MallocWithUnsetZeroInitializationWarning")>
    %endif

    %if MultiInstanceERTCode
        %if !EXISTS(MultiInstanceErrorCode) && ISFIELD(::CompiledModel.ConfigSet,"MultiInstanceErrorCode")
            %assign ::MultiInstanceErrorCode = ::CompiledModel.ConfigSet.MultiInstanceErrorCode
        %endif
    %endif

    %assign hasStandSystem = TLC_FALSE
    %assign numSystems = ::CompiledModel.NumSystems
    %foreach idx = numSystems
        %assign sys = ::CompiledModel.System[idx]
        %<LibAddToSystem(sys, "NeedCPIInDisable", 0)>
        %<LibAddToSystem(sys, "NeedCPIInEnable", 0)>
        %if sys.StandaloneSubsystem == 1
            %assign hasStandSystem = TLC_TRUE
            %% Set up fields for initialization of constBlockIO and rtP
            %<LibAddToSystem(sys, "StandaloneConstBlockIOInit", "")>
            %<LibAddToSystem(sys, "StandaloneParameterInit", "")>
            %foreach idx = ::CompiledModel.NumCoderDataGroups
                %if SLibDataGroupStaticInit(::CompiledModel.CoderDataGroup[idx])
                    %assign groupName = ::CompiledModel.CoderDataGroup[idx].Name
                    %assign groupToken = "CoderDataGroup" + groupName
                    %<LibAddToSystem(sys, "Standalone" + groupToken + "Init", "")>
                %endif
            %endforeach
            %<LibAddToSystem(sys, "StandaloneDataInit", "")>
            %<LibAddToSystem(sys, "CachedInitializeDataBody", "")>
            %<LibAddToSystem(sys, "TempInitBuffer", "")>
            %<LibAddToSystem(sys, "CachedNonFiniteParamAssignments", "")>
            %<LibAddToSystem(sys, "CachedNonFiniteBlockIOAssignments", "")>
        %elseif sys.FileNameOwnerIdx != numSystems && (sys.RTWSystemCode == 1 || sys.RTWSystemCode == 2)
            %<LibAddToSystem(sys, "TempInitBuffer", "")>
            %<LibAddToSystem(sys, "CachedInitializeDataBody", "")>
        %endif
    %endforeach
    %<LibAddToCompiledModel("HasStandaloneSubsystem",hasStandSystem)>

    %% These flags indicate that there is a variable of
    %% this type somewhere in the model.  Previously we
    %% used the root system to determine this, but with
    %% standalone systems, the root may not have any blockIO
    %% but a standalone subsystem could have some.
    %<LibAddToCompiledModel("HasBlockIOArg", 0)>
    %<LibAddToCompiledModel("HasConstBlockIOArg", 0)>
    %<LibAddToCompiledModel("HasDWorkArg", 0)>
    %<LibAddToCompiledModel("HasParametersArg", 0)>
    %<LibAddToCompiledModel("HasZCEventArg", 0)>
    %foreach idx = ::CompiledModel.NumCoderDataGroups
        %assign groupToken = "HasCoderDataGroup" + ::CompiledModel.CoderDataGroup[idx].Name + "Arg"
        %<LibAddToCompiledModel(groupToken, 0)>
    %endforeach

    %% Initialize service port map
    %<SLibInitServicePortInfoMap()>

    %if !EXISTS(CalledTflTlcCallbacks)
        %assign ::CalledTflTlcCallbacks = ""
    %else
        %assign ::CalledTflTlcCallbacks = CalledTflTlcCallbacks
    %endif

    %if (!SLibIsERTTarget())

        %%
        %% Ignore custom storage = true
        %%
        %if (IgnoreCustomStorageClasses == 0)
            %assign ::ShowErrorStackTrace = TLC_TRUE
            %<SLibReportErrorWithId("RTW:tlc:CSCNeedERT")>
        %endif

        %%
        %% Generate terminate function = true
        %%
        %if (IncludeMdlTerminateFcn == 0) && !SLibIsExportFcnDiagram()
            %assign errMsg = "To suppress generating model terminate function, you need to use an ERT or ERT-based target."
            %<LibReportFatalError(errMsg)>
        %endif

        %%
        %% Suppress error status = false
        %%
        %if (SuppressErrorStatus == 1)
            %assign errMsg = "To suppress error status codes, you need to use an ERT or ERT-based target."
            %<LibReportFatalError(errMsg)>
        %endif

        %%
        %% Suppress scheduler
        %%
        %if (SuppressMultiTaskScheduler == 1) && (GRTInterface == 1)
            %assign errMsg = "To suppress scheduler with classic call interface, "...
                "you need to use an ERT or ERT-based target."
            %<LibReportFatalError(errMsg)>
        %endif

        %%
        %% zero external memory at startup = true
        %%
        %if (ZeroExternalMemoryAtStartup == 0) && !::GenerateClassInterface
            %assign errMsg = "To remove root i/o zero initialization, you need to use an "...
                "ERT or ERT-based target."
            %<LibReportFatalError(errMsg)>
        %endif

        %%
        %% zero internal memory at startup = true
        %%
        %if (ZeroInternalMemoryAtStartup == 0) && !::GenerateClassInterface
            %assign errMsg = "To remove internal state zero initialization, you need to "...
                "use an ERT or ERT-based target."
            %<LibReportFatalError(errMsg)>
        %endif

        %%
        %% insert block description = false
        %%
        %if (InsertBlockDesc == 1)
            %assign errMsg = "To include block description in the generated code, you "...
                "need to use an ERT or ERT-based target."
            %<LibReportFatalError(errMsg)>
        %endif

        %%
        %% insert stateflow data description = false
        %%
        %if EXISTS(SFDataObjDesc) && (SFDataObjDesc == 1)
            %assign errMsg = "To include description for stateflow data object in the "...
                "generated code, you need to use an ERT or ERT-based target."
            %<LibReportFatalError(errMsg)>
        %endif

        %%
        %% insert Simulink data description = false
        %%
        %if (SimulinkDataObjDesc == 1)
            %assign errMsg = "To include description for Simulink data object in the "...
                "generated code, you need to use an ERT or ERT-based target."
            %<LibReportFatalError(errMsg)>
        %endif

        %%
        %% ert custom file banners = false
        %%
        %if (ERTCustomFileBanners == 1)
            %assign errMsg = "To generate customize file banners, you need to use an ERT "...
                "or ERT-based target."
            %<LibReportFatalError(errMsg)>
        %endif

        %%
        %% define naming rule = "None"
        %%
        %if EXISTS(DefineNamingRule) && (DefineNamingRule != "None")
            %assign errMsg = "To apply naming rule to #define declaration, you need to "...
                "use an ERT or ERT-based target."
            %<LibReportFatalError(errMsg)>
        %endif

        %%
        %% signal naming rule = "None"
        %%
        %if EXISTS(SignalNamingRule) && (SignalNamingRule != "None")
            %assign errMsg = "To apply naming rule to signal declaration, you need to use "...
                "an ERT or ERT-based target."
            %<LibReportFatalError(errMsg)>
        %endif

        %%
        %% parameter naming rule = "None"
        %%
        %if EXISTS(ParamNamingRule) && (ParamNamingRule != "None")
            %assign errMsg = "To apply naming rule to parameter declaration, you need to "...
                "use an ERT or ERT-based target."
            %<LibReportFatalError(errMsg)>
        %endif

        %%
        %% inlined parameter access = "Literals"
        %%
        %if (InlinedPrmAccess != "Literals")
            %assign errMsg = "To access inlined parameters through macros, you need to "...
                "use an ERT or ERT-based target."
            %<LibReportFatalError(errMsg)>
        %endif

        %%
        %% generate sample main = false
        %%
        %if EXISTS(GenerateSampleERTMain) && (GenerateSampleERTMain == 1)
            %assign errMsg = "To generate sample ert main, you need to use an ERT or "...
                "ERT-based target."
            %<LibReportFatalError(errMsg)>
        %endif

        %%
        %% PurelyIntegerCode = false
        %%
        %if (PurelyIntegerCode == 1)
            %assign errMsg = "To generate purely integer code, you need to use an ERT "...
                "or ERT-based target."
            %<LibReportFatalError(errMsg)>
        %endif

        %%
        %% SupportComplex = true
        %%
        %if (SupportComplex == 0)
            %assign errMsg = "To suppress complex math support, you need to use an "...
                "ERT or ERT-based target."
            %<LibReportFatalError(errMsg)>
        %endif

        %%
        %% SupportContinuousTime = true
        %%
        %if (SupportContinuousTime == 0)
            %assign errMsg = "To suppress continuous time support, you need to use an ERT or ERT-based target."
            %<LibReportFatalError(errMsg)>
        %endif

        %%
        %% SupportNonInlinedSFcns = true
        %%
        %if (SupportNonInlinedSFcns == 0)
            %assign errMsg = "To suppress non-inlined s-function support, you need to use an ERT or ERT-based target."
            %<LibReportFatalError(errMsg)>
        %endif

        %%
        %% NoFixptDivByZeroProtection = false
        %%
        %if EXISTS(NoFixptDivByZeroProtection) && (NoFixptDivByZeroProtection == 1)
            %assign errMsg = "To remove code that protects division against "...
                "arithmetic exceptions, you need to use an ERT or ERT-based target."
            %<LibReportFatalError(errMsg)>
        %endif

        %%
        %% CustomSymbolStr = $R$N$M
        %%
        %if (CustomSymbolStrGlobalVar != "$R$N$M" || ...
            CustomSymbolStrType != "$N$R$M_T" || ...
            (CustomSymbolStrField != "$N$M" && CustomSymbolStrField != "$H$N$M")|| ...
            (CustomSymbolStrBlkIO != "rtb_$N$M" && CustomSymbolStrBlkIO != "rtb_$H$N$M") || ...
            CustomSymbolStrTmpVar != "$N$M" || ...
            (CustomSymbolStrFcn != "$R$N$M$F" && CustomSymbolStrFcn != "$R$H$N$M$F")|| ...
            CustomSymbolStrMacro != "$R$N$M")
            %assign errMsg = "To customize the symbol mangling rule, "...
                "you need to use an ERT or ERT-based target."
            %<LibReportFatalError(errMsg)>
        %endif
    %endif

    %assign targetCannotHaveTIDArg = GenerateClassInterface || SLibFcnProtoCtrlActive()

    %if EXISTS(ERTRemoveTidArgForSingleTaskingModel)
        %if !ERTRemoveTidArgForSingleTaskingModel && targetCannotHaveTIDArg
            %assign errMsg = "Function Prototype Control or C++ class interface: "...
                "-a option ERTRemoveTidArgForSingleTaskingModel = 0 is not supported."...
                "Consider removing this option "
            %<LibReportFatalError(errMsg)>
        %endif
    %else
        %assign ::ERTRemoveTidArgForSingleTaskingModel = TLC_TRUE
    %endif

%endfunction %% SLibERTFeatureCheck

%% Function: FcnAssertScopedDSMAttributes ==========================================================
%% Abstract:
%%   We don't support legacy storage classes for data store references
%%
%function FcnAssertScopedDSMAttributes() void
    %foreach dwIdx = ::CompiledModel.DWorks.NumDWorks
        %assign dw = ::CompiledModel.DWorks.DWork[dwIdx]
        %if dw.IsDataStoreReference && ...
            !SLibOmitRecord(dw) && ...
            (!ISFIELD(dw, "VarGroupIdx") || dw.VarGroupIdx[0] < 0)
            %<LibReportFatalError("Scoped DSM does not support legacy storage classes")>
        %endif
    %endforeach
%endfunction

%% Function: SLibSetupCoderDataGroups ==============================================================
%% Abstract:
%%   Set up coder data groups
%%
%function SLibSetupCoderDataGroups() void
    %<FcnAssertScopedDSMAttributes()>
    %createrecord ScopedDSMInMultiInstanceDWork {}
    %<LibAddToCompiledModel("ScopedDSMInMultiInstanceDWork", ScopedDSMInMultiInstanceDWork)>
    %createrecord ScopedDSMInSingleInstance {}
    %<LibAddToCompiledModel("ScopedDSMInSingleInstance", ScopedDSMInSingleInstance)>
    %createrecord CoderDataGroups {}
    %<LibAddToCompiledModel("CoderDataGroups", CoderDataGroups)>
    %createrecord CoderGroupInitLoop {}
    %<LibAddToCompiledModel("CoderGroupInitLoop", CoderGroupInitLoop)>
    %createrecord ChildGroupMap {}
    %<LibAddToCompiledModel("ChildGroupMap", ChildGroupMap)>
    %createrecord ChildGroupInitInForEachMap {}
    %<LibAddToCompiledModel("ChildGroupInitInForEachMap", ChildGroupInitInForEachMap)>
    %<LibAddToCompiledModel("ChildCoderDataGroupAssignmentForRegistration", "")>
    %<LibAddToCompiledModel("AssignmentForResolvedScopedDSM", "")>
    %<LibAddToCompiledModel("ChildCoderDataGroupAssignmentForParamTs", "")>
    %<LibAddToCompiledModel("ChildCoderDataGroupMemcpy", "")>
    %<LibAddToCompiledModel("ChildCoderDataGroupDynamicInitializer", "")>
    %assign ancestorAllocatesCoderDataGroups = TLC_FALSE
    %if IsModelReferenceTarget()
        %% For ModelReferenceTarget, ancestorAllocatesCoderDataGroups is already computed in C++
        %assign ancestorAllocatesCoderDataGroups = ...
            CGMODEL_ACCESS("CGModel.ancestorAllocatesCoderDataGroupsModelRefTarget")
    %else
        %foreach idx = ::CompiledModel.NumCoderDataGroups
            %if !SLibAllocatesCoderDataGroup(::CompiledModel.CoderDataGroup[idx])
                %assign ancestorAllocatesCoderDataGroups = TLC_TRUE
                %break
            %endif
        %endforeach
    %endif
    %<LibAddToCompiledModel("AncestorAllocatesCoderDataGroups", ...
        ancestorAllocatesCoderDataGroups)>
    %<LibAddToCompiledModel("AncestorHasDataStoreReferenceInDWork", TLC_FALSE)>
%endfunction %% SLibSetupCoderDataGroups


%% Function: SLibSetupPrintStatusMsgs ==============================================================
%% Abstract:
%%   Utility function for printing a status message to STDOUT.
%%
%function SLibSetupPrintStatusMsgs(statusID) void
    %if !RTWVerbose
        %return
    %endif

    %selectfile STDOUT
    %switch statusID
      %case "libload"
%%}}
### Loading TLC function libraries
%%{{
        %break
      %default
        %break
    %endswitch
    %selectfile NULL_FILE
%endfunction %% SLibSetupPrintStatusMsgs


%% Function: SLibSetupLayoutOptions ================================================================
%% Abstract:
%%   Setup fields that are responsible for determining the layout of the
%%   generated code.
%%
%function SLibSetupLayoutOptions() void

    %assert (!IsModelReferenceTarget() || GenerateSampleERTMain == 0)

    %% Pass arguments into entry point functions
    %assert (!IsModelReferenceTarget() || MultiInstanceERTCode == 0 || GenerateClassInterface || ...
        (MultiInstanceERTCode == 1 && UsingMalloc))

    %% Pass arguments into entry point functions
    %if !EXISTS(MultiInstanceErrorCode)
        %assign ::MultiInstanceErrorCode = "None"
    %endif
    %<LibAddToCompiledModel("MultiInstanceErrorCode",MultiInstanceErrorCode)>

    %% Pass top level I/O using structures
    %if !EXISTS(RootIOStructures)
        %if GenerateClassInterface
            %assign ::RootIOStructures = 1
        %else
            %assign ::RootIOStructures = 0
        %endif
    %endif
    %<LibAddToCompiledModel("RootIOStructures",RootIOStructures)>

    %if SLibIsERTTarget() && ISFIELD(::CompiledModel.ConfigSet, "RootIOFormat")
        %% RootIOFormat does not exist, for e.g. for MDS
        %<LibAddToCompiledModel("RootIOFormat", ::CompiledModel.ConfigSet.RootIOFormat)>
    %else
        %% For non-ERT targets, assume "Individual arguments" by default
        %<LibAddToCompiledModel("RootIOFormat", "Individual arguments")>
    %endif

    %if !EXISTS(GenerateEnableDisable)
        %assign ::GenerateEnableDisable = 0
    %endif
    %<LibAddToCompiledModel("GenerateEnableDisable", GenerateEnableDisable)>

    %if !EXISTS(ExportFunctionsMode)
        %assign ::ExportFunctionsMode = 0
    %endif

    %%
    %% Output comments for parameters in model.prm file
    %%
    %if !EXISTS(ForceParamTrailComments)
        %assign ::ForceParamTrailComments = 0
    %endif
    %<LibAddToCompiledModel("ForceParamTrailComments", ForceParamTrailComments)>

    %%
    %% Boolean to display eliminted C-code with /* */
    %%
    %if !EXISTS(ShowEliminatedStatements)
        %assign ::ShowEliminatedStatements = 1
    %endif
    %<LibAddToCompiledModel("ShowEliminatedStatements", ShowEliminatedStatements)>

    %%
    %% Declare externs for all globals and function-calls.
    %%
    %if !EXISTS(HaveSeparateSourceFiles)
        %assign ::HaveSeparateSourceFiles = 0
    %endif
    %<LibAddToCompiledModel("HaveSeparateSourceFiles", HaveSeparateSourceFiles)>

    %%
    %% Boolean to switch on/off the protection against calling initialize function
    %% twice at startup.
    %%
    %if !EXISTS(ProtectCallInitFcnTwice)
        %assign ::ProtectCallInitFcnTwice = 0
    %endif
    %<LibAddToCompiledModel("ProtectCallInitFcnTwice", ProtectCallInitFcnTwice)>`

    %%
    %% TLC interface API
    %%
    %if !EXISTS(GenerateInterfaceAPI)
        %assign ::GenerateInterfaceAPI = 0
    %endif
    %<LibAddToCompiledModel("GenerateInterfaceAPI", GenerateInterfaceAPI)>

    %%
    %% ASAP2 file (assumes GenerateInterfaceAPI already defined)
    %%
    %if !EXISTS(GenerateASAP2)
        %assign ::GenerateASAP2 = 0
    %endif
    %<LibAddToCompiledModel("GenerateASAP2", GenerateASAP2)>
    %if GenerateASAP2 == 1
        %assign ::CompiledModel.GenerateInterfaceAPI = 1
    %endif

    %%
    %% MDX file
    %%
    %if !EXISTS(GenerateMDX)
        %assign ::GenerateMDX = 0
    %endif
    %<LibAddToCompiledModel("GenerateMDX", GenerateMDX)>

    %%
    %% Setup InlineParameters to be false if not setup already
    %%
    %if !EXISTS(InlineParameters)
        %assign ::InlineParameters = 0
    %endif
    %<LibAddToCompiledModel("InlineParameters", InlineParameters)>

    %%
    %% Inline outputs of blocks with Constant TID in C-code
    %%
    %if !EXISTS(InlineInvariantSignals)
        %if InlineParameters == 1
            %assign ::InlineInvariantSignals = 1
        %else
            %assign ::InlineInvariantSignals = 0
        %endif
    %endif
    %<LibAddToCompiledModel("InlineInvariantSignals", InlineInvariantSignals)>

    %%
    %% MaxStackSize
    %%
    %if !EXISTS(MaxStackSize)
        %assign ::MaxStackSize = rtInf
    %else
        %if EXISTS(DivideStackByRate) && DivideStackByRate == TLC_TRUE
            %assign ::MaxStackSize = MaxStackSize / ::CompiledModel.NumRuntimeExportedRates
        %endif
    %endif
    %<LibAddToCompiledModel("MaxStackSize", MaxStackSize)>

    %%
    %% MaxStackVariableSize
    %%
    %if !EXISTS(MaxStackVariableSize)
        %assign ::MaxStackVariableSize = rtInf
    %endif
    %<LibAddToCompiledModel("MaxStackVariableSize", MaxStackVariableSize)>

    %%
    %% Boolean to generate assertion free code, default is no asserts
    %%
    %if !EXISTS(DoAsserts)
        %assign ::DoAsserts = 0
    %endif
    %<LibAddToCompiledModel("DoAsserts", DoAsserts)>

    %%
    %% Set RateBasedStepFcn if not set yet
    %% this flag is used by targets that support
    %% RateBasedStep Fcn.
    %%
    %if !EXISTS(RateBasedStepFcn)
        %assign ::RateBasedStepFcn = 0
    %endif
    %<LibAddToCompiledModel("RateBasedStepFcn", RateBasedStepFcn)>

    %% Determine step function prototypes
    %assign rootSystem = ::CompiledModel.System[CompiledModel.NumSystems-1]
    %<LibAddToCompiledModel("RootSystemIsSingleRate", LibIsSingleRateSystem(rootSystem))>

%endfunction %% SLibSetupLayoutOptions


%% Function: SLibSetupRollingInfo ==================================================================
%% Abstract:
%%   Setup variables needed for rolling
%%   - Using the Code Generation page on the Simulation Parameters dialog, you can specify
%%     the RollThreshold
%%   - Other variables set up here are for tracking code generation during the
%%     execution of %roll constructs in TLC
%%
%function SLibSetupRollingInfo() void
    %%
    %% Automatic roll threshold
    %%
    %if !EXISTS(RollThreshold)
        %assign ::RollThreshold = 5
    %endif
    %<LibAddToCompiledModel("RollThreshold", RollThreshold)>

    %%
    %% Tracking field:
    %% For counter for roll loop control variable
    %%
    %if !ISFIELD(::CompiledModel, "LoopControlIdx")
        %<LibAddToCompiledModel("LoopControlIdx", 0)>
    %endif

    %%
    %% Tracking field:
    %% This is the current numeric loop offset,
    %% if we are inside a %roll and lcv != ""
    %%
    %if !ISFIELD(::CompiledModel, "CurrentLoopOffset")
        %<LibAddToCompiledModel("CurrentLoopOffset", 0)>
    %endif

    %%
    %% This is the current symobloc loop offset,
    %% if we are inside a %roll and lcv != ""
    %%
    %if !ISFIELD(::CompiledModel, "CurrentSymbolicLoopOffset")
        %<LibAddToCompiledModel("CurrentSymbolicLoopOffset", "")>
    %endif

    %%
    %% Tracking field:
    %% Current loop offset when inside a %roll
    %%
    %if !ISFIELD(::CompiledModel, "CurrentRollRegionOffset")
        %<LibAddToCompiledModel("CurrentRollRegionOffset", -1)>
    %endif

    %%
    %% Override Roll Variable Declaration 'const %<dt>' => '%<dt>'
    %%
    %if !ISFIELD(::CompiledModel, "RollInputIsWritable")
        %<LibAddToCompiledModel("RollInputIsWritable", 0)>
    %endif

%endfunction %% SLibSetupRollingInfo


%% Function: SLibSetupLoggingInfo ==================================================================
%% Abstract:
%%   Setup all globals related to logging data and states
%%
%function SLibSetupLoggingInfo() void
    %%
    %% Use standard ".mat" file logging
    %%
    %if MatFileLogging == 1 && IsModelReferenceTarget()
        %<SLibReportErrorWithId("RTW:tlc:NoMdlRefMatFileLogging")>
    %endif

    %<LibAddToCompiledModel("MatFileLogging", MatFileLogging)>
    %assert EXISTS(MultiInstanceERTCode) && EXISTS(MultiInstanceErrorCode)
    %if ( MatFileLogging && MultiInstanceERTCode && (GenerateClassInterface || !UsingMalloc) )
        %if MultiInstanceErrorCode == "Warning"
            %<SLibReportWarningWithId("RTW:tlc:MatFileLoggingNotForGenReusableCodeWarning")>
        %elseif MultiInstanceErrorCode == "Error"
            %<SLibReportErrorWithId("RTW:tlc:MatFileLoggingNotForGenReusableCodeError")>
        %endif
    %endif

    %%
    %% Append this prefix to all the variable names when saving to the
    %% .mat file
    %%
    %if !EXISTS(LogVarNameModifier)
        %assign ::LogVarNameModifier = "rt_"
    %endif
    %<LibAddToCompiledModel("LogVarNameModifier", LogVarNameModifier)>
    %if !EXISTS(BlockIOSignals)
        %assign ::BlockIOSignals = 0
    %endif
    %if !EXISTS(ParameterTuning)
        %assign ::ParameterTuning = 0
    %endif

    %if EXISTS(::ErrorXMLMode)
        %assign ::CompiledModel.ErrorXMLMode = ::ErrorXMLMode
    %endif

    %% Determine the maximum length of character strings in the generated code
    %if IsModelReferenceSimTarget()
        %assign ::RTWMaxStringLength = 2000 %% MSVC limit
    %else
        %if !EXISTS(RTWMaxStringLength)
            %% The limit set here is ANSI recommended. The limit can be overwritten
            %% by specifying a Configset TLC option -aRTWMaxStringLength = N
            %assign ::RTWMaxStringLength = 509
        %endif
    %endif

%endfunction %% SLibSetupLoggingInfo

%% Function: FcnSetupHdrsAndSources ================================================================
%% Abstract:
%%   Setup variables to store all sources & headers needed for model
%%
%function FcnSetupHdrsAndSources() void
    %% For model reference we do not generate model.c file
    %if !IsModelReferenceTarget()
        %<CGMODEL_ACCESS("CGModel.AddToModelSources", LibGetMdlSrcBaseName())>
    %endif
    %<LibAddToCompiledModel("ReusableLibSources", [])>
    %<LibAddToCompiledModel("NumReusableLibSources", 0)>
    %<LibAddToCompiledModel("Headers", [])>
    %<LibAddToCompiledModel("NumHeaders", 0)>

    %% These are not directly used by any of the TLC Library functions
    %% and are only maintained for backward compatibility with customer
    %% code.
    %<LibAddToCompiledModel("SysPathHeaders", [])>
    %<LibAddToCompiledModel("NumSysPathHeaders", 0)>
    %<LibAddToCompiledModel("SysLocalHeaders", [])>
    %<LibAddToCompiledModel("NumSysLocalHeaders", 0)>
    %<LibAddToCompiledModel("BlockPathHeaders", [])>
    %<LibAddToCompiledModel("NumBlockPathHeaders", 0)>
    %<LibAddToCompiledModel("BlockLocalHeaders", [])>
    %<LibAddToCompiledModel("NumBlockLocalHeaders", 0)>
    %<LibAddToCompiledModel("NonSharedPathHeaders", [])>
    %<LibAddToCompiledModel("NumNonSharedPathHeaders", 0)>
    %<LibAddToCompiledModel("NonSharedLocalHeaders", [])>
    %<LibAddToCompiledModel("NumNonSharedLocalHeaders", 0)>

%endfunction %% FcnSetupHdrsAndSources


%% Function: SLibSetupCodeGenTrackingFields ========================================================
%% Abstract:
%%   Setup fields that track the current state of code generation. These are
%%   fields that are setup for internal use by the TLC code-base.
%%
%function SLibSetupCodeGenTrackingFields() void
    %%
    %% Unmangle function names via RTWData
    %%
    %assign tmpVar = FunctionNamesRepository { dummy 1 }
    %<LibAddToCompiledModel("FunctionNamesRepository", FunctionNamesRepository)>

    %%
    %% Cache whether IntegerSizes exists (created when %including
    %% funclib.tlc, which %includes fixptlib.tlc, which can create
    %% IntegerSizes
    %%
    %<LibAddToCompiledModel("IntegerSizesExists", EXISTS(IntegerSizes))>
    %% These maximums, based on the target integer size, are used in
    %% determining the type of loop counters which may exceed the size
    %% of signed int on the target.
    %if ::CompiledModel.IntegerSizesExists
        %switch IntegerSizes.IntNumBits
          %case 8
          %case 16
          %case 32
            %assign ::TargetMaxInt = INT%<IntegerSizes.IntNumBits>MAX
            %assign ::TargetMaxUInt = UINT%<IntegerSizes.IntNumBits>MAX
            %break
          %default
            %assign ::TargetMaxInt = (1 << (IntegerSizes.IntNumBits-1)) - 1
            %assign ::TargetMaxUInt = (TargetMaxInt << 1) + 1
        %endswitch
    %else
        %assign ::TargetMaxInt = 0
        %assign ::TargetMaxUInt = 0
    %endif

    %%
    %% Setup GeneratingDeadCode (in MdlStart) to be false
    %%
    %<LibAddToCompiledModel("GeneratingDeadCode", 0)>

    %%
    %% Default value for child S-Functions
    %%
    %<LibAddToCompiledModel("NumChildSFunctions", 0)>
    %<LibAddToCompiledModel("ChildSFunctionList", [])>

    %%
    %% Setup fields for tracking the header and source files.
    %%
    %<FcnSetupHdrsAndSources()>

    %%
    %% Setup field to track if we need TID or not
    %%
    %<LibAddToCompiledModel("NeedTID", 0)>

    %%
    %% Setup field to track if we need TID in custom code
    %%
    %<LibAddToCompiledModel("CustomCodeNeedTID", TLC_FALSE)>

    %%
    %% Setup field to track if the model reference initilize function is empty
    %%
    %<LibAddToCompiledModel("EmptyModelRefInitializeFcn", 0)>

    %%
    %% Setup field to track if the model functions are empty
    %%
    %createrecord EmptyFunctionsInfo {EmptyInitFcn TLC_FALSE;...
        EmptyOutputUpdateFcn TLC_FALSE}
    %addtorecord ::CompiledModel EmptyFunctionsInfo EmptyFunctionsInfo

%endfunction %% SLibSetupCodeGenTrackingFields

%%Function SLibNeedGenerateGRTWrapper ==============================
%%  For GRT code formate, this function will determinate if we will
%%  generate GRT classic code or New GRT which is ERT with GRT Wrapper.
%%
%%   For ert code format, if Generate GRT Interface option is checked,
%%  returns true. and do diagnostic check.
%%

%function SLibNeedGenerateGRTWrapper() void
    %assign retVal = TLC_FALSE

    %assign ::isGRTMalloc = TLC_FALSE
    %if CodeFormat == "RealTime" || CodeFormat == "RealTimeMalloc" || (CodeFormat == "Embedded-C" && !SLibIsERTTarget())
        %if UsingMalloc
            %if GenRTModel
                %assert ::MultiInstanceERTCode == 1
                %assign ::RootIOStructures = 1
                %assign ::CompiledModel.RootIOStructures = 1
                %assign ::CompiledModel.HasSimStructVars = 0
                %assign ::CompiledModel.RootIOFormat = "Part of model data structure"
            %else
                %assign errMsg = "Real-Time malloc target doesn't support SimStruct, target "...
                    "must use rtModel. Malloc based targets must not have GenRTModel = 0 in " ...
                    "sytem target file."
                %<LibReportFatalError(errMsg)>
            %endif

            %if CodeFormat == "RealTimeMalloc"
                %assign ::isGRTMalloc = TLC_TRUE
            %endif

        %endif

        %if GenRTModel && !IsModelReferenceTarget()
            %assign ::CodeFormat = "Embedded-C"
            %assign retVal = TLC_TRUE
            %assign ::TargetOS = "BareBoardExample"
            %assign ::CombineOutputUpdateFcns = 0
            %if ::GRTInterface==TLC_FALSE
                %assign retVal = TLC_FALSE
                %assign ::CombineOutputUpdateFcns = ConfigSet.CombineOutputUpdateFcns
            %endif
        %endif
    %elseif SLibIsERTCodeFormat() && !IsModelReferenceTarget()
        %assign retVal = ::CompiledModel.ConfigSet.GRTInterface
        %if retVal
            %if CombineOutputUpdateFcns
                %<SLibReportErrorWithId("RTW:tlc:GRTInterface")>
            %endif
            %if PurelyIntegerCode
                %<SLibReportErrorWithId("RTW:tlc:GRTInterface2")>
            %endif
        %endif
        %if UsingMalloc
            %assert ::MultiInstanceERTCode == 1
            %if ::CompiledModel.RootIOFormat == "Part of model data structure" || ...
                ::CompiledModel.RootIOFormat == "Structure reference"
                %assign ::RootIOStructures = 1
                %assign ::CompiledModel.RootIOStructures = 1
            %else
                %assign ::RootIOStructures = 0
                %assign ::CompiledModel.RootIOStructures = 0
            %endif
            %assign ::CompiledModel.HasSimStructVars = 0
        %endif
    %endif

    %if retVal
        %if EXISTS(MultiInstanceERTCode) && MultiInstanceERTCode && !isGRTMalloc
            %<SLibReportErrorWithId("RTW:tlc:GRTInterface3")>
        %endif

        %foreach tid = ::CompiledModel.NumRuntimeExportedRates
            %<SLibSetNeedFloatAbsoluteTime(tid)>
        %endforeach
    %endif

    %assign ::SeparateRegistrationFcn = 0
    %assign ::PackageModelDataIntoRTM = 0
    %if retVal || ::UsingMalloc
        %assign ::SeparateRegistrationFcn = 1
    %endif
    %if ::UsingMalloc
        %assign ::PackageModelDataIntoRTM = 1
    %endif
    %assert CGMODEL_ACCESS("CGModel.IsUsingSeparateRegistrationFcn") == ::SeparateRegistrationFcn
    %return retVal

%endfunction

%% Function: SLibSetupCodeFormat ===================================================================
%% Abstract:
%%   Sets up:
%%   (a) Default code format if not already setup to be "RealTime"
%%
%%   (b) Accelerator and ExtMode to be 0 if not already setup/
%%
%%   (c) UsingMalloc and IOQualifier based on the CodeFormat:
%%
%%   .-----------------------+-------.
%%   | Code                  | Using |
%%   | Format                | Malloc|
%%   +-----------------------+-------+
%%   | RealTime              |   0   |
%%   | RealTimeMalloc        |   1   |
%%   | Embedded-C            |   0   |
%%   | Ada                   |   0   |
%%   | S-Function            |   1   |
%%   `-----------------------+-------'
%%
%%   Note on UsingMalloc:
%%   Codegen uses static or dynamic memory allocation for specified values of 0
%%   and 1, respectively.  Note these dependencies on UsingMalloc.
%%
%%   o Global parameter data is not allowed when dynamic memory allocation is
%%     used.  That is, TLC function LibCacheGlobalPrmData is disabled.
%%
%%   o Model_prm is included at the top of model.c and the bottom of model.c
%%     for UsingMalloc equal to 0 and 1, respectively.
%%
%%   (d) PreStructDeclarePragma & PostStructDeclarePragma
%%
%%   If code format is "RealTime", change to "Embedded-C" and
%%   "GenerateGRTWrapper=1"
%%
%function SLibSetupCodeFormat() void
    %%
    %% Setup global variables required to execute block functions
    %%
    %<SLibSetupSharedGlobalVariables()>

    %if ::isRAccel
        %assign ::raccelObserverLog = ...
            ::CompiledModel.ObserversInstrumentationInjection
    %else
        %assign ::raccelObserverLog = 0
    %endif

    %%
    %% The ExtModeXCP flag identifies an External Mode solution based on
    %% XCP Transport Layer
    %%
    %if EXISTS(ExtMode) && ...
        ISFIELD(::CompiledModel.ConfigSet, "ExtModeMexFile") && ...
        (::CompiledModel.ConfigSet.ExtModeMexFile == "ext_xcp")
        %assign ::ExtModeXCP = TLC_TRUE
    %else
        %assign ::ExtModeXCP = TLC_FALSE
    %endif

    %%
    %% The ExtModeXCPClassicInterface flag identifies an External Mode
    %% solution based on XCP Transport Layer and the Classic External Mode
    %% interface ext_work.h
    %%
    %% Note: this parameter has been introduced as temporary solution
    %%       to reduce the efforts to port an existing main to the new
    %%       XCP-based technology.
    %%       However ext_work.h interface will be deprecated in future releases
    %%       and it will be replaced by ext_mode.h
    %%
    %if !EXISTS(ExtModeXCPClassicInterface)
        %% By default, the ext_mode.h interface is only enabled when GenerateSampleERTMain
        %% is selected. This parameter can be overwritten by support package authors
        %% as appropriate, by passing the "-aExtModeXCPClassicInterface=X"
        %% argument in the TLCOptions
        %assign ::ExtModeXCPClassicInterface =  !GenerateSampleERTMain && !SLibGenerateNativeThreads() && ...
            !FEVAL("coder.internal.xcp.targetUsesExtModeInterface", ::CompiledModel.Name)
    %endif

    %% Suppress ErrorStatus in real-time model
    %if EXISTS(ExtMode) && ExtMode == 1 && SuppressErrorStatus == 1
        %if !ExtModeXCP
            %<SLibReportErrorWithId("RTW:tlc:RemoveErrorStatusNotSupportedWithClassicExtMode")>
        %elseif ExtModeXCPClassicInterface == 1
            %<SLibReportErrorWithId("RTW:tlc:RemoveErrorStatusNotSupportedWithXCPClassicInterface")>
        %endif
    %endif

    %if EXISTS(ExtMode) && (ExtMode == 1) && ExtModeXCP
        %if ExtModeXCPClassicInterface == 1
            %% C++ class is only supported for ext_mode.h interface
            %if GenerateClassInterface
                %<SLibReportErrorWithId("RTW:tlc:CppClassInterfaceOnlySupportedForExtModeHInterface")>
            %endif

            %% Add to BuildInfo the file containing the XCP implementation of the old "ext_work.h",
            %% originally adopted by Classic External Mode
            %if !FEVAL("rtw.connectivity.Utils.buildInfoAddXCPExtModeClassicInterface", ::CompiledModel.Name)
                %<SLibReportErrorWithId("RTW:tlc:ExtModeModifyBuildInfo")>
            %endif
        %else
            %% Add to BuildInfo the file containing the XCP implementation of the new "ext_mode.h" interface
            %if !FEVAL("rtw.connectivity.Utils.buildInfoAddXCPExtModeInterface", ::CompiledModel.Name)
                %<SLibReportErrorWithId("RTW:tlc:ExtModeModifyBuildInfo")>
            %endif
        %endif
    %endif


    %%
    %% When the code uses floating point arithmetic, the
    %% ExtModeXCPSimulationTimeInTicks flag allows the
    %% extmodeSimulationTime_T to be in base rate clock ticks, overriding
    %% the default settings. This can be used for the cases where
    %% targets don't have double-precision native types, and
    %% it is currently only supported for internal support packages.
    %%
    %if !EXISTS(ExtModeXCPSimulationTimeInTicks)
        %assign ::ExtModeXCPSimulationTimeInTicks = TLC_FALSE
    %endif

    %if EXISTS(ExtMode) && (ExtMode == 1) && ExtModeXCP && (ExtModeXCPSimulationTimeInTicks == 1)
        %% Generate an error if either the resolution or the actual FundamentalStepSize is below 1us
        %assign baseRateModMicrosecond = FEVAL("mod", CompiledModel.FundamentalStepSize, 0.000001)
        %assign EPS = FEVAL("eps", CompiledModel.FundamentalStepSize)
        %if (baseRateModMicrosecond > EPS)
            %<SLibReportErrorWithId("RTW:tlc:SimulationTimeInTicksInvalidResolution")>
        %endif
        %if ExtModeXCPClassicInterface
            %% Simulation Time in Ticks is not supported with Classic interface.
            %<SLibReportErrorWithId("RTW:tlc:SimulationTimeInTicksNotSupportedWithXCPClassicInterface")>
        %elseif !FEVAL("codertarget.target.isCoderTarget", ::CompiledModel.Name)
            %% Simulation Time in Ticks is not supported for host-based targets and
            %% custom HW which are non-codertarget target configurations.
            %<SLibReportErrorWithId("RTW:tlc:SimulationTimeInTicksNotSupported")>
        %else
            %% Add the macro XCP_EXTMODE_SIMULATION_TIME_IN_TICKS to BuildInfo
            %if !FEVAL("rtw.connectivity.Utils.buildInfoAddDefineToOptsGroup", ::CompiledModel.Name, "-DXCP_EXTMODE_SIMULATION_TIME_IN_TICKS")
                %<SLibReportErrorWithId("RTW:tlc:ExtModeModifyBuildInfo")>
            %endif
        %endif
    %endif

    %%
    %% Extmode flag
    %%   The flag is explicitly turned off for the following conditions:
    %%     1) ExtMode is not defined
    %%     2) The target is xPC (SLRT).  All xPC (SLRT) builds enable ExtMode,
    %%        but the extmode server in the generated code is not used and
    %%        does not need to be added to the build.
    %%     3) ExtMode is defined, but the interface level is not Level1
    %%        (old tcp/ip protocol) and we are not using XCP Open Protocol
    %%
    %if !EXISTS(ExtMode) || ...
        (EXISTS(xPC) && (xPC == 1)) || ...
        (EXISTS(slrealtime) && (slrealtime == 1)) || ...
        (ISFIELD(::CompiledModel.ConfigSet, "ExtModeIntrfLevel") && ...
        ::CompiledModel.ConfigSet.ExtModeIntrfLevel != "Level1" && ...
        !ExtModeXCP)
        %assign ::ExtMode = 0
    %endif

    %if ExtMode == 1 || isRSim
        %assign ::CompiledModel.HaveSeparateSourceFiles = 1
    %endif

    %%
    %% We generate code for the transition table if ExtMode is true or
    %% if we are generating the Rsim target to a top model and the Rsim
    %% option to load parameters is enabled.
    %%
    %% Note: the transition table is not required for XCP-based External Mode
    %%
    %assign ::CreateTransitionTable = 0
    %if ((ExtMode == 1) && !ExtModeXCP) || ...
        ((isRSim && !IsModelReferenceTarget() && RSIM_PARAMETER_LOADING == 1))
        %assign ::CreateTransitionTable = 1
    %endif

    %%
    %% In XCP-based External Mode, the generation of External Mode Task Info
    %% is required to retrieve the rate/task id associated to each signal.
    %% In particular, the extmode_task_info() function is used
    %% by coder.internal.xcp.updateCodeDescriptor script to write
    %% the task/rate id information in Code Descriptor.
    %%
    %% Moreover the ext_mode_types.h needs to be generated, as it contains
    %% data types definitions (such as extmodeSimulation_T) that are model dependent
    %%
    %assign ::CreateExtModeTaskInfo = 0
    %assign ::CreateExtModeTypes = 0
    %if (ExtMode == 1) && ExtModeXCP
        %assign ::CreateExtModeTaskInfo = 1
        %assign ::CreateExtModeTypes = 1
    %endif

    %if SLibNeedGenerateGRTWrapper()
        %assign ::GenerateGRTWrapper = TLC_TRUE
        %addtorecord ::CompiledModel GRTWrapper ""
        %addtorecord ::CompiledModel GRTWrapperFcnDef ""

        %% Standalone subsystems are not supported with GRT wrapper
        %if ::CompiledModel.HasStandaloneSubsystem
            %<SLibReportErrorWithId("RTW:tlc:GRTInterface4")>
        %endif
    %else
        %assign ::GenerateGRTWrapper = TLC_FALSE
    %endif

    %assign name = "rtCP"
    %<LibAddToCompiledModel("tUnstructConstParameters", name)>
    %<LibAddToCompiledModel("HasSharedConstants", TLC_FALSE)>

    %if (IsModelReferenceTarget() && IsSimstructBasedTarget())
        %assert (EXISTS(tMdlRefSfcnS))
        %% tMdlRefSfcn is not defined in the TLC files. Model reference
        %% targets that use SimStruct must declare tMdlRefSfcnS
        %% in their target TLC files
    %endif

    %if IsModelReferenceRTWTarget()
        %if !( SLibIsERTCodeFormat() || ...
            CodeFormat == "RealTime" || ...
            isRSim ) || ...
            UsingMalloc
            %<SLibReportErrorWithIdAndArgs("RTW:tlc:MRCodeFormat", CodeFormat)>
        %endif
        %assign ::CodeFormat = "Embedded-C"

        %if ::GenRTModel == 0
            %assign ::GenRTModel = 1
            %% Model reference coder target requires rtModel
            %% data structure to store information about the model

            %assign msgTxt = "### Turning on GenRTModel setting to use " ...
                "rtModel data structure"
            %<LibWriteToStandardOutput(msgTxt)>
        %endif
    %endif

    %% Global timing engine for model reference only works with
    %% Embedded-C and simstruct based targets
    %assign ::NumModelBlocksWithCAPI = 0
    %if HasModelReferenceBlocks()
        %if !SLibIsERTCodeFormat() && !::SimstructBasedTarget
            %<SLibReportErrorWithId("RTW:tlc:InvalidSTF")>
        %endif

        %% Count up the number of Model blocks that may have generated a C-API.
        %% For Coder targets, this will be all model blocks, but for SIM
        %% targets we will skip protected model blocks.
        %assign mdlRefBlks    = ::CompiledModel.ModelReferenceBlocks
        %assign nMdlRefBlks   = SIZE(mdlRefBlks,0)
        %foreach rowIdx = nMdlRefBlks
            %assign mdlRefInfo = mdlRefBlks[rowIdx]
            %assign mdlBlk  = ::CompiledModel.System[mdlRefInfo[0]].Block[mdlRefInfo[1]]
            %if mdlBlk.ParamSettings.SupportsCAPI
                %assign ::NumModelBlocksWithCAPI = ::NumModelBlocksWithCAPI + 1
            %endif
        %endforeach
    %endif

    %<LibAddToCompiledModel("CodeFormat", CodeFormat)>

    %%
    %% When this flag is true, initialization code is
    %% optimized out because 'ZeroInternalMemoryAtStartup' or
    %% 'ZeroExternalMemoryAtStartup' are set to false.
    %%

    %assign ::GenerateInitCodeRemoved    = TLC_FALSE

    %if !EXISTS(TargetRegistMutexOp)
        %assign ::TargetRegistMutexOp = 0
    %endif

    %if !EXISTS(TargetRegistSynchroOp)
        %assign ::TargetRegistSynchroOp = 0
    %endif

    %switch CodeFormat
      %case "RealTime"
        %assign IOQualifier   = "."
        %if UsingMalloc != 0
            %assign errTxt = "UsingMalloc setting passed in from gensettings " ...
                "is not consistent with selected CodeFormat"
            %<LibReportFatalError(errTxt)>
        %endif
        %break
      %case "RealTimeMalloc"
        %assign IOQualifier   = "->"
        %if UsingMalloc != 1
            %assign errTxt = "UsingMalloc setting passed in from gensettings " ...
                "is not consistent with selected CodeFormat"
            %<LibReportFatalError(errTxt)>
        %endif
        %break
      %case "Embedded-C"
        %if UsingMalloc
            %assign IOQualifier   = "->"
        %else
            %assign IOQualifier   = "."
        %endif
        %if UsingMalloc != 0 && !SLibIsERTCodeFormat()
            %assign errTxt = "UsingMalloc setting passed in from gensettings " ...
                "is not consistent with selected CodeFormat"
            %<LibReportFatalError(errTxt)>
        %endif
        %break
      %case "S-Function"
        %assign IOQualifier   = "->"
        %if UsingMalloc != 1
            %assign errTxt = "UsingMalloc setting passed in from gensettings " ...
                "is not consistent with selected CodeFormat"
            %<LibReportFatalError(errTxt)>
        %endif
        %break
      %default
        %<SLibReportErrorWithIdAndArgs("RTW:tlc:UnknownCodeFormat", CodeFormat)>
    %endswitch

    %%
    %% Error check for UsingMalloc and IOQualifier
    %%
    %assign errTxt = "Must specify UsingMalloc as 0 or 1."
    %if !EXISTS(UsingMalloc)
        %% variable doesn't exist
    %elseif !ISEQUAL(UsingMalloc, 0) && !ISEQUAL(UsingMalloc, 1)
        %% variable exists, but has invalid setting
    %else
        %% valid setting so clear error text
        %assign errTxt = ""
    %endif

    %if !EXISTS(IOQualifier)
        %assign errTxt = "Must specify IOQualifier corresponding to " ...
            "UsingMalloc.  Value should be . or -> for UsingMalloc equal " ...
            "to 0 and 1, respectively."
    %endif

    %if errTxt != ""
        %<LibReportFatalError(errTxt)>
    %endif

    %%
    %% Add fields to ::CompiledModel
    %%
    %assign ::IOQualifier = IOQualifier
    %<LibAddToCompiledModel("IOQualifier", IOQualifier)>

    %%
    %% Initialize target specific compiler hooks
    %%

    %% Pragmas for alignment of structures
    %if !EXISTS(PreStructDeclarePragma)
        %assign ::PreStructDeclarePragma = ""
    %endif
    %<LibAddToCompiledModel("PreStructDeclarePragma", PreStructDeclarePragma)>

    %if !EXISTS(PostStructDeclarePragma)
        %assign ::PostStructDeclarePragma = ""
    %endif
    %<LibAddToCompiledModel("PostStructDeclarePragma", PostStructDeclarePragma)>

    %% Load Model reference blocks' interfaces from binfo information mat-file.
    %with ::CompiledModel
        %<LoadModelReferenceBlocksInterface()>
    %endwith

    %if GenRTModel
        %<SLibInitRTMdlRecs()>
    %endif

    %assign cs = ::CompiledModel.ConfigSet

    %if SLibIsERTTarget()
        %assign srcCTemplate  = FEVAL("rtw_cgt_name_conv",cs.ERTSrcFileBannerTemplate,"cgt2tlc")
        %assign srcHTemplate  = FEVAL("rtw_cgt_name_conv",cs.ERTHdrFileBannerTemplate,"cgt2tlc")
        %assign dataCTemplate = FEVAL("rtw_cgt_name_conv",cs.ERTDataSrcFileTemplate,"cgt2tlc")
        %assign dataHTemplate = FEVAL("rtw_cgt_name_conv",cs.ERTDataHdrFileTemplate,"cgt2tlc")

        %if !EXISTS(ERTSrcFileBannerTemplate)
            %assign ::ERTSrcFileBannerTemplate = srcCTemplate
        %endif

        %if !EXISTS(ERTHdrFileBannerTemplate)
            %assign ::ERTHdrFileBannerTemplate = srcHTemplate
        %endif

        %if !EXISTS(ERTCustomFileTemplate)
            %assign ::ERTCustomFileTemplate = cs.ERTCustomFileTemplate
        %endif

        %<LibAddToCompiledModel("ERTSrcFileBannerTemplate",ERTSrcFileBannerTemplate)>
        %<LibAddToCompiledModel("ERTHdrFileBannerTemplate",ERTHdrFileBannerTemplate)>
        %<LibAddToCompiledModel("ERTDataSrcFileTemplate",dataCTemplate)>
        %<LibAddToCompiledModel("ERTDataHdrFileTemplate",dataHTemplate)>
        %<LibAddToCompiledModel("ERTCustomFileTemplate",ERTCustomFileTemplate)>
    %else
        %<LibAddToCompiledModel("ERTSrcFileBannerTemplate","n/a")>
        %<LibAddToCompiledModel("ERTHdrFileBannerTemplate","n/a")>
        %<LibAddToCompiledModel("ERTDataSrcFileTemplate","n/a")>
        %<LibAddToCompiledModel("ERTDataHdrFileTemplate","n/a")>
        %<LibAddToCompiledModel("ERTCustomFileTemplate","n/a")>
    %endif

    %% Initialize MatrixOfRequireRateInteraction for embedded-c
    %%
    %if SLibIsERTCodeFormat()
        %assign numSyncTs = ::CompiledModel.NumRuntimeExportedRates
        %if numSyncTs > 1
            %assign tmp = FEVAL("zeros", numSyncTs, numSyncTs)
        %else
            %assign tmp = Matrix(1,1)[[0]]
        %endif
        %addtorecord ::CompiledModel RequireMultiRateSampleHits 0
        %addtorecord ::CompiledModel RequireRateInteraction 0
        %addtorecord ::CompiledModel MatrixOfRequireRateInteraction tmp
    %endif

%endfunction %% SLibSetupCodeFormat


%% Function: FcnSetupCommonCodeIdents ==============================================================
%% Abstract:
%%   Setup identifiers that are common to all Code Formats.
%%
%function FcnSetupCommonCodeIdents() void
    %if !EXISTS(tRealPart)
        %assign ::tRealPart = "re"
    %endif
    %<LibAddToCompiledModel("tRealPart", tRealPart)>

    %if !EXISTS(tImagPart)
        %assign ::tImagPart = "im"
    %endif
    %<LibAddToCompiledModel("tImagPart", tImagPart)>

    %%yz %<LibAddToCompiledModel("tLocalBlockIO", "rtb")>

    %% Setup the timing bridge for model reference, and
    %% a variable to keep track of when it is accessed.
    %% For Simstruct based targets, we always need the GlobalTID map.
    %assign ::tMdlRefTimingBridgeAccessed = TLC_FALSE
    %assign ::tMdlRefGlobalTIDMapAccessed = ...
        (IsModelReferenceForASimstructBasedTarget()) ? TLC_TRUE : TLC_FALSE
    %assign ::tMdlRefNeedTIDArgs =  ::tMdlRefGlobalTIDMapAccessed

    %% This is no longer a boolean setting.  The decision to prefix
    %% model names is made by searching for "$R" (root model name) in
    %% the symbol format string.
    %if (!SLibIsERTTarget())
        %assign ::PrefixModelToStructs = 1
    %else
        %assign ::PrefixModelToStructs = ISSUBSTRING(CustomSymbolStrMacro,"$R")
    %endif

    %if IsModelReferenceTarget()
        %% PrefixModelToStructs is only used for global typedefs and variables.
        %% Most of the global typedefs/varaibles are not used by model reference.
        %% Most of model reference typedefs are generated based on the
        %% hidden root subsystem. (see ASSERT_MDLREF_NO_TBLOCKIO in this file)
        %%
        %% Note that since subsystems do not have RT_MODEL,
        %% in order to eliminate clash, we must prefix model name to
        %% RT_MODEL.

        %assign ::PrefixModelToStructs = 1

    %endif
    %<LibAddToCompiledModel("PrefixModelToStructs", PrefixModelToStructs)>

    %if !EXISTS(GenerateFullHeader)
        %assign ::GenerateFullHeader = 1
    %else
        %assign ::GenerateFullHeader = %<GenerateFullHeader>
    %endif
    %<LibAddToCompiledModel("GenerateFullHeader", GenerateFullHeader)>

    %if !EXISTS(IncludeFileBanners)
        %assign IncludeFileBanners = 1
    %endif
    %<LibAddToCompiledModel("IncludeFileBanners", IncludeFileBanners)>

    %if !EXISTS(ConfigCheckComments)
        %assign ::ConfigCheckComments = ""
    %else
        %assign ::ConfigCheckComments = %<ConfigCheckComments>
    %endif

    %if !EXISTS(GenerateDefaultFcnBanner)
        %assign ::GenerateDefaultFcnBanner = 0
    %else
        %assign ::GenerateDefaultFcnBanner = %<GenerateDefaultFcnBanner>
    %endif
    %if !EXISTS(GenerateDefaultFcnBannerSharedUtil)
        %assign ::GenerateDefaultFcnBannerSharedUtil = 0
    %else
        %assign ::GenerateDefaultFcnBannerSharedUtil = %<GenerateDefaultFcnBannerSharedUtil>
    %endif

    %if !EXISTS(GeneratedFileList)
        %assign ::GeneratedFileList = ""
    %else
        %assign ::GeneratedFileList = GeneratedFileList
    %endif


%endfunction %% FcnSetupCommonCodeIdents

%% Function: FcnSetupRTModelNames ==================================================================
%% Abstract:
%%   Used by RealTime and RealTimeMalloc targets to setup the names of the
%%   rtModel
%%
%function FcnSetupRTModelNames() void
    %if !EXISTS(::tSimStruct)
        %assign ::tSimStruct = GenRTModel ? "rtM_%<::CompiledModel.Name>" : "rtS"
    %endif
    %if !EXISTS(::tSimStructType)
        %assign ::tSimStructType = GenRTModel ? "rtModel_%<::CompiledModel.Name>" : ...
            "SimStruct"
    %endif
    %<LibAddToCompiledModel("::tSimStruct", tSimStruct)>
    %exit "Where is this called?"
%endfunction %% FcnSetupRTModelNames

%function SLibSetupCoderTypesInfo() void

    %assign potentialBaseNames = SLibCoderBasicTypesFilenames()

    %assign rtwtypesBaseName = SLibGetFileNameForCode("rtwtypes_hdr")
    %assign rtwtypesFileName = rtwtypesBaseName + ".h"
    %assign rtwtypesFilePath = FcnOutputFilePath(rtwtypesFileName)
    %assign potentialBaseNames = potentialBaseNames + rtwtypesBaseName

    %assign mdlrefTypesBaseName = SLibGetFileNameForCode("mdlrefTypes_hdr")
    %assign mdlrefTypesFileName = mdlrefTypesBaseName + ".h"
    %assign mdlrefTypesFilePath = FcnOutputFilePath(mdlrefTypesFileName)
    %assign potentialBaseNames = potentialBaseNames + mdlrefTypesBaseName

    %assign builtinTypeidTypesBaseName = SLibGetFileNameForCode("builtinTypeidTypes_hdr")
    %assign builtinTypeidTypesFileName = builtinTypeidTypesBaseName + ".h"
    %assign builtinTypeidTypesFilePath = FcnOutputFilePath(builtinTypeidTypesFileName)
    %assign potentialBaseNames = potentialBaseNames + builtinTypeidTypesBaseName

    %assign multiwordTypesBaseName = SLibGetFileNameForCode("multiwordTypes_hdr")
    %assign multiwordTypesFileName = multiwordTypesBaseName + ".h"
    %assign multiwordTypesFilePath = FcnOutputFilePath(multiwordTypesFileName)
    %assign potentialBaseNames = potentialBaseNames + multiwordTypesBaseName

    %assign replacementIntTypesBaseName = SLibGetFileNameForCode("replacementIntTypes_hdr")
    %assign replacementIntTypesFileName = replacementIntTypesBaseName + ".h"
    %assign replacementIntTypesFilePath = FcnOutputFilePath(replacementIntTypesFileName)
    %assign potentialBaseNames = potentialBaseNames + replacementIntTypesBaseName

    %assign replacementBoolTypeBaseName = SLibGetFileNameForCode("replacementBoolType_hdr")
    %assign replacementBoolTypeFileName = replacementBoolTypeBaseName + ".h"
    %assign replacementBoolTypeFilePath = FcnOutputFilePath(replacementBoolTypeFileName)
    %assign potentialBaseNames = potentialBaseNames + replacementBoolTypeBaseName

    %assign replacementOtherTypesBaseName = SLibGetFileNameForCode("replacementOtherTypes_hdr")
    %assign replacementOtherTypesFileName = replacementOtherTypesBaseName + ".h"
    %assign replacementOtherTypesFilePath = FcnOutputFilePath(replacementOtherTypesFileName)
    %assign potentialBaseNames = potentialBaseNames + replacementOtherTypesBaseName

    %assign zerocrossingTypesBaseName = SLibGetFileNameForCode("zerocrossingTypes_hdr")
    %assign zerocrossingTypesFileName = zerocrossingTypesBaseName + ".h"
    %assign zerocrossingTypesFilePath = FcnOutputFilePath(zerocrossingTypesFileName)
    %assign potentialBaseNames = potentialBaseNames + zerocrossingTypesBaseName

    %assign complexTypesBaseName = SLibGetFileNameForCode("complexTypes_hdr")
    %assign complexTypesFileName = complexTypesBaseName + ".h"
    %assign complexTypesFilePath = FcnOutputFilePath(complexTypesFileName)
    %assign potentialBaseNames = potentialBaseNames + complexTypesBaseName

    %assign halfTypeHdrBaseName = SLibGetFileNameForCode("halfType_hdr")
    %assign halfTypeHdrFileName = halfTypeHdrBaseName + ".h"
    %assign halfTypeHdrFilePath = FcnOutputFilePath(halfTypeHdrFileName)
    %assign imageTypeHdrBaseName = LibGetImageTypeSrcBaseName()
    %assign imageTypeHdrFileName = imageTypeHdrBaseName + ".h"
    %assign imageTypeHdrFilePath = FcnOutputFilePath(imageTypeHdrFileName)
    %assign potentialBaseNames = potentialBaseNames + halfTypeHdrBaseName + imageTypeHdrBaseName

    %assign halfTypeSrcBaseName = SLibGetFileNameForCode("halfType_src")
    %assign halfTypeSrcFileName = halfTypeSrcBaseName + "." + SLibGetHalfTypeFileExtension()

    %assign halfTypeSrcFilePath = FcnOutputFilePath(halfTypeSrcFileName)
    %assign imageTypeSrcBaseName = LibGetImageTypeSrcBaseName()
    %assign imageTypeSrcFileName = imageTypeSrcBaseName + "." + SLibGetHalfTypeFileExtension()

    %assign imageTypeSrcFilePath = FcnOutputFilePath(imageTypeSrcFileName)
    %assign potentialBaseNames = potentialBaseNames + halfTypeSrcBaseName + imageTypeSrcBaseName

    %createrecord coderTypesInfo {}
    %addtorecord coderTypesInfo BaseName rtwtypesBaseName
    %addtorecord coderTypesInfo ModelReferenceTypesBaseName mdlrefTypesBaseName
    %addtorecord coderTypesInfo BuiltinTypeidTypesBaseName builtinTypeidTypesBaseName
    %addtorecord coderTypesInfo MultiwordTypesBaseName multiwordTypesBaseName
    %addtorecord coderTypesInfo ReplacementIntTypesBaseName replacementIntTypesBaseName
    %addtorecord coderTypesInfo ReplacementBoolTypeBaseName replacementBoolTypeBaseName
    %addtorecord coderTypesInfo ReplacementOtherTypesBaseName replacementOtherTypesBaseName
    %addtorecord coderTypesInfo ZerocrossingTypesBaseName zerocrossingTypesBaseName
    %addtorecord coderTypesInfo HalfTypeHdrBaseName halfTypeHdrBaseName
    %addtorecord coderTypesInfo HalfTypeSrcBaseName halfTypeSrcBaseName
    %addtorecord coderTypesInfo ImageTypeHdrBaseName imageTypeHdrBaseName
    %addtorecord coderTypesInfo ImageTypeSrcBaseName imageTypeSrcBaseName
    %addtorecord coderTypesInfo ModelReferenceTypesFileName mdlrefTypesFileName
    %addtorecord coderTypesInfo BuiltinTypeidTypesFileName builtinTypeidTypesFileName
    %addtorecord coderTypesInfo MultiwordTypesFileName multiwordTypesFileName
    %addtorecord coderTypesInfo ReplacementIntTypesFileName replacementIntTypesFileName
    %addtorecord coderTypesInfo ReplacementBoolTypeFileName replacementBoolTypeFileName
    %addtorecord coderTypesInfo ReplacementOtherTypesFileName replacementOtherTypesFileName
    %addtorecord coderTypesInfo ZerocrossingTypesFileName zerocrossingTypesFileName
    %addtorecord coderTypesInfo ComplexTypesFileName complexTypesFileName
    %addtorecord coderTypesInfo HalfTypeHdrFileName halfTypeHdrFileName
    %addtorecord coderTypesInfo HalfTypeSrcFileName halfTypeSrcFileName
    %addtorecord coderTypesInfo ImageTypeHdrFileName imageTypeHdrFileName
    %addtorecord coderTypesInfo ImageTypeSrcFileName imageTypeSrcFileName
    %addtorecord coderTypesInfo RtwtypesFilePath rtwtypesFilePath
    %addtorecord coderTypesInfo ModelReferenceTypesFilePath mdlrefTypesFilePath
    %addtorecord coderTypesInfo BuiltinTypeidTypesFilePath builtinTypeidTypesFilePath
    %addtorecord coderTypesInfo MultiwordTypesFilePath multiwordTypesFilePath
    %addtorecord coderTypesInfo ReplacementIntTypesFilePath replacementIntTypesFilePath
    %addtorecord coderTypesInfo ReplacementBoolTypeFilePath replacementBoolTypeFilePath
    %addtorecord coderTypesInfo ReplacementOtherTypesFilePath replacementOtherTypesFilePath
    %addtorecord coderTypesInfo ZerocrossingTypesFilePath zerocrossingTypesFilePath
    %addtorecord coderTypesInfo ComplexTypesFilePath complexTypesFilePath
    %addtorecord coderTypesInfo HalfTypeHdrFilePath halfTypeHdrFilePath
    %addtorecord coderTypesInfo HalfTypeSrcFilePath halfTypeSrcFilePath
    %addtorecord coderTypesInfo ImageTypeHdrFilePath imageTypeHdrFilePath
    %addtorecord coderTypesInfo ImageTypeSrcFilePath imageTypeSrcFilePath
    %addtorecord coderTypesInfo PotentialBaseNames potentialBaseNames

    %<LibAddToCompiledModel("CoderTypesInfo", coderTypesInfo)>

%endfunction

%% Function: SLibSetupCodeIdentifiers===========================================
%% Abstract:
%%   Sets up fields for various Identifiers used in the generated code.
%%   Some of these fields are set up on the basis of the specific code format
%%
%function SLibSetupCodeIdentifiers() void

    %%
    %% Setup identifiers that do not depend on code format
    %%
    %<FcnSetupCommonCodeIdents()>

    %% Clear the projected multiword scm map
    %assign dummy = FEVAL("rtwprivate", "retrieveMultiWordUtilitiesAndFunctions", "%<::CompiledModel.MasterSharedCodeManagerFile>", 0, "")

    %% Only generate into _sharedutils if a sub-model or top model with references.
    %% This provides for backwards compatibility of the user makefiles and other
    %% custom post-codegen processing. Note: Any change to this logic should be
    %% duplicated in infoMATFileMgr.m so that checking _sharedutil dir checksum is
    %% done only when GenUtilsSrcInSharedLocation is set.
    %assign gShared = 0
    %assign gReusedLibs = 0
    %if LibHasClientsOrServers() || ...
        HasModelReferenceBlocksInModel() || ...
        IsModelReferenceTarget() || ...
        (::CompiledModel.ConfigSet.UtilityFuncGeneration == "Shared location") || ...
        (::CompiledModel.ConfigSet.ExistingSharedCode != "")
        %if !ISFIELD(::CompiledModel, "RTWInfoMatFile")
            %<LoadRTWInfoMatFileforTLC()>
        %endif
        %assign gShared = 1
        %assign gPath = ::CompiledModel.RTWInfoMatFile.sharedSourcesDir
    %else
        %assign gPath = FEVAL("rtwprivate", "rtwattic","getBuildDir")
    %endif
    %% Ensure MATLAB code and TLC code are in sync
    %assign rtwgenshared = FEVAL("rtw_gen_shared_utils", LibGetModelName())
    %% A modelref could be removed and this can cause differences between the sharedCodePlacement
    %% setting computed in RTWFile( gShared, which takes into account variant removal of modelref
    %% blocks) vs the one cached on the SLCompBD (rtwgenshared, which is not updated to reflect variant removal)
    %assert (rtwgenshared == gShared)
    %<LibAddToCompiledModel("GenUtilsSrcInSharedLocation", gShared)>
    %<CGMODEL_ACCESS("CGModel.SetGenUtilsSrcInSharedLocation", CAST("Boolean",gShared))>
    %<LibAddToCompiledModel("GenUtilsPath", gPath)>
    %<LibAddToCompiledModel("GenReusedLibsOutsideModel", gReusedLibs)>
    %% Store GenUtilsLocation in rtwattic for reference after TLC phase
    %matlab rtwprivate("rtwattic","AtticData","genDirForTFL","%<::CompiledModel.GenUtilsPath>")

    %assign ::Tid01Eq = ISEQUAL(::CompiledModel.SolverType, "FixedStep") && ...
        ::CompiledModel.FixedStepOpts.TID01EQ
    %<LibAddToCompiledModel("Tid01Eq", Tid01Eq)>
    %assign ::avoidTid01HitCheckOptimization = ISEQUAL(::CompiledModel.SolverType, "FixedStep") && ...
        ::CompiledModel.FixedStepOpts.avoidTid01HitCheckOptimization

    %% We may have unstructured global parameters for model
    %% blocks and modelref targets, independent of the code format.
    %if IsModelReferenceTarget() || HasModelReferenceBlocksInModel()
        %assign name = "rtP"
        %<LibAddToCompiledModel("tUnstructParameters", name)>
    %endif

    %switch ::CompiledModel.CodeFormat
      %case "Embedded-C"

        %if !EXISTS(AutoBuildProcedure)
            %assign ::AutoBuildProcedure = 0
        %endif

        %if IsModelReferenceTarget()
            %assign ::AutoBuildProcedure = 0
        %endif

        %if SLibGetSDPPlatformType() == "FUNCTION_PLATFORM"
            %assign ::AutoBuildProcedure = 0
        %endif

        %<LibAddToCompiledModel("AutoBuildProcedure", AutoBuildProcedure)>

        %assign varPrefix = PrefixModelToStructs ? "%<::CompiledModel.Name>_" : "rt"
        %assign tdPostfix = PrefixModelToStructs ? "_%<::CompiledModel.Name>" : ""

        %<LibAddToCompiledModel("tLogObject", "rtL")>
        %<LibAddToCompiledModel("tLogObjectType", "LogObject")>

        %<LibAddToCompiledModel("tExtModeObject", "rtE")>
        %<LibAddToCompiledModel("tExtModeObjectType", "ExtModeObject")>

        %assign ::logObject     = "logObject"
        %assign ::logObjectAddr = "&%<logObject>"

        %assign upperSolver = FEVAL("upper", ::CompiledModel.Solver)
        %<LibAddToCompiledModel("upperSolver", upperSolver)>
        %assign solverOrder = IDNUM(::CompiledModel.Solver)[1]
        %<LibAddToCompiledModel("solverOrder", solverOrder)>
        %break

      %case "RealTime"
        %if !EXISTS(AutoBuildProcedure)
            %assign ::AutoBuildProcedure = 0
        %endif
        %<LibAddToCompiledModel("AutoBuildProcedure", AutoBuildProcedure)>

        %assign upperSolver = FEVAL("upper", ::CompiledModel.Solver)
        %<LibAddToCompiledModel("upperSolver", upperSolver)>
        %assign solverOrder = IDNUM(::CompiledModel.Solver)[1]
        %<LibAddToCompiledModel("solverOrder", solverOrder)>
        %break

      %case "S-Function"
        %assign varPrefix = PrefixModelToStructs ? "%<::CompiledModel.Name>_" : ""
        %assign tdPostfix = PrefixModelToStructs ? "_%<::CompiledModel.Name>" : ""

        %if !EXISTS(AutoBuildProcedure)
            %assign ::AutoBuildProcedure = 0
        %endif
        %<LibAddToCompiledModel("AutoBuildProcedure", AutoBuildProcedure)>

        %break

    %endswitch

    %%
    %% Constant run-time parameters
    %%
    %if !EXISTS(tConstPrms)
        %assign ::tConstPrms = "rtCP"
    %endif

    %%
    %% Default logObject is the SimStruct. Is overridden in some
    %% code formats
    %%
    %if !EXISTS(logObject)
        %assign ::logObject   = ::tSimStruct
        %assign ::logObjectAddr = ::tSimStruct
    %endif

%endfunction %% SLibSetupCodeFmtRTWIdents


%% Function: SLibSetupLibSrcFcnNames ===============================================================
%% Abstract:
%%   Setup LibSrc function names.
%%
%function SLibSetupLibSrcFcnNames() void
    %if !EXISTS(tCreateLogVar)
        %assign ::tCreateLogVar = "rt_CreateLogVar"
    %endif

    %if !EXISTS(tCreateLogVarWithConvert)
        %assign ::tCreateLogVarWithConvert = "rt_CreateLogVarWithConvert"
    %endif

    %if !EXISTS(tUpdateLogVar)
        %assign ::tUpdateLogVar = "rt_UpdateLogVar"
    %endif

    %if !EXISTS(tCreateStructLogVar)
        %assign ::tCreateStructLogVar = \
        "rt_CreateStructLogVar"
    %endif

    %if !EXISTS(tUpdateStructLogVar)
        %assign ::tUpdateStructLogVar = \
        "rt_UpdateStructLogVar"
    %endif

    %<LibAddToCompiledModel("tCreateLogVar", tCreateLogVar)>
    %<LibAddToCompiledModel("tUpdateLogVar", tUpdateLogVar)>
    %<LibAddToCompiledModel("tCreateStructLogVar", tCreateStructLogVar)>
    %<LibAddToCompiledModel("tUpdateStructLogVar", tUpdateStructLogVar)>

%endfunction %% SLibSetupLibSrcFcnNames


%% Function: SLibCheckCompiledModel ================================================================
%% Abstract:
%%   Check if the ::CompiledModel satisfies some important preliminary criteria:
%%    - There are no algebraic loops
%%
%function SLibCheckCompiledMdl() void
    %%
    %% Exit if there are any algebraic loops
    %%
    %if ::CompiledModel.NumAlgebraicLoops > 0
        %if !Accelerator
            %<SLibReportErrorWithIdAndArgs("RTW:tlc:AlgebraicLoop", "Simulink Coder")>
        %endif
    %endif
%endfunction %% SLibCheckCompiledMdl


%% Function: SLibSetupDoCodeFmtChecks ==============================================================
%% Abstract:
%%   Do checks that pertain to specific code formats
%%
%function SLibSetupDoCodeFmtChecks() void
    %%
    %% S-Function wrapper for ERT-C-Code
    %%
    %if !EXISTS(GenerateErtSFunction)
        %assign ::GenerateErtSFunction = 0
    %endif
    %if GenerateErtSFunction == 1
        %if !SLibIsERTCodeFormat()
            %<SLibReportErrorWithId("RTW:tlc:ERTSfcn")>
        %elseif LibIsContinuous(0)
            %<SLibReportErrorWithId("RTW:tlc:ERTSfcn2")>
        %endif
    %endif
    %<LibAddToCompiledModel("GenerateErtSFunction", GenerateErtSFunction)>

    %<LibAddToCompiledModel("EmptyRealTimeObject", 0)>

    %%
    %% Flag to determine if purely integer code is to be generated.
    %% This flag will be set to 1 if INTEGER_CODE=1 is specified on the make_rtw
    %% command line.
    %% NOTE: This flag is only supported for the Embedded-C code format.
    %%
    %if PurelyIntegerCode == 1 && !SLibIsERTCodeFormat()
        %<SLibReportErrorWithId("RTW:tlc:IntegerOnly")>
    %endif

    %%
    %% Flag to indicate the model.rtw has been created with root Inports
    %% non-contiguous.  This is required for the S-Function code format.
    %%
    %if CodeFormat == "S-Function" && !Accelerator
        %assign InvalidSTF = 1
        %if ISFIELD(::CompiledModel.RTWGenSettings,"IsRTWSfcn")
            %if ::CompiledModel.RTWGenSettings.IsRTWSfcn == "yes"
                %assign InvalidSTF = 0
            %endif
        %endif
        %if InvalidSTF == 1
            %<SLibReportErrorWithId("RTW:tlc:SfcnCodeFormat")>
        %endif
    %endif

    %% Report errors for unsupported C++ targets
    %if GenCPP == 1
        %assign ::cppxPC     = 0
        %if EXISTS(xPC) && (xPC == 1)
            %assign ::cppxPC = 1
        %endif
        %if cppxPC == 1
            %<SLibReportErrorWithId("RTW:tlc:CPPForxPC")>
        %endif
    %endif
%endfunction %% SLibSetupDoCodeFmtChecks


%% Function: SLibSetupAdaCGTrackingFields ==========================================================
%% Abstract:
%%   Setup variables that track Ada code generation.
%%
%function SLibSetupAdaCGTrackingFields() void
    %%
    %% With RT_Lookup
    %%
    %if !EXISTS(WithRTlook)
        %assign ::WithRTlook = 0
    %endif
    %<LibAddToCompiledModel("WithRTlook", WithRTlook)>

    %%
    %% With RT_Lookup2D
    %%
    %if !EXISTS(WithRTlook2D)
        %assign ::WithRTlook2D = 0
    %endif
    %<LibAddToCompiledModel("WithRTlook2D", WithRTlook2D)>

    %%
    %% With RT_LookupND
    %%
    %if !EXISTS(WithRTLookupND)
        %assign ::WithRTLookupND = 0
    %endif
    %<LibAddToCompiledModel("WithRTLookupND", WithRTLookupND)>

    %%
    %% With RT_LookupND32
    %%
    %if !EXISTS(WithRTLookupND32)
        %assign ::WithRTLookupND32 = 0
    %endif
    %<LibAddToCompiledModel("WithRTLookupND32", WithRTLookupND32)>

    %%
    %% With RT_SplineND
    %%
    %if !EXISTS(WithRTSplineND)
        %assign ::WithRTSplineND = 0
    %endif
    %<LibAddToCompiledModel("WithRTSplineND", WithRTSplineND)>

    %%
    %% With RT_SplineND32
    %%
    %if !EXISTS(WithRTSplineND32)
        %assign ::WithRTSplineND32 = 0
    %endif
    %<LibAddToCompiledModel("WithRTSplineND32", WithRTSplineND32)>

    %%
    %% With RT_Rand
    %%
    %if !EXISTS(WithRTrand)
        %assign ::WithRTrand = 0
    %endif
    %<LibAddToCompiledModel("WithRTrand", WithRTrand)>

    %%
    %% Flag to include integer multiply and divide saturation routines.
    %%
    %if !EXISTS(WithRTsat)
        %assign ::WithRTsat = 0
    %endif
    %<LibAddToCompiledModel("WithRTsat", WithRTsat)>

    %%
    %% With RT_Matrix
    %%
    %if !EXISTS(WithRTmat)
        %assign ::WithRTmat = 0
    %endif
    %<LibAddToCompiledModel("WithRTmat", WithRTmat)>

    %%
    %% With Cstreams
    %%
    %if !EXISTS(WithCstreams)
        %assign ::WithCstreams = 0
    %endif
    %<LibAddToCompiledModel("WithCstreams", WithCstreams)>

    %%
    %% Flag to include declaration of constants for pi, e, ln(10), log10(e)
    %%
    %if !EXISTS(MathConstantDefines)
        %assign Pi = PiRec { Required 0 }
        %assign E = ERec { Required 0 }
        %assign LN10   = LN10Rec { Required 0 }
        %assign LOG10E = LOG10E { Required 0 }
        %assign MathConstantDefines = MathConstantDefinesRec { Stub 0 }
        %assign MathConstantDefines = MathConstantDefines + Pi
        %assign MathConstantDefines = MathConstantDefines + E
        %assign MathConstantDefines = MathConstantDefines + LN10
        %assign MathConstantDefines = MathConstantDefines + LOG10E
    %endif
    %assign ::MathConstantDefines = MathConstantDefines
    %<LibAddToCompiledModel("MathConstantDefines", MathConstantDefines)>

%endfunction %% SLibSetupAdaCGTrackingFields


%% Function: SLibSetupBIOAPI =======================================================================
%% Abstract:
%%   Setup Block IO Signals C API for monitoring signals in a running model
%%
%function SLibSetupBIOAPI() void
    %if !EXISTS(BlockIOSignals)
        %assign ::BlockIOSignals = 0
    %endif
    %if BlockIOSignals == 1
        %<SLibReportErrorWithId("RTW:tlc:DeprecatedParamTuningAndBlockIOSig")>
    %endif
%endfunction %% SLibSetupBIOAPI


%% Function: SLibSetupPrmAPI =======================================================================
%% Abstract:
%%   Parameter Tuning C API for changing parameter values in a running model
%%
%function SLibSetupPrmAPI() void
    %if !EXISTS(ParameterTuning)
        %assign ::ParameterTuning = 0
    %endif
    %if ParameterTuning == 1
        %<SLibReportErrorWithId("RTW:tlc:DeprecatedParamTuningAndBlockIOSig")>
    %endif
%endfunction %% SLibSetupPrmAPI

%% Function: SLibSetupUtilTypes ====================================================================
%% Abstract:
%%   Setup types for non-finite and control port variables
%%
%%
%function SLibSetupUtilTypes() void
    %assign ::tTIDType = LibGetDataTypeNameFromId(::CompiledModel.tSS_INTEGER)
    %assign ::tControlPortIdxType = LibGetDataTypeNameFromId(::CompiledModel.tSS_INTEGER)
    %assign ::tInfType = LibGetDataTypeNameFromId(::CompiledModel.tSS_DOUBLE)
    %assign ::tMinusInfType = LibGetDataTypeNameFromId(::CompiledModel.tSS_DOUBLE)
    %assign ::tNaNType = LibGetDataTypeNameFromId(::CompiledModel.tSS_DOUBLE)
%endfunction

%% Function: SLibSetupCAPI =========================================================================
%% Abstract:
%%   Setup C API for monitoring signals and tuning parameter in a running model
%%
%%
%function SLibSetupCAPI() void
    %assign int32Type = LibGetDataTypeNameFromId(::CompiledModel.tSS_INT32)
    %assign intType = LibGetDataTypeNameFromId(::CompiledModel.tSS_INTEGER)
    %assign uintType = LibGetDataTypeNameFromId(::CompiledModel.tSS_UINTEGER)
    %if !EXISTS(RTWCAPITestPtSignals)
        %assign ::RTWCAPITestPtSignals = 0
    %endif
    %if !EXISTS(RTWCAPISignals)
        %assign ::RTWCAPISignals     = 0
    %endif

    %% Only generate testpoints in the BlockSignals C-API structure if
    %% generating code for ModelRef Sim target.
    %if IsModelReferenceSimTarget()
        %assert (::RTWCAPISignals)
        %% We do not need all global signals. We only need
        %% test pointed signals
        %assign ::RTWCAPITestPtSignals = 1
    %endif

    %if !EXISTS(RTWCAPIParams)
        %assign ::RTWCAPIParams    = 0
    %endif
    %if !EXISTS(WriteCAPIUsingTemplates)
        %assign ::WriteCAPIUsingTemplates = 1
    %endif

    %% Add logic for turning on RTWCAPI States here
    %if !EXISTS(MatFileLogging)
        %assign ::MatFileLogging = 0
        %% Above line needs to replaced with below line with Matt's change
        %% %assign ::MatFileLogging = ::CompiledModel.ConfigSet.MatFileLogging
    %endif
    %% Compute if State Logging needs CAPI States. This is true if:
    %%  (1) there are model blocks
    %%  (2) state logging is on or Rapid Accelerator mode
    %%  (3) MatFileLogging is on
    %%  (4) the old api is not specified

    %assign RTWStatesLogging = 0
    %if !IsModelReferenceTarget() && HasModelReferenceBlocks()
        %assign dlo = ::CompiledModel.DataLoggingOpts
        %if (MatFileLogging == 1)
            %if ((dlo.StateSaveName != "" || dlo.FinalStateName != "") || ::isRAccel)
                %assign RTWStatesLogging = 1
            %endif
        %endif
    %endif
    %<LibAddToCompiledModel("RTWStatesLogging",RTWStatesLogging)>

    %if ISFIELD(::CompiledModel.ConfigSet, "RTWCAPIStates")
        %assign ConfigSetCAPIStates    = ::CompiledModel.ConfigSet.RTWCAPIStates
    %else
        %assign ConfigSetCAPIStates    = 0
    %endif

    %if !EXISTS(RTWCAPIStates)
        %assign ::RTWCAPIStates = 0
    %endif
    %assign ::RTWCAPIRootIO = 0
    %if ISFIELD(::CompiledModel.ConfigSet, "RTWCAPIRootIO") && ...
        ::CompiledModel.ConfigSet.RTWCAPIRootIO==TLC_TRUE
        %assign ::RTWCAPIRootIO  = 1
    %endif
    %% RTWCAPIStates is ON if either RTWCAPIStates (Model Reference Simulation,
    %% -aRTWCAPIStates TLC option) OR RTWStatesLogging (States are logged) OR
    %% ConfigSetCAPIStates (States is ON in the Config Set)
    %if RTWCAPIStates==0
        %assign ::RTWCAPIStates = RTWStatesLogging || ConfigSetCAPIStates
    %endif
    %assign ::RTWCAPI = ::RTWCAPISignals || ::RTWCAPIParams || ::RTWCAPIStates ...
        || ::RTWCAPIRootIO
    %if RTWCAPI
        %assign ::CompiledModel.HaveSeparateSourceFiles = 1
    %endif
    %if (RTWCAPIParams) && (CodeFormat == "S-Function")
        %<SLibReportErrorWithId("RTW:tlc:CAPIAccel2")>
    %endif
    %if PurelyIntegerCode && RTWCAPI
        %<SLibReportErrorWithId("RTW:tlc:CAPIIntegerOnly")>
    %endif
    %if !EXISTS(xPC)
        %assign ::xPC = 0
    %endif
    %assign ::tBlockSignals       = "rtBlockSignals"
    %assign ::tBlockSignalsType   = "rtwCAPI_Signals"
    %assign ::tBlockStates        = "rtBlockStates"
    %assign ::tBlockStatesType    = "rtwCAPI_States"
    %assign ::tBlockParams        = "rtBlockParameters"
    %assign ::tBlockParamsType    = "rtwCAPI_BlockParameters"
    %assign ::tModelParams        = "rtModelParameters"
    %assign ::tModelParamsType    = "rtwCAPI_ModelParameters"
    %assign ::tRootInputs         = "rtRootInputs"
    %assign ::tRootOutputs        = "rtRootOutputs"
    %assign ::tDataAddrType       = "void* "
    %assign ::tDataAddrMap        = "rtDataAddrMap"
    %assign ::tDataTypeMapType    = "rtwCAPI_DataTypeMap"
    %assign ::tDataTypeMap        = "rtDataTypeMap"
    %assign ::tDimensionMapType   = "rtwCAPI_DimensionMap"
    %assign ::tDimensionMap       = "rtDimensionMap"
    %assign ::tDimensionArrayType = uintType
    %assign ::tDimensionArray     = "rtDimensionArray"
    %assign ::tFixPtMapType       = "rtwCAPI_FixPtMap"
    %assign ::tFixPtMap           = "rtFixPtMap"
    %assign ::tElementMapType     = "rtwCAPI_ElementMap"
    %assign ::tElementMap         = "rtElementMap"
    %assign ::tSampleTimeMapType  = "rtwCAPI_SampleTimeMap"
    %assign ::tSampleTimeMap      = "rtSampleTimeMap"
    %assign ::tVarDimsAddrMapType = "%<int32Type>* "
    %assign ::tVarDimsAddrMap     = "rtVarDimsAddrMap"
    %assign ::SupportTunableStructParam  = 1
    %assign ::tStateIdxList       = "rt_LoggedStateIdxList"
    %assign ::tStateIdxListType   = intType


    %<LibAddToCompiledModel("RTWCAPI", RTWCAPI)>
    %<LibAddToCompiledModel("RTWCAPISignals", RTWCAPISignals)>
    %<LibAddToCompiledModel("RTWCAPIParams", RTWCAPIParams)>
    %<LibAddToCompiledModel("RTWCAPITestPtSignals", RTWCAPITestPtSignals)>
    %<LibAddToCompiledModel("RTWCAPIStates", RTWCAPIStates)>
    %if RTWCAPI
        %assign ::CompiledModel.GenerateInterfaceAPI = 1
    %endif
    %if RTWCAPISignals
        %assign ::CompiledModel.MapBlockOutputs = 1
    %endif
    %if RTWCAPIParams
        %assign ::CompiledModel.MapParameters        = 1
        %assign ::CompiledModel.MapStateflow         = 1
    %endif
    %if RTWCAPIStates
        %assign ::CompiledModel.MapDWork = 1
        %assign ::CompiledModel.MapContStates = 1
    %endif
    %if RTWCAPIRootIO
        %assign ::CompiledModel.MapExternalInputs  = 1
        %assign ::CompiledModel.MapExternalOutputs = 1
    %endif
    %if EXISTS(GenerateASAP2) && GenerateASAP2==1
        %assign ::CompiledModel.MapExternalOutputs = 1
    %endif
%endfunction %% SLibSetupCAPI

%function FcnShouldSetupCustomStorageClass() void
    %return ( (CustomStorageClasses.NumCustomStorageClasses > 0) || ...
        ((ISFIELD(::CompiledModel.ConfigSet, "MemSecPackage")) && ...
        ("--- None ---" != ::CompiledModel.ConfigSet.MemSecPackage)) || ...
        (SLibIsCoderDictionaryActiveForDefaults() && ...
        (SIZE(::CompiledModel.CoderDictionary.AllPackages, 1) > 0)) )
%endfunction

%function SLibSetupAndCheckCustomSCImpl() void

    %if !ISFIELD(::CompiledModel.ConfigSet, "MemSecPackage")
        %% Return early if non-ERT target
        %% But set custom storage class, since we allow GRT default mapping
        %addtorecord ::CompiledModel CoderDictionary {DefaultMemorySections ""}

        %with ::CompiledModel
            %if FcnShouldSetupCustomStorageClass()
                %<SLibSetupCustomStorageClasses()>
            %endif
        %endwith

        %return
    %endif

    %% Create a record in ::CompiledModel.CoderDictionary with same structure as
    %% ::CompiledModel.ConfigSet (just for memory sections). This will help
    %% minimize changes to downstream TLC code.
    %%
    %% In the .rtw file, the record is structured differently (that is, each
    %% memory section has its own class and package). Since this (or fully
    %% modeled MS) is the long-term plan, the structure in .rtw file aligns with
    %% the long-term plam.
    %if SLibIsCoderDictionaryActiveForDefaults()
        %% Memory Section class and package names are stored in the defaults mapping

        %% NOTE: In 17b, memory sections can only be selected from one package
        %assign msPackage = ::CompiledModel.CoderDictionary.PackageForDefaults
        %if msPackage == "--- None ---"
            %% This is needed when subsystems set memory sections
            %assign msPackage = ::CompiledModel.ConfigSet.MemSecPackage
        %endif

        %% Function Defaults
        %assign fcnDefaults = ::CompiledModel.CoderDictionary.FunctionDefaults
        %assign msInitTerm = FcnGetMemorySection(fcnDefaults.InitializeTerminate)
        %assign msExec = FcnGetMemorySection(fcnDefaults.Execution)
        %assign msSharedUtil = FcnGetMemorySection(fcnDefaults.SharedUtility)

        %% Data Defaults
        %assign dataDefaults = ::CompiledModel.CoderDictionary.DataDefaults
        %assign msInputs = FcnGetMemorySection(dataDefaults.Inputs)
        %assign msOutputs = FcnGetMemorySection(dataDefaults.Outputs)
        %assign msConstants = FcnGetMemorySection(dataDefaults.Constants)
        %assign msInternal = FcnGetMemorySection(dataDefaults.InternalData)

        %assign msParameters = "Default"
        %assign parametersMSRec = ""
        %if ISFIELD(dataDefaults.LocalParameters, "MemorySection")
            %assign parametersMSRec = dataDefaults.LocalParameters
        %elseif ISFIELD(dataDefaults.GlobalParameters, "MemorySection")
            %assign parametersMSRec = dataDefaults.GlobalParameters
        %endif

        %if (!ISEMPTY(parametersMSRec))
            %assign msParameters = FcnGetMemorySection(parametersMSRec)
        %endif

    %else
        %% Memory Section class and package names are stored in the ConfigSet

        %assign msPackage = ::CompiledModel.ConfigSet.MemSecPackage

        %% Function Defaults
        %assign msInitTerm = ::CompiledModel.ConfigSet.MemSecFuncInitTerm
        %assign msExec = ::CompiledModel.ConfigSet.MemSecFuncExecute
        %assign msSharedUtil = ::CompiledModel.ConfigSet.MemSecFuncSharedUtil

        %% Data Defaults
        %assign msInputs = ::CompiledModel.MemorySectionsFromMapping.MemSecDataInputs
        %assign msOutputs = ::CompiledModel.MemorySectionsFromMapping.MemSecDataOutputs
        %assign msConstants = ::CompiledModel.MemorySectionsFromMapping.MemSecDataConstants
        %assign msInternal = ::CompiledModel.MemorySectionsFromMapping.MemSecDataInternal
        %assign msParameters = ::CompiledModel.MemorySectionsFromMapping.MemSecDataParameters
    %endif

    %if !ISFIELD(::CompiledModel, "CoderDictionary")
        %% CoderDictionary record does not exist if CodeInterfaceCustomization < 2
        %addtorecord ::CompiledModel CoderDictionary {DefaultMemorySections ""}
        %addtorecord ::CompiledModel.CoderDictionary AllPackages ""
    %else
        %addtorecord ::CompiledModel.CoderDictionary DefaultMemorySections ""
        %if !ISFIELD(::CompiledModel.CoderDictionary, "AllPackages")
            %addtorecord ::CompiledModel.CoderDictionary AllPackages ""
        %endif
    %endif

    %createrecord msRecords { MemSecPackage "%<msPackage>" ; ...
        MemSecFuncInitTerm msInitTerm; ...
        MemSecFuncExecute msExec; ...
        MemSecFuncSharedUtil msSharedUtil; ...
        MemSecDataInputs msInputs; ...
        MemSecDataOutputs msOutputs; ...
        MemSecDataConstants msConstants; ...
        MemSecDataInternal msInternal; ...
        MemSecDataParameters msParameters }

    %assign ::CompiledModel.CoderDictionary.DefaultMemorySections = msRecords

    %with ::CompiledModel
        %if FcnShouldSetupCustomStorageClass()
            %% Setup custom storage classes if we have any
            %<SLibSetupCustomStorageClasses()>
        %endif
    %endwith

%endfunction

%% Function: SLibSetupAndCheckCustomSC =============================================================
%% Abstract:
%%   Setup custom storage classes.
%%
%function SLibSetupAndCheckCustomSC() void
    %assign ::BlockFcn = "GlobalMap"
    %<SLibSetupAndCheckCustomSCImpl()>
    %assign ::BlockFcn = "Unknown"
%endfunction %% SLibSetupAndCheckCustomSC

%% Function: FcnGetMemorySection ===================================================================
%% Abstract:
%%   Get memory section information given a data or function category record
%%
%function FcnGetMemorySection(categoryRec) void
    %assign ms = "Default"
    %if ISFIELD(categoryRec, "MemorySection")
        %assign msRec = categoryRec.MemorySection
        %assign ms = SLibGetMemorySectionForUUID(msRec.UUID)
    %endif

    %return ms
%endfunction %% FcnGetMemorySection

%% Function: FcnCacheRootBodyMthNames ==============================================================
%% Abstract:
%%   Cache method names for the root system based on code format
%%
%function FcnCacheRootBodyMthNames(rootSys,useCaps,useMdlName,reqMethods) void
    %assign mPrefix = useCaps ? "M" : "m"

    %if !ISFIELD(rootSys,"OutputFcn") && reqMethods.OutputFcn
        %if useMdlName
            %addtorecord rootSys OutputFcn "%<Name>_output"
        %else
            %addtorecord rootSys OutputFcn "%<mPrefix>dlOutputs"
        %endif
    %endif

    %if !ISFIELD(rootSys,"UpdateFcn") && reqMethods.UpdateFcn
        %if useMdlName
            %addtorecord rootSys UpdateFcn "%<Name>_update"
        %else
            %addtorecord rootSys UpdateFcn "%<mPrefix>dlUpdate"
        %endif
    %endif

    %if !ISFIELD(rootSys,"DerivativeFcn") && reqMethods.DerivativeFcn
        %if useMdlName
            %addtorecord rootSys DerivativeFcn "%<Name>_derivatives"
        %else
            %addtorecord rootSys DerivativeFcn "%<mPrefix>dlDerivatives"
        %endif
    %endif

    %if !ISFIELD(rootSys,"ProjectionFcn") && reqMethods.ProjectionFcn
        %if useMdlName
            %addtorecord rootSys ProjectionFcn "%<Name>_projection"
        %else
            %addtorecord rootSys ProjectionFcn "%<mPrefix>dlProjection"
        %endif
    %endif

    %if !ISFIELD(rootSys,"ForcingFunctionFcn") && reqMethods.ForcingFunctionFcn
        %if useMdlName
            %addtorecord rootSys ForcingFunctionFcn "%<Name>_forcingfunction"
        %else
            %addtorecord rootSys ForcingFunctionFcn "%<mPrefix>dlForcingFunction"
        %endif
    %endif

    %if !ISFIELD(rootSys,"MassMatrixFcn") && reqMethods.MassMatrixFcn
        %if useMdlName
            %addtorecord rootSys MassMatrixFcn "%<Name>_massmatrix"
        %else
            %addtorecord rootSys MassMatrixFcn "%<mPrefix>dlMassMatrix"
        %endif
    %endif

    %if !ISFIELD(rootSys,"InitSystemMatricesFcn") && reqMethods.InitSystemMatricesFcn
        %if useMdlName
            %addtorecord rootSys InitSystemMatricesFcn "%<Name>_initsystemmatrices"
        %else
            %addtorecord rootSys InitSystemMatricesFcn "%<mPrefix>dlInitSystemMatrices"
        %endif
    %endif

    %if !ISFIELD(rootSys,"SetupRuntimeResourcesFcn") && reqMethods.SetupRuntimeResourcesFcn
        %if useMdlName
            %addtorecord rootSys SetupRuntimeResourcesFcn "%<Name>_setupruntimeresources"
        %else
            %addtorecord rootSys SetupRuntimeResourcesFcn "%<mPrefix>dlSetupRuntimeResources"
        %endif
    %endif

    %if !ISFIELD(rootSys,"InitializeFcn") && reqMethods.InitializeFcn
        %if useMdlName
            %addtorecord rootSys InitializeFcn "%<Name>_initialize"
        %else
            %if CodeFormat == "S-Function"
                %addtorecord rootSys InitializeFcn "%<mPrefix>dlInitializeConditions"
            %else
                %addtorecord rootSys InitializeFcn "%<mPrefix>dlInitialize"
            %endif
        %endif
    %endif

    %if !ISFIELD(rootSys,"SystemInitializeFcn") && reqMethods.SystemInitializeFcn
        %if useMdlName
            %addtorecord rootSys SystemInitializeFcn "%<Name>_initialize"
        %else
            %if CodeFormat == "S-Function"
                %addtorecord rootSys SystemInitializeFcn "%<mPrefix>dlInitializeConditions"
            %else
                %addtorecord rootSys SystemInitializeFcn "%<mPrefix>dlInitialize"
            %endif
        %endif
    %endif

    %if !ISFIELD(rootSys,"SystemResetFcn") && reqMethods.SystemResetFcn
        %if useMdlName
            %addtorecord rootSys SystemResetFcn "%<Name>_reset"
        %else
            %addtorecord rootSys SystemResetFcn "%<mPrefix>dlReset"
        %endif
    %endif

    %if !ISFIELD(rootSys,"SharedInitializeFcn") && reqMethods.SharedInitializeFcn
        %if useMdlName
            %addtorecord rootSys SharedInitializeFcn "%<Name>_sharedInitialize"
        %else
            %addtorecord rootSys SharedInitializeFcn "%<mPrefix>dlSharedInitialize"
        %endif
    %endif

    %if !ISFIELD(rootSys,"EnableFcn") && reqMethods.EnableFcn
        %if useMdlName
            %addtorecord rootSys EnableFcn "%<Name>_enable"
        %else
            %addtorecord rootSys EnableFcn "%<mPrefix>dlEnable"
        %endif
    %endif

    %if !ISFIELD(rootSys,"DisableFcn") && reqMethods.DisableFcn
        %if useMdlName
            %addtorecord rootSys DisableFcn "%<Name>_disable"
        %else
            %addtorecord rootSys DisableFcn "%<mPrefix>dlDisable"
        %endif
    %endif

    %if !ISFIELD(rootSys,"ZeroCrossingFcn") && reqMethods.ZeroCrossingFcn
        %if useMdlName
            %addtorecord rootSys ZeroCrossingFcn "%<Name>_zeroCrossings"
        %else
            %addtorecord rootSys ZeroCrossingFcn "%<mPrefix>dlZeroCrossings"
        %endif
    %endif

    %if !ISFIELD(rootSys,"StartFcn") && reqMethods.StartFcn
        %if useMdlName
            %addtorecord rootSys StartFcn "%<Name>_start"
        %else
            %addtorecord rootSys StartFcn "%<mPrefix>dlStart"
        %endif
    %endif

    %if !ISFIELD(rootSys,"CleanupRuntimeResourcesFcn") && reqMethods.CleanupRuntimeResourcesFcn
        %if useMdlName
            %addtorecord rootSys CleanupRuntimeResourcesFcn "%<Name>_cleanupruntimeresources"
        %else
            %addtorecord rootSys CleanupRuntimeResourcesFcn "%<mPrefix>dlCleanupRuntimeResources"
        %endif
    %endif

    %if !ISFIELD(rootSys,"TerminateFcn") && reqMethods.TerminateFcn
        %if useMdlName
            %addtorecord rootSys TerminateFcn "%<Name>_terminate"
        %else
            %addtorecord rootSys TerminateFcn "%<mPrefix>dlTerminate"
        %endif
    %endif

    %if !ISFIELD(rootSys,"ConstCodeFcn") && reqMethods.ConstCodeFcn
        %if useMdlName
            %addtorecord rootSys ConstCodeFcn "%<Name>_Const"
        %else
            %addtorecord rootSys ConstCodeFcn "%<mPrefix>dlConst"
        %endif
    %endif

    %if !ISFIELD(rootSys,"ModelInitialize") && reqMethods.ModelInitializeFcn
        %if useMdlName
            %addtorecord rootSys ModelInitializeFcn "%<Name>_Initialize"
        %else
            %addtorecord rootSys ModelInitializeFcn "%<mPrefix>dlInitialize"
        %endif
    %endif
%endfunction %% FcnCacheRootBodyMthNames


%% Function: FcnSetupRootBodyReqMths ===============================================================
%% Abstract:
%%   Cache the root methods that are required by each code format
%%
%function FcnSetupRootBodyReqMths() void
    %%
    %% Initialize the record to have no methods
    %%
    %createrecord reqBodyMethods \
    {\
        EnableFcn            TLC_FALSE;\
        DisableFcn           TLC_FALSE;\
        SetupRuntimeResourcesFcn TLC_FALSE;\
        InitializeFcn        TLC_FALSE;\
        SystemInitializeFcn  TLC_FALSE;\
        SystemResetFcn       TLC_FALSE;\
        SharedInitializeFcn  TLC_FALSE;\
        StartFcn             TLC_FALSE;\
        OutputFcn            TLC_FALSE;\
        UpdateFcn            TLC_FALSE;\
        OutputUpdateFcn      TLC_FALSE;\
        DerivativeFcn        TLC_FALSE;\
        ProjectionFcn        TLC_FALSE;\
        ForcingFunctionFcn   TLC_FALSE;\
        MassMatrixFcn        TLC_FALSE;\
        InitSystemMatricesFcn TLC_FALSE;\
        CleanupRuntimeResourcesFcn TLC_FALSE;\
        TerminateFcn         TLC_FALSE;\
        ConstCodeFcn         TLC_FALSE;\
        ModelInitializeFcn   TLC_FALSE;\
        ZeroCrossingFcn      TLC_FALSE\
    }

    %switch CodeFormat
      %case "RealTime"
        %assign reqBodyMethods.StartFcn            = TLC_TRUE
        %assign reqBodyMethods.SystemInitializeFcn = TLC_TRUE
        %assign reqBodyMethods.SystemResetFcn      = TLC_TRUE
        %assign reqBodyMethods.EnableFcn           = TLC_TRUE
        %assign reqBodyMethods.OutputFcn           = TLC_TRUE
        %assign reqBodyMethods.UpdateFcn           = TLC_TRUE
        %assign reqBodyMethods.DerivativeFcn       = TLC_TRUE
        %assign reqBodyMethods.ProjectionFcn       = TLC_TRUE
        %assign reqBodyMethods.ForcingFunctionFcn  = TLC_TRUE
        %assign reqBodyMethods.MassMatrixFcn       = TLC_TRUE
        %assign reqBodyMethods.InitSystemMatricesFcn = TLC_TRUE
        %assign reqBodyMethods.TerminateFcn        = TLC_TRUE
        %if isRSimWithSolverModule %% ModelReference is ok. Embedded-C supports all
            %assign reqBodyMethods.ZeroCrossingFcn = TLC_TRUE
        %endif
        %assign reqBodyMethods.ConstCodeFcn        = TLC_TRUE
        %break
      %case "S-Function"
        %if Accelerator
            %assign reqBodyMethods.OutputFcn           = TLC_TRUE
            %assign reqBodyMethods.UpdateFcn           = TLC_TRUE
            %assign reqBodyMethods.DerivativeFcn       = TLC_TRUE
            %assign reqBodyMethods.ProjectionFcn       = TLC_TRUE
            %assign reqBodyMethods.ForcingFunctionFcn  = TLC_TRUE
            %assign reqBodyMethods.MassMatrixFcn       = TLC_TRUE
            %assign reqBodyMethods.InitSystemMatricesFcn = TLC_TRUE
            %assign reqBodyMethods.ZeroCrossingFcn     = TLC_TRUE
            %assign reqBodyMethods.TerminateFcn        = TLC_TRUE
            %assign reqBodyMethods.SetupRuntimeResourcesFcn  = TLC_TRUE
            %assign reqBodyMethods.CleanupRuntimeResourcesFcn = TLC_TRUE
        %else
            %assign reqBodyMethods.StartFcn            = TLC_TRUE
            %assign reqBodyMethods.SystemInitializeFcn = TLC_TRUE
            %assign reqBodyMethods.SystemResetFcn      = TLC_TRUE
            %assign reqBodyMethods.EnableFcn           = TLC_TRUE
            %assign reqBodyMethods.DisableFcn          = TLC_TRUE
            %assign reqBodyMethods.OutputFcn           = TLC_TRUE
            %assign reqBodyMethods.UpdateFcn           = TLC_TRUE
            %assign reqBodyMethods.DerivativeFcn       = TLC_TRUE
            %assign reqBodyMethods.ProjectionFcn       = TLC_TRUE
            %assign reqBodyMethods.ForcingFunctionFcn  = TLC_TRUE
            %assign reqBodyMethods.MassMatrixFcn       = TLC_TRUE
            %assign reqBodyMethods.InitSystemMatricesFcn = TLC_TRUE
            %assign reqBodyMethods.ZeroCrossingFcn     = TLC_TRUE
            %assign reqBodyMethods.TerminateFcn        = TLC_TRUE
            %assign reqBodyMethods.ConstCodeFcn        = TLC_TRUE
            %assign reqBodyMethods.SetupRuntimeResourcesFcn  = TLC_TRUE
            %assign reqBodyMethods.CleanupRuntimeResourcesFcn = TLC_TRUE
        %endif
        %break
      %case "Embedded-C"
      %case "Ada"
        %assign reqBodyMethods.StartFcn            = TLC_TRUE
        %assign reqBodyMethods.SystemInitializeFcn = TLC_TRUE
        %assign reqBodyMethods.SystemResetFcn      = TLC_TRUE
        %assign reqBodyMethods.EnableFcn           = TLC_TRUE
        %if EXISTS(GenerateErtSFunction) && ...
            ::GenerateErtSFunction == 1
            %% ERT sfunction need generate disable function
            %% in it wrapper
            %assign reqBodyMethods.DisableFcn      = TLC_TRUE
        %endif
        %assign reqBodyMethods.OutputFcn           = TLC_TRUE
        %assign reqBodyMethods.UpdateFcn           = TLC_TRUE
        %assign reqBodyMethods.DerivativeFcn       = TLC_TRUE
        %assign reqBodyMethods.ProjectionFcn       = TLC_TRUE
        %assign reqBodyMethods.ForcingFunctionFcn  = TLC_TRUE
        %assign reqBodyMethods.MassMatrixFcn       = TLC_TRUE
        %assign reqBodyMethods.InitSystemMatricesFcn = TLC_TRUE
        %assign reqBodyMethods.ZeroCrossingFcn     = TLC_TRUE
        %assign reqBodyMethods.TerminateFcn        = TLC_TRUE
        %assign reqBodyMethods.ConstCodeFcn        = TLC_TRUE
        %assign reqBodyMethods.ModelInitializeFcn  = TLC_TRUE
        %break
      %default
        %break
    %endswitch

    %return reqBodyMethods

%endfunction %% FcnSetupRootBodyReqMths

%function FcnParamsAreGlobalStruct() void
    %switch CodeFormat
      %case "RealTime"
        %return TLC_TRUE
        %break
      %case "S-Function"
        %return TLC_TRUE
        %break
      %case "Embedded-C"
        %return TLC_TRUE
        %break
      %default
        %return TLC_FALSE
        %break
    %endswitch
%endfunction


%% Function: FcnSetupRootPrmHdrReqInstances ========================================================
%% Abstract:
%%   Setup the required root parameter data instance vectors for the various
%%   code formats
%%
%function FcnSetupRootPrmHdrReqInstances(rootSys) void

    %<LibAddToCompiledModel("XQualifier",     IOQualifier)>
    %<LibAddToCompiledModel("UQualifier",     IOQualifier)>
    %<LibAddToCompiledModel("YQualifier",     IOQualifier)>
    %<LibAddToCompiledModel("PQualifier",     IOQualifier)>
    %<LibAddToCompiledModel("BQualifier",     IOQualifier)>
    %<LibAddToCompiledModel("DWorkQualifier", IOQualifier)>
    %<LibAddToCompiledModel("PrevZCQualifier",IOQualifier)>
    %<LibAddToCompiledModel("ConstBQualifier",IOQualifier)>
    %<LibAddToCompiledModel("ConstPQualifier",".")>

    %%
    %% Initialize the record to have no instances
    %%

    %createrecord reqPrmHdrInsts \
    {\
        GroupedCustomDataInst  TLC_FALSE;\
        ParamsInst             TLC_FALSE;\
        ConstBlockIOInst       TLC_FALSE;\
        ConstParamInst         TLC_FALSE;\
        ExpGlobalSigsInst      TLC_FALSE;\
        ExpGlobalPrmsInst      TLC_FALSE;\
        BlockIOInst            TLC_FALSE;\
        ExpGlobalDworkInst     TLC_FALSE;\
        ContStatesInst         TLC_FALSE;\
        ContStatesDisabledInst TLC_FALSE;\
        PeriodicContStatesInst TLC_FALSE;\
        MassMatricesInst       TLC_FALSE;\
        DworkInst              TLC_FALSE;\
        PrevZCStatesInst       TLC_FALSE;\
        ExtInpsInst            TLC_FALSE;\
        ExtOutputsInst         TLC_FALSE;\
        SimStructInst          TLC_FALSE;\
        GlobalPrmDataCacheInst TLC_FALSE\
    }

    %switch CodeFormat
      %case "RealTime"
        %assign reqPrmHdrInsts.GroupedCustomDataInst  = TLC_TRUE
        %assign reqPrmHdrInsts.ParamsInst             = FcnParamsAreGlobalStruct()
        %assign reqPrmHdrInsts.ConstBlockIOInst       = TLC_TRUE
        %assign reqPrmHdrInsts.ConstParamInst         = TLC_TRUE
        %assign reqPrmHdrInsts.ExpGlobalSigsInst      = TLC_TRUE
        %assign reqPrmHdrInsts.ExpGlobalPrmsInst      = TLC_TRUE
        %assign reqPrmHdrInsts.BlockIOInst            = TLC_TRUE
        %assign reqPrmHdrInsts.ExpGlobalDworkInst     = TLC_TRUE
        %assign reqPrmHdrInsts.ContStatesInst         = TLC_TRUE
        %assign reqPrmHdrInsts.ContStatesDisabledInst = TLC_TRUE
        %assign reqPrmHdrInsts.PeriodicContStatesInst = TLC_TRUE
        %assign reqPrmHdrInsts.MassMatricesInst       = TLC_TRUE
        %assign reqPrmHdrInsts.DworkInst              = TLC_TRUE
        %assign reqPrmHdrInsts.PrevZCStatesInst       = TLC_TRUE
        %assign reqPrmHdrInsts.ExtInpsInst            = TLC_TRUE
        %assign reqPrmHdrInsts.ExtOutputsInst         = TLC_TRUE
        %assign reqPrmHdrInsts.SimStructInst          = TLC_TRUE
        %assign reqPrmHdrInsts.GlobalPrmDataCacheInst = TLC_TRUE

        %break
      %case "S-Function"
        %if Accelerator
            %assign reqPrmHdrInsts.ParamsInst             = FcnParamsAreGlobalStruct()
            %assign reqPrmHdrInsts.ConstBlockIOInst       = TLC_TRUE
            %assign reqPrmHdrInsts.ConstParamInst         = TLC_TRUE
            %assign reqPrmHdrInsts.GlobalPrmDataCacheInst = TLC_TRUE
        %else
            %assign reqPrmHdrInsts.ParamsInst             = FcnParamsAreGlobalStruct()
            %assign reqPrmHdrInsts.ConstBlockIOInst   = TLC_TRUE
            %assign reqPrmHdrInsts.ConstParamInst     = TLC_TRUE
            %assign reqPrmHdrInsts.ExpGlobalSigsInst  = TLC_TRUE
            %assign reqPrmHdrInsts.ExpGlobalPrmsInst  = TLC_TRUE
        %endif
        %break
      %case "Embedded-C"
        %assign mdlRef = IsModelReferenceTarget()
        %assign multiOrMdlref = MultiInstanceERTCode || mdlRef

        %% In what cases do we generate instantiation code for unstructured
        %% global data as part of the body of the generated code?
        %%
        %% ---------------------------------------------------------------
        %%                  MdlRef                       |       Not MdlRef
        %% ---------------------------------------------------------------
        %%   SIM  | Coder (SimStructBased) |  Coder      | SimStructBased | Other
        %% ---------------------------------------------------------------
        %%  No(1) |         No(2)            |  No(2)    |        Y       |   Y
        %%
        %% NOTE:
        %% (1) Global data instances generated in model reference S-Fcn
        %% (2) Global data instances generated by top model.
        %assign genUnstrParamInsts = !mdlRef

        %assign reqPrmHdrInsts.GroupedCustomDataInst  = TLC_TRUE
        %assign reqPrmHdrInsts.ExpGlobalSigsInst      = TLC_TRUE
        %assign reqPrmHdrInsts.ExpGlobalPrmsInst      = genUnstrParamInsts
        %assign reqPrmHdrInsts.ExpGlobalDworkInst     = TLC_TRUE

        %assign reqPrmHdrInsts.DworkInst              = !multiOrMdlref
        %assign reqPrmHdrInsts.PrevZCStatesInst       = !multiOrMdlref
        %assign reqPrmHdrInsts.ContStatesInst         = !multiOrMdlref
        %assign reqPrmHdrInsts.ContStatesDisabledInst = !multiOrMdlref
        %assign reqPrmHdrInsts.PeriodicContStatesInst = !multiOrMdlref
        %assign reqPrmHdrInsts.MassMatricesInst       = !multiOrMdlref
        %assign reqPrmHdrInsts.BlockIOInst            = !multiOrMdlref
        %assign reqPrmHdrInsts.ExtInpsInst            = !multiOrMdlref
        %assign reqPrmHdrInsts.ExtOutputsInst         = !multiOrMdlref
        %assign reqPrmHdrInsts.SimStructInst          = !multiOrMdlref

        %assign reqPrmHdrInsts.ConstBlockIOInst       = TLC_TRUE
        %assign reqPrmHdrInsts.ConstParamInst         = TLC_TRUE

        %% Parameters result in a global structure except for multiERT
        %assign reqPrmHdrInsts.ParamsInst = FcnParamsAreGlobalStruct()

        %assign reqPrmHdrInsts.GlobalPrmDataCacheInst = TLC_TRUE

        %if MultiInstanceERTCode
            %assign ::CompiledModel.BQualifier      = "->"
            %assign ::CompiledModel.PQualifier      = FcnParamsAreGlobalStruct() ? "." : "->"
            %assign ::CompiledModel.DWorkQualifier  = "->"
            %assign ::CompiledModel.XQualifier      = "->"
            %assign ::CompiledModel.PrevZCQualifier = "->"
            %if RootIOStructures
                %if !GenerateClassInterface
                    %assign ::CompiledModel.UQualifier      = "->"
                    %assign ::CompiledModel.YQualifier      = "->"
                %else
                    %assign ::CompiledModel.UQualifier      = "."
                    %assign ::CompiledModel.YQualifier      = "."
                %endif
            %else
                %if SLibHasGlobalExternalInputsWithFPC()
                    %assign ::CompiledModel.UQualifier      = "->"
                %else
                    %assign ::CompiledModel.UQualifier      = "_"
                %endif
                %if SLibHasGlobalExternalOutputsWithFPC()
                    %assign ::CompiledModel.YQualifier      = "->"
                %else
                    %assign ::CompiledModel.YQualifier      = "_"
                %endif
            %endif
        %endif
        %break
      %default
        %break
    %endswitch

    %<LibAddToSystem(rootSys, "ReqRootPrmHdrDataInsts", reqPrmHdrInsts)>

%endfunction %% FcnSetupRootPrmHdrReqInstances


%% Function: SLibRootSystemMethodProps =============================================================
%% Abstract:
%%   Setup properties of the methods corresponding to the Root system
%%
%function SLibRootSystemMethodProps() void
    %with ::CompiledModel
        %assign rootIdx    = NumSystems-1
        %assign rootSystem = System[rootIdx]

        %%
        %% Setup root body and header method property defaults
        %%

        %% Do we need "static" prefix for root body methods?
        %assign rootBodyMthsStatic         = TLC_FALSE %% assume
        %% Do we capitalize the start of root body methods names?
        %assign rootBodyMthsCaps           = TLC_FALSE %% assume
        %% Do we use the name of the model in the root methods names (ERT)?
        %assign rootBodyMthUseMdlName      = TLC_FALSE %% assume
        %% Do we call mdlInitialize and mdlEnable in mdlStart?
        %assign rootBodyStartCallsInitEnab = TLC_FALSE %% assume
        %% Do we need tid for the root body output, update methods?
        %assign rootBodyTIDneeded          = TLC_FALSE %% assume
        %% Do we need verbose comments in model header?
        %assign rootHdrVerboseCmnts        = TLC_TRUE  %% assume
        %% Do we need generic defines to be made in the header?
        %assign rootHdrGenericDefines      = TLC_FALSE %% assume
        %% Do we need to declare prm instances to be static?
        %assign rootPrmHdrInstsStatic      = TLC_FALSE %% assume

        %%
        %% Setup root body and header method properties based on code format
        %%
        %switch CodeFormat
          %case "RealTime"
            %assign rootBodyMthsCaps           = TLC_TRUE
            %assign rootBodyStartCallsInitEnab = TLC_TRUE
            %assign rootBodyTIDneeded          = TLC_TRUE
            %assign rootHdrGenericDefines      = TLC_TRUE
            %break
          %case "Embedded-C"
            %assign rootBodyMthUseMdlName = TLC_TRUE
            %assign tid01Eq = ISEQUAL(SolverType, "FixedStep") && ...
                FixedStepOpts.TID01EQ
            %if SLibFcnProtoCtrlActive() || ...
                GenerateClassInterface
                %assign rootBodyTIDneeded  = TLC_FALSE
            %elseif GenerateGRTWrapper
                %assign rootBodyTIDneeded = TLC_FALSE
            %elseif NumRuntimeExportedRates == 1
                %% Single rate
                %assign rootBodyTIDneeded  = TLC_FALSE
            %elseif NumRuntimeExportedRates == 2 && tid01Eq && ...
                NumContStates == 0
                %% tid01eq special case
                %assign rootBodyTIDneeded  = TLC_FALSE
            %elseif SLibSingleTasking()
                %% multirate single tasking model
                %assign rootBodyTIDneeded  = !ERTRemoveTidArgForSingleTaskingModel
            %endif
            %if UsingMalloc && isGRTMalloc
                %assign rootPrmHdrInstsStatic      = TLC_TRUE
                %% dumps /* Block Parameters (%<::AutoOrDefaultStorageClass> storage) */ to model.c
            %endif
            %break
          %case "S-Function"
            %assign rootBodyMthsStatic      = TLC_TRUE
            %assign rootBodyTIDneeded       = TLC_TRUE
            %if Accelerator
                %assign rootHdrVerboseCmnts = TLC_FALSE
            %endif
            %break
          %case "Ada"
          %default
            %break
        %endswitch

        %%
        %% Cache into global variables
        %%
        %assign ::RootBodyMthsStatic         = rootBodyMthsStatic
        %assign ::RootBodyStartCallsInitEnab = rootBodyStartCallsInitEnab
        %assign ::RootBodyTIDneeded          = rootBodyTIDneeded
        %assign ::RootHdrVerboseCmnts        = rootHdrVerboseCmnts
        %assign ::RootHdrGenericDefines      = rootHdrGenericDefines
        %assign ::RootPrmHdrInstsStatic      = rootPrmHdrInstsStatic

        %with ::CompiledModel
            %assign rootIdx    = NumSystems-1
            %assign rootSystem = System[rootIdx]

            %%
            %% Setup which methods are to be generated in the body file
            %% for each code format
            %%
            %assign reqMethods = FcnSetupRootBodyReqMths()

            %%
            %% Setup the names of the root methods
            %%
            %<FcnCacheRootBodyMthNames(rootSystem, rootBodyMthsCaps, ...
                rootBodyMthUseMdlName, reqMethods)>

            %%
            %% Setup which data vector instances are setup in
            %% the parameters section of model.c for the various code formats
            %%
            %<FcnSetupRootPrmHdrReqInstances(rootSystem)>

        %endwith

    %endwith
%endfunction %% SLibRootSystemMethodProps

%% Function: SLibSetupTLCvtable ====================================================================
%% Abstract:
%%   Setup TLC replacement v-table with defaults
%%
%function SLibSetupTLCvtable() void
    %with ::CompiledModel
        %%fixed-point Outputs function of Product block:
        %if !EXISTS(productOutputsFixptType)
            %assign productOutputsFixptType = "Product"
            %<LibAddToCompiledModel("productOutputsFixptType",productOutputsFixptType)>
        %endif

        %if !EXISTS(productOutputsFixptFunc)
            %assign productOutputsFixptFunc = "OutputsFixpt"
            %<LibAddToCompiledModel("productOutputsFixptFunc",productOutputsFixptFunc)>
        %endif

        %%fixed-point Outputs function of Sum block:
        %if !EXISTS(sumOutputsFixptType)
            %assign sumOutputsFixptType = "Sum"
            %<LibAddToCompiledModel("sumOutputsFixptType",sumOutputsFixptType)>
        %endif

        %if !EXISTS(sumOutputsFixptFunc)
            %assign sumOutputsFixptFunc = "OutputsFixpt"
            %<LibAddToCompiledModel("sumOutputsFixptFunc",sumOutputsFixptFunc)>
        %endif

        %%fixed-point Outputs function of Gain block:
        %if !EXISTS(gainOutputsFixptType)
            %assign gainOutputsFixptType = "Gain"
            %<LibAddToCompiledModel("gainOutputsFixptType",gainOutputsFixptType)>
        %endif

        %if !EXISTS(gainOutputsFixptFunc)
            %assign gainOutputsFixptFunc = "FixptOutputs"
            %<LibAddToCompiledModel("gainOutputsFixptFunc",gainOutputsFixptFunc)>
        %endif
    %endwith
%endfunction %% SLibSetupTLCvtable

%function SLibSetupCustomCode() void
    %with ConfigSet
        %if EXISTS(CustomSourceCode)
            %<LibSourceFileCustomCode(CustomSourceCode, "header")>
        %endif

        %if EXISTS(CustomHeaderCode)
            %% RAccel main file is a .c file which can fail to compile if C++ custom
            %% header code is brought in.  Also, the raccel main file does not need
            %% the custom header since it is a fixed main.  Only the model.c can be
            %% customized and that will still bring in the custom header.
            %if isRAccel
                %assign CustomHeaderCodeRAccel = "#ifndef IN_RACCEL_MAIN\n%<CustomHeaderCode>\n#endif"
                %<LibHeaderFileCustomCode(CustomHeaderCodeRAccel, "header")>
            %else
                %<LibHeaderFileCustomCode(CustomHeaderCode, "header")>
            %endif
        %endif

        %if EXISTS(CustomInitializer)
            %assign rootSys = ::CompiledModel.System[CompiledModel.NumSystems-1]
            %if !WHITE_SPACE(CustomInitializer)
                %assign rootSys.InitializeMethodHasUserData = TLC_TRUE
            %endif
            %<LibSystemInitializeCustomCode(rootSys, CustomInitializer, "execution")>
        %endif

        %if EXISTS(CustomTerminator)
            %with ::CompiledModel
                %<LibMdlTerminateCustomCode(CustomTerminator, "execution")>
            %endwith
        %endif
    %endwith
%endfunction

%% Function: SLibIsCPPEncapMdlRefBuild =============================================================
%% Abstract:
%%   Return whether the build is for C++ encapsulation MdlRef target.
%%
%function SLibIsCPPEncapMdlRefBuild() void
    %return GenerateClassInterface && IsModelReferenceTarget()
%endfunction %% SLibIsCPPEncapMdlRefBuild

%% Function: SLibCacheDataAlignmentFlags ===========================================================
%% Abstract:
%%   Cache the registered data alignment flags.
%%
%function SLibCacheDataAlignmentFlags() void
    %assign ::fieldDAFlag = FEVAL("rtwprivate", "da_support", ::CompiledModel.Name, "DATA_ALIGNMENT_STRUCT_FIELD")
    %assign ::structDAFlag = FEVAL("rtwprivate", "da_support", ::CompiledModel.Name, "DATA_ALIGNMENT_WHOLE_STRUCT")
    %assign ::localDAFlag = FEVAL("rtwprivate", "da_support", ::CompiledModel.Name, "DATA_ALIGNMENT_LOCAL_VAR")
    %assign ::globalDAFlag = FEVAL("rtwprivate", "da_support", ::CompiledModel.Name, "DATA_ALIGNMENT_GLOBAL_VAR")
    %assign ::fieldAlign = fieldDAFlag.supported
    %assign ::structAlign = structDAFlag.supported
    %assign ::localAlign = localDAFlag.supported

%endfunction %% SLibCacheDataAlignmentFlags

%function SLibSetupSimulinkFunctionFPC() void
    %% Mirror enum defined in SlFcnCallCompArgInfo::PassByType

    %% NOTE: everything after POINTER should be pointer (see use in codeinfolib.tlc::AddSimulinkFunctionInfo)
    %addtorecord ::CompiledModel  \
    eSLFARG_PASSBYTYPE {          \
        AUTO 0                      \
        CONST_DATA 1                \
        ARR_SIZEONE 2               \
        CONST_ARR_SIZEONE 3         \
        POINTER 4                   \
        POINTER_VOID 5              \
        POINTER_CONST_DATA 6        \
        POINTER_CONST_VOID 7        \
        CONST_POINTER_CONST_DATA 8  \
    }
%endfunction

%% Function: SLibGetMemorySectionForUUID ===========================================================
%% Abstract:
%%   Return the memory section record given its UUID
%%   NOTE: For legacy memory sections, the class name is returned
%function SLibGetMemorySectionForUUID(msUUID) void
    %assign ms = "Default"
    %if CGMODEL_ACCESS("MemorySection.IsLegacy", msUUID)
        %assign ms = CGMODEL_ACCESS("MemorySection.ClassName", msUUID)
    %else
        %% New Memory Section
        %% NOTE: STRING is used to escape characters like double-quotes
        %assign comment = FcnHandleNewLineForMemSec(CGMODEL_ACCESS("MemorySection.Comment", msUUID))
        %assign preStatement = FcnHandleNewLineForMemSec(CGMODEL_ACCESS("MemorySection.PrePragma", msUUID))
        %assign postStatement = FcnHandleNewLineForMemSec(CGMODEL_ACCESS("MemorySection.PostPragma", msUUID))
        %createrecord ms { \
            IsConst TLC_FALSE \
            IsVolatile TLC_FALSE \
            Qualifier "" \
            Comment comment \
            PrePragma preStatement \
            PostPragma postStatement \
            PragmaPerVar %<CGMODEL_ACCESS("MemorySection.PragmaPerVar", msUUID)>}
    %endif

    %return ms
%endfunction %% SLibGetMemorySectionForUUID

%function ShouldUseMemberFunctionsForRTM() void
    %if !CGMODEL_ACCESS("CGModel.RTMMacrosAsMembersEnabled")
        %return TLC_FALSE
    %endif
    %if ::GRTInterface
        %return TLC_FALSE
    %endif
    %if !SLibIsERTTarget()
        %return TLC_FALSE
    %endif
    %if IsModelReferenceSimTarget()
        %return TLC_FALSE
    %endif
    %if (EXISTS(ExtMode) && ExtMode == 1)
        %return TLC_FALSE
    %endif
    %return (GenerateSampleERTMain || IsModelReferenceTarget())
%endfunction

%endif %% _SETUPLIB_

%% [EOF] setuplib.tlc
