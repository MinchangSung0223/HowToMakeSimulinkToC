%% ============================================================================
%% File : commonbodlib.tlc
%%
%% Abstract:
%%      This system TLC library file contains functions that are common
%%      between the different code generators for producing the model's
%%      source file.
%%
%%      The functions provide for caching code for all systems and also dumping
%%      the cached buffers.
%%
%% Note: The only CodeFormat dependencies allowed in this file are for:
%%       1) Creating function prototypes for subsystems
%%       2) Caching body code
%%
%%
%% Copyright 1994-2024 The MathWorks, Inc.
%%
%% ============================================================================
%include "dumpcodemetrics.tlc"
%selectfile NULL_FILE

%if EXISTS(_COMMONBODLIB_) == 0
%assign _COMMONBODLIB_ = 1

%% Function FcnForcedHasTIDArg(sys) void
%% Abstract:
%%   Return true is parameter tid is forced to include
%% for uniform subsystem interface.
%%
%% TopTester: test/toolbox/simulink/variants/var-inline-vsink/tmVarSinkRateTransBlk_VC1.m
%%
%function FcnForcedHasTIDArg(sys)
    %return (sys.Type == "root") && RootBodyTIDneeded
%endfunction

%% Function: FcnSysAccessedTID =====================================================================
%% Abstract:
%%      returns 1 if TID was used, then reset the flag
%%
%% TopTester: test/toolbox/simulink/variants/var-inline-vsink/tmVarSinkRateTransBlk_VC1.m
%%
%function FcnSysAccessedTID() void
    %if TLC_TRUE == ::CompiledModel.NeedTID
        %return 1
    %else
        %return 0
    %endif
%endfunction

%% Function: SLibSetTIDAddedInTLC ==================================================================
%% Abstract:
%%   Sets the flag that will ensure unused TID argument handling.
%%
%function SLibSetTIDAddedInTLC(system) void
    %assign system.TIDArgAddedInTLC = 1
%endfunction

%% Function: FcnSetSystemFcnNeedTIDFlag ============================================================
%% Abstract:
%%   Set NeedTIDIn%<Type> flag if tid is accessed.
%%   Set ForcedNeedTIDIn%<type>Fcn flags if tid is forced to be included
%%   in subsystem interface.
%%
%% TopTester: test/toolbox/simulink/variants/var-inline-vsink/tmVarSinkRateTransBlk_VC1.m
%%
%function FcnSetSystemFcnNeedTIDFlag(system, type) void
    %if FcnSysAccessedTID()
        %<LibSetSystemField(system, "NeedTIDIn%<type>", TLC_TRUE)>
    %elseif FcnForcedHasTIDArg(system)
        %<LibSetSystemField(system, "NeedTIDIn%<type>", TLC_FALSE)>
        %addtorecord system ForcedNeedTIDIn%<type> TLC_TRUE
    %endif
%endfunction

%% Function: FcnHasSystemFcn =======================================================================
%% Abstract:
%%   Returns true if a system functions has been generated by the Simulink Coder middle end.
%%
%function FcnHasSystemFcn(aSystem, aFcnType, aTID) void
    %assign module = ::CompiledModel.RTWCGModules.RTWCGModule[aSystem.CGIRModuleIdx]
    %if ISFIELD(module, "SystemFunctionTypes")
        %assign fcnType = ISEMPTY(aTID) ? aFcnType : "%<aFcnType>_TID%<aTID>"
        %return ISFIELD(module.SystemFunctionTypes, fcnType)
    %endif
    %return TLC_FALSE
%endfunction


%% Function: FcnHandlesUnusedTIDArg ================================================================
%% Abstract:
%%
%function FcnHandlesUnusedTIDArg(ss, type) void
    %openfile retBuf
    %if !SLibIsExplicitTaskingExportFcnRateGrouping(type, ss.CurrentTID)
        %if 1 == ss.TIDArgAddedInTLC && LibSystemFcnNeedsTID(ss,type)
            %if ISFIELD(ss, "ForcedNeedTIDIn" + type)
                %assert !LibGetSystemField(ss, "NeedTIDIn" + type)
                %<SLibUnusedParameter(::tTID)>

            %elseif SLibSystemFcnPeriodicRateGrouping(ss, type) && ...
                LibGetSystemField(ss, "NeedTIDIn" + type)
                /* If subsystem generates rate grouping %<type> functions,
                * when %<::tTID> is used in %<type> function for one rate,
                * all %<type> functions include %<::tTID> as argument.
                * As result, some %<type> functions may have unused %<::tTID>.
                */
                %<SLibUnusedParameter(::tTID)>
            %endif
        %elseif SLibGetNeedLocalTIDInSystem(ss, type) && ...
            SLibSystemFcnPeriodicRateGrouping(ss, type)
            /* If subsystem generates rate grouping %<type> functions,
            * when %<::tTID> is used in %<type> function for one rate,
            * all %<type> functions include %<::tTID> as a local variable.
            * As result, some %<type> functions may have unused %<::tTID>.
            */
            %<SLibUnusedParameter(::tTID)>
        %endif
    %endif
    %closefile retBuf

    %return retBuf
%endfunction %%FcnHandlesUnusedTIDArg


%% Function: FcnHandlesUnusedRTMForSimplifiedInterface =============================================
%% Abstract:
%%      For modelref simplified interface, RTM may be added but not used in the
%%      function body. This function adds unused parameter code to such
%%      functions.
%%
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tmg1672961.m
%function FcnHandlesUnusedRTMForSimplifiedInterface(ss, sysFcn)
    %% This function handles the situation when the RTM is added to a function
    %% interface whereas the function has no body, thus the RTM is unused.
    %% In this case, RTMArg is NOT NEEDED, thus SysFcnArgNeeded should return false.
    %% On the other hand, the RTM is always added to the interface for simplified
    %% interface to make the interface predictable. Therefore, the function
    %% prototype should have RTM as its arg.
    %% Since this function ONLY handles this situation, it uses a string comparison
    %% to checks whether the function's parameter is equal to the added RTM arg.
    %assign tid = ss.CurrentTID
    %openfile retBuf
    %if ::CompiledModel.RTWCGModules.RTWCGModule[ss.CGIRModuleIdx].SimplifiedInterface
        %assign rtmArgDef = ss.Interface.RTMArgDef
        %assign isPeriodicRateGrouping = SLibSystemFcnPeriodicRateGrouping(ss, sysFcn)
        %if !SysFcnArgNeeded(sysFcn, rtmArgDef, tid, isPeriodicRateGrouping)
            %if isPeriodicRateGrouping && !WHITE_SPACE(tid)
                %assign fieldName = "%<sysFcn>TID%<tid>FcnInfo"
            %else
                %assign fieldName = "%<sysFcn>FcnInfo"
            %endif
            %if ISFIELD(ss.InstanceCache, fieldName)
                %assign fcnInfo = GETFIELD(ss.InstanceCache, fieldName)
                %assign rtmParam = "%<tSimStructType> * const %<tSimStruct>"
                %assign containsRTM = ...
                    CGMODEL_ACCESS("String.find", fcnInfo.Params, rtmParam) != -1
                %if (containsRTM)
                    %<SLibUnusedParameter(tSimStruct)>
                %endif
            %endif
        %endif
    %endif
    %closefile retBuf
    %return retBuf
%endfunction


%% Function: FcnDeclareCPIIfNeeded =================================================================
%% Abstract:
%%      returns 1 if CPI (Control Port Index) was used in a function-call
%%      subsystem.
%%
%function FcnDeclareCPIIfNeeded(system, fcn) void
    %assign tempName = "NeedCPIIn" + fcn
    %return LibGetSystemField(system, tempName)
%endfunction


%% Function: SLibSystemNonEmpty ====================================================================
%% Abstract:
%%    Returns true if a system generates some code
%%
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tmg1672961.m
%function SLibSystemNonEmpty(system)
    %assign nonEmpty = ...
        !LibSystemFcnIsEmpty(system, "Start")              || ...
        !LibSystemFcnIsEmpty(system, "ConstCode")              || ...
        !LibSystemFcnIsEmpty(system, "SetupRuntimeResources")     || ...
        !LibSystemFcnIsEmpty(system, "Initialize")         || ...
        !LibSystemFcnIsEmpty(system, "SystemInitialize")   || ...
        !LibSystemFcnIsEmpty(system, "SystemReset")        || ...
        !LibSystemFcnIsEmpty(system, "Output")             || ...
        !LibSystemFcnIsEmpty(system, "Update")             || ...
        !LibSystemFcnIsEmpty(system, "Derivative")         || ...
        !LibSystemFcnIsEmpty(system, "Projection")         || ...
        !LibSystemFcnIsEmpty(system, "ForcingFunction")    || ...
        !LibSystemFcnIsEmpty(system, "MassMatrix")         || ...
        !LibSystemFcnIsEmpty(system, "OutputUpdate")       || ...
        !LibSystemFcnIsEmpty(system, "FinalizeDims")       || ...
        !LibSystemFcnIsEmpty(system, "SetDims")       || ...
        !LibSystemFcnIsEmpty(system, "Enable")             || ...
        !LibSystemFcnIsEmpty(system, "Disable")            || ...
        !LibSystemFcnIsEmpty(system, "CleanupRuntimeResources")
    %return (nonEmpty)
%endfunction %% SLibSystemNonEmpty


%% Function: SLibSystemTerminateNonEmpty ===========================================================
%% Abstract:
%%   Returns true if a system terminate generates some code
%%
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tmg1672961.m
%%
%function SLibSystemTerminateNonEmpty(system) void
    %return !LibSystemFcnIsEmpty(system, "Terminate")
%endfunction %% SLibSystemTerminateNonEmpty


%% Function: SLibPassThroughArgsRequired ===========================================================
%% Abstract:
%%   Returns true if the system in question requires arguments to by passed.
%%
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-codegen/tg1375551.m
%% TopTester: test/toolbox/simulink/blocks/lib_Discrete/DiscreteTimeIntegrator/rtw/tNumerics_dintegrt_globalin.m
%%
%function SLibPassThroughArgsRequired(system) void
    %if LibSystemIsRoot(system)
        %if MultiInstanceERTCode || GenerateClassInterface || UsingMalloc ...
            || SLibFcnProtoCtrlActive() || CodeFormat == "S-Function"
            %return TLC_TRUE
        %endif
    %elseif LibSystemIsNonReusedFcn(system)
        %if (CodeFormat == "S-Function") || ...
            ISFIELD(system,"RTWSystemCodeOptIntf") || ...
            (system.CrossNoArgFcnBound && (UsingMalloc || IsModelRefScalableBuild()))
            %return TLC_TRUE
        %endif
    %elseif LibSystemIsReusedFcn(system)
        %return TLC_TRUE
    %endif
    %return TLC_FALSE
%endfunction %% SLibPassThroughArgsRequired


%% Function: SLibCopyRootInputsArgAccessedFlags ====================================================
%% Abstract:
%%   This function is used to copy the access flags in the root IO records
%%   from a callee to the caller function.
%%
%% TopTester: test/toolbox/simulink/blocks/lib_Discrete/DiscreteTimeIntegrator/rtw/tNumerics_dintegrt_globalin.m
%%
%function SLibCopyRootInputsArgAccessedFlags(aSystemRec, calleeName) void
    %%
    %if LibSystemIsRoot(aSystemRec) && SLibPassThroughArgsRequired(aSystemRec)
        %%
        %assign cTID    = aSystemRec.CurrentTID
        %assign isRG    = SLibSystemFcnPeriodicRateGrouping(aSystemRec, calleeName)
        %with ::CompiledModel.ExternalInputs
            %foreach idx = NumExternalInputs
                %assign extInp = ExternalInput[idx]
                %if extInp.StorageClass == "Auto" && ...
                    SysFcnArgNeeded(calleeName, extInp, cTID, isRG)
                    %<SLibAccessArgHelper(extInp,"",cTID)>
                %endif
            %endforeach
        %endwith
        %with ::CompiledModel.ExternalOutputs
            %foreach idx = NumExternalOutputs
                %assign extOut = ExternalOutput[idx]
                %if SysFcnArgNeeded(calleeName, extOut, cTID, isRG)
                    %<SLibAccessArgHelper(extOut,"",cTID)>
                %endif
            %endforeach
        %endwith
    %endif
%endfunction

%% Function: FcnIsSubFunctionCreationReq ===========================================================
%% Abstract:
%% (modIdx < calleeModIdx) the current module is calling a function
%% from a parent module. In this case we need to generate the argument
%% list from the parent system.
%% If calling from same module then make sure that there is no recursion and
%% we are not repeating generation of subfunctions
%%
%function FcnIsSubFunctionCreationReq(currModIdx, calleeSubFcnModIdx, calleeSubFcnMod, calleeSubFcn) void
    %if currModIdx < calleeSubFcnModIdx
        %return TLC_TRUE
    %endif
    %if currModIdx == calleeSubFcnModIdx
        %% process only when there is no reursion and we have not already processed callee
        %return !calleeSubFcnMod.HasRecursion && !calleeSubFcn.HasPassThroughArgsAtCallSet
    %endif
    %return TLC_FALSE
%endfunction  %% FcnIsSubFunctionCreationRe

%% Function: SLibCGCallSubFcn ======================================================================
%% Abstract:
%%   This function is used to call subfunctions in a module. It calls a specific
%%   TLC function for each argument generated in RTWCG.
%%
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-codegen/tg1375551.m
%%
%function SLibCGCallSubFcn(aFcnName, aArgVec, modIdx, fcnIdx, callIdx) void
    %%
    %assign thisModule    = RTWCGModules.RTWCGModule[modIdx]
    %assign thisFcn       = thisModule.Function[fcnIdx]
    %assign thisCall      = thisFcn.FunctionCall[callIdx]
    %assign calleeModIdx  = thisCall.CalleeIdx[0]
    %assign calleeFcnIdx  = thisCall.CalleeIdx[1]
    %assign calleeInstIdx = thisCall.CalleeIdx[2]
    %assign calleeModule  = RTWCGModules.RTWCGModule[calleeModIdx]
    %assign callee        = calleeModule.Function[calleeFcnIdx]
    %assign sep           = ""

    %% By virtue of calling a sub function, the caller
    %% is effectively accessing class internals and
    %% cannot be marked static
    %if !callee.IsShared
        %assign thisFcn.ForbidStaticMemberDecl = TLC_TRUE
    %endif
    %assign thisModuleReusedParentSystemIdx = ::CompiledModel.System[thisModule.CGSystemIdx].ReusedParentSystemIdx
    %assign DW_InterfaceData = SLibCG_GetInterfaceData(thisModuleReusedParentSystemIdx, ::BlockFcn, "DWork")
    %assign DWArgIsNeeded = SysFcnArgNeeded(aFcnName, DW_InterfaceData, ::CompiledModel.System[thisModule.CGSystemIdx].CurrentTID, SLibIsPeriodicRateGrouping())
    %if DWArgIsNeeded
        %<SLibCG_TrackDW(thisModuleReusedParentSystemIdx)>
    %endif

    %if thisFcn.IsShared
        %assign argStr = ""
        %foreach argIdx = callee.NumArgs
            %if callee.ArgAccessed[argIdx] > 0
                %assign argStr = argStr + sep + aArgVec[argIdx]
                %assign sep    = ", "
            %endif
        %endforeach
        %return callee.Name + "(" + argStr + ")"
    %endif
    %assign system       = ::CompiledModel.System[thisModule.CGSystemIdx]
    %assign sysIdx       = system.SystemIdx
    %assign isScalableMRSys = ...
        IsModelReferenceBaseSys(system) && IsModelRefScalableBuild()
    %%
    %<SLibCopyRootInputsArgAccessedFlags(system, callee.Name)>
    %<SLibCopyArgAccessedFlags(sysIdx, callee.Name, ::BlockFcn, ...
        system.CurrentTID, isScalableMRSys)>
    %%
    %% (modIdx > calleeModIdx) the current module is calling a function
    %% from a child module. We need to generated complete argument accesses
    %% in this case, similar to those that are created for reusable subsystem
    %% function calls.
    %%
    %if modIdx > calleeModIdx
        %assign hasRTMArg = callee.SimStructArgIndex > -1
        %assign rtmNeeded = TLC_FALSE
        %if !hasRTMArg && ...
            FcnSysNeedAddRTMArg(system, callee.Name)
            %assign rtmNeeded = TLC_TRUE
        %endif

        %assign argStr = FcnGetAdditionalArgs(callee.Name, aArgVec, callee.Name, ...
            calleeModule.CGSystemIdx, thisModule.CGSystemIdx, calleeInstIdx, TLC_FALSE, rtmNeeded)
        %return callee.Name + "(" + argStr + ")"
    %else
        %assign argStr = ""
        %%
        %% (modIdx <= calleeModIdx) the current module is calling a function
        %% from a parent module. In this case we need to generate the argument
        %% list from the parent system.
        %%
        %if FcnIsSubFunctionCreationReq(modIdx, calleeModIdx, calleeModule, callee)
            %%
            %% FcnGenerateSubFcnBody will create the PassThroughArgs for the
            %% the current callee function call record
            %%
            %assign calleeSystem = ::CompiledModel.System[calleeModule.CGSystemIdx]
            %%
            %if SLibPassThroughArgsRequired(calleeSystem)
                %assign currentFcn = ::BlockFcn
                %assign saveTID = calleeSystem.CurrentTID
                %% Parent module's CurrentTID has not been setup yet; Need to use
                %% the context's, i.e., the caller's
                %assign calleeSystem.CurrentTID = system.CurrentTID
                %assign block = FcnRootOpaqueBlock()
                %assign prevModuleIdx   = ::CurrentModuleIdx
                %assign prevFunctionIdx = ::CurrentFunctionIdx
                %assert calleeModIdx == calleeSystem.CGIRModuleIdx
                %assign ::CurrentModuleIdx = calleeModIdx
                %assign ::CurrentFunctionIdx = -1
                %<FcnGenerateSubFcnBody(block, calleeModule, calleeFcnIdx, TLC_TRUE)>

                %assert ::CurrentModuleIdx == calleeModIdx
                %assign ::CurrentFunctionIdx = prevFunctionIdx
                %assign ::CurrentModuleIdx = prevModuleIdx
                %assign calleeSystem.CurrentTID = saveTID
                %assign ::BlockFcn = currentFcn
            %endif
        %endif
        %assign passThroughArgs = callee.PassThroughArgs
        %if thisModule.SimplifiedInterface && !SLibIsFcnSubFunction(system, thisFcn.Name)
            %% A simplified interface function calling a sub-function
            %if ISFIELD(callee, "PassThroughArgsFullPath")
                %assign passThroughArgs = callee.PassThroughArgsFullPath
            %endif
        %endif
        %if calleeModule.AccessesArgsGlobally
            %foreach argIdx = callee.NumArgs
                %if callee.ArgAccessed[argIdx] > 0
                    %assign addArg = TLC_FALSE
                    %assign idNum = SLibSafeIDNUM(callee.ArgSource, argIdx)
                    %assign argSrc = idNum[0]
                    %switch argSrc
                      %case "CPI"
                      %case "TID"
                      %case "X"
                        %assign addArg = TLC_TRUE
                        %break
                      %case "RTM"
                        %assign addArg = calleeModule.NeedsSimStruct
                        %break
                      %default
                        %if ISFIELD(system,"RTWSystemCodeOptIntf") && ...
                            (argSrc == "I" || argSrc == "O")
                            %assign addArg = TLC_TRUE
                        %endif
                        %break
                    %endswitch
                    %if addArg
                        %assign argStr = argStr + sep + aArgVec[argIdx]
                        %assign sep    = ", "
                    %endif
                %endif
            %endforeach
        %else
            %foreach argIdx = callee.NumArgs
                %if callee.ArgAccessed[argIdx] > 0
                    %assign argStr = argStr + sep + aArgVec[argIdx]
                    %assign sep    = ", "
                %endif
            %endforeach
        %endif
        %if callee.GpuKernel
            %assign kernelInvoke = "<<<" + aArgVec[0] + ", " + aArgVec[1] + ">>>"
        %else
            %assign kernelInvoke = ""
        %endif
        %%
        %% Make sure that we don't override a previously
        %% set HasPassThroughArgsAtCall flag. Only the first call site matters,
        %% as subsequent callsites might have arguments if the called function
        %% has been processed.
        %%
        %if !callee.HasPassThroughArgsAtCallSet
            %assign callee.HasPassThroughArgsAtCallSet = TLC_TRUE
            %assign callee.HasPassThroughArgsAtCall = !ISEMPTY(passThroughArgs)
        %endif
        %if ISEMPTY(passThroughArgs)
            %return callee.Name + kernelInvoke + "(" + argStr + ")"
        %else
            %%
            %% Subfunction called by iterator systems get the address of a
            %% BlockIO or DWork array element passed not just the base pointer.
            %%
            %% e.g. localBlockIO --> &localBlockIO[iterBlock_idx]
            %%
            %% The array element is accessed by pointer dereference inside
            %% of the sub-function.
            %%
            %% e.g. localBlockIO->someElement
            %%
            %if !system.GeneratingSubFunctions
                %assign argRepl = system.ArgumentReplacements
                %foreach replIdx = SIZE(argRepl, 1)/2
                    %assign argIdx = replIdx * 2
                    %assign passThroughArgs = ...
                        REGEXPREP( passThroughArgs, ...
                        "(^|\W|,)" + argRepl[argIdx] + "($|\W|,)", ...
                        "$1" + argRepl[argIdx+1] + "$2")
                %endforeach
            %endif
            %return callee.Name + kernelInvoke + "(" + argStr + sep + passThroughArgs + ")"
        %endif
    %endif
%endfunction %% SLibCGCallSubFcn
%% Function: SLibAddRootIOAsStructArgs =============================================================
%% Abstract:
%%   This function populates the root input struct argument for functions directly
%% accessed from root system
%%
%function SLibAddRootIOAsStructArgs(aSystemRec, argsFullPath, args, argDefs, comma) void
    %createrecord passThroughArgInfo {tArgsFullPath argsFullPath;tArgs args;tArgDefs argDefs}
    %% Get vargroup corresponding to the base system
    %assign thisModule = ::CompiledModel.RTWCGModules.RTWCGModule[aSystemRec.CGIRModuleIdx]
    %assign isSimpInterf = thisModule.SimplifiedInterface
    %assign varGroupIdx = FcnSysVarGroupIndex(aSystemRec, "ExternalInput", 0)
    %if varGroupIdx > -1
        %assign argName = VarGroups.VarGroup[varGroupIdx].Name
        %if isSimpInterf
            %assign parentVGIdx = SLibVarGroupParentIndex(varGroupIdx)
            %assert parentVGIdx > -1
            %assign path = SLibCGIRVarGroupPath(parentVGIdx, aSystemRec.SystemIdx, aSystemRec.CrossNoArgFcnBound)
            %assign argExprFullPath = "&(" + path + argName +")"
            %assign passThroughArgInfo.tArgsFullPath = argsFullPath + comma + argExprFullPath
        %endif
    %else
        %assign argName = ::tInput
    %endif

    %assign passThroughArgInfo.tArgs    = args + comma + argName
    %assign passThroughArgInfo.tArgDefs = argDefs + comma + ::tInputType + " *" + argName
    %return passThroughArgInfo
%endfunction
%%endfunction SLibAddRootIOAsStructArg

%% Function: SLibGetRootLevelArgDefs ===============================================================
%% Abstract:
%%   This function is used to generate the passthrough argument list for the
%%   root system. It is used to properly pass in model data such as model inputs
%%   and outputs (root IO) to subfunctions that are directly called from the
%%   root system.
%%
%% TopTester: matlab/test/toolbox/simulink/coreblocks/lib_MathOperations/Product/rtw/tProductBlk_Codegencheck_SFcnTarget.m
%% TopTester: matlab/test/toolbox/simulink/coreblocks/lib_MathOperations/Product/rtw/tProductBlk_Codegencheck_ERTSFcn_Target.m
%%
%function SLibGetRootLevelArgDefs(aSystemRec, aFunctionRec) void
    %%
    %if !SLibPassThroughArgsRequired(aSystemRec)
        %return
    %endif
    %%
    %assign fcnName = aFunctionRec.Name
    %assign cTID    = aSystemRec.CurrentTID
    %assign isRG    = SLibSystemFcnPeriodicRateGrouping(aSystemRec, fcnName)
    %assign args    = ""
    %assign argDefs = ""
    %assign comma   = ""
    %assert LibSystemIsRoot(aSystemRec)
    %% For AUTOSAR: In multi-instance models, the only function call
    %% subsystem argument is "self".
    %if SLibAutosarActive() && aFunctionRec.IsEntryPointSubFcn
        %assign aFunctionRec.PassThroughArgDefs = "%<FcnGetMultiInstanceRunnableArgs(0)>"
        %assign aFunctionRec.PassThroughArgs    = "%<FcnGetMultiInstanceRunnableArgs(1)>"
        %return
    %endif

    %%
    %% Root inputs
    %%
    %assign rootInputStructArgReq = TLC_FALSE
    %if CodeFormat != "S-Function"
        %%
        %assign useRootIOStructures = MultiInstanceERTCode && ...
            RootIOStructures && !GenerateClassInterface && !SLibFcnProtoCtrlActive()
        %%
        %with ::CompiledModel.ExternalInputs
            %if useRootIOStructures
                %assign rootInputsRequired = TLC_FALSE
                %foreach idx = NumExternalInputs
                    %assign extInp = ExternalInput[idx]
                    %if extInp.StorageClass == "Auto" && ...
                        SysFcnArgNeeded(fcnName, extInp, cTID, isRG)
                        %assign rootInputsRequired = TLC_TRUE
                        %break
                    %endif
                %endforeach
                %if rootInputsRequired
                    %assign args    = args + comma + ::tInput
                    %assign argDefs = argDefs + comma + ::tInputType + " *" + ::tInput
                    %assign comma   = ", "
                %endif
            %else
                %foreach idx = NumExternalInputs
                    %assign extInp = ExternalInput[idx]
                    %if extInp.StorageClass == "Auto" && ...
                        SysFcnArgNeeded(fcnName, extInp, cTID, isRG)
                        %%
                        %assign width    = LibGetRecordSymbolicWidth(extInp)
                        %assign optStar  = " "
                        %assign optWidth = width == "1" ? "" : "[%<width>]"
                        %assign dType    = LibGetRecordDataTypeName(extInp, "")
                        %assign reqLocalAccess = extInp.RequiresGlobalAccess == "no"
                        %assign argName  = ""
                        %%
                        %if SLibFcnProtoCtrlActive()
                            %if reqLocalAccess
                                %assign fcnData = FcnGetFunctionPrototypeRecord()
                                %assign spec = FcnGetFcnDataForPort(fcnData, "Inport", idx)
                                %assign argName = spec.ArgName
                                %if width == "1" && spec.Category == "Pointer"
                                    %assign optStar = " *"
                                %endif
                            %else
                                %assign rootInputStructArgReq = TLC_TRUE
                                %continue
                            %endif
                        %elseif GenerateClassInterface
                            %assign classConfObj = FcnGetRTWCPPStepPrototypeRecord()
                            %if !classConfObj.hasGlobalAccessForInport && reqLocalAccess
                                %assign spec = FcnGetFcnDataForPort(classConfObj, "Inport", idx)
                                %assign argName = spec.ArgName
                                %if width == "1" && spec.Category == "Pointer"
                                    %assign optStar = " *"
                                %endif
                            %else
                                %continue
                            %endif
                        %endif
                        %if ISEMPTY(argName)
                            %assign argName = ::tInput + UQualifier + LibGetRecordIdentifier(extInp)
                            %assign dtID    = LibGetRecordDataTypeId(extInp)
                            %if width == "1" && SLibDeclareDataAsPointer(dtID)
                                %assign optStar = " *"
                            %endif
                        %endif
                        %assign args     = args + comma + argName
                        %assign argDefs  = ...
                            argDefs + comma + dType + optStar + argName + optWidth
                        %assign comma   = ", "
                    %endif
                %endforeach
            %endif
        %endwith
        %with ::CompiledModel.ExternalOutputs
            %if useRootIOStructures
                %assign rootOutputsRequired = TLC_FALSE
                %foreach idx = NumExternalOutputs
                    %assign extOut = ExternalOutput[idx]
                    %if SysFcnArgNeeded(fcnName, extOut, cTID, isRG)
                        %assign rootOutputsRequired = TLC_TRUE
                        %break
                    %endif
                %endforeach
                %if rootOutputsRequired
                    %assign args    = args + comma + tOutput
                    %assign argDefs = argDefs + comma + tOutputType + " *" + tOutput
                    %assign comma   = ", "
                %endif
            %else
                %foreach idx = NumExternalOutputs
                    %assign extOut = ExternalOutput[idx]
                    %if SysFcnArgNeeded(fcnName, extOut, cTID, isRG)
                        %%
                        %assign width    = LibGetRecordSymbolicWidth(extOut)
                        %assign optStar  = " "
                        %assign optWidth = width == "1" ? "" : "[%<width>]"
                        %assign dType    = LibGetRecordDataTypeName(extOut, "")
                        %assign reqLocalAccess = extOut.RequiresGlobalAccess == "no"
                        %assign argName  = ""
                        %%
                        %if SLibFcnProtoCtrlActive()
                            %if reqLocalAccess
                                %assign fcnData = FcnGetFunctionPrototypeRecord()
                                %assign spec = FcnGetFcnDataForPort(fcnData, "Outport", idx)
                                %assign argName = spec.ArgName
                                %if width == "1" && spec.Category == "Pointer"
                                    %assign optStar = " *"
                                %endif
                            %else
                                %continue
                            %endif
                        %elseif GenerateClassInterface
                            %assign classConfObj = FcnGetRTWCPPStepPrototypeRecord()
                            %if !classConfObj.hasGlobalAccessForOutport && reqLocalAccess
                                %assign spec = FcnGetFcnDataForPort(classConfObj, "Outport", idx)
                                %assign argName = spec.ArgName
                                %if width == "1" && spec.Category == "Pointer"
                                    %assign optStar = " *"
                                %endif
                            %else
                                %continue
                            %endif
                        %elseif width == "1"
                            %assign optStar = " *"
                        %endif
                        %if ISEMPTY(argName)
                            %assign outpBlk = System[extOut.Block[0]].Block[extOut.Block[1]]
                            %assign argName = tOutput + YQualifier + LibGetRecordIdentifier(outpBlk)
                            %assign dtID    = LibGetRecordDataTypeId(extOut)
                            %if width == "1" && SLibDeclareDataAsPointer(dtID)
                                %assign optStar = " *"
                            %endif
                        %endif
                        %assign args     = args + comma + argName
                        %assign argDefs  = ...
                            argDefs + comma + dType + optStar + argName + optWidth
                        %assign comma   = ", "
                    %endif
                %endforeach
            %endif
        %endwith
    %endif
    %%
    %%
    %%
    %with aSystemRec.Interface
        %if !GenerateClassInterface
            %%
            %% rtModel argument
            %%
            %if CodeFormat == "S-Function"
                %if !SLibCG_FcnHasRTMArg(aFunctionRec) && ...
                    (SysFcnArgNeeded(fcnName, RTMArgDef,               cTID, isRG) || ...
                    SysFcnArgNeeded( fcnName, BlockIOArgDef,            cTID, isRG) || ...
                    SysFcnArgNeeded( fcnName, DWorkArgDef,              cTID, isRG) || ...
                    SysFcnArgNeeded( fcnName, ParameterArgDef,          cTID, isRG) || ...
                    SysFcnArgNeeded( fcnName, ContStatesArgDef,         cTID, isRG) || ...
                    SysFcnArgNeeded( fcnName, ContStatesDisabledArgDef, cTID, isRG) || ...
                    SysFcnArgNeeded( fcnName, ContStatesAbsoluteToleranceArgDef, cTID, isRG) || ...
                    SysFcnArgNeeded( fcnName, ContStatesPerturbMinArgDef, cTID, isRG) || ...
                    SysFcnArgNeeded( fcnName, ContStatesPerturbMaxArgDef, cTID, isRG) || ...
                    SysFcnArgNeeded( fcnName, ZCSVArgDef,               cTID, isRG))
                    %assign rtmArg  = FcnUpdateRTModelInterfaceArg(aSystemRec, ::tSimStruct)
                    %assign args    = args + comma + rtmArg
                    %assign argDefs = argDefs + comma + ::tSimStructType + " *" + ::tSimStruct
                    %assign comma   = ", "
                %endif
            %elseif  MultiInstanceERTCode
                %%
                %% rtModel argument
                %%
                %assign rtmAccessed = TLC_FALSE
                %if !SLibCG_FcnHasRTMArg(aFunctionRec) && ...
                    SysFcnArgNeeded(fcnName, RTMArgDef, cTID, isRG)
                    %assign rtmArg  = FcnUpdateRTModelInterfaceArg(aSystemRec, ::tSimStruct)
                    %assign args    = args + comma + rtmArg
                    %assign argDefs = argDefs + comma + ::tSimStructType + " *" + ::tSimStruct
                    %assign comma   = ", "
                    %assign rtmAccessed = TLC_TRUE
                %endif
                %assign sysIdx = aSystemRec.SystemIdx
                %assign thisModule = ::CompiledModel.RTWCGModules.RTWCGModule[aSystemRec.CGIRModuleIdx]
                %assign isSimpInterf = thisModule.SimplifiedInterface
                %assign useSelf = TLC_FALSE
                %if isSimpInterf
                    %assign selfGroupIdx = SLibGetSelfCoderDataGroupIndex()
                    %assert selfGroupIdx >= 0
                    %assign selfGroup = ::CompiledModel.CoderDataGroup[selfGroupIdx]
                    %assign selfGroupArgDefToken = "CoderDataGroup" + selfGroup.Name + "ArgDef"
                    %if EXISTS(selfGroupArgDefToken) && SysFcnArgNeeded(fcnName, %<selfGroupArgDefToken>, cTID, isRG)
                        %assign useSelf = TLC_TRUE
                    %endif
                %endif
                %assign argsFullPath = args
                %% Add external inputs struct arg for case where Step function FPC
                %% is on and root inputs is not accessed locally
                %if rootInputStructArgReq
                    %assign passThroughArgsInfo = SLibAddRootIOAsStructArgs(aSystemRec, argsFullPath, args, argDefs, comma)
                    %assign argsFullPath =  passThroughArgsInfo.tArgsFullPath
                    %assign args = passThroughArgsInfo.tArgs
                    %assign argDefs = passThroughArgsInfo.tArgDefs
                    %assign comma   = ", "
                %endif
                %%
                %% Block IO argument
                %%
                %if SysFcnArgNeeded(fcnName, BlockIOArgDef, cTID, isRG) && !useSelf
                    %% Get vargroup corresponding to the base system
                    %assign varGroupIdx = FcnSysVarGroupIndex(aSystemRec, "BlockIO", 0)
                    %if varGroupIdx > -1
                        %assign argName = VarGroups.VarGroup[varGroupIdx].Name
                        %if isSimpInterf
                            %% For simplified interface, BlockIO is InSelf
                            %assign parentVGIdx = SLibVarGroupParentIndex(varGroupIdx)
                            %assert parentVGIdx > -1
                            %assign path = SLibCGIRVarGroupPath(parentVGIdx, sysIdx, aSystemRec.CrossNoArgFcnBound)
                            %assign argExprFullPath = "&(" + path + argName +")"
                            %assign argsFullPath = argsFullPath + comma + argExprFullPath
                        %endif
                    %else
                        %assign argName = ::tBlockIO
                    %endif

                    %assign args    = args + comma + argName
                    %assign argDefs = argDefs + comma + ::tBlockIOType + " *" + argName
                    %assign comma   = ", "
                %endif
                %%
                %% Constant block IO (not passed in as an argument)
                %%
                %%
                %% DWork argument
                %%
                %if SysFcnArgNeeded(fcnName, DWorkArgDef, cTID, isRG) && !useSelf
                    %% Get vargroup corresponding to the base system
                    %assign varGroupIdx = FcnSysVarGroupIndex(aSystemRec, "DWork", 0)
                    %if varGroupIdx > -1
                        %assign argName = VarGroups.VarGroup[varGroupIdx].Name
                        %if isSimpInterf
                            %assign parentVGIdx = SLibVarGroupParentIndex(varGroupIdx)
                            %assert parentVGIdx > -1
                            %assign path = SLibCGIRVarGroupPath(parentVGIdx, sysIdx, aSystemRec.CrossNoArgFcnBound)
                            %assign argExprFullPath = "&(" + path + argName +")"
                            %assign argsFullPath = argsFullPath + comma + argExprFullPath
                        %endif
                    %else
                        %assign argName = ::tDWork
                    %endif

                    %assign args    = args + comma + argName
                    %assign argDefs = argDefs + comma + ::tDWorkType + " *" + argName
                    %assign comma   = ", "
                %endif
                %%
                %% Parameter H-Struct argument
                %%
                %if SysFcnArgNeeded(fcnName, ParameterArgDef, cTID, isRG)
                    %assign args    = args + comma + ::tParameters
                    %assign argDefs = argDefs + comma + ::tParametersType + " *" + ::tParameters
                    %assign argsFullPath = argsFullPath + comma + ::tParameters
                    %assign comma   = ", "
                %endif
                %%
                %% Continuous States argument
                %%
                %if SysFcnArgNeeded(fcnName, ContStatesArgDef, cTID, isRG)
                    %assign args    = args + comma + ::tContState
                    %assign argDefs = argDefs + comma + ::tContStateType + " *" + ::tContState
                    %assign comma   = ", "
                %endif
                %%
                %% Continuous States Disabled argument
                %%
                %if SysFcnArgNeeded(fcnName, ContStatesDisabledArgDef, cTID, isRG)
                    %assign args    = args + comma + ::tXdis
                    %assign argDefs = argDefs + comma + ::tXdisType + " *" + ::tXdis
                    %assign comma   = ", "
                %endif
                %%
                %% Continuous States Absolute Tolerance argument
                %%
                %if SysFcnArgNeeded(fcnName, ContStatesAbsoluteToleranceArgDef, cTID, isRG)
                    %assign args    = args + comma + ::tXAbsTol
                    %assign argDefs = argDefs + comma + ::tXAbsTolType + " *" + ::tXAbsTol
                    %assign comma   = ", "
                %endif
                %%
                %% Continuous States Perturb Min argument
                %%
                %if SysFcnArgNeeded(fcnName, ContStatesPerturbMinArgDef, cTID, isRG)
                    %assign args    = args + comma + ::tXPerturbMin
                    %assign argDefs = argDefs + comma + ::tXPerturbMinType + " *" + ::tXPerturbMin
                    %assign comma   = ", "
                %endif
                %%

                %% Continuous States Perturb Max argument
                %%
                %if SysFcnArgNeeded(fcnName, ContStatesPerturbMaxArgDef, cTID, isRG)
                    %assign args    = args + comma + ::tXPerturbMax
                    %assign argDefs = argDefs + comma + ::tXPerturbMaxType + " *" + ::tXPerturbMax
                    %assign comma   = ", "
                %endif
                %%
                %%


                %% ZcSignalValue  argument
                %%
                %if SysFcnArgNeeded(fcnName, ZCSVArgDef, cTID, isRG)
                    %assign args    = args + comma + ::tZCSignalValue
                    %assign argDefs = argDefs + comma + ::tZCSignalValueType + " *" + ...
                        ::tZCSignalValue
                    %assign comma   = ", "
                %endif
                %%
                %% Zero Crossing Event argument
                %%
                %if SysFcnArgNeeded(fcnName, ZCEventArgDef, cTID, isRG)
                    %assign args    = args + comma + ::tPrevZCState
                    %assign argDefs = argDefs + comma + ::tPrevZCStateType + " *" + ...
                        ::tPrevZCState
                    %assign comma   = ", "
                %endif
                %%
                %% Coder Group argument
                %%
                %foreach coderGroupIndex = ::CompiledModel.NumCoderDataGroups
                    %assign coderGroup = ::CompiledModel.CoderDataGroup[coderGroupIndex]
                    %assign coderGroupArgDefToken = "CoderDataGroup" + coderGroup.Name + "ArgDef"
                    %% Skip the coder data group if it is already added (e.g. synthesized self added as RTM),
                    %% or can be accessed through self.
                    %assign skipGroup = SLibIsSynthesizedRTM(coderGroup) && rtmAccessed || ...
                        SLibIsSelfStructured() && !coderGroup.IsSelf && SLibAccessGroupThroughSelf(coderGroup)
                    %if skipGroup
                        %continue
                    %endif
                    %if EXISTS(coderGroupArgDefToken) && SysFcnArgNeeded(fcnName, %<coderGroupArgDefToken>, cTID, isRG)
                        %assign coderGroupVarGroup = SLibVarGroupForCoderGroup(coderGroup)
                        %assign argToken = "::tCoderDataGroup" + coderGroup.Name
                        %if coderGroup.IsSelf
                            %assign argName = coderGroupVarGroup.SelfStructureArgumentName
                        %elseif coderGroup.AsStructure == "InParent"
                            %assign argName = coderGroupVarGroup.StructureInstanceName
                        %else
                            %assign argName = %<argToken>
                        %endif

                        %% Make sure arg is not already added in the function interface for outlined block functions
                        %assign coderGroupAccessed = TLC_FALSE
                        %if aFunctionRec.IsOutlinedBlockFcn
                            %foreach argIdx = aFunctionRec.NumArgs
                                %if aFunctionRec.ArgNames[argIdx] == argName ...
                                    && aFunctionRec.ArgAccessed[argIdx] > 0
                                    %assign coderGroupAccessed = TLC_TRUE
                                    %break
                                %endif
                            %endforeach
                        %endif
                        %if coderGroupAccessed
                            %continue
                        %endif

                        %assign typeToken = argToken + "Type"
                        %assign typeName = coderGroup.IsSelf ? ...
                            coderGroupVarGroup.SelfStructureTypeName : %<typeToken>
                        %assign typeName = SLibTypeQualifierForGroup(coderGroup) + typeName
                        %assign args    = args + comma + argName
                        %assign argsFullPath = argsFullPath + comma + argName
                        %assign argDefs = argDefs + comma + typeName + " *" + argName
                        %assign comma   = ", "
                    %endif
                %endforeach

                %assert MultiInstanceERTCode
                %addtorecord aFunctionRec PassThroughArgsFullPath argsFullPath

                %%
                %% ZCEvent H-Struct argument **** part of dwork
                %%
                %%
                %% Canonical Parameters *** not applicable for the root system
                %%
                %%
                %% CanonicalDWork *** not applicable for the root system
                %%
            %endif
        %endif
    %endwith
    %assign aFunctionRec.PassThroughArgDefs = argDefs
    %assign aFunctionRec.PassThroughArgs    = args
%endfunction

%% Function: FcnResetModelRefLocalVars =============================================================
%% Abstract:
%%    Resets the cached model reference local variable declaration for
%%    given function (through module and function index).
%%
%function FcnResetModelRefLocalVars(aModule, aSubFcnIdx) void
    %assign        fcn = aModule.Function[aSubFcnIdx]
    %assign     system = ::CompiledModel.System[aModule.CGSystemIdx]
    %<SLibResetModelRefLocalVars(system, fcn.Name, "")>
%endfunction

%% Function: FcnGenerateSubFcnBody =================================================================
%% Abstract:
%%   Generates and returns the function body for a given sub-function
%%
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tmg1331407_VC1.m
%function FcnGenerateSubFcnBody(aOpaqueBlock, aModule, aSubFcnIdx, aCalledFromChildMod) void
    %assert -1 == ::CurrentFunctionIdx
    %assign ::CurrentFunctionIdx = aSubFcnIdx
    %assign   fileName = aModule.TLCFileName + "_Functions"
    %assign        fcn = aModule.Function[aSubFcnIdx]
    %assign    fcnName = fcn.Name
    %assign     system = ::CompiledModel.System[::CompiledModel.System[aModule.CGSystemIdx].NonInlinedParentSystemIdx]
    %assign     lboDef = ::CompiledModel.BlockOutputs.LocalBlockOutputDefaults
    %assign     ldwDef = ::CompiledModel.DWorks.DWorkDefaults
    %assign callerFcn = ::BlockFcn
    %assign ::BlockFcn = fcnName
    %<LibSetGlobalSysFcnsForArgAccess([])>
    %assign sysField = fcnName + "Fcn"
    %if !ISFIELD(system, sysField)
        %addtorecord system %<sysField> fcnName
    %endif
    %assign localRecordField = "DeclareIn" + fcnName + "FcnScope"
    %if !ISFIELD(lboDef, localRecordField)
        %addtorecord lboDef %<localRecordField> 0
    %endif
    %if !ISFIELD(ldwDef, localRecordField)
        %addtorecord ldwDef %<localRecordField> 0
    %endif
    %assign ::GlobalGeneratingSubFunctions = TLC_TRUE
    %assign system.GeneratingSubFunctions = TLC_TRUE
    %assign reusedParent = ::CompiledModel.System[system.ReusedParentSystemIdx]
    %assign isScalableMRSys = ...
        IsModelReferenceBaseSys(reusedParent) && IsModelRefScalableBuild()
    %with system
        %assign tlcFcnName = fcnName + "_Fcn%<aSubFcnIdx>"
        %assign    fcnBody = GENERATE_TYPE(aOpaqueBlock, tlcFcnName, fileName)
        %if aCalledFromChildMod
            %<SLibCopyRootInputsArgAccessedFlags(system, fcnName)>
            %<SLibCopyArgAccessedFlags(aModule.CGSystemIdx, fcnName, callerFcn, ...
                system.CurrentTID, isScalableMRSys)>
        %endif
    %endwith
    %if !fcn.IsShared
        %if LibSystemIsRoot(system)
            %<SLibGetRootLevelArgDefs(system, fcn)>
        %else
            %assign            fcnInfo = SLibSystemFcnInfoRecord(system, fcnName)
            %assign passThroughArgDefs = fcnInfo.Params
            %%
            %if !ISEMPTY(passThroughArgDefs) && !WHITE_SPACE(passThroughArgDefs)
                %assign fcn.PassThroughArgDefs = passThroughArgDefs
                %assign fcn.PassThroughArgs = ...
                    FEVAL("rtwprivate", "getargstr", passThroughArgDefs)
            %endif
            %if isScalableMRSys && TLC_TRUE == reusedParent.ContainsNonreusedFcn
                %<SLibAccessMdlRefGlobals(fcn)>
            %endif
        %endif
    %endif
    %assign ::GlobalGeneratingSubFunctions = TLC_FALSE
    %assign system.GeneratingSubFunctions = TLC_FALSE
    %%
    %assign ::BlockFcn = callerFcn
    %assert ::CurrentFunctionIdx == aSubFcnIdx
    %assign ::CurrentFunctionIdx = -1
    %return fcnBody
%endfunction

%% Function: SLibFcnHasArgs ========================================================================
%% Abstract:
%%   Returns true if a function has any arguments that have been accessed.
%%
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-codegen/tg1375551.m
%%
%function SLibFcnHasArgs(aFcnRecord) void
    %foreach argIdx = aFcnRecord.NumArgs
        %if aFcnRecord.ArgAccessed[argIdx] > 0
            %return TLC_TRUE
        %endif
    %endforeach
    %return TLC_FALSE
%endfunction %% SLibFcnHasArgs

%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-codegen/tg1375551.m
%%
%function FcnGetSubFcnGlobalVars(system, fcn) void
    %if !fcn.IsEntryPointSubFcn
        %return ""
    %endif

    %assign saveBlockFcn = ::BlockFcn
    %assign ::BlockFcn = fcn.Name
    %assign backTID = system.CurrentTID
    %assign system.CurrentTID =fcn.FcnTID
    %assign globalVars = LibInitializeGlobalVars(system, fcn.Name)
    %assign system.CurrentTID = backTID
    %assign ::BlockFcn = saveBlockFcn

    %return globalVars
%endfunction %% FcnGetSubFcnGlobalVars

%% Function: FcnGenMatFileIterationWrapperFunctionPrototype ========================================
%% Description:
%%   Generate the prototye for the basic looping wrapper function
%%
%function FcnGenMatFileIterationWrapperFunctionPrototype(fcnName)
    %return "void %<fcnName>_wrapper_loop(void* pMatrix, const void* aMatrix, int iterations)"
%endfunction

%% Function: FcnGenMatFileNWrapperFunctionPrototype ================================================
%% Description:
%%   Generate the prototye for a N wrapper function
%%
%function FcnGenMatFileNWrapperFunctionPrototype(fcnName, iterations)
    %return "void %<fcnName>_wrapper%<iterations>(void* pMatrix, const void* aMatrix)"
%endfunction

%% Function: FcnGenMatFileNWrapperFunctionPrototypes ===============================================
%% Description:
%%   Generate the prototyes for all N wrapper functions of a given fcn
%%
%function FcnGenMatFileNWrapperFunctionPrototypes(fcn)
    %assign fcnPrototypes = ""
    %if ISFIELD(fcn, "LoggingNWrappers")
        %foreach iterationIndex = fcn.NumLoggingNWrappers
            %assign iterations = fcn.LoggingNWrappers[iterationIndex]
            %assign fcnPrototypes = fcnPrototypes + FcnGenMatFileNWrapperFunctionPrototype(fcn.Name, iterations) + ";\n"
        %endforeach
    %endif
    %return fcnPrototypes
%endfunction

%% Function: FcnGenMatFileLoggingWrapperFunctionPrototype ==========================================
%% Description:
%%   Generate the prototype for the base wrapper function
%%
%function FcnGenMatFileLoggingWrapperFunctionPrototype(fcn)
    %assign fcnProto = ""
    %if ISFIELD(fcn, "NumArgs") && fcn.NumArgs > 0 && ...
        ISFIELD(fcn, "LoggingWrapperType") && fcn.LoggingWrapperType == "Simple"
        %assign fcnProto = "void %<fcn.Name>_wrapper(void* pMatrix, const void* aMatrix)"
    %endif
    %return fcnProto
%endfunction

%% Function: FcnGenAllMatFileWrapperFunctionPrototypes =============================================
%% Description:
%%   Generate the prototyes for all wrapper functions of a given fcn
%%
%% TopTester: test/toolbox/simulink/variants/var-simulinkfcns/tAutoInherit.m
%%
%function FcnGenAllMatFileWrapperFunctionPrototypes(fcn)
    %assign fcnPrototypes = FcnGenMatFileLoggingWrapperFunctionPrototype(fcn)
    %if fcnPrototypes != "" && ISFIELD(fcn, "LoggingNWrappers")
        %assign fcnName = fcn.Name
        %if fcn.NumLoggingNWrappers == 1
            %assign iterations = fcn.LoggingNWrappers[0]
            %assign fcnPrototypes = fcnPrototypes + ";\n" + ...
                FcnGenMatFileNWrapperFunctionPrototype(fcnName, iterations)
        %else
            %assign fcnPrototypes = fcnPrototypes + ";\n" + ...
                FcnGenMatFileIterationWrapperFunctionPrototype(fcnName)
            %foreach iterationIndex = fcn.NumLoggingNWrappers
                %assign iterations = fcn.LoggingNWrappers[iterationIndex]
                %assign fcnPrototypes = fcnPrototypes + ";\n" + ...
                    FcnGenMatFileNWrapperFunctionPrototype(fcnName, iterations)
            %endforeach
        %endif
    %endif
    %return fcnPrototypes
%endfunction

%% Function: FcnGenMatFileLoggingWrapperFunction ===================================================
%% Description:
%%   Cache all code for mat file logging wrapper functions
%%
%% TopTester: test/toolbox/simulink/coreblocks/lib_MathOperations/Product/rtw/tRowMajorEMLSupport.m
%%
%function FcnGenMatFileLoggingWrapperFunction(fcn)
    %openfile fcnBuffer
    %if ISFIELD(fcn, "NumArgs") && fcn.NumArgs > 0 && ...
        ISFIELD(fcn, "LoggingWrapperType") && fcn.LoggingWrapperType == "Simple"
        %assign argType = fcn.ArgTypes[0]
        %assign baseName = SLibGetTypeNameFromCGType(argType)
        %assign fcnName = fcn.Name

        %<FcnGenMatFileLoggingWrapperFunctionPrototype(fcn)>
        {
            %<baseName>* bpMatrix = (%<baseName>*) pMatrix;
            const %<baseName>* baMatrix = (const %<baseName>*) aMatrix;
            %<fcnName>(baMatrix, bpMatrix);
        }

        %if ISFIELD(fcn, "LoggingNWrappers")
            %assign width = fcn.LoggedTypeWidth
            %if fcn.NumLoggingNWrappers == 1
                %assign iterations = fcn.LoggingNWrappers[0]
                %<FcnGenMatFileNWrapperFunctionPrototype(fcnName, iterations)>
                {
                    %<baseName>* bpMatrix = (%<baseName>*) pMatrix;
                    const %<baseName>* baMatrix = (const %<baseName>*) aMatrix;
                    int i = 0;
                    while(i < %<iterations>)
                    {
                        %<fcnName>(baMatrix + i * %<width>, bpMatrix + i * %<width>);
                        i = i + 1;
                    }
                }
            %else
                %<FcnGenMatFileIterationWrapperFunctionPrototype(fcnName)>
                {
                    %<baseName>* bpMatrix = (%<baseName>*) pMatrix;
                    const %<baseName>* baMatrix = (const %<baseName>*) aMatrix;
                    int i = 0;
                    while(i < iterations)
                    {
                        %<fcnName>(baMatrix + i * %<width>, bpMatrix + i * %<width>);
                        i = i + 1;
                    }
                }
                %foreach iterationIndex = fcn.NumLoggingNWrappers
                    %assign iterations = fcn.LoggingNWrappers[iterationIndex]
                    %<FcnGenMatFileNWrapperFunctionPrototype(fcnName, iterations)>
                    {
                        %<fcn.Name>_wrapper_loop(pMatrix, aMatrix, %<iterations>);
                    }
                %endforeach
            %endif
        %endif
    %endif
    %closefile fcnBuffer
    %return fcnBuffer
%endfunction

%% Function: SLibGenModuleSubFunctionAsClassMemFcn
%%  Should a sub function called by a subsystem
%%  be generated as a member function in the model class?
%function SLibGenModuleSubFunctionAsClassMemFcn(system)
    %assign result = GenerateClassInterface && ...
        !IsModelReferenceBaseSys(system) && ...
        !LibSystemIsReusedLibraryFcn(system)
    %return result
%endfunction

%% Function: FcnUseSystemMemorySection =============================================================
%% Abstract:
%%   Returns true if function should use parent system's memory section
%%
%function FcnUseSystemMemorySection(fcn) void
    %% Note that we don't use IsShared which can toggle depending on whether or
    %% not utilities are shared
    %return fcn.UseSystemMemorySection
%endfunction

%% Function: SLibModuleHasMissingArgs ==============================================================
%% Abstract:
%%   Returns true if function calls in subfunction have missing arguments
%%   in a given module
%%
%function SLibModuleHasMissingArgs(aModule, aTestInterfaceFcnIdx) void
    %assign hasMissingArgs = TLC_FALSE
    %foreach fcnIdx = aModule.NumSubFunctions
        %if fcnIdx != aTestInterfaceFcnIdx
            %assign fcn = aModule.Function[fcnIdx]
            %%
            %% Reset the flag that indicates HasPassThroughArgsAtCall has been set
            %%
            %assign fcn.HasPassThroughArgsAtCallSet = TLC_FALSE
            %%
            %% If fcn.PassThroughArgs doesn't match HasPassThroughArgsAtCall, then
            %% we have a callsite to this function with a none matching argument list.
            %% In thid case we have to continue with the argument propagation.
            %%
            %if !ISEMPTY(fcn.PassThroughArgs) != fcn.HasPassThroughArgsAtCall
                %assign hasMissingArgs = TLC_TRUE
            %endif
        %endif
    %endforeach
    %return hasMissingArgs
%endfunction

%% Function: ShouldEmitSimulinkVariantFcnsInFile ===================================================
%% Simulink.Variant functions in startup activation can be created in different module scopes, because
%% the same startup condition with Simulink.Variant can be present in different scopes. However, when the
%% modules get late inlined, we need to avoid emitting the same functions in a given file scope as these are static
%% functions
%function ShouldEmitSimulinkVariantFcnsInFile(module, fcnIdx)
    %assign fcn = module.Function[fcnIdx]
    %assign   system = ::CompiledModel.System[module.CGSystemIdx]
    %assign isMdlRefSys  = IsModelReferenceBaseSys(system)
    %if isMdlRefSys
        %return TLC_FALSE
    %endif
    %assign fileName = CGMODEL_ACCESS("CGModel.System.SourceFileName", system.SystemIdx)
    %assign mangledName = fcn.Name + "#" + fileName
    %if !ISFIELD(::CompiledModel, "EmittedSimulinkVariantInfo")
        %addtorecord ::CompiledModel EmittedSimulinkVariantInfo ["%<mangledName>"]
        %return TLC_TRUE
    %endif
    %assign numSimVarInfo = SIZE(::CompiledModel.EmittedSimulinkVariantInfo)[1]
    %foreach simVarsIdx = numSimVarInfo
        %if ::CompiledModel.EmittedSimulinkVariantInfo[simVarsIdx] == mangledName
            %return TLC_FALSE
        %endif
    %endforeach
    %assign ::CompiledModel.EmittedSimulinkVariantInfo = ::CompiledModel.EmittedSimulinkVariantInfo + mangledName
    %return TLC_TRUE
%endfunction


%% Function: FcnGenModuleSubFunctions ==============================================================
%% Abstract:
%%   This function generates the subfunctions called by system functions in
%%   the module. Each function is generated separately using its own function
%%   type for argument tracking. The functions are generated in reverse
%%   callgraph order.
%%
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-codegen/tg1375551.m
%% TopTester: test/toolbox/simulink/variants/var-vss-flexiblevariants/tFlexibleVariantsCodeGen2.m
%% TopTester: test/toolbox/rtw/targets/AUTOSAR/Variants/dimensionVariants/tDimensionVariants9.m
%% TopTester: test/toolbox/simulink/variants/var-mgr-cmd/tVariantManager3.m
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tVariantSource7.m
%%
%function FcnGenModuleSubFunctions(module, testInterfaceFcnIdx) void
    %assign    block = FcnRootOpaqueBlock()
    %assign fileName = module.TLCFileName + "_Functions"
    %assign   system = ::CompiledModel.System[module.CGSystemIdx]
    %assign system.CurrentTID = ""
    %assign genSharedUtils = (::CompiledModel.GenUtilsSrcInSharedLocation == 1)
    %assign useEncapsCPP   = ::GenerateClassInterface && ...
        (IsBaseSystem(system.SystemIdx) || SLibGenModuleSubFunctionAsClassMemFcn(system))
    %%

    %if module.HasRecursion && ...
        (module.HasOptAccessArgs || SLibPassThroughArgsRequired(system))
        %assign numRecursions = 0
        %%
        %% Recurse until we have no missing arguments
        %%
        %foreach recursionIdx = module.NumSubFunctions
            %foreach fcnIdx = module.NumSubFunctions
                %if fcnIdx != testInterfaceFcnIdx
                    %<FcnGenerateSubFcnBody(block, module, fcnIdx,TLC_FALSE)>
                %endif
            %endforeach
            %assign numRecursions = numRecursions + 1
            %if !SLibModuleHasMissingArgs(module, testInterfaceFcnIdx)
                %break
            %endif
        %endforeach
        %%
        %% Assert that the argument propagation converges before we reach
        %% maximum necessary interations.
        %%
        %assert numRecursions <= module.NumSubFunctions
        %%
        %if IsModelReferenceBaseSys(system) && IsModelRefScalableBuild() && ...
            !::GenerateClassInterface
            %foreach fcnIdx = module.NumSubFunctions
                %if fcnIdx != testInterfaceFcnIdx
                    %<FcnResetModelRefLocalVars(module, fcnIdx)>
                %endif
            %endforeach
        %endif
    %endif
    %%

    %assign notRootFileName = NotRootFileName(system)
    %assign needNamespace = TLC_FALSE

    %assign   exported = ""
    %assign dnnExported = ""
    %assign entryPoint = ""
    %assign subFcnProt = ""
    %assign shaFcnProt = "" %% shared function prototypes
    %assign subFcnCode = ""
    %assign inlineProt = ""
    %assign inlineCode = ""
    %assign extApiProt = ""
    %assign extApiCode = ""
    %assign memberProt = ""
    %openfile exported
    %openfile dnnExported
    %openfile entryPoint
    %openfile subFcnProt
    %openfile subFcnCode
    %openfile shaFcnProt
    %openfile inlineProt
    %openfile inlineCode
    %openfile extApiProt
    %openfile extApiCode
    %openfile memberProt
    %foreach fcnIdx = module.NumSubFunctions

        %if fcnIdx == testInterfaceFcnIdx || ...
            module.Function[fcnIdx].IsAlreadyEmitted
            %continue
        %endif

        %assign          fcn = module.Function[fcnIdx]
        %assign prevBlockFcn = ::BlockFcn
        %assign   ::BlockFcn = fcn.Name
        %if fcn.IsShared
            %<LibPushEmptyStackSharedUtils()>
        %endif
        %assign      fcnBody = FcnGenerateSubFcnBody(block, module, fcnIdx,TLC_FALSE)
        %assign hasPassThroughArgs = !ISEMPTY(fcn.PassThroughArgs)
        %assign         globalVars = FcnGetSubFcnGlobalVars(system,fcn)
        %if hasPassThroughArgs
            %assign passThroughArgDefs = fcn.PassThroughArgDefs
        %else
            %assign passThroughArgDefs = ""
        %endif
        %assign  fcnClose = ")"
        %assign seperator = ", "
        %assign hasArgs = SLibFcnHasArgs(fcn)
        %if !hasArgs || !hasPassThroughArgs
            %assign seperator = ""
            %if !hasArgs && !hasPassThroughArgs
                %assign fcnClose = "void)"
            %endif
        %endif
        %assign constMember = ""
        %if FcnIsConstMemberMethod(system, fcn.Name)
            %assign constMember = " const"
        %endif
        %assign fcnProto = fcn.ProtoType + seperator + passThroughArgDefs + fcnClose + constMember
        %assign fcnProto = REGEXPREP( fcnProto, "\\()", "(void)")
        %if SLibFcnBufferContainsRTM(fcnProto)
            %<SLibUpdateSymbolForFunction(fcn.Name, SLibGetFcnDeclarationRTMSymbolName(), TLC_TRUE)>
        %endif
        %assign localVars = ...
            fcn.HasLocalData ? FcnDeclareAccessedLocalVariables(system) : ""
        %%
        %% Function prototype dispatching
        %%
        %selectfile NULL_FILE
        %assign extern = ""
        %assign repFcn = ""
        %if fcn.IsShared
            %if !genSharedUtils
                %if !SLibLookupUtilityDecl(fcn.Name)
                    %<SLibInsertUtilityDecl(fcn.Name)>
                    %selectfile shaFcnProt
                %endif
            %endif
        %elseif useEncapsCPP && !fcn.NoEncapsCpp
            %assign fcnProto = REGEXPREP(fcnProto, "^\\s*(extern|static)\\s+", "")
            %selectfile memberProt
        %elseif fcn.IsExported || fcn.IsExportedImport
            %if fcn.IsEntryPointSubFcn
                %assign rtnTypeStr = ...
                    SLibAutosarCompilerAbstractionForFcnDeclRtnType("void", "FuncCalledByRTE", "")
                %assign fcnProto = STRNREP(fcnProto, "void", rtnTypeStr, 1)
                %selectfile entryPoint
            %elseif fcn.DnnExportMethod
                %selectfile dnnExported
            %else
                %selectfile exported
            %endif
        %else
            %selectfile subFcnProt
        %endif

        %if !fcn.IsAccessMethod
            %openfile guardedProto

            %if !fcn.IsShared
                %% Should fcn => system ??
                %% Guard the sub functions declaration in the given module with the variant conditions
                %% fcn is the function record here from which the variant conditions can
                %% be queried.
                %% Example, Stateflow charts, MATLAB function blocks, rate transition blocks comes up
                %% as sub functions in the generated code.
                %if ISFIELD(fcn, "ModuleIfCondition")
                    %<fcn.ModuleIfCondition>
                %endif

            %endif

            %if FcnUseSystemMemorySection(fcn)
                %if SLibAutosarActive() && (FEVAL("feature", "ArMemSectionForStateflowChrt") == 1)
                    %assign runnableName = CGMODEL_ACCESS("CGModel.getRunnableNameForSharedUtilFcn", fcn.Name)
                    %if !ISEMPTY(runnableName)
                        %<SLibGetFcnMemSecPragmaForFunction(fcn.Name, "UNKNOWN", runnableName, "Pre")>\
                        %<extern> %<fcnProto>;
                        %<SLibGetFcnMemSecPragmaForFunction(fcn.Name, "UNKNOWN", runnableName, "Post")>\
                    %else
                        %<SLibGetFcnMemSecPragmaForSystemOnDecl(fcn.Name, "MemSecFuncExecute", "Pre", system)>\
                        %<extern> %<fcnProto>;
                        %<SLibGetFcnMemSecPragmaForSystemOnDecl(fcn.Name, "MemSecFuncExecute", "Post", system)>\
                    %endif
                %else
                    %<SLibGetFcnMemSecPragmaForSystemOnDecl(fcn.Name, "MemSecFuncExecute", "Pre", system)>\
                    %<extern> %<fcnProto>;
                    %<SLibGetFcnMemSecPragmaForSystemOnDecl(fcn.Name, "MemSecFuncExecute", "Post", system)>\
                %endif
            %else
                %<SLibGetFcnMemSecPragmaForSystemOnDecl(fcn.Name, "MemSecFuncSharedUtil", "Pre", system)>\
                %<extern> %<fcnProto>;
                %<SLibGetFcnMemSecPragmaForSystemOnDecl(fcn.Name, "MemSecFuncSharedUtil", "Post", system)>\
            %endif
            %% Guard the sub functions declaration in the given module with the variant conditions
            %% fcn is the function record here from which the variant conditions can
            %% be queried.
            %if !fcn.IsShared
                %if ISFIELD(fcn, "ModuleIfCondition")
                    %<fcn.ModuleEndIfCondition>
                %endif
            %endif

            %closefile guardedProto

            %if ISFIELD(fcn, "HeaderFile") && ...
                !ISEMPTY(fcn.HeaderFile) && ...
                (fcn.HeaderFile != CGMODEL_ACCESS("CGModel.System.HeaderFileName", system.SystemIdx)) && ...
                !SLibIsCompactFileFormat()

                %assign modelTypesHeader = SLibGetFileNameForCode("mdl_types_hdr") + ".h"
                %assign declFileName = SLibGetFileNameWithoutExtension(fcn.HeaderFile)
                %assign declFile = SLibAddModelFile("SystemHeader", "Simulink", declFileName)
                %assign declFileGroup = "interface"
                %<SLibSetModelFileAttribute(declFile, "Group", declFileGroup)>
                %if LibUseOldFilePackagingInfrastructure()
                    %% Add rtwtypes.h, only needed if using old file packaging infrastructure
                    %<LibSetIncludesSection(declFile, "RequiredIncludes", "rtwtypes.h")> %% sbcheck: ok(TLCTYPES)
                %endif
                %<LibSetIncludesSection(declFile, "RequiredIncludes", modelTypesHeader)>
                %<SLibSetModelFileAttribute(declFile, "Declarations", guardedProto)>
            %else
                %<guardedProto>
            %endif
        %endif

        %selectfile NULL_FILE

        %%
        %% Function body code generation
        %%
        %assign fcnComment = ""
        %if !ISEMPTY(fcn.BlockName) && !ISEMPTY(fcn.BlockType)
            %assign fcnType = ""
            %if !ISEMPTY(fcn.FunctionType)
                %assign fcnType = fcn.FunctionType + " function"
            %else
                %assign fcnType = "Function"
            %endif
            %assign fcnComment = "%<fcnType> for " + fcn.BlockType + ...
                ": '" + fcn.BlockName + "'"
        %endif
        %if !ISEMPTY(fcn.Abstract)
            %if !ISEMPTY(fcnComment)
                %assign fcnComment = fcnComment + "\n"
            %endif
            %assign fcnComment = fcnComment + fcn.Abstract
        %endif
        %assign fcnDefinition = ""
        %openfile fcnDefinitionHeader
        %%
        %% Shared function handling
        %%
        %if fcn.IsShared
            %if genSharedUtils && LibUseOldFilePackagingInfrastructure()
                %assign headers = fcn.FcnHeaders
                %assign numHeaders = SIZE(headers, 1)
                %foreach idx = numHeaders
                    %assign header = ::CompiledModel.RTWCGStrings[headers[idx]]
                    %%    hasTLCGenCallBack=false; isGeneratedUtility=true
                    %<FcnTrackHeaderFileUsage(header, TLC_FALSE, TLC_TRUE)>
                %endforeach
            %endif
        %endif
        %%
        %if useEncapsCPP && !fcn.IsShared && !fcn.NoEncapsCpp
            %assign memberFcnName = CPPClassName + "::" + fcn.Name
            %assign fcnProtoForDef = STRNREP(fcnProto, fcn.Name, memberFcnName, 1)
        %else
            %assign fcnProtoForDef = fcnProto
            %% If the prototype is for an exported function, and
            %% we're preserving extern in fcn declarations, the prototype
            %% will have an extern in it.  This is not want we want for
            %% the function definition prototype; strip it off.
            %if fcn.IsExported && LibPreserveExternInFcnDecls()
                %assign fcnProtoForDef = REGEXPREP(fcnProtoForDef, "^\\s*extern\\s+", "")
            %endif
        %endif

        %%reset needNamespace for each loop
        %assign needNamespace = TLC_FALSE
        %if useEncapsCPP && !fcn.IsShared && !fcn.NoEncapsCpp
            %assign needNamespace = SLibSystemNeedsNamespace(system)
        %endif

        %%
        %% Sub-functions are MemSecFuncSharedUtil
        %%
        %assign generatedFor = FcnGeneratedFor(system)
        %if fcn.IsShared
            %assign fcn_category = "utility"
        %else
            %assign fcn_category = "model"
        %endif
        %if FcnUseSystemMemorySection(fcn)
            %assign msFcnType    = "MemSecFuncExecute"
        %else
            %assign msFcnType    = "MemSecFuncSharedUtil"
        %endif
        %createrecord fcnInfo { Name fcn.Name;  Returns  ""; ...
            Params passThroughArgDefs; Abstract fcnComment; Category fcn_category; ...
            GeneratedBy "commonbodlib.tlc"; Type "Sub"; GeneratedFor generatedFor }
        %%
        %if needNamespace
            %<SLibEmitNamespaceStartForSystem(system)>
        %else
            %% before dumping a non-member function, close the namespace if it is opened
            %% when fcn.IsShared and genSharedUtils, should not affect namespace here because it is generated to other file
            %if (fcn.IsShared && !genSharedUtils)
                %<SLibEmitNamespaceCloseForSystem(system)>
            %endif
        %endif

        %<SLibDumpFunctionBanner(fcnInfo)>
        %closefile fcnDefinitionHeader
        %openfile fcnCommonBody
        %% Guard the sub functions definition in the given module with the variant conditions
        %% fcn is the function record here from which the variant conditions can
        %% be queried.
        %if !fcn.IsShared
            %if ISFIELD(fcn, "ModuleIfCondition")
                %<fcn.ModuleIfCondition>
            %endif
        %endif
        %<fcnProtoForDef>
        {
            %assign mrLocalVars = FcnDumpMRLocalVars(system, fcn.Name, "")
            %if !ISEMPTY(mrLocalVars)
                %<mrLocalVars>
            %endif
            %if !ISEMPTY(localVars)
                %if TYPE(localVars) == "Vector"
                    %<localVars[0]>
                %else
                    %assert TYPE(localVars) == "String"
                    %<localVars>
                %endif
            %endif
            %if !ISEMPTY(globalVars) && !WHITE_SPACE(globalVars)
                %<globalVars>
                {
            %endif
            %<fcnBody>
            %if !ISEMPTY(globalVars) && !WHITE_SPACE(globalVars)
            }
            %endif
        }
        %if fcn.IsShared
            %assign wrapperBody = FcnGenMatFileLoggingWrapperFunction(fcn)
            %<wrapperBody>
        %endif
        %% Guard the sub functions definition in the given module with the variant conditions
        %% fcn is the function record here from which the variant conditions can
        %% be queried.
        %if !fcn.IsShared
            %if ISFIELD(fcn, "ModuleIfCondition")
                %<fcn.ModuleEndIfCondition>
            %endif
        %endif
        %closefile fcnCommonBody
        %assign newSharedFunctionAdded = TLC_FALSE
        %if fcn.IsShared
            %if !SLibLookupUtility(fcn.Name)
                %<SLibInsertUtility(fcn.Name)>
                %assign newSharedFunctionAdded = TLC_TRUE
                %if genSharedUtils
                    %% Create function definition buffer without Pragma
                    %% to avoid duplicated pragmas after calling SLibDumpUtilsSourceCode
                    %openfile fcnDefinitionNOPragma
                    %<fcnDefinitionHeader>
                    %<fcnCommonBody>
                    %closefile fcnDefinitionNOPragma
                    %assign wrapperProto = FcnGenAllMatFileWrapperFunctionPrototypes(fcn)
                    %if wrapperProto != ""
                        %assign wrapperProto = wrapperProto + ";\n"
                    %endif
                    %assign fcnProtoForUtil = fcnProto + ";\n" + wrapperProto
                    %<SLibDumpUtilsSourceCodeForSystem(fcn.Name, fcnProtoForUtil, fcnDefinitionNOPragma, ...
                        FcnUseSystemMemorySection(fcn) ? system : [], TLC_FALSE)>
                %else
                    %selectfile subFcnCode
                %endif
            %endif
        %else
            %selectfile subFcnCode
        %endif
        %if fcn.IsShared
            %assign includesBuf = LibPopStackSharedUtilsIncludes()
        %endif

        %if module.Function[fcnIdx].IsSimulinkVariantFcn && !ShouldEmitSimulinkVariantFcnsInFile(module,fcnIdx)
            %continue
        %endif

        %% create function definition buffer with Pragma wrapped
        %openfile fcnDefinition
        %if fcn.IsOutlinedBlockFcn
            /* RateTransition function %<fcn.Name> */
        %endif
        %<fcnDefinitionHeader>
        %if ISFIELD(fcn, "AccessFunctionMemorySectionUUID")
            %<SLibGetFcnMemSecPragmaForAccessMethod(fcn, "Pre")>
        %else
            %if SLibAutosarActive() && FcnUseSystemMemorySection(fcn) && (FEVAL("feature", "ArMemSectionForStateflowChrt") == 1)
                %assign runnableName = CGMODEL_ACCESS("CGModel.getRunnableNameForSharedUtilFcn", fcn.Name)
                %if !ISEMPTY(runnableName)
                    %<SLibGetFcnMemSecPragmaForFunction(fcn.Name, "UNKNOWN", runnableName, "Pre")>
                %else
                    %<SLibGetFcnMemSecPragmaForSystem(fcn.Name, msFcnType, "Pre", system)>
                %endif
            %else
                %<SLibGetFcnMemSecPragmaForSystem(fcn.Name, msFcnType, "Pre", system)>
            %endif
        %endif
        %<fcnCommonBody>
        %if ISFIELD(fcn, "AccessFunctionMemorySectionUUID")
            %<SLibGetFcnMemSecPragmaForAccessMethod(fcn, "Post")>
        %else
            %if SLibAutosarActive() && FcnUseSystemMemorySection(fcn) && (FEVAL("feature", "ArMemSectionForStateflowChrt") == 1)
                %assign runnableName = CGMODEL_ACCESS("CGModel.getRunnableNameForSharedUtilFcn", fcn.Name)
                %if !ISEMPTY(runnableName)
                    %<SLibGetFcnMemSecPragmaForFunction(fcn.Name, "UNKNOWN", runnableName, "Post")>
                %else
                    %<SLibGetFcnMemSecPragmaForSystem(fcn.Name, msFcnType, "Post", system)>
                %endif
            %else
                %<SLibGetFcnMemSecPragmaForSystem(fcn.Name, msFcnType, "Post", system)>
            %endif
        %endif
        %closefile fcnDefinition
        %if !fcn.IsExportedImport
            %if ISFIELD(fcn, "DefinitionFile") && ...
                !ISEMPTY(fcn.DefinitionFile) && ...
                (fcn.DefinitionFile != CGMODEL_ACCESS("CGModel.System.SourceFileName", system.SystemIdx)) && ...
                !SLibIsCompactFileFormat()
                %assign defFileName = SLibGetFileNameWithoutExtension(fcn.DefinitionFile)
                %assign defFileMatchesSubsystemFile = ISEQUAL(defFileName, CGMODEL_ACCESS("CGModel.System.SourceFileName", system.SystemIdx))
                %assign defFile = SLibAddModelFile("SystemBody", "Simulink", defFileName)
                %assign defFileGroup = "interface"
                %<SLibSetModelFileAttribute(defFile, "Group", defFileGroup)>
                %if LibUseOldFilePackagingInfrastructure()
                    %% Add rtwtypes.h, only needed if using old file packaging infrastructure
                    %<LibSetIncludesSection(defFile, "RequiredIncludes", "rtwtypes.h")> %% sbcheck: ok(TLCTYPES)
                %endif
                %if ISFIELD(fcn,"HeaderFile") && !ISEMPTY(fcn.HeaderFile) && !defFileMatchesSubsystemFile
                    %<LibSetIncludesSection(defFile, "RequiredIncludes", fcn.HeaderFile)>
                %endif
                %if defFileName != LibGetMdlSrcBaseName() %% g1806081
                    %assign modelHeader = SLibGetFileNameForCode("mdl_hdr") + ".h"
                    %<LibSetIncludesSection(defFile, "RequiredIncludes", modelHeader)>
                    %if !SLibIsCompactFileFormat()
                        %assign modelPrivHeader = SLibGetFileNameForCode("mdl_priv_hdr") + ".h"
                        %<LibSetIncludesSection(defFile, "RequiredIncludes", modelPrivHeader)>
                    %endif
                %endif
                %<SLibSetModelFileAttribute(defFile, "Functions", fcnDefinition)>
            %else
                %<fcnDefinition>
                %if newSharedFunctionAdded && !WHITE_SPACE(fcnDefinition) && !genSharedUtils
                    %% g2919613: update file packaging infrastructure that the shared function is emitted in this system's source file
                    %assign systemSourceFile = SLibGetFullFileNameForSystemCode("sys_fcn_defn", system.FileNameOwnerIdx)
                    %assign success = CGMODEL_ACCESS("FileRepository.updateSourceFileForFunctionName", fcn.Name, systemSourceFile)
                    %assert success
                %endif
            %endif
        %endif
        %assign ::BlockFcn = prevBlockFcn
    %endforeach %% fcnIdx = module.NumSubFunctions
    %if system.SystemNamespaceFlag == 1
        %selectfile subFcnCode
        %<SLibEmitNamespaceCloseForSystem(system)>
    %endif
    %closefile memberProt
    %closefile extApiCode
    %closefile extApiProt
    %closefile inlineCode
    %closefile inlineProt
    %closefile subFcnCode
    %closefile subFcnProt
    %closefile shaFcnProt
    %closefile dnnExported
    %closefile exported
    %closefile entryPoint
    %assign unused = UNLOAD_GENERATE_TYPE(block, fileName)
    %%
    %<LibSetSystemField(system, "CachedSubFunctions", subFcnCode)>
    %%
    %if !WHITE_SPACE(subFcnProt)
        %assign comment = "/* Forward declaration for local functions */\n"
        %assign subFcnProt = comment + subFcnProt
        %<SLibCacheSystemCodeToFile("sys_sub_fcn_fwd_decl", system, subFcnProt)>
    %endif
    %%
    %if !WHITE_SPACE(shaFcnProt)
        %<SLibCacheCodeToFile("mdl_priv_fcn_decl", shaFcnProt)>
    %endif
    %%
    %if !WHITE_SPACE(entryPoint)
        %openfile entryPointBuf

        /* Exported entry point functions */
        %<entryPoint>
        %closefile entryPointBuf
        %if SLibAutosarActive()
            %if !ISFIELD(::CompiledModel.RTWAutosar,"ExportedFunctionDecls")
                %addtorecord ::CompiledModel.RTWAutosar ExportedFunctionDecls entryPointBuf
            %endif
        %else
            %<SLibCacheSystemCodeToFile("sys_fcn_decl", system, entryPointBuf)>
        %endif
    %endif

    %%
    %% DNN Functions cannot be emitted to _private because of
    %% they'll be upward exposed to parent models. Cannot be
    %% emitted to model header because then we get a
    %% cyclic compile dependency since DNN network included by
    %% parent model and is a member of child model. So we emit
    %% predict declarations to the types file
    %if !WHITE_SPACE(dnnExported)
        %assign comment =  "/* DNN functions */"
        %assign dnnFcns = comment + dnnExported
        %<SLibCacheCodeToFile("data_simulink_variant_include", dnnFcns)>
    %endif

    %%
    %if !WHITE_SPACE(exported)
        %assign comment =  "/* Exported functions */"
        %assign exportedFcn = comment + exported
        %assign exported = ...
            GetHideChildDefineSymbol("ifndef") + ...
            exportedFcn + ...
            GetHideChildDefineSymbol("endif")
        %if fcn.IsExported
            %assign exported = ...
                FcnAddExternCPrefixStart() + ...
                exported + ...
                FcnAddExternCPrefixEnd()
        %endif

        %<SLibCacheSystemCodeToFile("sys_exported_fcn_decl", system, exported)>
    %endif
    %%
    %if useEncapsCPP
        %<LibAddToSystemField(system, "SystemMemberPrototype", memberProt)>
    %endif
%endfunction

%function SLibGetOutputFcnStr()
    %if IsModelReferenceTarget() || !CombineOutputUpdateFcns
        %return "Output"
    %else
        %return "OutputUpdate"
    %endif
%endfunction

%% Function: FcnGenBodySysCache ====================================================================
%% Description:
%%   Cache all code for a module (including root).
%%
%function FcnGenBodySysCache(module) void
    %% Assert (!system.SystemCached)
    %assign system = System[module.CGSystemIdx]
    %assign isRoot = (system.Type == "root")
    %assign testFcnIdx = isRoot ? ...
        ::CompiledModel.RTWCGModules.TestInterfaceFcnIdx : -1

    %if system.IsRateGroupedSLFcn == TLC_TRUE && !Accelerator
        %% Contents of rate grouped simulink function subsystems are emitted by the root module
        %return
    %endif

    %if (system.CrossNoArgFcnBound && (UsingMalloc || (MultiInstanceERTCode && !GenerateClassInterface)))
        %% The first of these tracks if *any* subsystem has the "cross" flag set
        %% (need this to know whether to put extra fields in RT_MODEL).
        %% The second tracks if *this* subsystem has the "cross" flag set
        %% (need this to communicate this info across GENERATE_TYPE boundary,
        %% so generated code knows how to address certain globals).
        %% thisSubsysCross will get reset to false at the bottom of this function.
        %assign ::AnyCross = TLC_TRUE
        %assign ::ThisSubsysCross = TLC_TRUE
    %endif

    %%
    %% Generated code for sub-functions and exported functions
    %%
    %%%<SLibAddTLCCompileStatsCheckPoint(TLC_TRUE,"Generate code for sub-functions and exported functions")>
    %if module.NumSubFunctions > 0
        %with ::CompiledModel
            %<FcnGenModuleSubFunctions(module, testFcnIdx)>
        %endwith
    %endif
    %%%<SLibAddTLCCompileStatsCheckPoint(TLC_FALSE,"Generate code for sub-functions and exported functions")>

    %% Allowing sub functions of rate grouped SLF to be emitted. This is needed when a SLF
    %% contains a SF chart that generates a function.
    %% test/toolbox/simulink/mdelref/fcncall/scheduling/tExpChartLvlFcn_3/lvlTwo_G1384883_Standalone
    %if system.IsRateGroupedSLFcn == TLC_TRUE
        %% Body of rate grouped simulink functions are emitted by the root module
        %return
    %endif

    %if (ISFIELD(system,"NoCode"))
        %if (system.NoCode == "yes")
            %<SLibExtModeHostOnlyStub(system)>
            %assign ::ThisSubsysCross = TLC_FALSE
            %return ""
        %endif
    %endif

    %% EnableFcn, InitializeFcn, and StartFcn fields should always exist in
    %% System record
    %% However, there may not be any blocks in the system that generate initialize
    %% or enable code.  Thus, we must cache those two functions first -- Start
    %% will call them if they are non-empty.

    %if ISFIELD(system,"SetupRuntimeResourcesFcn")
        %<SLibFcnGenBodySysFcnEntry(system,"SetupRuntimeResources","SetupRuntimeResources",...
            TLC_TRUE,TLC_TRUE,TLC_FALSE,TLC_FALSE)>
    %endif

    %% Cache Initialize before Enable so Initialize args get added to Enable
    %if ISFIELD(system,"InitializeFcn")
        %<SLibFcnGenBodySysFcnEntry(system,"Initialize","InitializeConditions",...
            TLC_TRUE,TLC_TRUE,TLC_FALSE,TLC_FALSE)>
    %endif

    %if ISFIELD(system,"SystemInitializeFcn")
        %<SLibFcnGenBodySysFcnEntry(system,"SystemInitialize","SystemInitialize",...
            TLC_TRUE,TLC_TRUE,TLC_FALSE,TLC_FALSE)>
    %endif

    %if ISFIELD(system,"SystemResetFcn")
        %<SLibFcnGenBodySysFcnEntry(system,"SystemReset","SystemReset",...
            TLC_TRUE,TLC_TRUE,TLC_FALSE,TLC_FALSE)>
    %endif

    %if ISFIELD(system, "FinalizeDimsFcn")
        %<SLibFcnGenBodySysFcnEntry(system,"FinalizeDims","FinalizeDims",...
            TLC_FALSE,TLC_FALSE,TLC_FALSE,TLC_FALSE)>
    %endif

    %if ISFIELD(system, "SetDimsFcn")
        %<SLibFcnGenBodySysFcnEntry(system,"SetDims","SetDims",...
            TLC_FALSE,TLC_FALSE,TLC_FALSE,TLC_FALSE)>
    %endif

    %if ISFIELD(system,"EnableFcn")
        %<SLibFcnGenBodySysFcnEntry(system,"Enable","Enable",...
            TLC_TRUE,TLC_TRUE,TLC_FALSE,TLC_FALSE)>
    %endif

    %if ISFIELD(system,"CleanupRuntimeResourcesFcn")
        %<SLibFcnGenBodySysFcnEntry(system,"CleanupRuntimeResources","CleanupRuntimeResources",...
            TLC_TRUE,TLC_TRUE,TLC_FALSE,TLC_FALSE)>
    %endif

    %% Don't cache start function since it will never be called, Accelerator
    %% runs start function via Simulink.
    %if Accelerator && CGMODEL_ACCESS("CGModel.AcceleratorExpandedSystemFcns") == 0
        %<LibSetSystemField(system, "CachedStartFcn", "")>
    %else
        %<SLibFcnGenBodySysFcnEntry(system,"Start","Start",...
            TLC_TRUE,TLC_TRUE,TLC_FALSE,TLC_FALSE)>
    %endif

    %if ISFIELD(system, "ModelInitializeFcn")
        %<SLibFcnGenBodySysFcnEntry(system,"ModelInitialize","ModelInitialize",...
            TLC_FALSE,TLC_FALSE,TLC_FALSE,TLC_FALSE)>
    %endif

    %if 1 == system.StandaloneSubsystem
        %assign zcInit = SLibGetPrevZCStateInitCode(system)
        %if !ISEMPTY(zcInit)
            %<LibAddToSystemField(system, "CachedInitializeDataBody", zcInit)>
        %endif
    %endif

    %assign isPartForRoot = SLibPartitionGroupingSystem(system)

    %if ISFIELD(system,"DerivativeFcn") && (!isRoot || (NumContStates > 0))
        %<SLibFcnGenBodySysFcnEntry(system,"Derivative","Derivatives",...
            TLC_TRUE,TLC_FALSE,TLC_TRUE, ...
            isPartForRoot)>
    %endif


    %if ISFIELD(system,"ProjectionFcn") && (!isRoot || (NumContStates > 0))
        %<SLibFcnGenBodySysFcnEntry(system,"Projection","Projection",...
            TLC_TRUE,TLC_FALSE,TLC_FALSE, ...
            isPartForRoot)>
    %endif


    %if ISFIELD(system,"ForcingFunctionFcn") && (ModelIsLinearlyImplicit == "yes") && (!isRoot || (NumContStates > 0))
        %<SLibFcnGenBodySysFcnEntry(system,"ForcingFunction","ForcingFunction",...
            TLC_TRUE,TLC_FALSE,TLC_FALSE, ...
            isPartForRoot)>
    %endif


    %if ISFIELD(system,"MassMatrixFcn") && (ModelIsLinearlyImplicit == "yes") && (!isRoot || (NumContStates > 0))
        %<SLibFcnGenBodySysFcnEntry(system,"MassMatrix","MassMatrix",...
            TLC_TRUE,TLC_FALSE,TLC_FALSE, ...
            isPartForRoot)>
    %endif


    %if ISFIELD(system,"ZeroCrossingFcn") && (!isRoot || (NumNonsampledZCs > 0))
        %<SLibFcnGenBodySysFcnEntry(system,"ZeroCrossing","ZeroCrossings",...
            TLC_TRUE,TLC_FALSE,TLC_FALSE, ...
            isPartForRoot)>
    %endif


    %if ISFIELD(system,"DisableFcn")
        %<SLibFcnGenBodySysFcnEntry(system,"Disable","Disable",...
            TLC_TRUE,TLC_TRUE,TLC_FALSE,TLC_FALSE)>
    %endif

    %if ISFIELD(system,"UpdateFcn")
        %<SLibFcnGenBodySysFcnEntry(system,"Update","Update",...
            TLC_TRUE,TLC_TRUE,TLC_TRUE,TLC_TRUE)>
    %endif

    %if ISFIELD(system,"ConstCodeFcn")
        %<SLibFcnGenBodySysFcnEntry(system,"ConstCode","ConstCode",...
            TLC_TRUE,TLC_TRUE,TLC_FALSE,TLC_FALSE)>
    %endif

    %% Cache Outputs function after update fcn because the
    %% the Output method checks if output or update is empty
    %% before generating special code for conditionally
    %% executed systems (such as setting the mode in an enabled
    %% subsystem).  It is possible with CGIR for the Output buffer
    %% of an enabled subsystem to be empty, but the Update buffer
    %% to be nonempty.
    %if !system.DeletedInIR
        %if ISFIELD(system,"OutputFcn")
            %<SLibFcnGenBodySysFcnEntry(system,"Output","Outputs",...
                TLC_TRUE,TLC_TRUE,TLC_TRUE,TLC_TRUE)>
        %elseif ISFIELD(system,"OutputUpdateFcn")
            %<SLibFcnGenBodySysFcnEntry(system,"OutputUpdate","OutputUpdate",...
                TLC_TRUE,TLC_TRUE,TLC_TRUE,TLC_TRUE)>
        %endif
    %endif

    %%
    %% For ert model reference the registration function will be in the top level
    %% subsystem file. If all blocks have constant sample time, only registration
    %% function will be generated. The registration function will be dumped in
    %% in ertreg.tlc.
    %assign isMdlRefSys  = IsModelReferenceBaseSys(system)
    %assign nonEmpty = isRoot || isMdlRefSys || SLibSystemNonEmpty(system) || ...
        (LibIsServer(system) && system.IsConstUncalledFunction == "no")
    %<LibSetSystemField(system, "SystemNonEmpty", nonEmpty)>
    %<LibSetSystemField(system, "SystemCached",   TLC_TRUE)>

    %% For the model reference base system, we generate the interface
    %% and prototype in FcnGenBodySysCache.  This is because information
    %% from Output may be needed in Update to determine if an
    %% rtModel argument is needed (one reason is the firstInitCond).
    %%
    %% NOTE(mdt): We do not need to this here for OutputUpdate because
    %% we call ModelrefMarkRTMIfNeeded at the end of
    %% FcnGenBodyOutputUpdateFcnCache after both Output and Update
    %% have already been generated.  This avoids the problem that
    %% happens when Output and Update are called separately.
    %if isMdlRefSys
        %if ISFIELD(system,"UpdateFcn")
            %assign ::BlockFcn = "Update"
            %<LibSetGlobalSysFcnsForArgAccess([])>
            %if ISFIELD(system, "UpdateOOCC")
                %<LibSetGlobalSysFcnsForArgAccess(system.UpdateOOCC)>
            %endif
            %<LibDefineSystemFcn(system, "Update")>
            %assign ::BlockFcn = "Unknown"
        %endif

        %if ISFIELD(system,"OutputFcn") && !system.DeletedInIR
            %assign ::BlockFcn = "Output"
            %<LibSetGlobalSysFcnsForArgAccess([])>
            %if ISFIELD(system, "OutputOOCC")
                %<LibSetGlobalSysFcnsForArgAccess(system.OutputOOCC)>
            %endif
            %<LibDefineSystemFcn(system, SLibGetOutputFcnStr())>
            %assign ::BlockFcn = "Unknown"
        %endif
    %endif

    %% cache global vars after all system functions have been cached
    %if isMdlRefSys && SLibIsExportFcnDiagram()
        %with system.Interface
            %% Add initialization of uninitalized canonical parameters to start function.
            %% This is needed here because of code execution order issues. Canonical
            %% params for model ref are marked as "accessed" when invoking
            %% FcnAddParametersAndReturn for the rate grouped SLF (sysFcn="Output").
            %% See the call to  %<SLibAccessMdlRefCanParam(argSrcIdx, "Start")>
            %% when looping through canonical params. However, the "Start" function
            %% has already been cached, so the globals that are marked as "accessed"
            %% never actually get initialized. I need this loop here to initialize
            %% those missed global vars. The call to SLibAccessMdlRefCanParam
            %% passes in "Start" so I'm looking for "GlobalStartAccessed" here.
            %% see :test/toolbox/simulink/modelref/fcncall/client_server/tCodegen2 -lvlTwo_g1062759
            %openfile tmpbufParam
            %foreach argIdx = NumCanonicalPrmArgDefs
                %assign argDef = CanonicalPrmArgDef[argIdx]
                %if (!ISFIELD(argDef, "ConnectedToSimulinkFunction") || argDef.ConnectedToSimulinkFunction == "no") ...
                    && SystemGlobalDeclIsNeeded(argDef) ...
                    && ISFIELD(argDef, "GlobalStartAccessed") ...
                    && !ISFIELD(argDef, "GlobalInitialized")
                    %<argDef.GlobalIdentifier> = %<LibGetRecordIdentifier(argDef)>;
                %endif
            %endforeach
            %closefile tmpbufParam
            %assign fcnRecord = SLibSystemFcnInfoRecord(system, "Start")
            %if !WHITE_SPACE(tmpbufParam)
                %assign fieldName = "CachedStartGlobalVars"
                %if !LibIsSystemField(system, fieldName)
                    %<LibSetSystemField(system, fieldName, tmpbufParam)>
                %else
                    %<LibAddToSystemField(system, fieldName, tmpbufParam)>
                %endif
                %% Global access not accounted for when caching start fcn
                %% therefore we need to recompute the prototype
                %<LibSetSystemField(system,"StartFcnInfo",fcnRecord)>
            %endif

            %% Delayed caching of start prototype
            %if !LibSystemFcnIsEmptyHelper(system,"Start","")
                %<LibCacheSubsystemPrototype(system,fcnRecord)>
            %endif

            %% Add initialization of uninitalized canonical I/O to system init function.
            %% This is needed to deal with the consequences of inlining the rate grouped
            %% simulink function's init code into model init. When the rate grouped
            %% SLF acceses a global, it expects that global to be initialized by its
            %% init or start fcn. Prior to rate grouping, that init or start fcn would
            %% not have all model canonical I/O passed as arguments. Hence, the need
            %% for marking the arg as needing global access. However, when that SLF init
            %% code is inlined into model init, that accessed var may actually be passed into
            %% model init as an argument. So, arg tracking decides that global access is
            %% not needed (it can just use the passed in arg). So, without the init fcn
            %% marking a need for global access, the initialization of the global needed
            %% by the SLF is not accomplished. We end up with a seg-v due to unitialize
            %% data access. See
            %% test/toolbox/simulink/modelref/fcncall/scheduling/tModelRefBasic_Concat_SimulinkFcns.m
            %openfile tmpbuf
            %foreach argIdx=NumCanonicalInputArgDefs
                %assign argDef = CanonicalInputArgDef[argIdx]
                %if (!ISFIELD(argDef, "ConnectedToSimulinkFunction") || argDef.ConnectedToSimulinkFunction == "no") ...
                    && SystemGlobalDeclIsNeeded(argDef) ...
                    && ISFIELD(argDef, "GlobalInitializationNeeded") ...
                    && !ISFIELD(argDef, "GlobalInitialized")
                    %<argDef.GlobalIdentifier> = %<LibGetRecordIdentifier(argDef)>;
                %endif
            %endforeach
            %foreach argIdx=NumCanonicalOutputArgDefs
                %assign argDef = CanonicalOutputArgDef[argIdx]
                %if (!ISFIELD(argDef, "ConnectedToSimulinkFunction") || argDef.ConnectedToSimulinkFunction == "no") ...
                    && SystemGlobalDeclIsNeeded(argDef) ...
                    && ISFIELD(argDef, "GlobalInitializationNeeded") ...
                    && !ISFIELD(argDef, "GlobalInitialized")
                    %<argDef.GlobalIdentifier> = %<LibGetRecordIdentifier(argDef)>;
                %endif
            %endforeach
            %closefile tmpbuf
            %if !WHITE_SPACE(tmpbuf)
                %assign fieldName = "CachedSystemInitializeGlobalVars"
                %if !LibIsSystemField(system, fieldName)
                    %<LibSetSystemField(system, fieldName, tmpbuf)>
                %else
                    %<LibAddToSystemField(system, fieldName, tmpbuf)>
                %endif
            %endif
        %endwith
    %endif

    %if (ISFIELD(module, "RTWFcnConst") && ISFIELD(module.RTWFcnConst, "ClassTLCFileName"))
        %%Emit the class declaration file
        %openfile classBuf
        %include module.RTWFcnConst.ClassTLCFileName
        %closefile classBuf
        %<SLibCacheSystemCodeToFile("sys_fcn_decl", system, classBuf)>
    %endif

    %% Reset flag for next subsystem
    %assign ::ThisSubsysCross = TLC_FALSE
%endfunction %% FcnGenBodySysCache


%% Function: FcnGenSystemTerminate =================================================================
%% Description:
%%   Cache all terminate code for a subsystem.  Ultimately, this function
%%   should also be able to cache code for the root system.
%%
%% TopTester: test/toolbox/rtw/targets/AUTOSAR/Variants/dimensionVariants/tDimensionVariants9.m
%%
%function FcnGenSystemTerminate(system) void
    %% Assert (!system.SystemTerminateCached)

    %if (ISFIELD(system,"NoCode"))
        %if (system.NoCode == "yes")
            %<SLibExtModeHostOnlyStub(system)>
            %return ""
        %endif
    %endif

    %<FcnGenBodyTerminateFcnCache(system)>

%endfunction %% FcnGenSystemTerminate


%% Function: FcnCacheLocalVars =====================================================================
%% Abstract:
%%   Generates the local variable declaration for a given function type and
%%   caches it in the systems instance record.
%%
%% TopTester: test/toolbox/simulink/variants/var-inline-general/tIVfcnCall_neg.m
%% TopTester: test/toolbox/simulink/variants/var-inline-general/tRootOutportStorageClass.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants_subsys.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tmg1672961.m
%function FcnCacheLocalVars(system, fcnType) void
    %assign multiTID = (fcnType == "Update") || ...
        (fcnType == "Output") || ...
        (fcnType == "OutputUpdate") || ...
        (SLibContFcnPartitionGrouping(fcnType) && ...
        SLibPartitionGroupingSystem(system))

    %if SLibNonEmptyModel()
        %assign isRoot = LibSystemIsRoot(system)
        %if (fcnType == "Update") && (CombineOutputUpdateFcns != 0) && isRoot
            %return
        %endif

        %assign localVar = FcnDeclareAccessedLocalVariables(system)
        %if LibIsDeploymentDiagram() && isRoot
            %if !WHITE_SPACE(SLibDeploymentGetLocalVars(fcnType))
                %assign localVar = localVar + SLibDeploymentGetLocalVars(fcnType)
            %endif
        %endif

        %if fcnType == "ModelInitialize"
            %openfile servicePortInit
            %<SLibCacheServicePortDWork()>
            %closefile servicePortInit
            %if !WHITE_SPACE(servicePortInit)
                %assign localVar = localVar + servicePortInit
            %endif
        %endif

        %% For rate grouped Simulink functions in modelref the local
        %% var decls need to be transfered from the original SLF system
        %% (which does not get emitted) to the root system that really
        %% contains the rate grouped SLF. Without this transfer, local
        %% vars are never declared.
        %assign isMdlRefHiddenRoot = TLC_FALSE
        %if IsModelReferenceTarget() && ::CurrentModuleIdx == RTWCGModules.NumRTWCGModules - 2
            %assign isMdlRefHiddenRoot = TLC_TRUE
        %endif
        %if isRoot || isMdlRefHiddenRoot
            %% Add in local vars for rate grouped Simulink Functions
            %assign numSubsys = NumSystems-1
            %foreach sysIdx = numSubsys
                %assign aSubsys = System[sysIdx]
                %if aSubsys.IsRateGroupedSLFcn
                    %assign slfLocalVars = FcnDeclareAccessedLocalVariables(aSubsys)
                    %if !ISEMPTY(slfLocalVars)
                        %if ISEMPTY(localVar)
                            %assign localVar = slfLocalVars
                        %else
                            %assert TYPE(localVar) == TYPE(slfLocalVars)
                            %if TYPE(localVar) == "Vector"
                                %assert (SIZE(localVar,1) >= SIZE(slfLocalVars,1))
                                %assign numLocalVar = SIZE(slfLocalVars,1)
                                %foreach bufIdx = numLocalVar
                                    %assign localVar[bufIdx] = localVar[bufIdx] + slfLocalVars[bufIdx]
                                %endforeach
                            %elseif TYPE(localVar) == "String"
                                %assign localVar = localVar + slfLocalVars
                            %endif
                        %endif
                    %endif
                %endif
            %endforeach
        %endif

        %assert (TYPE(localVar) == "String" && !multiTID) || ...
            multiTID
        %if multiTID
            %<LibSetSystemFieldForTID(system, fcnType,"LocalBO", localVar)>
        %else
            %if !ISEMPTY(localVar)
                %<LibSetSystemField(system, "Cached" + fcnType + "LocalBO", localVar)>
            %endif
        %endif
    %endif
%endfunction

%% Function: FncGenInitStatesInRootStart ===========================================================
%% Abstract:
%%   This function generate code initialize states
%% if needed
%%
%% TopTester: test/toolbox/simulink/variants/var-inline-vsink/tmVarSinkRateTransBlk_VC1.m
%%
%function FncGenInitStatesInRootStart()
    %assign ss = System[NumSystems - 1] %% root system
    %openfile retBuf
    %% Load intial states if needed.
    %if ::CompiledModel.LoadInitialState == "yes"
        %if ::isRAccel
            if (%<RTMGetGlobalInitialStatesAvailable()>) {
        %endif
        /* initial state override */
        %assign origBlockFcn = ::BlockFcn
        %assign ::BlockFcn = "Start"
        %<FcnLoadInitialState()>\
        %assign ::BlockFcn = origBlockFcn
        %if ::isRAccel
        }
        %endif
    %endif
    %closefile retBuf
    %return retBuf
%endfunction %% FncGenInitStatesInRootStart


%% Function: FcnGenInitMassMatrixPr ================================================================
%% Abstract:
%%   This function generates code that initializes MassMatrixPr offsets in DWork
%%   MassMatrixPr offsets are only generated at the model root level.
%%
%function FcnGenInitMassMatrixPr(system) void
    %assert (ModelIsLinearlyImplicit == "yes")
    %assert (system.Type == "root")

    %openfile tempbuf

    /* Root-level init GlobalMassMatrixPr offset */
    {
        %foreach mmIdx = ::CompiledModel.MassMatrices.NumMassMatrices
            %assign mm = ::CompiledModel.MassMatrices.MassMatrix[mmIdx]
            %assign prOffset = mm.IndexPr
            %assign grSrc = mm.GrSrc
            %assign comment  = "/* '%<SLibGrBlockName(grSrc)>' */"

            %assign grSubSys = ::CompiledModel.BlockHierarchyMap.Subsystem[grSrc[0]]
            %assign grBlock  = grSubSys.Block[grSrc[1]]
            %assign isSubsys = grBlock.Type == "SubSystem"

            %assign dwIdx = -1  %% invalid
            %assign dw = ""
            %assign foundMassMatrixDWork = TLC_FALSE
            %foreach blkDW = grBlock.NumDWorks
                %assign dwIdx = grBlock.DWork[blkDW]._idx
                %assign dw = ::CompiledModel.DWorks.DWork[dwIdx]
                %if dw.Name == "MASS_MATRIX_PR"
                    %assign foundMassMatrixDWork = TLC_TRUE
                    %break
                %endif
            %endforeach
            %assert foundMassMatrixDWork
            %with system

                %if ISFIELD(mm, "ForEachSSLoopBnds")
                    %% The owner block is inside For Each subsystem.
                    %% Need to initialize the DWork value correctly for each iteration
                    %assign ::NeedForEachLoopInReg = TLC_TRUE
                    %assign ::NumForEachLoopHierarchyLevel = SIZE(mm.ForEachSSLoopBnds,1)
                    %assign ::ForEachLoopHierarchyLevel = ::NumForEachLoopHierarchyLevel
                    %assign mmPrOffset = LibIsDeploymentDiagram() ? ...
                        "%<SLibDeploymentGetSystemMassMatrixPr(grSrc[0], grSrc[1], prOffset, isSubsys)>" : "%<prOffset>"
                    {
                        %% Form loop for every parent For Each subsystem
                        %assign int32Type = LibGetDataTypeNameFromId(::CompiledModel.tSS_INT32)
                        %foreach ssIdx = SIZE(mm.ForEachSSLoopBnds,1)
                            %assign iterVar = "i_%<ForEachLoopHierarchyLevel>"
                            %assign ::ForEachLoopHierarchyLevel = ::ForEachLoopHierarchyLevel - 1
                            %<int32Type> %<iterVar>;
                            for (%<iterVar> = 0; %<iterVar> < %<mm.ForEachSSLoopBnds[::ForEachLoopHierarchyLevel]>; %<iterVar>++) {
                                %assign mmPrOffset = mmPrOffset + "+" + iterVar + "*%<mm.ForEachSSMassMatrixPrSize[::ForEachLoopHierarchyLevel]>"
                            %endforeach
                            %assign ::ForEachLoopHierarchyLevel = 1
                %else
                    %assign mmPrOffset = LibIsDeploymentDiagram() ? ...
                        "%<SLibDeploymentGetSystemMassMatrixPr(grSrc[0], grSrc[1], prOffset, isSubsys)>" : "%<prOffset>"
                %endif

                %<SLibBlockMassMatrixPrOffsetInternal("", "", 0, dwIdx, dw, 1)> = %<mmPrOffset>; %<comment>

                %if ISFIELD(mm, "ForEachSSLoopBnds")
                    %% Close the loop for every parent For Each subsystem
                    %foreach ssIdx = SIZE(mm.ForEachSSLoopBnds,1)
                    }
                %endforeach
            }
            %assign ::NeedForEachLoopInReg = TLC_FALSE
                %endif

            %endwith
        %endforeach
    }

    %closefile tempbuf

    %return tempbuf

%endfunction   %% FcnGenInitMassMatrixPr



%function FcnGenInitMassMatrixPrInRoot() void

    %openfile retBuf

    %if (::CompiledModel.ModelIsLinearlyImplicit == "yes") && !IsModelReferenceTarget()

        %assign ss = System[NumSystems - 1] %% root system

        %<FcnGenInitMassMatrixPr(ss)>

    %endif

    %closefile retBuf
    %if !WHITE_SPACE(retBuf)
        %return retBuf
    %else
        %return ""
    %endif

%endfunction %% FncGenInitMassMatrixPrInRoot


%% Function FcnNonRootSystemHasModes(system) ===================================
%% Description:
%%      Return whether system is not root and has modes
%function FcnNonRootSystemHasModes(system) void
    %if system.Type == "root"
        %return TLC_FALSE
    %else
        %assign callSites      = system.CallSites
        %assign graphParentSys = ::CompiledModel.System[callSites[0][2]]
        %assign ssBlock        = graphParentSys.Block[callSites[0][3]]
        %return ssBlock.ModeVector[0] > 0
    %endif
%endfunction


%% Function: FcnGenerateTerminate ==================================================================
%% Description:
%%      Generate terminate code for the system
%%
%% TopTester: test/toolbox/simulink/variants/var-general/tVariantGecks6.m
%% TopTester: test/toolbox/simulink/variants/var-mgr-cmd/tVariantManager3.m
%% TopTester: test/toolbox/rtw/targets/AUTOSAR/Variants/dimensionVariants/tDimensionVariants9.m
%%
%function FcnGenerateTerminate(system)
    %openfile tmpBuffer
    %with system
        %if system.Type == "root"
            %foreach idx = LibGetNumAsyncTasks()
                %assign tid = idx + NumRuntimeExportedRates
                %if RTMAbsTimeNeedTransProtection(tid) && ...
                    SLibConcurrentTasks()
                    %<SLibCGIRMutexOp(3,SLibGetTimerSemID(tid))>
                %endif
            %endforeach
            %<SLibTermServicePorts()>
        %endif
        %if SLibNonEmptyModel()
            %assign rootOpaqueBlock = FcnRootOpaqueBlock()
            %assign ::CurrentModuleIdx = system.CGIRModuleIdx
            %assign termCode = FcnGenerateCodeFromModule(rootOpaqueBlock, system, "Terminate")
            %assign ::CurrentModuleIdx = -1
            %<termCode>
            %if system.Type == "root" && ::isRAccel
                %if ::raccelObserverLog
                    observerLogCleanup();
                %endif
                %assign nulldef = SLibGetNullDefinitionFromTfl()
            %endif
        %endif
    %endwith
    %% Stateflow global machine terminate
    %if IsBaseSystem(system.SystemIdx)
        %<SLibWriteMachineTerminate()>\
        %% slplugin function call for model reference accel mode
        %if IsModelReferenceSimTarget() && !GenerateClassInterface
            if(!slIsRapidAcceleratorSimulating()) {
                %assign simS = RTMsGet(system, "MdlRefSfcnS")
                slmrRunPluginEvent(%<simS>, "%<CompiledModel.Name>", "SIMSTATUS_TERMINATING_MODELREF_ACCEL_EVENT");
            }
        %endif
        %<SLibDumpOpaqueTypeDestructCode(::CompiledModel.System[GetBaseSystemIdx()], "OpaqueTypeDestruct", TLC_TRUE)>
    %endif

    %closefile tmpBuffer
    %if !WHITE_SPACE(tmpBuffer)
        %% If "Terminate function required" is OFF, do not generate terminate code
        %% since it will not get used in generated code. Also warn the user that
        %% the terminate code is getting discarded.
        %if !IncludeMdlTerminateFcn
            %<FcnThrowTerminateFcnWarning()>
            %assign tmpBuffer = ""
        %endif
        %return tmpBuffer
    %else
        %return ""
    %endif
%endfunction  %% FcnGenerateTerminate

%% Function: FcnThrowTerminateFcnWarning ===========================================================
%% Description:
%%      Throw warning that code generation did not generate a terminate function.
%%      The warning will be thrown only once.
%%
%function FcnThrowTerminateFcnWarning() void
    %if !ISFIELD(::CompiledModel,"TerminateFcnWarningThrown")
        %if SLibIsExportFcnDiagram()
            %<SLibReportWarningWithId("Coder:buildProcess:TerminateFunctionNecessaryExportFcnModel")>
        %else
            %<SLibReportWarningWithId("Coder:buildProcess:TerminateFunctionNecessaryRequiredOff")>
        %endif
        %<LibAddToCompiledModel("TerminateFcnWarningThrown",TLC_TRUE)>
    %endif
%endfunction %% FcnThrowTerminateFcnWarning


%% Function: FcnGenBodyTerminateFcnCache(system) ===============================
%% Description:
%%      Caches system Terminate function
%%
%% TopTester: test/toolbox/rtw/targets/AUTOSAR/Variants/dimensionVariants/tDimensionVariants9.m
%%
%function FcnGenBodyTerminateFcnCache(system) void
    %assign terminateFcn    = FcnGenerateTerminate(system)
    %if IsBaseSystem(system.SystemIdx)
        %assign terminateProf = SLibGenProfSysTerminate(system)
        %<LibSetSystemField(system, "CachedTerminateProfileEndCode", terminateProf)>
    %endif
    %<LibSetSystemField(system, "CachedTerminateFcn",    terminateFcn)>
    %<FcnCacheLocalVars(system, "Terminate")>
    %<LibDefineSystemFcn(system, "Terminate")>
    %assign terminateNonEmpty = SLibSystemTerminateNonEmpty(system)
    %<LibSetSystemField(system, "SystemTerminateNonEmpty", terminateNonEmpty)>
    %<LibSetSystemField(system, "SystemTerminateCached", TLC_TRUE)>

%endfunction %% FcnGenBodyTerminateFcnCache

%% Function: FcnGenerateTidGuardOpenCodeInMain(tid) =====================
%%  Return TID guard open potion.
%%  If rate grouping is on, return "" because
%%  rate grouped code does not need tid guard
%%
%% NOTE: This function is similar to FcnGenerateTidGuardOpenCode function
%% except for the MajorTimeStep check (since this code will be in main.c)
%function FcnGenerateTidGuardOpenCodeInMain(tid)
    %if SLibIsPeriodicRateGrouping()
        %return "{ %<LibTaskComment(tid)>"
    %else
        %assign tidGuard = FcnERTIsSampleHitInMain(tid)
        %if tidGuard == "1"
            %return "{ %<LibTaskComment(tid)>"
        %else
            %return  "if (%<tidGuard>) { %<LibTaskComment(tid)>"
        %endif
    %endif
%endfunction %%  FcnGenerateTidGuardOpenCode

%% Function: FcnGenerateTidGuardOpenCode(tid) ===========================
%%  Return TID guard open potion.
%%  If rate grouping is on, return "" because
%%  rate grouped code does not need tid guard
%%
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%%
%function FcnGenerateTidGuardOpenCode(tid)
    %if SLibIsPeriodicRateGrouping()
        %return "{ %<LibTaskComment(tid)>"
    %else
        %assign tidGuard = LibIsSampleHit(tid)
        %if tidGuard == "1"
            %return "{ %<LibTaskComment(tid)>"
        %else
            %return  "if (%<tidGuard>) { %<LibTaskComment(tid)>"
        %endif
    %endif
%endfunction %%  FcnGenerateTidGuardOpenCode

%% Function: FcnGenerateTidGuardCloseCode(tid) ===========================
%%  Return TID guard close potion.
%%  If rate grouping is on, return "" because
%%  rate grouped code does not need tid guard
%%
%function FcnGenerateTidGuardCloseCode(tid)
    %return  "}"
%endfunction %%  FcnGenerateTidGuardCloseCode


%% Function: SystemNeedTidGuard(system, tid) =====================
%% Return true if tid guard is need in subsystem code for specific
%% tid
%%
%function SystemNeedTidGuard(system, tid)
    %assign needTidGuard = TLC_TRUE

    %if LibIsSingleRateSystem(system)
        %assign needTidGuard = TLC_FALSE
    %elseif SLibSingleTasking() && TID == 0 && ...
        (Accelerator || (CodeFormat!="S-Function"))
        %assign needTidGuard = TLC_FALSE
    %endif

    %return needTidGuard
%endfunction

%function FcnGenerateTimeManagementForDuringExecution(tid)

    %assert SLibGetUsingTimerServiceLevel() > 0
    %if ISEMPTY(tid)
        %assign tid = 0
    %endif

    %if SLibGetTimerServiceWhenToCallRule(tid) != "DuringExecution" || IsModelReferenceTarget()
        %return ""
    %endif

    %assign needTimeService = SLibNeedAbsoluteTimeService(tid)
    %assign needTickService = SLibNeedFunctionClockTickService(tid)
    %assign needFunctionStepSizeService = SLibNeedFunctionStepSizeService(tid)
    %assign needFunctionStepTickService = SLibNeedFunctionStepTickService(tid)

    %openfile retBuf
    %if needTimeService || (needFunctionStepSizeService && LibAsynchronousTriggeredTID(tid))
        %<RTMGet("TaskTime%<tid>")> = %<::CompiledModel.TimerService[tid].GetAbsoluteTimeFcnName>();
    %endif
    %if needTickService || (needFunctionStepTickService && LibAsynchronousTriggeredTID(tid))
        %<RTMGet("ClockTick%<tid>")> = %<::CompiledModel.TimerService[tid].GetFunctionClockTickFcnName>();
    %endif
    %if needFunctionStepSizeService && LibAsynchronousTriggeredTID(tid)
        %<RTMGet("FunctionStepSize%<tid>")> = %<RTMGet("TaskTime%<tid>")> - %<RTMGet("PreTaskTime%<tid>")>;
        %<RTMGet("PreTaskTime%<tid>")> = %<RTMGet("TaskTime%<tid>")>;
    %endif
    %if needFunctionStepTickService && LibAsynchronousTriggeredTID(tid)
        %<RTMGet("FunctionStepTick%<tid>")> = %<RTMGet("ClockTick%<tid>")> - %<RTMGet("PreClockTick%<tid>")>;
        %<RTMGet("PreClockTick%<tid>")> = %<RTMGet("ClockTick%<tid>")>;
    %endif

    %closefile retBuf
    %return retBuf
%endfunction


%% Function: FcnGenerateTimeManagementForAsyncTs ===================================================
%% Abstractu:
%%   Generate code for asynchronous task to manage timer.
%% An asynchronous task can update its timer from base rate
%% timer, its caller task, or external timer.
%%
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function FcnGenerateTimeManagementForAsyncTs(fcnType, tid,loc)
    %assert LibAsynchronousTriggeredTID(tid) || SLibExplicitTaskingTID(tid) || ...
        SLibGetTimerServiceWhenToCallRule(tid) == "DuringExecution"

    %if SLibGetUsingTimerServiceLevel() >= 3 || SLibNeedFunctionClockTickService(tid)
        %if loc == "top"
            %return FcnGenerateTimeManagementForDuringExecution(tid)
        %else
            %return ""
        %endif
    %endif

    %if !SLibNeedAbsoluteTimeForTID(tid) || !ClockTickForTIDIsReqFcn(tid)
        %% Instead of using condition !LibAsyncTaskAccessTimeInFcn(tid, ::BlockFcn),
        %% use !SLibNeedAbsoluteTimeForTID(tid) || !ClockTickForTIDIsReqFcn(tid)
        %% (g1182394).
        %return ""
    %endif
    %assign ts  = SampleTime[tid]

    %% If async timer is Self_internal, timer increase by 1
    %% when timer is update. Timer should be updated in Outputs function
    %% once and only once. Timer can't be updated in other fcn type.
    %if ts.TimeSource == "Self_internal"
        %if (fcnType != "Outputs" && fcnType != "Output") || loc == "top"
            %return ""
        %endif
    %else
        %if loc == "bottom"
            %return ""
        %endif
    %endif

    %% If sample time is Asynchronous and need abs time,
    %% and this subsystem is the top one associated with
    %% the async sample time, then
    %% fcnCall need update absolute time whenever it
    %% runs.
    %openfile retBuf
    %if (ts.Asynchronous == "yes" || ts.ExplicitTasking == "yes") && ...
        ts.NeedAbsoluteTime == "yes"
        %if ts.TimeSource == "BaseRate"
            %<FcnAsyncTaskUpdatesTimersFromBaseRate(tid)>
        %elseif ts.TimeSource == "Self" && ...
            !ISFIELD(SampleTime[tid], "AsyncSfcnBlkIdx")
            %if ISFIELD(ts,"EventTaskTimeClock")
                %<LibGetClockTick(tid)> =   %<ts.EventTaskTimeClock>(%<ts.SGID>);
            %elseif SampleTime[tid].IsUnionTs != "yes" && ...
                SampleTime[tid].EventSourceType != "MultiCaller"
                %<LibGetClockTick(tid)> = getTick(%<tid>);
            %endif
        %elseif SampleTime[tid].TimeSource == "Self_internal"
            %assign ct = LibGetClockTick(tid)
            %<SLibUpdateClockTickForTID(tid, ct)>
        %elseif SampleTime[tid].TimeSource == "Caller"
            %<LibGetClockTick(tid)> = %<LibGetClockTick(FcnGetAsyncPromotedTID(tid))>;
        %endif
    %endif
    %closefile retBuf
    %return retBuf
%endfunction

%% Function:SLibGetSysFcnBodyHelper =================
%%
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function SLibGetSysFcnBodyHelper(system, fcnType, dontChkEmpty, tid)
    %assign system.CurrentTID = tid

    %assign dontChkEmpty = dontChkEmpty || ...
        (fcnType == "OutputUpdate" && ...
        (LibSystemIsForceNonInline(system) || LibIsServer(system) && system.IsConstUncalledFunction == "no"))

    %openfile retBuf

    %assert TYPE(tid) == "Number" || ISEQUAL(tid, "")

    %if LibAsynchronousTriggeredTID(tid) && ...
        !SLibNonInlinedModelWideEventTID(tid)
        %% asynchronous tid
        %% below added for
        %% runsuite tClientServer3 -testspec:testInOutArgs
        %% Do not skip an empty function when it is exported
        %if SLibIsExplicitTaskingExportFcnRateGrouping(fcnType, tid)
            %assign hasFcnBody = TLC_TRUE
        %else
            %assign hasFcnBody = (dontChkEmpty || ...
                !LibSystemFcnIsEmptyForTID(system,fcnType)) && ...
                !IsBaseSystem(system.SystemIdx)
        %endif

    %elseif ISEQUAL(tid, "") && ...
        (!FcnSysModuleIsRateGrouping(system,fcnType) || !SLibIsExportFcnDiagram())
        %if !IsModelReferenceSimTarget()
            %assign hasFcnBody = dontChkEmpty || ...
                !LibSystemFcnIsEmptyHelper(system, fcnType, tid)
        %else
            %% This code is needed because for model ref sim target, the tid of a simulink function SS
            %% does not appear to be the actual tid of the subsystem in the model. In the case
            %% of a simulink function, the tid might be 1 for the SLF SS in rtw
            %% codegen but would be "" for modelref sim codegen. If it is ""
            %% then we need to loop over all tids to see if the SLF subsystem is
            %% really empty. This may result in empty/uncalled SS code in the sim
            %% code, but since it is simulation this is not a problem.
            %assign hasFcnBody = dontChkEmpty || ...
                !LibSystemFcnIsEmpty(system,fcnType)
        %endif
    %else
        %% tid that is a top level entry point
        %assign hasFcnBody = dontChkEmpty || ...
            !LibSystemFcnIsEmptyForTID(system,fcnType)
    %endif

    %if hasFcnBody
        %assign  fcnBody =  SLibGetBody%<fcnType>FcnCache(system)
        %<fcnBody>
    %endif

    %if FcnAddMdlRefTid1Interface(system, tid)
        %<SLibGetSysFcnBodyHelper(system, fcnType, dontChkEmpty, 1)>
    %endif

    %closefile retBuf
    %assign fcnRecord = SLibSystemFcnInfoRecord(system, fcnType)
    %assign fcnName = fcnRecord.CGIRName
    %assign sourceFileName = CGMODEL_ACCESS("FileRepository.getSourceFileForFunctionName", fcnName)
    %assign headerFileName = CGMODEL_ACCESS("FileRepository.getHeaderFileForFunctionName", fcnName)

    %if SLibGetEnableFileControlForEntryPointFcns() && !SLibFCTInfoStoredUsingFcnName(system.CurrentTID) && ISEMPTY(sourceFileName)
        %if fcnType == "Output" || fcnType == "OutputUpdate"
            %assign sourceFileName = GetEntryPointFcnMappedFile("OutputFcn", "Source", system.CurrentTID)
            %assign headerFileName = GetEntryPointFcnMappedFile("OutputFcn", "Header", system.CurrentTID)
        %elseif fcnType == "Update"
            %assign sourceFileName = GetEntryPointFcnMappedFile("UpdateFcn", "Source", system.CurrentTID)
            %assign headerFileName = GetEntryPointFcnMappedFile("UpdateFcn", "Header", system.CurrentTID)
        %endif
    %endif

    %assign system.CurrentTID = -1

    %if sourceFileName == SLibGetFileNameForSystemCode("sys_fcn_defn", system.SystemIdx) + "." + ::LangFileExt
        %return retBuf
    %endif

    %if !SLibGetEnableFileControlForSimulinkFcns() || ISEMPTY(sourceFileName)
        %return retBuf
    %else
        %assign opFile = SLibAddModelFile("SystemSource", "Simulink", sourceFileName)
        %assign modelHdrFile = LibGetMdlPubHdrBaseName() + ".h"
        %<SLibSetModelFileAttribute(opFile, "Group", "model")>
        %<SLibSetModelFileAttribute(opFile, "Functions", retBuf)>
        %<LibSetIncludesSection(opFile, "RequiredIncludes", headerFileName)>
        %<LibSetIncludesSection(opFile, "RequiredIncludes", modelHdrFile)>
        %return ""
    %endif
%endfunction

%function FcnGetCodeCacheTid(system, fcnType, tid) void
    %assign tid01eq = ISEQUAL(SolverType, "FixedStep") && FixedStepOpts.TID01EQ
    %if tid01eq && tid == 1
        %assign tid = 0
    %endif
    %return SLibSynchronousTID(tid) && ...
        !SLibSystemFcnPeriodicRateGrouping(system, fcnType) ? "" : ...
        tid
%endfunction

%% Function: SLibGetRateGroupedFcnBody =============================================================
%%   Returned rate grouped Fcn body
%%  Only "Update" "Output" "OutputUdate" fcn body can
%%  be rate grouped.
%%  If system tid is asynchronous tid,
%%      always return rate grouped fcn body.
%%  If system tid is synchronous tid,
%%      - return rate grouped body if system is rate grouped
%%      - otherwise, return non-rate-grouped body.
%function SLibGetRateGroupedFcnBody(system, fcnType, dontChkEmpty)
    %openfile retBuf
    %%
    %assert fcnType == "Update" || ...
        fcnType == "Output" || fcnType == "OutputUpdate"

    %assign ssTaskToFirstTid = FcnGetSubsystemTaskToFirstTID(system)
    %foreach idx = SIZE(ssTaskToFirstTid, 1)
        %assign tid = FcnGetCodeCacheTid(system, fcnType, ssTaskToFirstTid[idx])
        %<SLibGetSysFcnBodyHelper(system, fcnType, dontChkEmpty, tid)>
    %endforeach

    %closefile retBuf
    %return retBuf
%endfunction %% SLibGetRateGroupedFcnBody

%function SLibIsMemberMethod(system, fcnType)
    %assign ssTaskToFirstTid = FcnGetSubsystemTaskToFirstTID(system)
    %foreach idx = SIZE(ssTaskToFirstTid, 1)
        %assign tid = FcnGetCodeCacheTid(system, fcnType, ssTaskToFirstTid[idx])
        %assign fcnInfo = LibGetFcnInfo(system, fcnType, tid)

        %assign openStr = fcnInfo.Open

        %if EXISTS(::CPPClassName) && ::CPPClassName != ""
            %assign classPrefix = ::CPPClassName + "::"
            %if ISSUBSTRING(openStr, classPrefix) && ...
                !ISSUBSTRING(fcnInfo.Name, classPrefix)
                %return TLC_TRUE
            %endif
        %endif
    %endforeach
    %return TLC_FALSE
%endfunction

%% Function: SLibCheckForMemFcn ====================================================================
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%function SLibCheckForMemFcn(system, needToDumpSysFcn)
    %assign isRoot       = (system.Type == "root")
    %assign dontChkEmpty = isRoot

    %if needToDumpSysFcn
        %if ISFIELD(system,"SetupRuntimeResourcesFcn")
            %if !LibSystemFcnIsEmpty(system, "SetupRuntimeResources")
                %return SLibIsMemberMethod(system,"SetupRuntimeResources")
            %endif
        %endif
        %if ISFIELD(system,"InitializeFcn")
            %if !LibSystemFcnIsEmpty(system, "Initialize")
                %return SLibIsMemberMethod(system,"Initialize")
            %endif
        %endif
        %if ISFIELD(system,"SystemInitializeFcn")
            %if !LibSystemFcnIsEmpty(system, "SystemInitialize")
                %return SLibIsMemberMethod(system,"SystemInitialize")
            %endif
        %endif
        %if ISFIELD(system,"SystemResetFcn")
            %if !LibSystemFcnIsEmpty(system, "SystemReset")
                %return SLibIsMemberMethod(system,"SystemReset")
            %endif
        %endif
        %% EnableFcn always exists
        %if ISFIELD(system,"EnableFcn")
            %if !LibSystemFcnIsEmpty(system,"Enable")
                %return SLibIsMemberMethod(system,"Enable")
            %endif
        %endif
        %% DisableFcn always exists
        %if ISFIELD(system,"DisableFcn")
            %if !LibSystemFcnIsEmpty(system,"Disable")
                %return SLibIsMemberMethod(system, "Disable")
            %endif
        %endif
        %% FinalizeDimsFcn may or may not exist
        %if ISFIELD(system, "FinalizeDimsFcn")
            %if !LibSystemFcnIsEmpty(system, "FinalizeDims")
                %return SLibIsMemberMethod(system, "FinalizeDims")
            %endif
        %endif
        %% SetDimsFcn may exist
        %if ISFIELD(system, "SetDimsFcn")
            %if !LibSystemFcnIsEmpty(system, "SetDims")
                %return SLibIsMemberMethod(system, "SetDims")
            %endif
        %endif
        %% StartFcn always exists
        %if ISFIELD(system,"StartFcn")
            %if dontChkEmpty || !LibSystemFcnIsEmpty(system,"Start")
                %return SLibIsMemberMethod(system, "Start")
            %endif
        %endif
        %if ISFIELD(system,"OutputFcn")
            %return SLibIsMemberMethod(system, "Output")
        %endif
        %if ISFIELD(system,"UpdateFcn")
            %return SLibIsMemberMethod(system, "Update")
        %endif
        %if ISFIELD(system,"DerivativeFcn") && (!isRoot || (NumContStates > 0))
            %if dontChkEmpty || !LibSystemFcnIsEmpty(system,"Derivative")
                %return SLibIsMemberMethod(system, "Derivative")
            %endif
        %endif
        %if ISFIELD(system,"ProjectionFcn") && (!isRoot || (NumContStates > 0))
            %if dontChkEmpty || !LibSystemFcnIsEmpty(system,"Projection")
                %return SLibIsMemberMethod(system, "Projection")
            %endif
        %endif
        %if ISFIELD(system,"ForcingFunctionFcn") && (ModelIsLinearlyImplicit == "yes") && (!isRoot || (NumContStates > 0))
            %if dontChkEmpty || !LibSystemFcnIsEmpty(system,"ForcingFunction")
                %return SLibIsMemberMethod(system, "ForcingFunction")
            %endif
        %endif
        %if ISFIELD(system,"MassMatrixFcn") && (ModelIsLinearlyImplicit == "yes") && (!isRoot || (NumContStates > 0))
            %if dontChkEmpty || !LibSystemFcnIsEmpty(system,"MassMatrix")
                %return SLibIsMemberMethod(system, "MassMatrix")
            %endif
        %endif
        %if ISFIELD(system,"ZeroCrossingFcn") && (!isRoot || (NumNonsampledZCs > 0))
            %if dontChkEmpty || !LibSystemFcnIsEmpty(system,"ZeroCrossing")
                %return SLibIsMemberMethod(system, "ZeroCrossing")
            %endif
        %endif
        %if ISFIELD(system,"OutputUpdateFcn")
            %return SLibIsMemberMethod(system, "OutputUpdate")
        %endif
        %if ISFIELD(system,"CleanupRuntimeResourcesFcn")
            %if !LibSystemFcnIsEmpty(system, "CleanupRuntimeResources")
                %return SLibIsMemberMethod(system,"CleanupRuntimeResources")
            %endif
        %endif
        %% TerminateFcn should always exist
        %if (!isRoot || !(Accelerator && CGMODEL_ACCESS("CGModel.AcceleratorExpandedSystemFcns") == 0)) && ...
            (dontChkEmpty || !LibSystemFcnIsEmpty(system,"Terminate"))
            %return SLibIsMemberMethod(system, "Terminate")
        %endif
        %if ISFIELD(system, "ConstCodeFcn")
            %if !LibSystemFcnIsEmpty(system,"ConstCode")
                %return SLibIsMemberMethod(system, "ConstCode")
            %endif
        %endif
        %return TLC_FALSE
    %else
        %return TLC_FALSE
    %endif %% needToDumpSysFcn
%endfunction

%% Function: SLibGetSystemFcnBodyCacheHelper =======================================================
%% Abstract:
%%     Helper function for SLibGetSystemFcnBodyCache
%%
%% TopTester: test/toolbox/simulink/coreblocks/lib_SignalAttributes/InitialCondition/rtw/tinitcond.m
%% TopTester: test/toolbox/simulink/blocks/sb2sl/tsb2slmdlref2.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%function SLibGetSystemFcnBodyCacheHelper(system, needToDumpSysFcn)
    %assign isRoot       = (system.Type == "root")
    %assign dontChkEmpty = isRoot
    %openfile codeBuffer

    %if needToDumpSysFcn
        %if ISFIELD(system,"SetupRuntimeResourcesFcn")
            %if !LibSystemFcnIsEmpty(system, "SetupRuntimeResources")
                %<SLibGetBodySetupRuntimeResourcesFcnCache(system)>
            %endif
        %endif
        %if ISFIELD(system,"InitializeFcn")
            %if !LibSystemFcnIsEmpty(system, "Initialize")
                %<SLibGetBodyInitializeFcnCache(system)>
            %endif
        %endif
        %if ISFIELD(system,"SystemInitializeFcn")
            %if !LibSystemFcnIsEmpty(system, "SystemInitialize")
                %<SLibGetBodySystemInitializeFcnCache(system)>
            %endif
        %endif
        %if ISFIELD(system,"SystemResetFcn")
            %if !LibSystemFcnIsEmpty(system, "SystemReset")
                %<SLibGetBodySystemResetFcnCache(system)>
            %endif
        %endif
        %% EnableFcn always exists
        %if ISFIELD(system,"EnableFcn")
            %if !LibSystemFcnIsEmpty(system,"Enable")
                %<SLibGetBodyEnableFcnCache(system)>
            %endif
        %endif
        %% DisableFcn always exists
        %if ISFIELD(system,"DisableFcn")
            %if !LibSystemFcnIsEmpty(system,"Disable")
                %<SLibGetBodyDisableFcnCache(system)>
            %endif
        %endif
        %% FinalizeDimsFcn may or may not exist
        %if ISFIELD(system, "FinalizeDimsFcn")
            %if !LibSystemFcnIsEmpty(system, "FinalizeDims")
                %<SLibGetBodyFinalizeDimsFcnCache(system)>
            %endif
        %endif
        %% SetDimsFcn may exist
        %if ISFIELD(system, "SetDimsFcn")
            %if !LibSystemFcnIsEmpty(system, "SetDims")
                %<SLibGetBodySetDimsFcnCache(system)>
            %endif
        %endif
        %% StartFcn always exists
        %if ISFIELD(system,"StartFcn")
            %if dontChkEmpty || !LibSystemFcnIsEmpty(system,"Start")
                %<SLibGetBodyStartFcnCache(system)>
            %endif
        %endif
        %if ISFIELD(system,"OutputFcn")
            %<SLibGetRateGroupedFcnBody(system, "Output", dontChkEmpty)>
        %endif
        %if ISFIELD(system,"UpdateFcn")
            %<SLibGetRateGroupedFcnBody(system, "Update", dontChkEmpty)>
        %endif
        %if ISFIELD(system,"DerivativeFcn") && (!isRoot || (NumContStates > 0))
            %if dontChkEmpty || !LibSystemFcnIsEmpty(system,"Derivative")
                %<SLibGetBodyDerivativeFcnCache(system)>
            %endif
        %endif
        %if ISFIELD(system,"ProjectionFcn") && (!isRoot || (NumContStates > 0))
            %if dontChkEmpty || !LibSystemFcnIsEmpty(system,"Projection")
                %<SLibGetBodyProjectionFcnCache(system)>
            %endif
        %endif
        %if ISFIELD(system,"ForcingFunctionFcn") && (ModelIsLinearlyImplicit == "yes") && (!isRoot || (NumContStates > 0))
            %if dontChkEmpty || !LibSystemFcnIsEmpty(system,"ForcingFunction")
                %<SLibGetBodyForcingFunctionFcnCache(system)>
            %endif
        %endif
        %if ISFIELD(system,"MassMatrixFcn") && (ModelIsLinearlyImplicit == "yes") && (!isRoot || (NumContStates > 0))
            %if dontChkEmpty || !LibSystemFcnIsEmpty(system,"MassMatrix")
                %<SLibGetBodyMassMatrixFcnCache(system)>
            %endif
        %endif
        %if ISFIELD(system,"ZeroCrossingFcn") && (!isRoot || (NumNonsampledZCs > 0))
            %if dontChkEmpty || !LibSystemFcnIsEmpty(system,"ZeroCrossing")
                %<SLibGetBodyZeroCrossingFcnCache(system)>
            %endif
        %endif
        %if ISFIELD(system,"OutputUpdateFcn")
            %<SLibGetRateGroupedFcnBody(system, "OutputUpdate", dontChkEmpty)>
        %endif
        %if ISFIELD(system,"CleanupRuntimeResourcesFcn")
            %if !LibSystemFcnIsEmpty(system, "CleanupRuntimeResources")
                %<SLibGetBodyCleanupRuntimeResourcesFcnCache(system)>
            %endif
        %endif
        %% TerminateFcn should always exist
        %if (!isRoot || !(Accelerator && CGMODEL_ACCESS("CGModel.AcceleratorExpandedSystemFcns") == 0)) && ...
            (dontChkEmpty || !LibSystemFcnIsEmpty(system,"Terminate")) && ...
            IncludeMdlTerminateFcn
            %openfile termFcnBuffer
            %<SLibGetBodyTerminateFcnCache(system)>
            %closefile termFcnBuffer
            %<SLibPrintEntryPointFcnToFile("TermFcn", "Source", 0, "", termFcnBuffer, "Definition")>\
        %endif
        %if ISFIELD(system, "ConstCodeFcn")
            %if !LibSystemFcnIsEmpty(system,"ConstCode")
                %<SLibGetBodyConstCodeFcnCache(system)>
            %endif
        %endif
    %endif
    %closefile codeBuffer
    %return codeBuffer
%endfunction

%% Function: NotRootFileName =======================================================================
%% Abstract:
%%    Return true if the code for this system does not go to model.c
%%
%function NotRootFileName(system)
    %assign isRoot = (system.Type == "root")
    %assign notRootFileName = 0
    %if !isRoot
        %assign rootFileName = GetRootSystemSourceFileName()
        %assign notRootFileName = (CGMODEL_ACCESS("CGModel.System.SourceFileName", system.SystemIdx) != rootFileName)
    %endif
    %return notRootFileName
%endfunction

%% Function: SLibDumpGlobalVarDeclaration ==========================================================
%% Abstract:
%%     Dump global variable declration in the specified file.
%%
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%%
%function SLibDumpGlobalVarDeclaration(system, file) void
    %if !system.StandaloneSubsystem
        %assign buf = LibDeclareGlobalVars(system,"","")
        %if !WHITE_SPACE(buf)
            %assign sysInfo = GetSystemNameForComments(system)
            %openfile globalBuf

            /* Declare global variables for system: %<sysInfo> */
            %<buf>\
            %closefile globalBuf
            %<SLibSetModelFileAttribute(file, "Declarations",globalBuf)>

            %if IsModelReferenceTarget()
                %<FcnDeclareCanonicalIOArgInModelReferncePrivateHeaderFile(system)>\
            %endif
        %endif
    %endif
%endfunction


%% Function: LibSetSharedFunctionOutputDir
%% TopTester: test/toolbox/simulink/compiletime_xform/lutToPLookupInterpND/tPir2EngineLutGecks04.m
%%
%function LibSetSharedFunctionOutputDir(system, includeSourceFile)
    %assign duplicate = LibAddToReusableLibModelSources(CGMODEL_ACCESS("CGModel.System.SourceFileName", system.SystemIdx))
    %assign libname = SLibGetReusableLibraryOutputDirectory(system)
    %assign sysIdx = system.SystemIdx
    %assign usingLibraryCode = CGMODEL_ACCESS("CGModel.getSystemUsesLibraryCode", sysIdx)
    %if (usingLibraryCode)
        %assign libname = CGMODEL_ACCESS("CGModel.getCompiledLibraryFileLocation", sysIdx)
    %endif

    %if includeSourceFile
        %assign srcFile = SLibGetFileRecForSystemCode("sys_fcn_defn", system, TLC_TRUE, TLC_FALSE)
        %<LibSetSourceFileOutputDirectory(srcFile, libname)>
    %endif

    %assign hdrFile = SLibGetFileRecForSystemCode("sys_fcn_decl", system, TLC_TRUE, TLC_FALSE)
    %<LibSetSourceFileOutputDirectory(hdrFile, libname)>

    %% Add source file
    %if LibIsSystemExistingLibrary(system) && !duplicate
        %if includeSourceFile
            %assign FileName  = SLibGetFileNameForSystemCode("sys_fcn_defn", sysIdx)
            %assign sourceExt = ::LangFileExt
            %if (usingLibraryCode)
                %%assign group = "sharedlibraryutility"
                %<SLibAddGeneratedFileToList("%<FileName>.%<sourceExt>", ...
                    "sharedlibraryutility","source",libname)>
            %else
                %<SLibAddGeneratedFileToList("%<FileName>.%<sourceExt>", ...
                    "utility","source",libname)>
            %endif
            %<LibSetSourceFileSection(srcFile, "WrittenToDisk", TLC_TRUE)>
        %endif

        %% Add header file
        %assign FileName  = SLibGetFileNameForSystemCode("sys_fcn_decl", sysIdx)
        %if (usingLibraryCode)
            %<SLibAddGeneratedFileToList("%<FileName>.h","sharedlibraryutility", ...
                "header",libname)>
        %else
            %<SLibAddGeneratedFileToList("%<FileName>.h","utility", ...
                "header",libname)>
        %endif
        %<LibSetSourceFileSection(hdrFile, "WrittenToDisk", TLC_TRUE)>
    %endif
    %return duplicate
%endfunction


%% Function: LibSetPublicServerOutputDir
%function LibSetPublicServerOutputDir(system) void
    %assign libname = SLibGetReusableLibraryOutputDirectory(system)
    %assign hdrFile = SLibGetFileRecForSystemCode("sys_fcn_decl", system, TLC_TRUE, TLC_FALSE)
    %<LibSetSourceFileOutputDirectory(hdrFile, libname)>
%endfunction

%% Function: LibSkipSystemFcnEmission
%% Abstract: Returns if we need to skip emitting system function.
%%           This is true when the function is already emitted in C++.
%function LibSkipSystemFcnEmission(system) void
    %assign skipEmittingSystemFcn = TLC_FALSE
    %if CGMODEL_ACCESS("CGModel.DirectEmitSubsystemFiles")
        %assign thisModule = ...
            ::CompiledModel.RTWCGModules.RTWCGModule[system.CGIRModuleIdx]
        %if !EXISTS(thisModule.Function)
            %return skipEmittingSystemFcn
        %endif
        %assign numFunctionRecords = SIZE(thisModule.Function)
        %assign numFunctions = numFunctionRecords[1]
        %assign prevFunctionsAreEmitted = TLC_TRUE
        %foreach idx = numFunctions
            %assign func = thisModule.Function[idx]
            %assign skipEmittingSystemFcn = ...
                prevFunctionsAreEmitted && (func.IsAlreadyEmitted == 1)
            %assign prevFunctionsAreEmitted = skipEmittingSystemFcn
        %endforeach
    %endif
    %return skipEmittingSystemFcn
%endfunction
%% endfunction LibSkipSystemFcnEmission

%% Function: SLibDumpSystemHeadersAndBanner ========================================================
%% Abstract:
%%   Dump the header files required by a subsystem
%%   Dump banners in the subsystem file
%function SLibDumpSystemHeadersAndBanner(system) void
    %assign modelName = ::CompiledModel.Name
    %assign includeBuf = ""
    %assign bannerBuf  = ""

    %% This is where we tell the emitter to put Reusable Library Code
    %% and header files into their own Directory, not that of the model
    %if LibSystemIsReusedLibraryFcn(system)
        %assign duplicate = LibSetSharedFunctionOutputDir(system, TLC_TRUE)
    %else
        %assign duplicate = LibAddToModelSources(CGMODEL_ACCESS("CGModel.System.SourceFileName", system.SystemIdx))
    %endif

    %assign ::CompiledModel.HaveSeparateSourceFiles = 1

    %if !duplicate
        %assign fileOwnerSys = ::CompiledModel.System[system.FileNameOwnerIdx]

        %% If we are allowing nonreusable functions to live inside
        %% reusable functions, then handle all necessary extern
        %% global declarations in subsystem files.
        %if ::CompiledModel.AllowNoArgFcnInReusedFcn
            %<SLibGlobalFileHandling(fileOwnerSys, system)>
        %endif
        %openfile bannerBuf
        %% Dump comments, only if its the first time
        /*
        %<SLibSystemBanner(fileOwnerSys)>\
        *
        * Note that the functions contained in this file are part of a Simulink
        * model, and are not self-contained algorithms.
        */
        %closefile bannerBuf
        %openfile includeBuf
        %assign sysFileName = CGMODEL_ACCESS("CGModel.System.HeaderFileName", system.SystemIdx)
        %assign fullSysFileName =  sysFileName + ".h"
        %assign srcFileName = CGMODEL_ACCESS("CGModel.System.SourceFileName", system.SystemIdx) + ".c"
        %assign needSysHeader = ...
            !((SLibAutosarActive() && LibIsGlobalServer(fileOwnerSys)) || ...
            (LibIsServer(fileOwnerSys) && fileOwnerSys.IsConstUncalledFunction == "yes"))
        %if needSysHeader
            %% system.h might include custom headers, so always include system.h in system.c
            %<SLibUpdateHeadersNeededByFile(SLibGetFullFileNameForSystemCode("sys_src_incl", system.SystemIdx), sysFileName + ".h")>\
        %endif
        %if !CGMODEL_ACCESS("FileRepository.getIsFileAlreadyIncluded", fullSysFileName, srcFileName) && needSysHeader
            #include "%<sysFileName>.h"
        %endif

        %% Do not put out an include for global data into a library source file
        %if !LibSystemIsReusedLibraryFcn(system)
            %if IsModelReferenceTarget()
                %assign fileName = SLibGetSystemOutputHdrFileBaseName(System[NumSystems-2])
                %% Only include the header file if the system file name is different
                %% than the model reference base system file name. Note that
                %% system.SystemFileName is included above
                %if fileName != sysFileName
                    /* Include model header file for global data */
                    #include "%<fileName>.h"
                %endif
            %else
                %assign modelHdrFile = LibGetMdlPubHdrBaseName() + ".h"
                %if !CGMODEL_ACCESS("FileRepository.getIsFileAlreadyIncluded", modelHdrFile , srcFileName)
                    /* Include model header file for global data */
                    %<SLibIncludeModelHeader()>
                %endif
            %endif
            %<SLibIncludePrivateHeader()>
            %if SLibIsFunctionProfilingOn()
                %% include model.h in subsystem.c if function-level profiling is on for global externs
                %<SLibUpdateHeadersNeededByFile(srcFileName, LibGetModelFileFullName("ModelHeaderFile"))>
            %endif

            %% copySfcnModulesToBuildDir depends on sfName_private.h in the file
            %if ::CompiledModel.CodeFormat == "S-Function"
                %assign mdlPrivateHeader = SLibGetFullFileNameForCode("mdl_priv_hdr")
                %<SLibUpdateHeadersNeededByFile(srcFileName, mdlPrivateHeader)>
            %endif
        %else
            %% If we're an RLS, and there's any constant parameters, we need to include
            %% the constant parameter extern declaration.
            %if SLibHasSharedConstantParameters()
                %assign externDecls = LibGetSystemField(system, "SharedConstantsExterns")
                %<SLibCacheSystemCodeToFile("sys_data_decl", system, externDecls)>
            %endif
            %assign rlsConstDecl = LibGetSystemField(system, "RLSConstantDecl")
            %<SLibCacheSystemCodeToFile("sys_data_decl", system, rlsConstDecl)>
            %<LibDumpSharedDataIncludes(system)>
        %endif
        %if isRSim && (LibGetMdlSrcBaseName() != CGMODEL_ACCESS("CGModel.System.SourceFileName", system.SystemIdx))
            %assign hasFrF = FcnCheckSystemForFromFileBlock(system)
            %if hasFrF
                extern FrFInfo %<::CompiledModel.Name>_gblFrFInfo[];
            %endif
        %endif

        %closefile includeBuf
    %endif %% if !duplicate ... - comments dumped

    %<SLibCacheSystemCodeToFile("sys_src_ban", system, bannerBuf)>
    %<SLibCacheSystemCodeToFile("sys_src_incl", system, includeBuf)>
%endfunction

%% Function: SLibGetNeedDumpSysFcn
%% Abstract: Returns if we need to dump system function.
%function SLibGetNeedDumpSysFcn(system)
    %assign res = [ TLC_FALSE, TLC_FALSE, "" ]
    %% Dump any variables needed by standalone subsystems
    %assign standVars = ""
    %if system.StandaloneSubsystem
        %assign standVars = SLibDumpStandaloneVarDeclarationsForSystem(system)
    %endif

    %assign needToDumpSysFcn = ((LibIsSystemNonEmpty(system) || ...
        LibIsSystemTerminateNonEmpty(system) || ...
        LibSystemIsForceNonInline(system) || ...
        !ISEMPTY(standVars) || ...
        (system.FileNameOwnerIdx == (system.SystemIdx) && ...
        !FcnCustomDataBuffersIsEmpty(CGMODEL_ACCESS("CGModel.System.SourceFileName", system.SystemIdx),"source",""))) && ...
        !LibSystemIsInlined(system))

    %%
    %% We are in the process of updating stateflow to mark the stateflow
    %% subsystem as "Function", if it is generating a function for the
    %% function call subsystem. When all changes are in A, we can enable
    %% the following Assertion.
    %% For now, stateflow may be inlined, therefore, we need to check
    %% the following:
    %%
    %assign needToDump = needToDumpSysFcn || ...
        !ISEMPTY(LibGetSystemField(system, "CachedSubFunctions"))

    %assign res[0] = needToDump
    %assign res[1] = needToDumpSysFcn
    %assign res[2] = standVars

    %return res
%endfunction

%% Function: SLibGetSystemBodyCache ================================================================
%% Abstract:
%%   Get or dump the cached body for the specified system (including root).
%%
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/simulink/blocks/tselector_blkDialog.m
%%
%function SLibGetSystemBodyCache(system)
    %if LibIsSystemDumped(system)
        %return ""
    %endif

    %assign notRootFileName = NotRootFileName(system)

    %assign res = SLibGetNeedDumpSysFcn(system)

    %assign needToDump = res[0]
    %assign needToDumpSysFcn = res[1]
    %assign standVars = res[2]
    %assign skipSystemEmission = TLC_FALSE

    %if !needToDump


        %if notRootFileName && (system.FileNameOwnerIdx == (system.SystemIdx))
            %% For RLS's, if we're not generating a source file, make sure we still
            %% specify that the header file is going to shared utilities, as it will still
            %% be generated
            %if LibSystemIsReusedLibraryFcn(system)
                %assign dup = LibSetSharedFunctionOutputDir(system, TLC_FALSE)

                %% Since this subsystem is effectively empty, error out for library builds
                %if CGMODEL_ACCESS("CGModel.isCodeGenContextBuild")
                    %<SLibReportErrorWithIdAndArgs("Simulink:librarycodegen:EmptySubsystemForLibraryBuild", ...
                        ["%<system.Name>"])>
                %endif
                %assign fileIdx = SOURCE_FILE_EXISTS("%<system.Identifier>.%<::LangFileExt>")

                %if fileIdx >=0
                    %% Filter the shared source file from the file repository to prevent
                    %% emission of an empty file
                    %<SLibDirectAccessSetFileAttribute(::CompiledModel.ModelFiles.ModelFile[fileIdx], "Filter", TLC_TRUE)>


                %endif

            %endif

            %assign skipSystemEmission = LibSkipSystemFcnEmission(system)
            %if !IsModelReferenceTarget() && !LibIsServer(system) && !skipSystemEmission
                %assign warnTxt = "The subsystem %<system.Name> specifies "...
                    "file name options. However, no code is generated for this subsystem. The specified "...
                    "source code file will not be created. "
                %<LibReportWarning(warnTxt)>
            %endif
        %endif
        %<LibSetSystemField(system, "SystemDumped", TLC_TRUE)>

        %if !skipSystemEmission
            %return ""
        %endif
    %endif

    %openfile codeBuffer1
    %<LibGetSystemField(system, "CachedSubFunctions")>\
    %closefile codeBuffer1

    %assign codeBuffer2 = SLibGetSystemFcnBodyCacheHelper(system, needToDumpSysFcn)
    %assign isMemFcn = TLC_FALSE
    %if GenerateClassInterface
        %assign isMemFcn = SLibCheckForMemFcn(system, needToDumpSysFcn)
    %endif
    %assign needNamespace = TLC_FALSE
    %if isMemFcn
        %assign needNamespace = SLibSystemNeedsNamespace(system)
    %endif

    %%
    %% Comparing with ::CompiledModel.Name will not hold good for RTWSFCN/ACCEL
    %% But, it's OK since we will not generate separate files for them
    %% Systems generating into model.c are handled by srtbody.tlc and dumped
    %% there directly

    %assign retBuf = ""

    %if notRootFileName
        %<SLibDumpSystemHeadersAndBanner(system)>

        %if (ISFIELD(system,"DSMsThatNeedFwdDecl"))
            %assign fileName = SLibGetFullFileNameForSystemCode("sys_data_decl", system.SystemIdx)
            %openfile includeDWorkDecl
            %assign DeclsNeeded = system.DSMsThatNeedFwdDecl
            %foreach dsmIdx = SIZE(DeclsNeeded,1)
                %assign declId = DeclsNeeded[dsmIdx]
                %assign dwRec = ::CompiledModel.DWorks.DWork[declId]
                %<FcnAlwaysGenerateBlockDWorkExternalDefinition(dwRec)>
                %<SLibUpdateSymbolFwdDeclInFile(fileName, LibGetRecordIdentifier(dwRec))>
            %endforeach
            %closefile includeDWorkDecl
            %<SLibCacheSystemCodeToFile("sys_data_decl", system,includeDWorkDecl )>
        %endif

        %<SLibCacheSystemCodeToFile("sys_fcn_defn", system, codeBuffer1)>
        %if needNamespace  %%don't need to check for memfcn, it is done when assigning needNamespace
            %openfile nsopen
            %<SLibEmitNamespaceStartForSystem(system)>
            %closefile nsopen
            %<SLibCacheSystemCodeToFile("sys_fcn_defn", system, nsopen)>
        %endif
        %if isMemFcn == TLC_FALSE %%the check for namespace flag is in SLibEmitNamespaceCloseForNonMemFcn
            %openfile nsStr
            %<SLibEmitNamespaceCloseForSystem(system)>
            %closefile nsStr
            %<SLibCacheSystemCodeToFile("sys_fcn_defn", system, nsStr)>
        %endif

        %<SLibCacheSystemCodeToFile("sys_fcn_defn", system, codeBuffer2)>

        %openfile nsclose
        %<SLibEmitNamespaceCloseForSystem(system)>
        %closefile nsclose
        %<SLibCacheSystemCodeToFile("sys_fcn_defn", system, nsclose)>

        %<SLibCacheSystemCodeToFile("sys_stand_var_decl", system, standVars)>
        %assign isRls = LibSystemIsReusedLibraryFcn(system)
        %assign isGlobalServer = LibIsGlobalServer(system)
        %assign opFile = SLibGetFileRecForSystemCode("sys_stand_var_decl", system, isRls, isGlobalServer)
        %if !GenerateClassInterface
            %<SLibDumpGlobalVarDeclaration(system, opFile)>
        %endif
        %<LibSetSystemField(system, "SystemDumped", TLC_TRUE)>
        %% retBuf is ""
    %else %% dumping into root (model.c) or (model_acc.c)
        %assert !IsModelReferenceTarget()
        %<SLibCacheCodeToFile("mdl_stand_var_decl", standVars)>
        %assign rootFile = SLibGetFileRecForCode("mdl_stand_var_decl")
        %<SLibDumpGlobalVarDeclaration(system, rootFile)>

        %openfile retBuf
        %<codeBuffer1>\
        %if needNamespace
            %<SLibEmitNamespaceStartForSystem(System[NumSystems-1])>
        %endif
        %if isMemFcn == TLC_FALSE
            %<SLibEmitNamespaceCloseForSystem(System[NumSystems-1])>
        %endif
        %<codeBuffer2>\
        %<SLibEmitNamespaceCloseForSystem(System[NumSystems-1])>
        %closefile retBuf
    %endif %% if notRootFileName

    %return retBuf

%endfunction %% SLibGetSystemBodyCache

%% Function: FcnCheckSystemForFromFileBlock(system)
%% Description:
%%    returns true if the system contains a FromFile block
%%    false otherwise.
%function FcnCheckSystemForFromFileBlock(system)
    %foreach idx = system.NumBlocks
        %if system.Block[idx].Type == "FromFile"
            %return 1
        %endif
    %endforeach
    %return 0
%endfunction %% FcnCheckSystemForFromFileBlock

%%      Generates the SetupRuntimeResources function.
%%
%function SLibGetBodySetupRuntimeResourcesFcnCache(ss) void
    %openfile tmpBuffer
    %<LibDumpFcnOpen(ss,"SetupRuntimeResources")>\
    %<FcnDumpMRLocalVars(ss, "SetupRuntimeResources", "")>\
    %<LibDumpSystemSSVars(ss,"SetupRuntimeResources")>\
    %<LibGetSystemLocalVars(ss,"SetupRuntimeResources","")>
    %<SLibGetFcnLocalVars(ss,"SetupRuntimeResources","")>
    %<LibDumpSystemUserCode(ss,"SetupRuntimeResources","Header")>\
    %<LibDumpGlobalVars(ss, "SetupRuntimeResources")>\
    %<LibDumpFcnBegin(ss,"SetupRuntimeResources")>\
    %<LibDumpSystemUserCode(ss,"SetupRuntimeResources","Body")>\
    %<LibDumpSystemFcn(ss,"SetupRuntimeResources")>\
    %<LibDumpSystemUserCode(ss,"SetupRuntimeResources","Trailer")>\
    %<LibDumpFcnClose(ss,"SetupRuntimeResources")>
    %closefile tmpBuffer
    %assign retBuffer = ""
    %if !WHITE_SPACE(tmpBuffer)
        %openfile retBuffer
        %if LibSystemIsInlined(ss)
            %<SLibGetFcnComment(ss,"SetupRuntimeResources")>\
        %else
            %assign fcnAbstract = SLibGetFcnCommentContents(ss,"SetupRuntimeResources")
            %assign fcnInfo = LibGetFcnInfo(ss, "SetupRuntimeResources", ss.CurrentTID)
            %assign fcnBlockDescription = SLibGetBlockDescriptionForSS(ss, "SetupRuntimeResources")
            %addtorecord fcnInfo Abstract fcnAbstract Category "model" GeneratedBy "commonbodlib.tlc" ...
                Type "SetupRuntimeResources" GeneratedFor FcnGeneratedFor(ss) BlockDescription fcnBlockDescription
            %<SLibDumpFunctionBanner(fcnInfo)>
            %undef fcnRec
        %endif
        %<tmpBuffer>\
        %closefile retBuffer
    %endif
    %return retBuffer
%endfunction

%% Function: SLibGetBodyInitializeFcnCache(ss) =================================
%% Description:
%%      Generates the initialize function for these system types.
%%        o enable (states reset)
%%        o enable with trigger (states reset)
%%
%function SLibGetBodyInitializeFcnCache(ss) void
    %openfile tmpBuffer
    %<LibDumpFcnOpen(ss,"Initialize")>\
    %<FcnDumpMRLocalVars(ss, "Initialize", "")>\
    %<LibDumpSystemSSVars(ss,"Initialize")>\
    %<LibGetSystemLocalVars(ss,"Initialize","")>
    %<SLibGetFcnLocalVars(ss,"Initialize","")>
    %<LibDumpSystemUserCode(ss,"Initialize","Header")>\
    %<LibDumpGlobalVars(ss, "Initialize")>\
    %<LibDumpFcnBegin(ss,"Initialize")>\
    %<LibDumpSystemUserCode(ss,"Initialize","Body")>\
    %<LibDumpSystemFcn(ss,"Initialize")>\
    %<LibDumpSystemUserCode(ss,"Initialize","Trailer")>\
    %<LibDumpFcnClose(ss,"Initialize")>
    %closefile tmpBuffer
    %assign retBuffer = ""
    %if !WHITE_SPACE(tmpBuffer)
        %openfile retBuffer
        %if LibSystemIsInlined(ss)
            %<SLibGetFcnComment(ss,"Initial conditions")>\
        %else
            %assign fcnAbstract = SLibGetFcnCommentContents(ss,"Initial conditions")
            %assign fcnInfo = LibGetFcnInfo(ss, "Initialize", ss.CurrentTID)
            %assign fcnBlockDescription = SLibGetBlockDescriptionForSS(ss, "Initial conditions")
            %addtorecord fcnInfo Abstract fcnAbstract Category "model" GeneratedBy "commonbodlib.tlc" ...
                Type "Initialize" GeneratedFor FcnGeneratedFor(ss) BlockDescription fcnBlockDescription
            %<SLibDumpFunctionBanner(fcnInfo)>
            %undef fcnRec
        %endif
        %<tmpBuffer>\
        %closefile retBuffer
    %endif
    %return retBuffer
%endfunction

%% Function: SLibGetBodySystemInitializeFcnCache(ss) =================================
%% Description:
%%      Generates the system initialize function.
%%
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc/tVariantSource3.m
%%
%function SLibGetBodySystemInitializeFcnCache(ss) void
    %openfile tmpBuffer
    %<LibDumpFcnOpen(ss,"SystemInitialize")>\
    %<FcnDumpMRLocalVars(ss, "SystemInitialize", "")>\
    %<LibDumpSystemSSVars(ss,"SystemInitialize")>\
    %<LibGetSystemLocalVars(ss,"SystemInitialize","")>
    %<SLibGetFcnLocalVars(ss,"SystemInitialize","")>
    %<LibDumpSystemUserCode(ss,"Initialize","Header")>\
    %<LibDumpGlobalVars(ss, "SystemInitialize")>\
    %<LibDumpFcnBegin(ss,"SystemInitialize")>\
    %<LibDumpSystemUserCode(ss,"Initialize","Body")>\
    %<LibDumpSystemFcn(ss,"SystemInitialize")>\
    %<LibDumpSystemUserCode(ss,"Initialize","Trailer")>\
    %<LibDumpFcnClose(ss,"SystemInitialize")>
    %closefile tmpBuffer
    %assign retBuffer = ""
    %if !WHITE_SPACE(tmpBuffer)
        %openfile retBuffer
        %if LibSystemIsInlined(ss)
            %<SLibGetFcnComment(ss,"System initialize")>\
        %else
            %assign fcnAbstract = SLibGetFcnCommentContents(ss,"System initialize")
            %assign fcnInfo = LibGetFcnInfo(ss, "SystemInitialize", ss.CurrentTID)
            %assign fcnBlockDescription = SLibGetBlockDescriptionForSS(ss, "System initialize")
            %addtorecord fcnInfo Abstract fcnAbstract Category "model" GeneratedBy "commonbodlib.tlc" ...
                Type "SystemInitialize" GeneratedFor FcnGeneratedFor(ss) BlockDescription fcnBlockDescription
            %<SLibDumpFunctionBanner(fcnInfo)>
            %undef fcnRec
        %endif
        %<tmpBuffer>\
        %closefile retBuffer
    %endif
    %return retBuffer
%endfunction

%% Function: SLibGetBodySystemResetFcnCache(ss) =================================
%% Description:
%%      Generates the system reset function.
%%
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortReset3.m
%%
%function SLibGetBodySystemResetFcnCache(ss) void
    %openfile tmpBuffer
    %<LibDumpFcnOpen(ss,"SystemReset")>\
    %<FcnDumpMRLocalVars(ss, "SystemReset", "")>\
    %<LibDumpSystemSSVars(ss,"SystemReset")>\
    %<LibGetSystemLocalVars(ss,"SystemReset","")>
    %<SLibGetFcnLocalVars(ss,"SystemReset","")>
    %<LibDumpSystemUserCode(ss,"SystemReset","Header")>\
    %<LibDumpGlobalVars(ss, "SystemReset")>\
    %<LibDumpFcnBegin(ss,"SystemReset")>\
    %<LibDumpSystemUserCode(ss,"SystemReset","Body")>\
    %<LibDumpSystemFcn(ss,"SystemReset")>\
    %<LibDumpSystemUserCode(ss,"SystemReset","Trailer")>\
    %<LibDumpFcnClose(ss,"SystemReset")>
    %closefile tmpBuffer
    %assign retBuffer = ""
    %if !WHITE_SPACE(tmpBuffer)
        %openfile retBuffer
        %if LibSystemIsInlined(ss)
            %<SLibGetFcnComment(ss,"Reset conditions")>\
        %else
            %assign fcnAbstract = SLibGetFcnCommentContents(ss,"System reset")
            %assign fcnInfo = LibGetFcnInfo(ss, "SystemReset", ss.CurrentTID)
            %assign fcnBlockDescription = SLibGetBlockDescriptionForSS(ss, "System reset")
            %addtorecord fcnInfo Abstract fcnAbstract Category "model" GeneratedBy "commonbodlib.tlc" ...
                Type "SystemReset" GeneratedFor FcnGeneratedFor(ss) BlockDescription fcnBlockDescription
            %<SLibDumpFunctionBanner(fcnInfo)>
            %undef fcnRec
        %endif
        %<tmpBuffer>\
        %closefile retBuffer
    %endif
    %return retBuffer
%endfunction

%% Function: SLibGetBodyCleanupRuntimeResourcesFcnCache(ss) =================================
%% Description:
%%      Generates the CleanupRuntimeResources function.
%% TopTester: test/toolbox/simulink/blocks/sb2sl/tsb2slmdlref2.m
%%
%function SLibGetBodyCleanupRuntimeResourcesFcnCache(ss) void
    %openfile tmpBuffer
    %<LibDumpFcnOpen(ss,"CleanupRuntimeResources")>\
    %<FcnDumpMRLocalVars(ss, "CleanupRuntimeResources", "")>\
    %<LibDumpSystemSSVars(ss,"CleanupRuntimeResources")>\
    %<LibGetSystemLocalVars(ss,"CleanupRuntimeResources","")>
    %<SLibGetFcnLocalVars(ss,"CleanupRuntimeResources","")>
    %<LibDumpSystemUserCode(ss,"CleanupRuntimeResources","Header")>\
    %<LibDumpGlobalVars(ss, "CleanupRuntimeResources")>\
    %<LibDumpFcnBegin(ss,"CleanupRuntimeResources")>\
    %<LibDumpSystemUserCode(ss,"CleanupRuntimeResources","Body")>\
    %<LibDumpSystemFcn(ss,"CleanupRuntimeResources")>\
    %<LibDumpSystemUserCode(ss,"CleanupRuntimeResources","Trailer")>\
    %<LibDumpFcnClose(ss,"CleanupRuntimeResources")>
    %closefile tmpBuffer
    %assign retBuffer = ""
    %if !WHITE_SPACE(tmpBuffer)
        %openfile retBuffer
        %if LibSystemIsInlined(ss)
            %<SLibGetFcnComment(ss,"CleanupRuntimeResources")>\
        %else
            %assign fcnAbstract = SLibGetFcnCommentContents(ss,"CleanupRuntimeResources")
            %assign fcnInfo = LibGetFcnInfo(ss, "CleanupRuntimeResources", ss.CurrentTID)
            %assign fcnBlockDescription = SLibGetBlockDescriptionForSS(ss, "CleanupRuntimeResources")
            %addtorecord fcnInfo Abstract fcnAbstract Category "model" GeneratedBy "commonbodlib.tlc" ...
                Type "CleanupRuntimeResources" GeneratedFor FcnGeneratedFor(ss) BlockDescription fcnBlockDescription
            %<SLibDumpFunctionBanner(fcnInfo)>
            %undef fcnRec
        %endif
        %<tmpBuffer>\
        %closefile retBuffer
    %endif
    %return retBuffer
%endfunction

%% Function: FcnLoadInitialState ===================================================================
%% Abstract:
%%   Load Initial values for continuous and discrete states that are non-zero.
%% TopTester: test/toolbox/simulink/variants/var-inline-vsink/tmVarSinkRateTransBlk_VC1.m
%%
%function FcnLoadInitialState() Output
    %assign realType = LibGetDataTypeNameFromId(::CompiledModel.tSS_DOUBLE)
    %assign equalSign = LibGetDataInitEqualSign()
    %%
    %% Continuous States
    %%
    %foreach csIdx = ContStates.NumContStates
        %assign cs = ContStates.ContState[csIdx]
        %assign ic = cs.InitialValue
        %if ISEMPTY(ic) || !cs.DataLoggingOn
            %continue
        %endif
        %assign isMdlRef = FcnOwnerBlkType(cs) == "ModelReference"
        %if cs.Width == 1 && !isMdlRef
            %assign sgnl = SLibContinuousState(cs,"","",0,NumSystems-1, TLC_FALSE)
            %<sgnl> = %<ic[0]>;
        %else
            %assign addr = SLibContinuousStateAddr(cs, NumSystems-1)
            {
                %assign comma = ""
                %assign varName = "rtcs%<csIdx>_%<cs.Identifier>"
                static const %<realType> %<varName>[%<cs.Width>]%<equalSign>{
                    %if SIZE(ic,1) == 1
                        %foreach idx = cs.Width
                            %<comma>%<ic[0]>
                            %assign comma = ","
                        %endforeach
                    %else
                        %foreach idx = cs.Width
                            %<comma>%<ic[idx]>
                            %assign comma = ","
                        %endforeach
                    %endif
                };
                (void) %<LibGenMemFcnCall("memcpy", addr, varName, ...
                    "%<cs.Width>*sizeof(%<realType>)")>;
            }
        %endif
        %%==========================================================
        %% If the continuous is defined in an integrator, we
        %% need to tell the integrator block that the initial value
        %% does not need to be loaded any more.
        %%===========================================================
        %if cs.SigSrc[0] >= 0 && cs.SigSrc[2] >=0
            %assign system = System[cs.SigSrc[0]]
            %assign block = System[cs.SigSrc[0]].Block[cs.SigSrc[2]]
            %if block.Type=="Integrator"
                %with system
                    %with block
                        %<GENERATE(block, "ClearICNeedsLoading", system)>
                    %endwith
                %endwith
            %endif
        %endif

    %endforeach
    %%
    %% Discrete States
    %%
    %foreach dwIdx = DWorks.NumDWorks
        %assign ds = DWorks.DWork[dwIdx]
        %assign ic = ds.InitialValue
        %if ISEMPTY(ic) || !ds.DataLoggingOn
            %continue
        %endif
        %with System[NumSystems-1]
            %with System[ds.SigSrc[0]].Block[ds.SigSrc[2]]
                %if !ISFIELD(ds, "FirstRootIdx")
                    %addtorecord ds FirstRootIdx dwIdx
                %endif
                %assign sgnl = LibBlockDWork(ds,"","",0)
                %assign addr = LibBlockDWorkAddr(ds,"","",0)
            %endwith
        %endwith
        %if SLibDWorkWidth(ds) == 1
            %<sgnl> = %<ic[0]>;
        %else
            {
                %assign comma = ""
                %assign varName = "rtds%<dwIdx>_%<LibGetRecordIdentifier(ds)>"
                %assign dtype = SLibGetRecordDataTypeName(ds,"")
                static const %<dtype> %<varName>[%<SLibDWorkWidth(ds)>]%<equalSign>{
                    %if SLibDWorkIsComplex(ds)
                        %foreach idx = SLibDWorkWidth(ds)
                            %<comma>{%<REAL(ic[idx])>, %<IMAG(ic[idx])>}
                            %assign comma = ","
                        %endforeach
                    %else
                        %foreach idx = SLibDWorkWidth(ds)
                            %<comma>%<ic[idx]>
                            %assign comma = ","
                        %endforeach
                    %endif
                };
                (void) %<LibGenMemFcnCall("memcpy", addr, varName, ...
                    "%<SLibDWorkWidth(ds)>*sizeof(%<dtype>)")>;
            }
        %endif

    %endforeach
%endfunction %% FcnLoadInitialState

%% Function: FcnInitializeDatasetInput =============================================================
%% Abstract:
%%
%% TopTester: test/toolbox/simulink/variants/var-simulinkfcns/tAutoInherit.m
%function FcnInitializeDatasetInput(system) Output
    %if !LibUseOldFilePackagingInfrastructure()
        %<SLibAddArrayToNonSharedIncludes(SLibCoderBasicTypesFilenames())>
    %endif
    %<SLibAddToNonSharedIncludes("sigstream_rtw.h")>
    %<SLibAddToNonSharedIncludes("simtarget/slSimTgtSigstreamRTW.h")>
    %<SLibAddToNonSharedIncludes("simtarget/slSimTgtSlioCoreRTW.h")>
    %<SLibAddToNonSharedIncludes("simtarget/slSimTgtSlioClientsRTW.h")>
    %<SLibAddToNonSharedIncludes("simtarget/slSimTgtSlioSdiRTW.h")>
    {
        bool externalInputIsInDatasetFormat = false; %% sbcheck: ok(TLCTYPES)
        %if ExternalInputs.NumAperiodicPartitions > 0
            bool hasAperiodicPartitionHitTimes = false; %% sbcheck: ok(TLCTYPES)
        %endif
        void *pISigstreamManager = rt_GetISigstreamManager(rtS);
        rtwISigstreamManagerGetInputIsInDatasetFormat( ...
            pISigstreamManager, ...
            &externalInputIsInDatasetFormat ...
            );
        if (externalInputIsInDatasetFormat) {
            %foreach idx = ExternalInputs.NumExternalInputs
                %%  TopTester: matlab/test/toolbox/simulink/sl_loading/fromWksAndInport/tDatasetFormat.m
                %assign extInp = ExternalInputs.ExternalInput[idx]
                %% Inactive (SVCE false) inports built in raccel will not be present. Hence, skip init'ing them
                %% TopTester: matlab/test/toolbox/simulink/variants/var-inline-general/tRootIOFcnCall.m -testspec:lvlTwo_mG1377701_ra
                %if ISFIELD(extInp, "Inactive")
                    %continue
                %endif
                %assign fcnCall = extInp.FunctionCallInitiator == "yes"
                %assign hasFcnCallInfo = LibIsSystemField(system, "FcnCallInputInfo")
                %if fcnCall
                    %%  TopTester: test/toolbox/simulink/variants/var-inline-general/tsimfcsys_rapidaccel.m
                    %if hasFcnCallInfo
                        %with system
                            %with FcnRootOpaqueBlock()
                                %assign currentBlockFcn = ::BlockFcn
                                %assign ::BlockFcn = "Start"
                                %assign fcnCallInfo = LibGetSystemField(system, "FcnCallInputInfo")
                                %assign fcnCallIdx = 0
                                %foreach idx2 = SIZE(fcnCallInfo.FcnCallInfo,1)
                                    %assign info = fcnCallInfo.FcnCallInfo[idx2]
                                    %if(info.PortIdx == idx)
                                        %assign fcnCallIdx = idx2
                                        %break
                                    %endif
                                %endforeach
                                %assign dworkIdx = fcnCallInfo.FcnCallInfo[fcnCallIdx].dworkIndex
                                %assign dwork = ::CompiledModel.DWorks.DWork[dworkIdx]
                                %assign youtAddr = LibBlockDWorkAddr(dwork, "", "", 0)
                                rtwISigstreamManagerSetDestinationBase( ...
                                    pISigstreamManager, ...
                                    %<idx>,  ...
                                    %<youtAddr> ...
                                    );
                                %assign ::BlockFcn = currentBlockFcn
                            %endwith %% %with FcnRootOpaqueBlock()
                        %endwith %% %with system
                    %endif
                %else %% %if fcnCall
                    %assign yout = SLibGetExtUIdentifier(extInp, "0", "%<tRealPart>")
                    %assign youtAddr = "&" + yout
                    rtwISigstreamManagerSetDestinationBase( ...
                        pISigstreamManager, ...
                        %<idx>,  ...
                        %<youtAddr> ...
                        );
                %endif %% %if fcnCall
            %endforeach
        }

        %if ExternalInputs.NumAperiodicPartitions > 0
            rtwISigstreamManagerHasAperiodicPartitionHitTimes( ...
                pISigstreamManager, ...
                &hasAperiodicPartitionHitTimes ...
                );
            if (hasAperiodicPartitionHitTimes) {
                %foreach idx = ExternalInputs.NumAperiodicPartitions
                    %assign upInfo = ExternalInputs.AperiodicPartitions[idx]
                    %assign name = upInfo.Name
                    gblAperiodicPartitionSignalIds[%<idx>] = ...
                        rtwISigstreamManagerAperiodicPartitionDestinationIdx( ...
                        pISigstreamManager, ...
                        "%<name>");
                    if (gblAperiodicPartitionSignalIds[%<idx>] != -1) {
                        rtwISigstreamManagerSetDestinationBase( ...
                            pISigstreamManager, ...
                            gblAperiodicPartitionSignalIds[%<idx>],  ...
                            &gblUconstrainedPartitionNumHits[%<idx>]);
                    }
                %endforeach
            }
        %endif
        %if ::raccelObserverLog
            observerLogInit();
        %endif
    }
%endfunction %% FcnInitializeDatasetInput

%% Function: SLibGetBodyStartFcnCache(ss) ======================================
%% Description:
%%      Generates the start function for systems
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tmVariantsRSim.m
%% TopTester: test/toolbox/simulink/blocks/lib_Discrete/DiscreteTimeIntegrator/rtw/tdintegrt.m
%%
%function SLibGetBodyStartFcnCache(ss) void
    %assign isRootInSfcn = (ss.Type == "root") && ...
        (CodeFormat == "S-Function") && !Accelerator

    %openfile tmpBuffer
    %<LibDumpFcnOpen(ss,"Start")>\
    %<FcnDumpMRLocalVars(ss, "Start", "")>\
    %if isRootInSfcn
        %<LibDumpSfunTargetChecks()> \
        {
    %endif
    %<LibDumpSystemSSVars(ss,"Start")>\
    %<LibGetSystemLocalVars(ss,"Start","")>
    %<SLibGetFcnLocalVars(ss,"Start","")>
    %<LibDumpSystemUserCode(ss,"Start","Header")>\
    %<LibDumpGlobalVars(ss, "Start")>\
    %<LibDumpFcnBegin(ss,"Start")>\
    %% open code
    %openfile tmpBuffer2
    %if (ss.Type == "root") && ::isRAccel
        %<FcnInitializeDatasetInput(ss)>
        %if EXISTS(CompiledModel.SupportSimEventsRegistration)
            /* Initialize Discrete Event Systems*/
            sldeInitialize();
        %endif
    %endif
    %if ss.Type == "root" && (::isRAccel || isRSim)
        %<SLibDumpOpaqueTypeConstructCode(::CompiledModel.System[GetBaseSystemIdx()])>
    %endif
    %% Dump code to update variant parameters for raccel
    %if ss.Type == "root" && (::isRAccel || isRSim)
        %<SLibDumpVariantParamStInit(TLC_TRUE)>
    %endif
    %<LibDumpSystemUserCode(ss,"Start","Body")>\
    %<LibDumpSystemFcn(ss,"Start")>\
    %<LibDumpSystemUserCode(ss,"Start","Trailer")>\
    %%
    %% For some targets, we allow root to call Initialize and Enable
    %% within the context of start
    %%
    %if (ss.Type == "root")
        %if RootBodyStartCallsInitEnab
            %if (!LibSystemFcnIsEmpty(ss, "SystemInitialize"))
                %assign fcnInfo = LibGetSystemField(ss, "SystemInitialize" + "FcnInfo")
                %assign comArgs = fcnInfo.CommonArgs
                %<fcnInfo.Name>(%<comArgs>);
            %endif
            %if (!LibSystemFcnIsEmpty(ss, "Enable"))
                %assign fcnInfo = LibGetSystemField(ss, "Enable" + "FcnInfo")
                %assign comArgs = fcnInfo.CommonArgs
                %<fcnInfo.Name>(%<comArgs>);
            %endif
        %endif
        %% Load intial states if needed.
        %<FncGenInitStatesInRootStart()>
    %endif
    %if isRootInSfcn
        %assign prevBlockFcn = ::BlockFcn
        %assign ::BlockFcn = "Start"
        %assign buff = ""
        %openfile buff
        %<SLibInitPrevZCSignalStates()>
        %closefile buff
        %assign ::BlockFcn = prevBlockFcn
        %if !WHITE_SPACE(buff)

            /* Previous zero-crossing state intialization */
            %<buff>
        %endif
    }
    %endif
    %closefile tmpBuffer2
    %% extra code for exported function to update external outputs
    %<tmpBuffer2>\
    %% close code
    %<LibDumpFcnClose(ss,"Start")>
    %closefile tmpBuffer
    %assign retBuffer = ""
    %if !WHITE_SPACE(tmpBuffer)
        %openfile retBuffer
        %if LibSystemIsInlined(ss)
            %<SLibGetFcnComment(ss,"Start")>\
        %else
            %assign fcnAbstract = SLibGetFcnCommentContents(ss,"Start")
            %assign fcnInfo = LibGetFcnInfo(ss, "Start", ss.CurrentTID)
            %assign fcnBlockDescription = SLibGetBlockDescriptionForSS(ss, "Start")
            %addtorecord fcnInfo Abstract fcnAbstract Category "model" GeneratedBy "commonbodlib.tlc" ...
                Type "Start" GeneratedFor FcnGeneratedFor(ss) BlockDescription fcnBlockDescription
            %<SLibDumpFunctionBanner(fcnInfo)>
        %endif
        %<tmpBuffer>\
        %closefile retBuffer
    %endif
    %return retBuffer
%endfunction


%% Function: SLibGetBodyOutputFcnCache(ss) =====================================
%% Description:
%%      Generates the output function for an enable subsystem.
%%
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-sim/tg1167032.m
%% TopTester: test/toolbox/simulink/variants/var-inline-general/tmemLayoutBlksInactivPorts.m
%%
%function SLibGetBodyOutputFcnCache(ss) void
    %if SLibSystemFcnPeriodicRateGrouping(ss, "Output") || ...
        LibAsynchronousTriggeredTID(ss.CurrentTID) || ...
        (SLibPartitionGroupingSystem(ss))
        %assign tid = ss.CurrentTID
    %else
        %assign tid = ""
    %endif

    %if LibAsynchronousTriggeredTID(tid) && !SLibNonInlinedModelWideEventTID(tid)
        %if (SLibIsMultiRateAndPeriodicRateGrouping(ss) || ...
            !FcnIsForcedInlinedForAsync(ss,tid) || ...
            LibIsDeploymentDiagram() || ...
            SLibIsExplicitTaskingExportFcnRateGrouping("Output", tid))
            %assign systemFcnIsEmpty = LibSystemFcnIsEmptyForTID(ss, "Output")
        %else
            %assign systemFcnIsEmpty = TLC_TRUE
        %endif
    %else
        %% Added ::isRAccel for test/toolbox/simulink/modelref/fcncall/client_server/inout_args/tinout_args1
        %if ISEQUAL(tid, "") && (!SLibIsExportFcnDiagram() || ::isRAccel)
            %% If not grouping rating, system output
            %% fcn always exists
            %assign systemFcnIsEmpty = TLC_FALSE
        %else
            %assign systemFcnIsEmpty = LibSystemFcnIsEmptyForTID(ss, "Output")
        %endif
    %endif

    %if IsModelReferenceBaseSys(ss)
        %% Create and initialize it here. It may be updated at the end
        %% of the function
        %addtorecord ss ModelRefOutputFcnIsEmpty%<tid> "yes"
    %endif

    %if systemFcnIsEmpty
        %return ""
    %endif

    %assign isSSMapped = SLibPartitionGroupingSystem(ss)
    %if isSSMapped
        %assert TYPE(tid) == "Number"
    %endif
    %openfile tmpBuffer
    %if !isSSMapped
        %<LibDumpFcnOpen(ss,"Output")>\
    %endif
    %<FcnDumpMRLocalVars(ss, "Output", tid)>\
    %% Profiler declaration code
    %<LibDumpSystemProfileCode(ss,"Output", "Decls")>\
    %<LibDumpSystemSSVars(ss,"Output")>\
    %if !isSSMapped
        %<LibGetSystemLocalVars(ss,"Output",tid)>
        %<SLibGetFcnLocalVars(ss,"Output",tid)>
    %endif
    %<LibDumpSystemUserCode(ss,"Output","Header")>\
    %if !LibSystemFcnIsEmpty(ss, "Output")
        %if !isSSMapped
            %<LibDumpGlobalVars(ss, "Output%<tid>")>\
        %else
            %<LibDumpGlobalVars(ss, "Output%<tid>%<ss.CurrentPID>")>\
        %endif
    %endif
    %if !ISEQUAL(ss.Type, "root")
        %<LibDumpFcnBegin(ss,"Output")>\
    %endif

    %%
    %% Generated S-Function data store reads
    %%
    %if (ss.Type == "root") && (CodeFormat == "S-Function") && !Accelerator
        %assign ::BlockFcn = "Output"
        %<SLibGenDataStoreReads(::tSimStruct)>
        %assign ::BlockFcn = "Unknown"
    %endif

    %% Profiler start code
    %<LibDumpSystemProfileCode(ss,"Output", "Start")>\

    %% When we are generating for model reference, write out
    %% part of the ERT timing Engine.
    %% output code
    %if !isSSMapped
        %<UpdateRateTransitionFlagsHelper(ss, tid, TLC_FALSE)>
    %endif
    %<LibDumpSystemUserCode(ss,"Output","Body")>\

    %if isSSMapped
        %<LibDumpSystemFcn(ss,"Output%<tid>%<ss.CurrentPID>")>\
    %else
        %<LibDumpSystemFcn(ss,"Output%<tid>")>\
    %endif
    %<LibDumpSystemUserCode(ss,"Output","Trailer")>\
    %if !isSSMapped || SLibPartitionNeedTIDArg(ss.CurrentPID)
        %<FcnHandlesUnusedTIDArg(ss, "Output")>
    %endif
    %<FcnHandlesUnusedRTMForSimplifiedInterface(ss, "Output")>

    %% Profiler finish code
    %<LibDumpSystemProfileCode(ss,"Output", "End")>\

    %%
    %% Generated S-Function data store writes
    %%
    %if (ss.Type == "root") && (CodeFormat == "S-Function") && !Accelerator
        %assign ::BlockFcn = "Output"
        %<SLibGenDataStoreWrites(::tSimStruct)>
        %assign ::BlockFcn = "Unknown"
    %endif
    %if !isSSMapped
        %<LibDumpFcnClose(ss,"Output")>
    %endif
    %closefile tmpBuffer
    %assign retBuffer = ""
    %if !WHITE_SPACE(tmpBuffer)
        %openfile retBuffer
        %assign expFcn = SLibIsExplicitTaskingExportFcnRateGrouping("Output",ss.CurrentTID)
        %if LibSystemIsInlined(ss) && (!isSSMapped) && !expFcn
            %<SLibGetFcnComment(ss,"Outputs")>\
        %elseif !isSSMapped && !expFcn
            %assign fcnAbstract = SLibGetFcnCommentContents(ss,"Outputs")
            %assign fcnInfo = LibGetFcnInfo(ss, "Output", ss.CurrentTID)
            %assign fcnBlockDescription = SLibGetBlockDescriptionForSS(ss,"Outputs")
            %addtorecord fcnInfo Abstract fcnAbstract Category "model" GeneratedBy "commonbodlib.tlc" ...
                Type "Output" GeneratedFor FcnGeneratedFor(ss) BlockDescription fcnBlockDescription
            %<SLibDumpFunctionBanner(fcnInfo)>
            %<addToBackupCodeMetrics(ss, fcnInfo.Name, fcnInfo.Name, tid)>
        %endif
        %<tmpBuffer>\
        %closefile retBuffer

        %if IsModelReferenceBaseSys(ss)
            %assign ss.ModelRefOutputFcnIsEmpty%<tid> = "no"
        %endif

    %endif

    %return retBuffer
%endfunction %% SLibGetBodyOutputFcnCache

%% Function: SLibGetBodyUpdateFcnCache(ss) =====================================
%% Description:
%%      Generates the update function for an enable subsystem.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants2.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants3.m
%%
%function SLibGetBodyUpdateFcnCache(ss) void
    %if SLibNonInlinedIRTEventTID(ss.CurrentTID)
        %return ""
    %endif

    %if SLibSystemFcnPeriodicRateGrouping(ss, "Update") || ...
        LibAsynchronousTriggeredTID(ss.CurrentTID) || ...
        (SLibPartitionGroupingSystem(ss))
        %assign tid = ss.CurrentTID
    %else
        %assign tid = ""
    %endif

    %if IsModelReferenceBaseSys(ss)
        %addtorecord ss ModelRefUpdateFcnIsEmpty%<tid> "yes"
    %endif

    %assign isSSMapped = SLibPartitionGroupingSystem(ss)
    %if isSSMapped
        %assert TYPE(tid) == "Number"
    %endif
    %openfile tmpBuffer
    %if !isSSMapped
        %<LibDumpFcnOpen(ss,"Update")>\
    %endif
    %<FcnDumpMRLocalVars(ss, "Update", tid)>\
    %% Profiler declaration code
    %<LibDumpSystemProfileCode(ss,"Update", "Decls")>\

    %<LibDumpSystemSSVars(ss,"Update")>\
    %if !isSSMapped
        %<LibGetSystemLocalVars(ss,"Update",tid)>
        %<SLibGetFcnLocalVars(ss,"Update",tid)>
    %endif
    %<LibDumpSystemUserCode(ss,"Update","Header")>\
    %if isSSMapped
        %<LibDumpGlobalVars(ss, "Update%<tid>%<ss.CurrentPID>")>\
    %else
        %<LibDumpGlobalVars(ss, "Update%<tid>")>\
    %endif
    %if !isSSMapped
        %<LibDumpFcnBegin(ss,"Update")>\
    %endif

    %% Profiler start code
    %<LibDumpSystemProfileCode(ss,"Update", "Start")>\

    %% open code
    %<LibDumpSystemUserCode(ss,"Update","Body")>\
    %if isSSMapped
        %<LibDumpSystemFcn(ss,"Update%<tid>%<ss.CurrentPID>")>\
    %else
        %<LibDumpSystemFcn(ss,"Update%<tid>")>\
    %endif
    %<LibDumpSystemUserCode(ss,"Update","Trailer")>\
    %<FcnHandlesUnusedTIDArg(ss, "Update")>
    %<FcnHandlesUnusedRTMForSimplifiedInterface(ss, "Update")>

    %% Profiler finish code
    %<LibDumpSystemProfileCode(ss,"Update", "End")>\
    %if !isSSMapped
        %<LibDumpFcnClose(ss,"Update")>
    %endif
    %closefile tmpBuffer
    %assign retBuffer = ""
    %if !WHITE_SPACE(tmpBuffer)
        %openfile retBuffer
        %if LibSystemIsInlined(ss) && (!isSSMapped)
            %<SLibGetFcnComment(ss,"Update")>\
        %elseif !isSSMapped
            %assign fcnAbstract = SLibGetFcnCommentContents(ss,"Update")
            %assign fcnInfo = LibGetFcnInfo(ss, "Update", ss.CurrentTID)
            %assign fcnBlockDescription = SLibGetBlockDescriptionForSS(ss,"Update")
            %addtorecord fcnInfo Abstract fcnAbstract Category "model" GeneratedBy "commonbodlib.tlc" ...
                Type "Update" GeneratedFor FcnGeneratedFor(ss) BlockDescription fcnBlockDescription
            %<SLibDumpFunctionBanner(fcnInfo)>
            %<addToBackupCodeMetrics(ss, fcnInfo.Name, fcnInfo.Name, tid)>
        %endif
        %<tmpBuffer>\
        %closefile retBuffer
        %if IsModelReferenceBaseSys(ss)
            %assign ss.ModelRefUpdateFcnIsEmpty%<tid> = "no"
        %endif
    %endif
    %return retBuffer
%endfunction  %%SLibGetBodyUpdateFcnCache

%% Function: SLibGetBodyDerivativeFcnCache(ss) =================================
%% Description:
%%      Generates the derivatives function for an enable system containing
%%      continuous states.  Note that DerivativeFcn only exists if the
%%      system has continuous states.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants3.m
%%
%function SLibGetBodyDerivativeFcnCache(ss) void
    %openfile tmpBuffer
    %assign isSSMapped = SLibIsMappedInDeploymentDiagram(ss)
    %if (SLibIsERTCodeFormat()) && LibSystemIsRoot(ss) && !isSSMapped
        %assign fcnRec = LibGetSystemField(ss, "DerivativeFcnInfo")
        %if !GenerateClassInterface
            %assign fcnName = "%<fcnRec.Name>"
        %else
            %assign className = CGMODEL_ACCESS("CGModel.getClassName")
            %assign fcnName = "%<className>::%<fcnRec.Name>"
        %endif
        %<SLibGetFcnMemSecPragma(fcnName, "MemSecFuncExecute", "Pre")>\
        %assign fcnReturns = "void"
        %assign fcnParams = "%<SLibModelFcnArgs("Derivative",0,"")>"
        %createrecord fcnInfo {Name fcnName; Returns fcnReturns; Params fcnParams}
        %openfile localVariables
        %if MultiInstanceERTCode && !GenerateClassInterface
            %assign rootSystem = ::CompiledModel.System[NumSystems-1]
            %<SLibDumpLocalVariablesForBlockFcn(rootSystem, "Derivative")>
        %endif
        %closefile localVariables

        %<fcnReturns> %<fcnName>(%<fcnParams>)
        {
            %if !WHITE_SPACE(localVariables)
                %<localVariables>
            %endif
            %assign closeScopeOnly = TLC_FALSE
    %else
        %assign fcnInfo = LibGetFcnInfo(ss, "Derivative", ss.CurrentTID)
        %if !isSSMapped || SLibPartitionNeedContFcnDecl(ss.CurrentPID)
            %% If this is not generated for partition grouping or, in MDS
            %% this is generated for synthesized task with continuous rate,
            %% we then need the fcn open
            %<LibDumpFcnOpen(ss,"Derivative")>\
            %assign closeScopeOnly = TLC_FALSE
        %else
            %% If this is generated for explicit partition, ignore fcn open
            %% but adding a left bracket to create a name scope
            {
                %assign closeScopeOnly = TLC_TRUE
        %endif
    %endif

    %<FcnDumpMRLocalVars(ss, "Derivative", "")>\
    %% Profiler declaration code
    %<LibDumpSystemProfileCode(ss,"Derivative", "Decls")>\

    %assign tidTrailer = isSSMapped ? "%<ss.CurrentTID>" : ""
    %assign pidTrailer = isSSMapped ? "%<ss.CurrentPID>" : ""

    %<LibDumpSystemSSVars(ss,"Derivative%<tidTrailer>%<pidTrailer>")>\
    %<LibGetSystemLocalVars(ss,"Derivative","%<tidTrailer>")>
    %<SLibGetFcnLocalVars(ss,"Derivative","%<tidTrailer>")>
    %<LibDumpSystemUserCode(ss,"Derivative","Header")>\
    %<LibDumpGlobalVars(ss, "Derivative%<tidTrailer>%<pidTrailer>")>\
    %<LibDumpFcnBegin(ss,"Derivative")>\

    %% Profiler start code
    %<LibDumpSystemProfileCode(ss,"Derivative", "Start")>\

    %% open code
    %<LibDumpSystemUserCode(ss,"Derivative","Body")>\
    %<LibDumpSystemFcn(ss,"Derivative%<tidTrailer>%<pidTrailer>")>\
    %<LibDumpSystemUserCode(ss,"Derivative","Trailer")>\

    %% Profiler finish code
    %<LibDumpSystemProfileCode(ss,"Derivative", "End")>\

    %% MDS does not dump the function, just close the scope
    %if closeScopeOnly
    }
    %else
        %<LibDumpFcnClose(ss,"Derivative")>
    %endif

    %closefile tmpBuffer
    %assign retBuffer = ""
    %if !WHITE_SPACE(tmpBuffer)
        %assign isSSMapped = SLibIsMappedInDeploymentDiagram(ss)
        %openfile retBuffer
        %if LibSystemIsInlined(ss) && (!isSSMapped)
            %<SLibGetFcnComment(ss,"Derivatives")>\
        %elseif (!isSSMapped) || SLibPartitionNeedContFcnDecl(ss.CurrentPID)
            %assign fcnAbstract = SLibGetFcnCommentContents(ss,"Derivatives")
            %assign fcnBlockDescription = SLibGetBlockDescriptionForSS(ss,"Derivatives")
            %addtorecord fcnInfo Abstract fcnAbstract Category "model" GeneratedBy "commonbodlib.tlc" ...
                Type "Derivative" GeneratedFor FcnGeneratedFor(ss) BlockDescription fcnBlockDescription
            %<SLibDumpFunctionBanner(fcnInfo)>
        %endif
        %<tmpBuffer>\
        %closefile retBuffer
    %endif
    %return retBuffer
%endfunction


%% Function: SLibGetBodyProjectionFcnCache(ss) =================================
%% Description:
%%      Generates the projection function for an enable system containing
%%      continuous states.  Note that ProjectionFcn only exists if the
%%      system has continuous states.
%%
%% TopTester: test/toolbox/simulink/coreblocks/lib_SignalAttributes/InitialCondition/rtw/tinitcond.m
%%
%function SLibGetBodyProjectionFcnCache(ss) void
    %assign tmpBuffer = ""
    %if CodeFormat == "S-Function" && ModelHasProjections == "yes" || ...
        CodeFormat != "S-Function"
        %openfile tmpBuffer
        %assign isSSMapped = SLibIsMappedInDeploymentDiagram(ss)
        %if (SLibIsERTCodeFormat()) && LibSystemIsRoot(ss) && !isSSMapped
            %assign fcnRec = LibGetSystemField(ss, "ProjectionFcnInfo")
            %if !GenerateClassInterface
                %assign fcnName = "%<fcnRec.Name>"
            %else
                %assign className = CGMODEL_ACCESS("CGModel.getClassName")
                %assign fcnName = "%<className>::%<fcnRec.Name>"
            %endif
            %<SLibGetFcnMemSecPragma(fcnName, "MemSecFuncExecute", "Pre")>\
            %assign fcnReturns = "void"
            %assign fcnParams = SLibModelFcnArgs("Projection",0,"")
            %createrecord fcnInfo {Name fcnName; Returns fcnReturns; Params fcnParams}
            %openfile localVariables
            %if MultiInstanceERTCode && !GenerateClassInterface
                %assign rootSystem = ::CompiledModel.System[NumSystems-1]
                %<SLibDumpLocalVariablesForBlockFcn(rootSystem, "Projection")>
            %endif
            %closefile localVariables

            %<fcnReturns> %<fcnName>(%<fcnParams>)
            {
                %if !WHITE_SPACE(localVariables)
                    %<localVariables>
                %endif
        %else
            %assign fcnInfo = LibGetFcnInfo(ss, "Projection", ss.CurrentTID)
            %if !isSSMapped || SLibPartitionNeedContFcnDecl(ss.CurrentPID)
                %<LibDumpFcnOpen(ss,"Projection")>\
            %else
                {
            %endif
        %endif

        %assign tidTrailer = isSSMapped ? "%<ss.CurrentTID>" : ""
        %assign pidTrailer = isSSMapped ? "%<ss.CurrentPID>" : ""

        %<FcnDumpMRLocalVars(ss, "Projection", "%<tidTrailer>")>\
        %<LibDumpSystemSSVars(ss,"Projection%<tidTrailer>%<pidTrailer>")>\
        %<LibGetSystemLocalVars(ss,"Projection","%<tidTrailer>")>
        %<SLibGetFcnLocalVars(ss,"Projection","%<tidTrailer>")>
        %<LibDumpSystemUserCode(ss,"Projection","Header")>\
        %<LibDumpGlobalVars(ss, "Projection%<tidTrailer>%<pidTrailer>")>\
        %<LibDumpFcnBegin(ss,"Projection")>\
        %% open code
        %<LibDumpSystemUserCode(ss,"Projection","Body")>\
        %<LibDumpSystemFcn(ss,"Projection%<tidTrailer>%<pidTrailer>")>\
        %<LibDumpSystemUserCode(ss,"Projection","Trailer")>\
        %<LibDumpFcnClose(ss,"Projection")>
        %closefile tmpBuffer
    %endif
    %assign retBuffer = ""
    %if !WHITE_SPACE(tmpBuffer)
        %assign isSSMapped = SLibIsMappedInDeploymentDiagram(ss)
        %openfile retBuffer
        %if LibSystemIsInlined(ss) && (!isSSMapped)
            %<SLibGetFcnComment(ss,"Projection")>\
        %elseif !isSSMapped || SLibPartitionNeedContFcnDecl(ss.CurrentPID)
            %assign fcnAbstract = SLibGetFcnCommentContents(ss,"Projection")
            %assign fcnBlockDescription = SLibGetBlockDescriptionForSS(ss,"Projection")
            %addtorecord fcnInfo Abstract fcnAbstract Category "model" GeneratedBy "commonbodlib.tlc" ...
                Type "Projection" GeneratedFor FcnGeneratedFor(ss) BlockDescription fcnBlockDescription
            %<SLibDumpFunctionBanner(fcnInfo)>
        %endif
        %<tmpBuffer>\
        %closefile retBuffer
    %endif
    %return retBuffer
%endfunction

%% Function: SLibGetBodyForcingFunctionFcnCache(ss) =================================
%% Description:
%%      Generates the ForcingFunction function for an enable system containing
%%      continuous states.  Note that ForcingFunctionFcn only exists if the
%%      system has continuous states.
%%
%function SLibGetBodyForcingFunctionFcnCache(ss) void
    %assign tmpBuffer = ""
    %if ModelIsLinearlyImplicit == "yes"
        %openfile tmpBuffer
        %assign isSSMapped = SLibIsMappedInDeploymentDiagram(ss)
        %if (SLibIsERTCodeFormat()) && LibSystemIsRoot(ss) && !isSSMapped
            %assign fcnRec = LibGetSystemField(ss, "ForcingFunctionFcnInfo")
            %if !GenerateClassInterface
                %assign fcnName = "%<fcnRec.Name>"
            %else
                %assign className = CGMODEL_ACCESS("CGModel.getClassName")
                %assign fcnName = "%<className>::%<fcnRec.Name>"
            %endif
            %<SLibGetFcnMemSecPragma(fcnName, "MemSecFuncExecute", "Pre")>\
            %assign fcnReturns = "void"
            %assign fcnParams = SLibModelFcnArgs("ForcingFunction",0,"")
            %createrecord fcnInfo {Name fcnName; Returns fcnReturns; Params fcnParams}
            %openfile localVariables
            %if MultiInstanceERTCode && !GenerateClassInterface
                %assign rootSystem = ::CompiledModel.System[NumSystems-1]
                %<SLibDumpLocalVariablesForBlockFcn(rootSystem, "ForcingFunction")>
            %endif
            %closefile localVariables

            %createrecord fcnInfo {Name fcnName; Returns fcnReturns; Params fcnParams}
            %<fcnReturns> %<fcnName>(%<fcnParams>)
            {
                %if !WHITE_SPACE(localVariables)
                    %<localVariables>
                %endif
        %else
            %assign fcnInfo = LibGetFcnInfo(ss, "ForcingFunction", ss.CurrentTID)
            %if !isSSMapped || SLibPartitionNeedContFcnDecl(ss.CurrentPID)
                %<LibDumpFcnOpen(ss,"ForcingFunction")>\
            %else
                {
            %endif
        %endif

        %assign tidTrailer = isSSMapped ? "%<ss.CurrentTID>" : ""
        %assign pidTrailer = isSSMapped ? "%<ss.CurrentPID>" : ""

        %<FcnDumpMRLocalVars(ss, "ForcingFunction", "%<tidTrailer>")>\
        %<LibDumpSystemSSVars(ss,"ForcingFunction%<tidTrailer>%<pidTrailer>")>\
        %<LibGetSystemLocalVars(ss,"ForcingFunction","%<tidTrailer>")>
        %<SLibGetFcnLocalVars(ss,"ForcingFunction","%<tidTrailer>")>
        %<LibDumpSystemUserCode(ss,"ForcingFunction","Header")>\
        %<LibDumpGlobalVars(ss, "ForcingFunction%<tidTrailer>%<pidTrailer>")>\
        %<LibDumpFcnBegin(ss,"ForcingFunction")>\
        %% open code
        %<LibDumpSystemUserCode(ss,"ForcingFunction","Body")>\
        %<LibDumpSystemFcn(ss,"ForcingFunction%<tidTrailer>%<pidTrailer>")>\
        %<LibDumpSystemUserCode(ss,"ForcingFunction","Trailer")>\
        %% close code
        %<LibDumpFcnClose(ss,"ForcingFunction")>
        %closefile tmpBuffer
    %endif
    %assign retBuffer = ""
    %if !WHITE_SPACE(tmpBuffer)
        %assign isSSMapped = SLibIsMappedInDeploymentDiagram(ss)
        %openfile retBuffer
        %if LibSystemIsInlined(ss) && (!isSSMapped)
            %<SLibGetFcnComment(ss,"ForcingFunction")>
        %elseif (!isSSMapped) || SLibPartitionNeedContFcnDecl(ss.CurrentPID)
            %assign fcnAbstract = SLibGetFcnCommentContents(ss,"ForcingFunction")
            %assign fcnBlockDescription = SLibGetBlockDescriptionForSS(ss,"ForcingFunction")
            %addtorecord fcnInfo Abstract fcnAbstract Category "model" GeneratedBy "commonbodlib.tlc" ...
                Type "Forcing" GeneratedFor FcnGeneratedFor(ss) BlockDescription fcnBlockDescription
            %<SLibDumpFunctionBanner(fcnInfo)>
        %endif
        %<tmpBuffer>\
        %closefile retBuffer
    %endif
    %return retBuffer
%endfunction


%% Function: SLibGetBodyMassMatrixFcnCache(ss) =================================
%% Description:
%%      Generates the MassMatrix function for an enable system containing
%%      continuous states.  Note that MassMatrixFcn only exists if the
%%      system has continuous states.
%%
%function SLibGetBodyMassMatrixFcnCache(ss) void
    %assign tmpBuffer = ""
    %if ModelIsLinearlyImplicit == "yes"
        %openfile tmpBuffer
        %assign isSSMapped = SLibIsMappedInDeploymentDiagram(ss)
        %if (SLibIsERTCodeFormat()) && LibSystemIsRoot(ss) && !isSSMapped
            %assign fcnRec = LibGetSystemField(ss, "MassMatrixFcnInfo")
            %if !GenerateClassInterface
                %assign fcnName = "%<fcnRec.Name>"
            %else
                %assign className = CGMODEL_ACCESS("CGModel.getClassName")
                %assign fcnName = "%<className>::%<fcnRec.Name>"
            %endif
            %<SLibGetFcnMemSecPragma(fcnName, "MemSecFuncExecute", "Pre")>\
            %assign fcnReturns = "void"
            %assign fcnParams = SLibModelFcnArgs("MassMatrix",0,"")
            %createrecord fcnInfo {Name fcnName; Returns fcnReturns; Params fcnParams}
            %openfile localVariables
            %if MultiInstanceERTCode && !GenerateClassInterface
                %assign rootSystem = ::CompiledModel.System[NumSystems-1]
                %<SLibDumpLocalVariablesForBlockFcn(rootSystem, "MassMatrix")>
            %endif
            %closefile localVariables

            %<fcnReturns> %<fcnName>(%<fcnParams>)
            {
                %if !WHITE_SPACE(localVariables)
                    %<localVariables>
                %endif
        %else
            %assign fcnInfo = LibGetFcnInfo(ss, "MassMatrix", ss.CurrentTID)
            %if !isSSMapped || SLibPartitionNeedContFcnDecl(ss.CurrentPID)
                %<LibDumpFcnOpen(ss,"MassMatrix")>\
            %else
                {
            %endif
        %endif

        %assign tidTrailer = isSSMapped ? "%<ss.CurrentTID>" : ""
        %assign pidTrailer = isSSMapped ? "%<ss.CurrentPID>" : ""

        %<FcnDumpMRLocalVars(ss, "MassMatrix", "%<tidTrailer>")>\
        %<LibDumpSystemSSVars(ss,"MassMatrix%<tidTrailer>%<pidTrailer>")>\
        %<LibGetSystemLocalVars(ss,"MassMatrix","%<tidTrailer>")>
        %<SLibGetFcnLocalVars(ss,"MassMatrix","%<tidTrailer>")>
        %<LibDumpSystemUserCode(ss,"MassMatrix","Header")>\
        %<LibDumpGlobalVars(ss, "MassMatrix%<tidTrailer>%<pidTrailer>")>\
        %<LibDumpFcnBegin(ss,"MassMatrix")>\
        %% open code
        %<LibDumpSystemUserCode(ss,"MassMatrix","Body")>\
        %<LibDumpSystemFcn(ss,"MassMatrix%<tidTrailer>%<pidTrailer>")>\
        %<LibDumpSystemUserCode(ss,"MassMatrix","Trailer")>\
        %% close code
        %<LibDumpFcnClose(ss,"MassMatrix")>
        %closefile tmpBuffer
    %endif
    %assign retBuffer = ""
    %if !WHITE_SPACE(tmpBuffer)
        %assign isSSMapped = SLibIsMappedInDeploymentDiagram(ss)
        %openfile retBuffer
        %if LibSystemIsInlined(ss) && (!isSSMapped)
            %<SLibGetFcnComment(ss,"MassMatrix")>\
        %elseif (!isSSMapped) || SLibPartitionNeedContFcnDecl(ss.CurrentPID)
            %assign fcnAbstract = SLibGetFcnCommentContents(ss,"MassMatrix")
            %assign fcnBlockDescription = SLibGetBlockDescriptionForSS(ss,"MassMatrix")
            %addtorecord fcnInfo Abstract fcnAbstract Category "model" GeneratedBy "commonbodlib.tlc" ...
                Type "MassMatrix" GeneratedFor FcnGeneratedFor(ss) BlockDescription fcnBlockDescription
            %<SLibDumpFunctionBanner(fcnInfo)>
        %endif
        %<tmpBuffer>\
        %closefile retBuffer
    %endif
    %return retBuffer
%endfunction


%% Function: SLibGetBodyZeroCrossingFcnCache(ss) ===============================
%% Description:
%%      Generates the ZeroCrossings function for an enable/atomic system
%%      containing continuous states.
%%
%function SLibGetBodyZeroCrossingFcnCache(ss) void
    %openfile tmpBuffer
    %assign isSSMapped = SLibIsMappedInDeploymentDiagram(ss)
    %if (SLibIsERTCodeFormat()) && LibSystemIsRoot(ss) && !isSSMapped
        %assign fcnRec = LibGetSystemField(ss, "ZeroCrossingFcnInfo")
        %if !GenerateClassInterface
            %assign fcnName = "%<fcnRec.Name>"
        %else
            %assign className = CGMODEL_ACCESS("CGModel.getClassName")
            %assign fcnName = "%<className>::%<fcnRec.Name>"
        %endif
        %<SLibGetFcnMemSecPragma(fcnName, "MemSecFuncExecute", "Pre")>\
        %assign fcnReturns = "void"
        %assign fcnParams = "%<SLibModelFcnArgs("ZeroCrossing",0,"")>"
        %createrecord fcnInfo {Name fcnName; Returns fcnReturns; Params fcnParams}
        %openfile localVariables
        %if MultiInstanceERTCode && !GenerateClassInterface
            %assign rootSystem = ::CompiledModel.System[NumSystems-1]
            %<SLibDumpLocalVariablesForBlockFcn(rootSystem, "ZeroCrossing")>
        %endif
        %closefile localVariables

        %<fcnReturns> %<fcnName>(%<fcnParams>)
        {
            %if !WHITE_SPACE(localVariables)
                %<localVariables>
            %endif
    %else
        %if !isSSMapped || SLibPartitionNeedContFcnDecl(ss.CurrentPID)
            %<LibDumpFcnOpen(ss,"ZeroCrossing")>\
        %else
            {
        %endif
    %endif

    %assign tidTrailer = isSSMapped ? "%<ss.CurrentTID>" : ""
    %assign pidTrailer = isSSMapped ? "%<ss.CurrentPID>" : ""

    %<FcnDumpMRLocalVars(ss, "ZeroCrossing", "%<tidTrailer>")>\
    %<LibDumpSystemSSVars(ss,"ZeroCrossing%<tidTrailer>%<pidTrailer>")>\
    %<LibGetSystemLocalVars(ss,"ZeroCrossing","%<tidTrailer>")>
    %<SLibGetFcnLocalVars(ss,"ZeroCrossing","%<tidTrailer>")>
    %<LibDumpSystemUserCode(ss,"ZeroCrossing","Header")>\
    %<LibDumpGlobalVars(ss, "ZeroCrossing%<tidTrailer>%<pidTrailer>")>\
    %<LibDumpFcnBegin(ss,"ZeroCrossing")>\
    %% open code
    %<LibDumpSystemUserCode(ss,"ZeroCrossing","Body")>\
    %<LibDumpSystemFcn(ss,"ZeroCrossing%<tidTrailer>%<pidTrailer>")>\
    %<LibDumpSystemUserCode(ss,"ZeroCrossing","Trailer")>\
    %% close code
    %<LibDumpFcnClose(ss,"ZeroCrossing")>
    %closefile tmpBuffer
    %assign retBuffer = ""
    %if !WHITE_SPACE(tmpBuffer)
        %openfile retBuffer
        %assign isSSMapped = SLibIsMappedInDeploymentDiagram(ss)
        %if LibSystemIsInlined(ss) && !isSSMapped
            %<SLibGetFcnComment(ss,"ZeroCrossings")>\
        %elseif (!isSSMapped) || SLibPartitionNeedContFcnDecl(ss.CurrentPID)
            %assign fcnAbstract = SLibGetFcnCommentContents(ss,"ZeroCrossings")
            %assign fcnInfo = LibGetFcnInfo(ss, "ZeroCrossing", ss.CurrentTID)
            %assign fcnBlockDescription = SLibGetBlockDescriptionForSS(ss,"ZeroCrossings")
            %addtorecord fcnInfo Abstract fcnAbstract  Category "model" GeneratedBy "commonbodlib.tlc" ...
                Type "ZeroCrossing" GeneratedFor FcnGeneratedFor(ss) BlockDescription fcnBlockDescription
            %<SLibDumpFunctionBanner(fcnInfo)>
        %endif
        %<tmpBuffer>\
        %closefile retBuffer
    %endif
    %return retBuffer
%endfunction


%% Function: SLibGetBodyEnableFcnCache(ss) =====================================
%% Description:
%%      Generates the enable function for these system types.
%%        o enable
%%        o enable with trigger
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function SLibGetBodyEnableFcnCache(ss) void
    %openfile tmpBuffer
    %<LibDumpFcnOpen(ss,"Enable")>\
    %<FcnDumpMRLocalVars(ss, "Enable", "")>\
    %<LibDumpSystemSSVars(ss,"Enable")>\
    %<LibGetSystemLocalVars(ss,"Enable","")>
    %<SLibGetFcnLocalVars(ss,"Enable","")>
    %<LibDumpSystemUserCode(ss,"Enable","Header")>\
    %<LibDumpGlobalVars(ss, "Enable")>\
    %<LibDumpFcnBegin(ss,"Enable")>\
    %<LibDumpSystemUserCode(ss,"Enable","Body")>\
    %<LibDumpSystemFcn(ss,"Enable")>\
    %<LibDumpSystemUserCode(ss,"Enable","Trailer")>\
    %<LibDumpFcnClose(ss,"Enable")>
    %closefile tmpBuffer
    %assign retBuffer = ""
    %if !WHITE_SPACE(tmpBuffer)
        %openfile retBuffer
        %if LibSystemIsInlined(ss)
            %<SLibGetFcnComment(ss,"Enable")>\
        %else
            %assign fcnAbstract = SLibGetFcnCommentContents(ss,"Enable")
            %assign fcnInfo = LibGetFcnInfo(ss, "Enable", ss.CurrentTID)
            %assign fcnBlockDescription = SLibGetBlockDescriptionForSS(ss,"Enable")
            %addtorecord fcnInfo Abstract fcnAbstract  Category "model" GeneratedBy "commonbodlib.tlc" ...
                Type "Enable" GeneratedFor FcnGeneratedFor(ss) BlockDescription fcnBlockDescription
            %<SLibDumpFunctionBanner(fcnInfo)>
        %endif
        %<tmpBuffer>\
        %closefile retBuffer
    %endif
    %return retBuffer
%endfunction


%% Function: SLibGetBodyDisableFcnCache(ss) ====================================
%% Description:
%%      Generates the disable function for these system types.
%%        o enable
%%        o enable with trigger
%%
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%function SLibGetBodyDisableFcnCache(ss) void
    %openfile tmpBuffer
    %<LibDumpFcnOpen(ss,"Disable")>\
    %<FcnDumpMRLocalVars(ss, "Disable", "")>\
    %<LibDumpSystemSSVars(ss,"Disable")>\
    %<LibGetSystemLocalVars(ss,"Disable","")>
    %<SLibGetFcnLocalVars(ss,"Disable","")>
    %<LibDumpSystemUserCode(ss,"Disable","Header")>\
    %<LibDumpGlobalVars(ss, "Disable")>\
    %<LibDumpFcnBegin(ss,"Disable")>\
    %% disable code
    %openfile tmpBuffer2
    %<LibDumpSystemUserCode(ss,"Disable","Body")>\
    %<LibDumpSystemFcn(ss,"Disable")>\
    %<LibDumpSystemUserCode(ss,"Disable","Trailer")>\
    %closefile tmpBuffer2
    %<tmpBuffer2>\
    %% close code
    %<LibDumpFcnClose(ss,"Disable")>
    %closefile tmpBuffer
    %assign retBuffer = ""
    %if !WHITE_SPACE(tmpBuffer)
        %openfile retBuffer
        %if LibSystemIsInlined(ss)
            %<SLibGetFcnComment(ss,"Disable")>\
        %else
            %assign fcnAbstract = SLibGetFcnCommentContents(ss,"Disable")
            %assign fcnInfo = LibGetFcnInfo(ss, "Disable", ss.CurrentTID)
            %assign fcnBlockDescription = SLibGetBlockDescriptionForSS(ss,"Disable")
            %addtorecord fcnInfo Abstract fcnAbstract  Category "model" GeneratedBy "commonbodlib.tlc" ...
                Type "Disable" GeneratedFor FcnGeneratedFor(ss) BlockDescription fcnBlockDescription
            %<SLibDumpFunctionBanner(fcnInfo)>
        %endif
        %<tmpBuffer>\
        %closefile retBuffer
    %endif
    %return retBuffer
%endfunction


%function SLibGetBodyFinalizeDimsFcnCache(ss)  void
    %openfile retBuffer
    %if LibSystemIsInlined(ss)
        %<SLibGetFcnComment(ss,"FinalizeDims")>\
    %else
        %assign fcnAbstract = SLibGetFcnCommentContents(ss,"FinalizeDims")
        %assign fcnInfo = LibGetFcnInfo(ss, "FinalizeDims", ss.CurrentTID)
        %addtorecord fcnInfo Abstract fcnAbstract Category "model" GeneratedBy "commonbodlib.tlc" ...
            Type "FinalizeDims" GeneratedFor FcnGeneratedFor(ss) ...
            BlockDescription SLibGetBlockDescriptionForSS(ss, "FinalizeDims")
        %<SLibDumpFunctionBanner(fcnInfo)>
    %endif
    %<LibDumpFcnOpen(ss,"FinalizeDims")>\
    %<FcnDumpMRLocalVars(ss, "FinalizeDims", "")>\
    %<LibDumpSystemSSVars(ss,"FinalizeDims")>\
    %<LibGetSystemLocalVars(ss,"FinalizeDims","")>
    %<SLibGetFcnLocalVars(ss,"FinalizeDims","")>
    %<LibDumpGlobalVars(ss, "FinalizeDims")>\
    %<LibDumpSystemFcn(ss, "FinalizeDims")>
    %<LibDumpFcnClose(ss,"FinalizeDims")>
    %closefile retBuffer
    %return retBuffer
%endfunction

%function SLibGetBodySetDimsFcnCache(ss)  void
    %openfile retBuffer
    %if LibSystemIsInlined(ss)
        %<SLibGetFcnComment(ss,"SetDims")>\
    %else
        %assign fcnAbstract = SLibGetFcnCommentContents(ss,"SetDims")
        %assign fcnInfo = LibGetFcnInfo(ss, "SetDims", ss.CurrentTID)
        %assign fcnBlockDescription = SLibGetBlockDescriptionForSS(ss,"Outputs")
        %addtorecord fcnInfo Abstract fcnAbstract  Category "model" GeneratedBy "commonbodlib.tlc" ...
            Type "SetDims" GeneratedFor FcnGeneratedFor(ss) BlockDescription fcnBlockDescription
        %<SLibDumpFunctionBanner(fcnInfo)>
    %endif
    %<LibDumpFcnOpen(ss,"SetDims")>\
    %<FcnDumpMRLocalVars(ss, "SetDims", "")>\
    %<LibDumpSystemSSVars(ss,"SetDims")>\
    %<LibGetSystemLocalVars(ss,"SetDims","")>
    %<SLibGetFcnLocalVars(ss,"SetDims","")>
    %<LibDumpGlobalVars(ss, "SetDims")>\
    %<LibDumpSystemFcn(ss, "SetDims")>
    %<LibDumpFcnClose(ss,"SetDims")>
    %closefile retBuffer
    %return retBuffer
%endfunction

%% TopTester: test/toolbox/simulink/variants/var-inline-vsink/tmVariantSrcSink1_VC1.m
%function SLibGetBodyConstCodeFcnCache(ss)  void
    %openfile retBuffer
    %if LibSystemIsInlined(ss)
        %<SLibGetFcnComment(ss,"ConstCode")>\
    %else
        %assign fcnAbstract = SLibGetFcnCommentContents(ss,"ConstCode")
        %assign fcnInfo = LibGetFcnInfo(ss, "ConstCode", ss.CurrentTID)
        %addtorecord fcnInfo Abstract fcnAbstract Category "model" GeneratedBy "commonbodlib.tlc" ...
            Type "ConstCode" GeneratedFor FcnGeneratedFor(ss) ...
            BlockDescription SLibGetBlockDescriptionForSS(ss, "ConstCode")
        %<SLibDumpFunctionBanner(fcnInfo)>
    %endif
    %<LibDumpFcnOpen(ss,"ConstCode")>\
    %<FcnDumpMRLocalVars(ss, "ConstCode", "")>\
    %<LibDumpSystemSSVars(ss,"ConstCode")>\
    %<LibGetSystemLocalVars(ss,"ConstCode","")>
    %<SLibGetFcnLocalVars(ss,"ConstCode","")>
    %<LibDumpGlobalVars(ss, "ConstCode")>\
    %<LibDumpSystemFcn(ss, "ConstCode")>
    %<LibDumpFcnClose(ss,"ConstCode")>
    %closefile retBuffer
    %return retBuffer
%endfunction

%% Function: FcnGetFcnCommentToken(ss, fcn, token, prefix) =======================================
%% Description:
%%    Return token's content for comments
%%    Valid token: "FcnDescription", "GeneratedFor", "BlockDescription"
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tmSfFcnCall_VC1.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tvss_code_variants.m
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tmreuse_across_models.m
%% TopTester: test/toolbox/simulink/blocks/sb2sl/tsb2slmdlref.m
%%
%function FcnGetFcnCommentToken(ss, fcn, token, prefix) void
    %assign retBuffer = ""
    %if ss.Type == "atomic" && ISFIELD(ss, "CalledByBlock") && ss.CalledByBlock == "yes"
        %% do not return any thing
        %return ""
    %elseif (ss.Type == "root")
        %if ISEQUAL(token, "FcnDescription")
            %return "%<fcn> for %<ss.Type> system: '%<ss.Name>'"
        %elseif ISEQUAL(token, "GeneratedFor")
            %return "'%<ss.Name>'"
        %elseif ISEQUAL(token, "BlockDescription")
            %return ""
        %endif
    %elseif IsModelReferenceBaseSys(ss)
        %if ISEQUAL(token, "FcnDescription")
            %return "%<fcn> for referenced model: '%<::CompiledModel.Name>'"
        %elseif ISEQUAL(token, "GeneratedFor")
            %return ""
        %elseif ISEQUAL(token, "BlockDescription")
            %return ""
        %endif
    %else
        %assign cs    = ss.CallSites
        %assign numCs = SIZE(cs, 0)
        %assert (numCs > 0)

        %assign ssType = ss.Type + " system"
        %if LibIsServer(ss)
            %assign ssType = "Simulink Function"
        %endif
        %assign retOneBlk = (numCs == 1 || LibSystemIsInlined(ss))
        %assign thisCs = cs[0]
        %assign thisBlk = System[thisCs[2]].Block[thisCs[3]]
        %if retOneBlk
            %assign blkName = SLibGrBlockCommentName(ss.GraphCallSites[0])
            %if ISEQUAL(token, "FcnDescription")
                %if LibSystemIsReusedLibraryFcn(ss) && ISFIELD(ss, "RLSCommentName")
                    %return "%<fcn> for %<ssType>: %<ss.RLSCommentName>"
                %else
                    %return "%<fcn> for %<ssType>: %<blkName>"
                %endif
            %elseif ISEQUAL(token, "GeneratedFor")
                %return "%<blkName>"
            %elseif ISEQUAL(token, "BlockDescription")
                %assign blkName = SLibGrBlockCommentName(ss.GraphCallSites[0])
                %if LibSystemIsInlined(ss) && ISFIELD(thisBlk, "MaskType") && ...
                    thisBlk.MaskType == "Stateflow"
                    %assign retBuffer = "Chart description for: %<blkName>"
                %else
                    %assign retBuffer = "Block description for: %<blkName>"
                %endif
            %endif
        %else
            %assign max = 10
            %assign num = (numCs > max+1) ? max : numCs
            %if ISEQUAL(token, "FcnDescription")
                %assign retBuffer = "%<fcn> for %<ssType>:\n"
                %foreach cIdx = num
                    %assign blkName = SLibGrBlockCommentName(ss.GraphCallSites[cIdx])
                    %assign retBuffer = retBuffer + prefix + "   " + blkName + "\n"
                %endforeach
                %if numCs > num
                    %return retBuffer + prefix + "   ...\n"
                %else
                    %return retBuffer
                %endif
            %elseif ISEQUAL(token, "GeneratedFor")
                %assign retBuffer = ""
                %foreach cIdx = num
                    %assign blkName = SLibGrBlockCommentName(ss.GraphCallSites[cIdx])
                    %if cIdx < num-1
                        %assign retBuffer = retBuffer + "%<blkName>,\n"
                    %else
                        %assign retBuffer = retBuffer + "%<blkName>"
                    %endif
                %endforeach
                %if numCs > num
                    %return retBuffer + ",..."
                %else
                    %return retBuffer
                %endif
            %elseif ISEQUAL(token, "BlockDescription")
                %assign retBuffer = "Common block description:"
            %endif
        %endif
    %endif
    %assign ret_blockdescription = FcnGetBlockDescriptionInFcnBanner(thisBlk)
    %if !ISEMPTY(ret_blockdescription)
        %return retBuffer + "\n" + ret_blockdescription
    %else
        %return ""
    %endif
%endfunction

%% Function: FcnGeneratedFor(ss) =======================================
%% Description:
%%    Return system or block path for function comments
%%    If the system is reused, first 10(11) instances are returned
%%
%function FcnGeneratedFor(ss)
    %return FcnGetFcnCommentToken(ss, "", "GeneratedFor", "")
%endfunction

%% Function: SLibGetBlockDescriptionForSS(ss) =======================================
%% Description:
%%    Return block description for system
%%
%function SLibGetBlockDescriptionForSS(ss, fcn)
    %assign needBlkDsc = !(ss.Type == "atomic" &&  ...
        ISFIELD(ss, "CalledByBlock") && ss.CalledByBlock == "yes") && ...
        (ss.Type != "root") && !IsModelReferenceBaseSys(ss) && ...
        !ss.DescInCallSite && ...
        (fcn == "Output and update" || fcn == "Outputs" || fcn == "SetDims" || fcn == "FinalizeDims")
    %if !needBlkDsc
        %return ""
    %endif
    %return FcnGetFcnCommentToken(ss, fcn, "BlockDescription", "")
%endfunction

%% Function: SLibGetFcnComment(ss, fcn) =======================================
%% Description:
%%    Return comment for each function type with /* */ format. If the system is reused
%%    the comment includes the first 10(11) instances of the reused system.
%%
%function SLibGetFcnComment(ss, fcn) void
    %assign retBuffer = "/* " + FcnGetFcnCommentToken(ss, fcn, "FcnDescription", " *  ") + " */"
    %return retBuffer
%endfunction

%% Function: SLibGetFcnCommentContents(ss, fcn) =======================================
%% Description:
%%    Return comment for each function type without /* */ format. If the system is reused
%%    the comment includes the first 10(11) instances of the reused system.
%%
%function SLibGetFcnCommentContents(ss, fcn) void
    %return FcnGetFcnCommentToken(ss, fcn, "FcnDescription", "")
%endfunction

%% Function: SLibGetBodyOutputUpdateFcnCache(ss) ===============================
%% Description:
%%      Generates the output/update function for systems that have output
%%      and update combined into one function.
%%      Note: a function-call is generated even if it is empty.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%% TopTester: test/toolbox/simulink/variants/var-simfcns-inherit/tmWithCombSpecAndInherit_VC1.m
%%
%function SLibGetBodyOutputUpdateFcnCache(ss) void
    %if SLibSystemFcnPeriodicRateGrouping(ss, "OutputUpdate") || ...
        LibAsynchronousTriggeredTID(ss.CurrentTID)
        %assign tid = ss.CurrentTID
    %else
        %assign tid = ""
    %endif

    %% Simulink functions can't just be removed if they're empty - unless its actually
    %% a different sampletime from the callsite (async/irt & empty).  Since Simulink functions
    %% are always combined output/update, don't need to cover this case in SLibGetBodyOutputFcnCache
    %% This logic seems way more complicated than it should be.  The basic idea:
    %% 1> Don't emit code for inlined IRT unless the function is actualled called from IRT
    %%    (single rate, or the current tid matched the definition tid)
    %% 2> Don't emit code for noninlined IRT if empty & not actually called from IRT
    %% 3> Don't emit code got rate grouped function
    %% 4> Always emit everything else, even if empty
    %%
    %% The tricky part for #1 & #2 is distinguishing a simulink function with IRT inside from
    %% a siulink function without IRT that is called from IRT only.
    %if LibIsServer(ss)
        %if SLibInitEventTID(tid) || (SLibTermEventTID(tid) && !IsModelReferenceSimTarget())
            %% Remove Init and term code if this is a multirate function and the
            %% function has its own init code.  Need to distinguish from multirate
            %% and called from inside someone else's Init function which we do
            %% have to emit the function.
            %assign systemFcnIsEmpty = !LibIsSingleRateSystem(ss) && ...
                !ISEQUAL(tid, FcnGetSubsystemCodeBufTID(ss))
        %elseif SLibNonInlinedModelWideEventTID(tid)
            %% Non-lined IRT doesn't emit if empty and not actually the definition rate
            %assign systemFcnIsEmpty = LibSystemFcnIsEmptyHelper(ss, "OutputUpdate", tid) && ...
                !LibIsSingleRateSystem(ss) && ...
                !ISEQUAL(tid, FcnGetSubsystemCodeBufTID(ss))
        %elseif ss.IsRateGroupedSLFcn
            %% Do not emit the rate grouped Simulink function's subsystem code. It
            %% will be emitted by the root module.
            %assign systemFcnIsEmpty = TLC_TRUE
        %else
            %% Otherwise, this must be emitted even if empty
            %assign systemFcnIsEmpty = TLC_FALSE
        %endif
    %elseif LibAsynchronousTriggeredTID(tid) && !SLibNonInlinedModelWideEventTID(tid)
        %if ISEQUAL(tid, FcnGetSubsystemCodeBufTID(ss)) || ...
            SLibIsExplicitTaskingExportFcnRateGrouping("OutputUpdate",tid)
            %assign systemFcnIsEmpty = LibSystemFcnIsEmptyForTID(ss, "OutputUpdate")
        %else
            %assign systemFcnIsEmpty = TLC_TRUE
        %endif
    %else
        %if ISEQUAL(tid, "") && SLibIsExportFcnDiagram() && (LibSystemIsRoot(ss) || IsModelReferenceBaseSys(ss))
            %assign systemFcnIsEmpty = TLC_TRUE
        %else
            %assign systemFcnIsEmpty = LibSystemFcnIsEmptyForTID(ss, "OutputUpdate")
        %endif
    %endif

    %if IsModelReferenceBaseSys(ss)
        %% Create this field and initialize it to "yes"
        %% This will be updated at the end of function
        %addtorecord ss ModelRefOutputUpdateFcnIsEmpty%<tid> "yes"
    %endif

    %if !systemFcnIsEmpty
        %assign isSSMapped = SLibIsMappedInDeploymentDiagram(ss)
        %openfile tmpBuffer
        %% open
        %if !isSSMapped
            %<LibDumpFcnOpen(ss,"OutputUpdate")>\
        %endif
        %<FcnDumpMRLocalVars(ss, "OutputUpdate", tid)>\
        %% Profiler declaration code
        %<LibDumpSystemProfileCode(ss,"OutputUpdate", "Decls")>\
        %% output declarations
        %<LibDumpSystemSSVars(ss,"OutputUpdate")>\
        %if !isSSMapped
            %<LibGetSystemLocalVars(ss,"OutputUpdate",tid)>
        %endif
        %assign localOutputVars = SLibGetFcnLocalVars(ss, "Output", tid)
        %assign localUpdateVars = SLibGetFcnLocalVars(ss, "Update", tid)
        %assign needBraces = !ISEMPTY(localOutputVars) && !ISEMPTY(localUpdateVars)
        %if !needBraces && !isSSMapped
            %<localOutputVars>
            %<localUpdateVars>
        %endif
        %if (SLibFcnProtoCtrlActive() || GenerateClassInterface) && ...
            IsModelReferenceBaseSys(ss)
            %if !GenerateClassInterface
                %assign fcnData = FcnGetFunctionPrototypeRecord()
            %else
                %assign fcnData = FcnGetRTWCPPStepPrototypeRecord()
            %endif
            %<FcnModelStepFcnReturnCode(fcnData, "ReturnDeclaration")>
            %<FcnModelStepBufferInputsCode(fcnData)>
        %endif
        %<LibDumpSystemUserCode(ss,"Output","Header")>\
        %<LibDumpGlobalVars(ss, "OutputUpdate%<tid>")>\
        %<LibDumpFcnBegin(ss,"OutputUpdate")>\
        %% Profiler start code
        %<LibDumpSystemProfileCode(ss,"OutputUpdate", "Start")>\
        %% When we are generating for model reference, write out
        %% part of the ERT timing Engine.
        %assign mdlrefSys = IsModelReferenceBaseSys(ss)
        %% output code
        %<UpdateRateTransitionFlagsHelper(ss, tid, TLC_FALSE)>
        %<LibDumpSystemUserCode(ss,"Output","Body")>\
        %if needBraces && !ISEMPTY(localOutputVars)
            %<"{">
            %<localOutputVars>
        %endif
        %<LibDumpSystemFcn(ss,"Output%<tid>")>\
        %if needBraces && !ISEMPTY(localOutputVars)
            %<"}">
        %endif
        %<LibDumpSystemUserCode(ss,"Output","Trailer")>\
        %% update declarations
        %%
        %assign userCodeBuffer = ""
        %openfile userCodeBuffer
        %<LibDumpSystemUserCode(ss,"Update","Header")>\
        %<LibDumpSystemUserCode(ss,"Update","Body")>\
        %if needBraces && !ISEMPTY(localUpdateVars)
            %<"{">
            %<localUpdateVars>
        %endif
        %<LibDumpSystemFcn(ss,"Update%<tid>")>\
        %if needBraces && !ISEMPTY(localUpdateVars)
            %<"}">
        %endif
        %<LibDumpSystemUserCode(ss,"Update","Trailer")>\
        %closefile userCodeBuffer
        %%
        %if !WHITE_SPACE(userCodeBuffer)
            %assign needBrace = !LibSystemUserCodeIsEmpty(ss,"Update","Header")
            %if needBrace
                {
            %endif
            %<userCodeBuffer>
            %if needBrace
            }
            %endif
        %endif
        %%
        %<FcnHandlesUnusedTIDArg(ss, "Output")>
        %<FcnHandlesUnusedRTMForSimplifiedInterface(ss, "OutputUpdate")>
        %% Profiler finish code
        %<LibDumpSystemProfileCode(ss,"OutputUpdate", "End")>\

        %if (SLibFcnProtoCtrlActive() || GenerateClassInterface) && ...
            IsModelReferenceBaseSys(ss)
            %if !GenerateClassInterface
                %assign fcnData = FcnGetFunctionPrototypeRecord()
            %else
                %assign fcnData = FcnGetRTWCPPStepPrototypeRecord()
            %endif
            %<FcnModelStepBufferOutputsCode(fcnData)>
            %<FcnModelStepFcnReturnCode(fcnData,"ReturnStatement")>
        %endif
        %if !isSSMapped
            %<LibDumpFcnClose(ss,"OutputUpdate")>
        %endif
        %closefile tmpBuffer
    %else
        %assign tmpBuffer = ""
    %endif
    %assign retBuffer = ""
    %openfile retBuffer
    %if !WHITE_SPACE(tmpBuffer)
        %if LibSystemIsInlined(ss) && (!isSSMapped)
            %<SLibGetFcnComment(ss,"Output and update")>\
        %elseif (!isSSMapped)
            %assign fcnAbstract = SLibGetFcnCommentContents(ss,"Output and update")
            %assign fcnInfo = LibGetFcnInfo(ss, "OutputUpdate", ss.CurrentTID)
            %assign fcnBlockDescription = SLibGetBlockDescriptionForSS(ss,"Output and update")
            %addtorecord fcnInfo Abstract fcnAbstract Category "model" GeneratedBy "commonbodlib.tlc" ...
                Type "Output and update" GeneratedFor FcnGeneratedFor(ss) BlockDescription fcnBlockDescription
            %<SLibDumpFunctionBanner(fcnInfo)>
            %<addToBackupCodeMetrics(ss, fcnInfo.Name, fcnInfo.Name, tid)>
        %endif
        %<tmpBuffer>\
    %endif

    %% Only generate stubs for "main" tid.
    %if (TYPE(tid) != "Number") || !SLibModelWideEventTID(tid) || SLibInitResetTermEventTID(tid)
        %<SLibGenerateFNIStubs(ss)>\
        %<SLibGenerateISRStubs(ss)>\
    %endif
    %closefile retBuffer
    %if IsModelReferenceBaseSys(ss)
        %assign ss.ModelRefOutputUpdateFcnIsEmpty%<tid> = "no"
    %endif
    %return retBuffer
%endfunction

%% Function: SLibGetBodyTerminateFcnCache(ss) ==================================
%% Description:
%%      Generates the terminate function for systems
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortFcnCall4.m
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tmVariantsRSim.m
%%
%function SLibGetBodyTerminateFcnCache(ss) void
    %% We need to change the BlockFcn to terminate because the
    %% rtModel is accessed here.  This currently does not cause
    %% any problems, but it would make the Interface record incorrect.
    %assign oldBlockFcn = ::BlockFcn
    %assign ::BlockFcn = "Terminate"
    %assign isRoot = (ss.Type == "root")
    %%
    %openfile tmpBuffer
    %<LibDumpFcnOpen(ss,"Terminate")>\
    %<FcnDumpMRLocalVars(ss, "Terminate", "")>\
    %if IsBaseSystem(ss.SystemIdx)
        %<LibDumpSystemProfileCode(ss, "Terminate", "End")>
    %endif
    %<LibDumpSystemSSVars(ss,"Terminate")>\
    %<LibGetSystemLocalVars(ss,"Terminate","")>
    %<SLibGetFcnLocalVars(ss,"Terminate","")>
    %<LibDumpSystemUserCode(ss,"Terminate","Header")>\
    %<LibDumpGlobalVars(ss, "Terminate")>\
    %<LibDumpFcnBegin(ss,"Terminate")>\
    %<LibDumpSystemUserCode(ss,"Terminate","Body")>\
    %<LibDumpSystemFcn(ss,"Terminate")>\
    %if isRoot && UsingMalloc && !Accelerator
        %<SLibGenRootTermMemFreeCode()>\
    %endif
    %<LibDumpSystemUserCode(ss,"Terminate","Trailer")>\
    %<LibDumpFcnClose(ss,"Terminate")>
    %closefile tmpBuffer
    %assign retBuffer = ""
    %if !WHITE_SPACE(tmpBuffer)
        %openfile retBuffer
        %if LibSystemIsInlined(ss)
            %<SLibGetFcnComment(ss,"Termination")>\
        %else
            %assign fcnAbstract = SLibGetFcnCommentContents(ss,"Termination")
            %assign fcnInfo = LibGetFcnInfo(ss, "Terminate", ss.CurrentTID)
            %assign fcnBlockDescription = SLibGetBlockDescriptionForSS(ss,"Termination")
            %addtorecord fcnInfo Abstract fcnAbstract Category "model" GeneratedBy "commonbodlib.tlc" ...
                Type "Terminate" GeneratedFor FcnGeneratedFor(ss) BlockDescription fcnBlockDescription
            %<SLibDumpFunctionBanner(fcnInfo)>
        %endif
        %<tmpBuffer>\
        %closefile retBuffer
    %endif
    %assign ::BlockFcn = oldBlockFcn
    %return retBuffer
%endfunction %% SLibGetBodyTerminateFcnCache


%% Function: LibDumpSystemFcn(system,fcn) ======================================
%% Description:
%%      Outputs the cached contents of the specified function for a system.
%%
%function LibDumpSystemFcn(system,fcn) Output
    %assign tempFcnName = "Cached" + fcn + "Fcn"
    %assign code = LibGetSystemField(system, tempFcnName)
    %if code != "/* rate grouped */"
        %% don't dump this comment line
        %% is comment line is only used
        %% to indicate the code is not
        %% empty, is rate grouped
        %<LibTrapCacheAssert(code)>\
        %<code>\
    %endif
%endfunction %% LibDumpSystemFcn


%% Function: LibDumpSystemSSVars(system,fcn) ===================================
%% Description:
%%      Outputs the cached simstruct variables that are needed by the function.
%%
%function LibDumpSystemSSVars(system,fcn) Output
    %assign tempSSVarsName  = "Cached" + fcn + "SSVars"
    %assign code = LibGetSystemField(system, tempSSVarsName)
    %<code>\
%endfunction %% LibDumpSystemSSVars

%% Function: LibDumpSystemProfileCode(system,fcn, part) ========================
%% Description:
%%      Outputs the cached profile code
%%      fcn:  terminate, output, update, outputupdate, derivative
%%      part: ProfileDecls, ProfileStart, ProfileEnd
%%
%function LibDumpSystemProfileCode(system,fcn, part) Output
    %assign tempProfile  = "Cached" + fcn + "Profile"+ part + "Code"
    %assign code = LibGetSystemField(system, tempProfile)
    %<code>\
%endfunction %% LibDumpSystemProfileCode

%% Function: SLibGetFcnLocalVars ===================================================================
%% Abstract:
%%   Returns the local variable declaration for a given system function and
%%   sample time index (and partition index if partition grouping is on)
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function SLibGetFcnLocalVars(system, fcn, tid) void
    %assign retVal = ""
    %assign prefix = "Cached" + fcn
    %if ISEMPTY(tid)
        %assign retVal = LibGetSystemField(system, prefix + "LocalVars")
        %if ISEMPTY(retVal) && LibIsSystemField(system, prefix + "0LocalVars")
            %assign retVal = LibGetSystemField(system, prefix + "0LocalVars")
        %endif
    %else
        %if ISFIELD(system, "CurrentPID") && system.CurrentPID != -1
            %assign retVal = LibGetSystemField(system, prefix + "%<tid>%<system.CurrentPID>LocalVars")
        %else
            %assign retVal = LibGetSystemField(system, prefix + "%<tid>LocalVars")
        %endif
        %% For a synchronous tid, might be cached under tid ""
        %if ISEMPTY(retVal) && ...
            !LibAsynchronousTriggeredTID(tid) && ...
            LibIsSystemField(system, prefix + "LocalVars")
            %assign retVal = LibGetSystemField(system, prefix + "LocalVars")
        %endif
    %endif
    %return retVal
%endfunction

%% Function: SLibResetFcnLocalVars =================================================================
%% Abstract:
%%   Resets the local variable declaration cache for a given system function
%%   and task index.
%%
%function SLibResetFcnLocalVars(system, fcn, tid) void
    %assign prefix = "Cached" + fcn
    %if ISEMPTY(tid)
        %assign retVal = LibGetSystemField(system, prefix + "LocalVars")
        %if ISEMPTY(retVal) && LibIsSystemField(system, prefix + "0LocalVars")
            %<LibSetSystemField(system, prefix + "0LocalVars", "")>
        %else
            %<LibSetSystemField(system, prefix + "LocalVars", "")>
        %endif
    %else
        %assign retVal = LibGetSystemField(system, prefix + "%<tid>LocalVars")
        %if ISEMPTY(retVal) && LibIsSystemField(system, prefix + "LocalVars")
            %<LibSetSystemField(system, prefix + "LocalVars", "")>
        %else
            %<LibSetSystemField(system, prefix + "%<tid>LocalVars", "")>
        %endif
    %endif
%endfunction

%% Function: LibGetSystemLocalVars(system,fcn) =================================
%% Description:
%%      Outputs the cached local variables that are needed by the function.
%% TopTester: test/toolbox/rtw/targets/AUTOSAR/Variants/dimensionVariants/tDimensionVariants9.m
%%
%function LibGetSystemLocalVars(system, fcn, tid) void
    %if ISFIELD(system, "CurrentPID") && system.CurrentPID != -1
        %assign tempLocalBOName = "Cached" + fcn + "%<tid>%<system.CurrentPID>LocalBO"
    %else
        %assign tempLocalBOName = "Cached" + fcn + "%<tid>LocalBO"
    %endif
    %assign localVars = ""
    %if LibIsSystemField(system, tempLocalBOName)
        %assign code = LibGetSystemField(system, tempLocalBOName)
        %if code != "/* rate grouped */"
            %% don't dump this comment line
            %% is comment line is only used
            %% to indicate the code is not
            %% empty, is rate grouped
            %assign localVars = code
        %endif
    %endif
    %return localVars
%endfunction %% LibGetSystemLocalVars

%% Function: SLibSystemFcnTypeMayUseTid(fcn) ===================================
%% Abstract:
%%   Return true if the fcn is the type that may use tid in its code body.
%%
%function SLibSystemFcnTypeMayUseTid(fcn)
    %return (fcn == "Output"   || fcn == "Outputs" || ...
        fcn == "Update" || fcn == "RootUpdate" || ...
        fcn == "OutputUpdate" || fcn == "UpdateContStates")
%endfunction

%% Function: LibSystemFcnNeedsTID(system,fcn) ==================================
%% Description:
%%      returns TLC_TRUE if the system function needs TID passed in,
%%      else returns TLC_FALSE
%% TopTester: test/toolbox/simulink/variants/var-vss-sigobj/tVSSSigObj.m
%% TopTester: test/toolbox/simulink/variants/var-general/tvariant_merge.m
%function LibSystemFcnNeedsTID(system,fcn) void
    %assign retVal = TLC_FALSE
    %assign tidIsUsedInFcn = TLC_FALSE

    %% Only potential multirate function may use TID.
    %if !SLibSystemFcnTypeMayUseTid(fcn)
        %return retVal
    %endif

    %% First, figure out whether the tid is used in the function.
    %switch fcn
      %case "UpdateContStates"
      %case "Update"
      %case "RootUpdate"
        %assign tidIsUsedInFcn = LibGetSystemField(system, "NeedTIDInUpdate")
        %break
      %case "Output"
      %case "Outputs"
      %case "OutputUpdate"
        %assign tidIsUsedInFcn = LibGetSystemField(system, "NeedTIDInOutput")
        %break
      %default
        %% Other function types are single rate.
        %% always assert
        %assert TLC_FALSE
    %endswitch

    %% Second, find out if tid arg is required to pass in fcn.
    %if LibSystemIsRoot(system)
        %% If target requires tid at root.
        %% Note: GRT target must pass in tid arg because external customers
        %% may rely on this.
        %if RootBodyTIDneeded
            %assign retVal = TLC_TRUE
        %else
            %if SLibSystemFcnPeriodicRateGrouping(system, fcn)
                %% Root level wrapper function that calls each rate-grouped
                %% step function, must pass in tid arg.
                %% This is the case to support static ert main
                %assign retVal  = ISEQUAL(system.CurrentTID, "") || ...
                    (SLibNeedWrapperStepFcn()!=0 && system.CurrentTID == 0 && ...
                    ::GenerateClassInterface && EXISTS(NumServicePorts) && NumServicePorts>0)
            %endif
            %if tidIsUsedInFcn && !retVal
                %% tid is not passed in, but is used
                %% add local tid in fcn scope.
                %<SLibSetNeedLocalTIDInSystem(system,fcn)>
            %endif
        %endif
    %else
        %if tidIsUsedInFcn
            %assign retVal = TLC_TRUE
        %else
            %% If tid is not used, but the fcn callsite assume tid arg.
            %% (e.g. Non-inline sfcn). Force the fcn to have tid arg.
            %assign retVal =  SLibSystemFcnTypeMayUseTid(fcn) && FcnForcedHasTIDArg(system)
        %endif
    %endif

    %return retVal
%endfunction %% LibSystemFcnNeedsTID


%% Function: LibSystemFcnNeedsCPI(system,fcn) ==================================
%% Description:
%%      returns TLC_TRUE if the system function needs CPI (Control Port Index)
%%      passed in, else returns TLC_FALSE
%%
%function LibSystemFcnNeedsCPI(system,fcn) void
    %if fcn == "OutputUpdate" || ...
        fcn == "Enable" || ...
        fcn == "Disable"
        %assign tempName = "NeedCPIIn" + fcn
        %return LibGetSystemField(system, tempName)
    %else
        %return TLC_FALSE
    %endif
%endfunction %% LibSystemFcnNeedsCPI

%% Function: SLibSystemTidMatch(system, tid)
%% Abstract:
%%    Return trun if tid matches base tid of the subsystem.
%%
%function SLibSystemTidMatch(system, tid)

    %if !LibIsSingleRateSystem(system)
        %return TLC_TRUE
    %endif

    %assign sysTid = LibGetSubsystemTID(system, TLC_TRUE)

    %if ISEQUAL(tid,"")
        %return TLC_TRUE
    %elseif ISEQUAL(tid, sysTid)
        %return TLC_TRUE
    %else
        %assign tid01Eq = ISEQUAL(SolverType, "FixedStep") && FixedStepOpts.TID01EQ
        %return tid01Eq && ...
            (tid == 0 || tid == 1) && ...
            (sysTid == 0 || sysTid == 1)
    %endif
%endfunction

%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-codegen/subsystemBuild/tIVSubsystemBuild_1.m
%% TopTester: test/toolbox/simulink/variants/var-inline-general/tIVfcnCall_neg.m
%function SLibSystemUserDataIsEmpty(system, fcnType, tid)
    %if TYPE(tid) == "Number"
        %assert tid >= 0
        %% userCode is not rate grouped, when check if code for specific tid
        %% is empty, should not include user code unless the tid equal to
        %% subsystem tid
        %if system.Type != "root"
            %assign ssTid = FcnGetSubsystemCustomCodeBufTID(system)
            %if !ISEQUAL(tid, ssTid)
                %return TLC_TRUE
            %endif
        %endif
    %endif

    %% Since CGIR will generate call-site code when %<fcnType>MethodHasUserData
    %% is true. TLC must generate function for this fcnType even the code is empty.
    %% The only exceptions are:
    %%  1. System is inlined,(no call site code is emitted by CGIR in this case).
    %%  2. Is root system. (call site code is NOT emitted by CGIR, it is generate in TLC
    %%  3. fcn type is terminate. All subsystem terminate code is placed in models
    %%     terminate function. (see ProcessRTWdata(RTWdata, system) in custcode.tlc)
    %%  4. fcn type is initialize. (Custom initialize code is cached in in the system
    %%     if it has an initialize function, otherwise cache in models start function.
    %%
    %if LibSystemIsInlined(system) || system.Type == "root" || ...
        fcnType == "Terminate" || fcnType == "Initialize"
        %if fcnType == "OutputUpdate"
            %assign userCodeIsEmpty = ...
                WHITE_SPACE(LibGetSystemField(system, "OutputHeader" )) && ...
                WHITE_SPACE(LibGetSystemField(system, "OutputBody"   )) && ...
                WHITE_SPACE(LibGetSystemField(system, "OutputTrailer")) && ...
                WHITE_SPACE(LibGetSystemField(system, "UpdateHeader" )) && ...
                WHITE_SPACE(LibGetSystemField(system, "UpdateBody"   )) && ...
                WHITE_SPACE(LibGetSystemField(system, "UpdateTrailer"))
        %else
            %assign userCodeIsEmpty = ...
                WHITE_SPACE(LibGetSystemField(system, "%<fcnType>Header" )) && ...
                WHITE_SPACE(LibGetSystemField(system, "%<fcnType>Body"   )) && ...
                WHITE_SPACE(LibGetSystemField(system, "%<fcnType>Trailer"))
        %endif
    %else
        %if fcnType == "OutputUpdate"
            %assign fcnType = "Output"
        %endif
        %assign fieldname = "%<fcnType>MethodHasUserData"
        %assign userCodeIsEmpty = !ISFIELD(system, fieldname) || !GETFIELD(system, fieldname)
    %endif

    %return userCodeIsEmpty
%endfunction

%% TopTester: test/toolbox/simulink/variants/var-inline-general/tIVfcnCall_neg.m
%function LibSystemFcnIsEmptyHelper(system, fcn, tid)
    %% Output may have been combined with update
    %if fcn == "Output" && !ISFIELD(system,"OutputFcn") &&  ...
        !(ISFIELD(system,"OutputCalledInUpdate") &&  ...
        system.OutputCalledInUpdate == "yes")
        %assign fcn = "OutputUpdate"
    %endif

    %if SLibSystemFcnIsRateGroupType(fcn)
        %if !SLibIsMultiRateAndPeriodicRateGrouping(system) && !LibAsynchronousTriggeredTID(tid) && ...
            !SLibIsExplicitTaskingExportFcnRateGrouping(fcn, tid) && ...
            !(SLibPartitionGroupingSystem(system) && TYPE(tid) == "Number")
            %% system is not rate grouped, ignore tid value
            %if SLibSystemTidMatch(system,tid)
                %assign tid = ""
            %else
                %return TLC_TRUE
            %endif
        %endif
    %else
        %% sysFcn is not rate grouped, ignore tid value
        %assign tid = ""
    %endif

    %if !ISFIELD(system,"%<fcn>Fcn") && system.Type != "root"
        %return TLC_TRUE
    %endif

    %assign pidVec = []
    %if SLibPartitionGroupingSystem(system) && TYPE(tid) == "Number"
        %assign pidVec =  SLibGetPidFromTid(tid)
    %endif

    %if fcn == "OutputUpdate"
        %if system.DeletedInIR
            %return TLC_TRUE
        %endif
        %if SLibPartitionGroupingSystem(system) && TYPE(tid) == "Number"
            %assign rtwCode = []
            %foreach i = SIZE(pidVec, 1)
                %assign rtwCode = rtwCode + ...
                    LibGetSystemField(system, "CachedOutput%<tid>%<pidVec[i]>Fcn") + ...
                    LibGetSystemField(system, "CachedUpdate%<tid>%<pidVec[i]>Fcn")
            %endforeach
        %else
            %assign rtwCode = LibGetSystemField(system, "CachedOutput%<tid>Fcn") + ...
                LibGetSystemField(system, "CachedUpdate%<tid>Fcn")
        %endif
    %elseif fcn == "Output" && system.DeletedInIR
        %return TLC_TRUE
    %else
        %if SLibPartitionGroupingSystem(system) && TYPE(tid) == "Number"
            %assign rtwCode = []
            %foreach i = SIZE(pidVec, 1)
                %assign rtwCode = rtwCode + ...
                    LibGetSystemField(system, "Cached%<fcn>%<tid>%<pidVec[i]>Fcn")
            %endforeach
        %else
            %assign rtwCode = LibGetSystemField(system, "Cached%<fcn>%<tid>Fcn")
        %endif
    %endif

    %assign ssCodeIsEmpty = TLC_TRUE
    %if ISEQUAL(tid, "")
        %assign ssCodeIsEmpty = ...
            WHITE_SPACE(LibGetSystemField(system, "Cached%<fcn>ProfileDeclsCode")) && ...
            WHITE_SPACE(LibGetSystemField(system, "Cached%<fcn>ProfileStartCode")) && ...
            WHITE_SPACE(LibGetSystemField(system, "Cached%<fcn>ProfileEndCode"))
    %endif

    %% If the TID is not associated with any PID then rtwCode will be []
    %% and WHITE_SPACE(rtwCode) will return TLC_FALSE
    %assign rtwCodeIsEmpty = ISEMPTY(rtwCode) || WHITE_SPACE(rtwCode)
    %assign userCodeIsEmpty = SLibSystemUserDataIsEmpty(system, fcn, tid)

    %<LibTrapCacheAssert(rtwCode)>

    %if (fcn == "Update" && !ISEQUAL(tid, ""))
        %assign isEmpty = (rtwCodeIsEmpty && userCodeIsEmpty)
    %else
        %assign isEmpty= (rtwCodeIsEmpty && userCodeIsEmpty && ssCodeIsEmpty)
    %endif

    %if fcn == "Start" && SLibCacheModelArgsInStart(system)
        %assign isEmpty = TLC_FALSE
    %endif

    %assign isOutputFcn = (fcn == "Output" || fcn == "Update" || fcn == "OutputUpdate")
    %if isEmpty == TLC_TRUE && (Accelerator || isRAccel) && isOutputFcn && ...
        LibSystemIsRoot(system)
        %assign isEmpty = TLC_FALSE
    %endif
    %if isEmpty == TLC_TRUE && IsModelReferenceBaseSys(system) && isOutputFcn

        %%Function body is empty since isEmpty==TLC_TRUE
        %%Here we keep track of whether the model has
        %%only model wide events other than tid=""
        %%See g1930056.
        %if TYPE(tid) == "Number"
            %assign emptyTIDandMdlHasOnlyModelWideEvents = TLC_FALSE
        %else
            %%Assume
            %assign emptyTIDandMdlHasOnlyModelWideEvents = TLC_TRUE
            %foreach tid_temp = NumSampleTimes
                %if tid_temp != 0 && !SLibModelWideEventTID(tid_temp)
                    %assign emptyTIDandMdlHasOnlyModelWideEvents = TLC_FALSE
                    %break
                %endif
            %endforeach
        %endif

        %if !IsModelReferenceSimTarget() || SLibParameterChangeEventTID(tid) || ...
            !(MdlRefIsConstSampleBlock() || emptyTIDandMdlHasOnlyModelWideEvents)
            %if ISFIELD(system, "ModelRef%<fcn>FcnIsEmpty%<tid>")
                %% The code has already been dumped
                %assign isEmpty = ISEQUAL(system.ModelRef%<fcn>FcnIsEmpty%<tid>, "yes")
            %else
                %assign mdlRefAllowOptimizeEmpty = SLibIsExportFcnDiagram()

                %% Assume it is not empty
                %if !mdlRefAllowOptimizeEmpty && ...
                    (!LibAsynchronousTriggeredTID(tid) || SLibNonInlinedModelWideEventTID(tid))
                    %assign isEmpty = TLC_FALSE
                %endif
            %endif
            %if SLibParameterChangeEventTID(tid) && !Accelerator && !isRAccel
                %% Under the feature control of ParameterService. If the code for parameter change event is
                %% inlined in CGIR, the code body should be empty.
                %% always mark the function as empty
                %assign isEmpty = TLC_TRUE
            %endif
        %endif
    %endif

    %% Exported functions should never be considered empty. They should be emitted
    %% in almost all cases. The exception is system code for rate grouped simulink
    %% functions. The code will be emitted by the root module.
    %if (SLibIsExplicitTaskingExportFcnRateGrouping(fcn, tid) || ...
        (GenerateClassInterface  && !SLibModelWideEventTID(tid) && isOutputFcn  && LibIsServer(system))) && !system.IsRateGroupedSLFcn
        %assign isEmpty = TLC_FALSE
    %endif

    %return isEmpty
%endfunction %%LibSystemFcnIsEmptyHelper

%% Function: LibSystemFcnIsEmpty(system,fcn) ===================================
%% Description:
%%      Function that returns TLC_FALSE if the system contains cached code for
%%      the specified function name for any task.
%%
%function LibSystemFcnIsEmpty(system,fcn) void
    %assign isEmpty = LibSystemFcnIsEmptyHelper(system, fcn, "")
    %if fcn == "Output" || fcn == "Update" || fcn == "OutputUpdate"
        %foreach tid = NumSampleTimes
            %assign isEmpty = isEmpty && LibSystemFcnIsEmptyHelper(system, fcn, tid)
        %endforeach
    %endif

    %if fcn == "Terminate" && UsingMalloc
        %assign isEmpty = TLC_FALSE
    %endif
    %return isEmpty
%endfunction %% LibSystemFcnIsEmpty(system,fcn)

%% Function: LibSystemFcnIsEmptyForTID(system,fcn) ===================================
%% Description:
%%      Function that returns TLC_FALSE if the system contains cached code for
%%      the specified function name of specific Tid.
%%
%function LibSystemFcnIsEmptyForTID(system,fcn) void
    %assign tid = SLibSystemFcnPeriodicRateGrouping(system, fcn) ||...
        LibAsynchronousTriggeredTID(system.CurrentTID) ? system.CurrentTID : ""

    %assign isEmpty = LibSystemFcnIsEmptyHelper(system, fcn, tid)

    %return isEmpty
%endfunction


%% Function: LibSystemIsForceNonInline =============================================================
%%
%% Abstract:
%%    Accessor function for system's ForceNonInline flag
%%
%function LibSystemIsForceNonInline(system)
    %return system.ForceNonInline
%endfunction %% LibSystemIsForceNonInline

%% Function: LibSystemCalledByNonInlineSfcn ========================================================
%%
%% Abstract:
%%    Accessor function for system's CalledByNonInlineSfcn flag
%%
%function LibSystemCalledByNonInlineSfcn(system)
    %return system.CalledByNonInlineSfcn
%endfunction %% LibSystemCalledByNonInlineSfcn


%% Function: LibSystemIsContainedWithinReusedLibraryFcn(system) void =========================
%% Description:
%%      Returns TLC_TRUE if we encounter an RLS anywhere in the system
%%      hierarchy going upwards from the current system to the root.
%%
%function LibSystemIsContainedWithinReusedLibraryFcn(sysIdx, instanceIdx) void
    %assign system = ::CompiledModel.System[sysIdx]
    %if LibSystemIsRoot(system)
        %return TLC_FALSE
    %elseif LibSystemIsReusedLibraryFcn(system)
        %return TLC_TRUE
    %else
        %assign parentCallSiteIdx = system.CallSites[instanceIdx]
        %assign parentSysIdx = parentCallSiteIdx[0]
        %assign parentInstIdx = parentCallSiteIdx[1]
        %return LibSystemIsContainedWithinReusedLibraryFcn(parentSysIdx, parentInstIdx)
    %endif
%endfunction %%LibSystemIsContainedWithinReusedLibraryFcn

%% Function: SLibCurrentlyGeneratingSharedFcn() void ======================
%% Description:
%%      Returns TLC_TRUE if the current model being generated is a shared
%%      function
%%
%function SLibCurrentlyGeneratingSharedFcn() void
    %assign moduleIdx = ::CurrentModuleIdx >= 0? ::CurrentModuleIdx : GetBaseModuleIdx()
    %assign rtwModule = RTWCGModules.RTWCGModule[moduleIdx]
    %return LibSystemIsReusedLibraryFcn(System[rtwModule.CGSystemIdx])

%endfunction %% LibSystemIsReusedLibraryFcn

%% Function: SLibSystemHasOwnDataScope(system) void ============================
%% Description:
%%      Returns TLC_TRUE if the system stores its data in a new scope.
%%
%function SLibSystemHasOwnDataScope(system) void
    %return (system.HStructDeclSystemIdx == system.SystemIdx)
%endfunction %% SLibSystemHasOwnDataScope




%%
%% Local Functions used only in this file.
%%
%% Function: FcnDeclareAccessedLocalVariables ======================================================
%% Description:
%%      A routine to declare all accessed local variables. Right now it
%%      includs block output signals and local scratch DWorks. Once they
%%      are declared, the "DeclareInFcnScope" fields for these local
%%      variables are reset to zero
%% Syntax:
%%      FcnDeclareAccessedLocalVariables(system)
%%
%% TopTester: test/toolbox/rtw/targets/AUTOSAR/Variants/dimensionVariants/tDimensionVariants9.m
%% TopTester: test/toolbox/rtw/targets/AUTOSAR/Variants/inlineVariants/tInlineVariants3.m
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc/tVariantSource3.m
%%
%function FcnDeclareAccessedLocalVariables(system) void
    %assign outputLocalBO  = FcnDeclareAccessedLocalVariableGivenType( ...
        system, "LocalBlockOuput")
    %assign outputLocalSDW = FcnDeclareAccessedLocalVariableGivenType( ...
        system, "LocalDWork")

    %% Merge outputLocalBO and outputLocalSDW

    %% - one of them could be an empty string, the other maybe a vector or a string.
    %% - if any one of them is a vector, it cannot be an empty vector
    %assert TYPE(outputLocalBO) == TYPE(outputLocalSDW) || ISEMPTY(outputLocalBO) || ISEMPTY(outputLocalSDW)

    %if TYPE(outputLocalBO) == "Vector" || TYPE(outputLocalSDW) == "Vector"
        %assign localBOSize = SIZE(outputLocalBO, 1)
        %assign localSDWSize= SIZE(outputLocalSDW,1)

        %if localBOSize == 0
            %assign retVal = outputLocalSDW
        %elseif localSDWSize == 0
            %assign retVal = outputLocalBO
        %else
            %assign retVal = outputLocalBO
            %foreach tid = localSDWSize
                %assign retVal[tid] = retVal[tid] + outputLocalSDW[tid]
            %endforeach
        %endif
    %else
        %% BO/DWORK are either string/string, vector/string, string/vector
        %assign retVal = outputLocalBO + outputLocalSDW
    %endif

    %return retVal
%endfunction

%function FcnIsStdContainerAndMatrixNotUsingStdArray(bo)
    %return LibGetRecordIsStdContainer(bo) && !SLibIsMatrixUsingStdArray()
%endfunction

%function FcnAddInitStringIfSupported(str, bo) Output
    %if !CGMODEL_ACCESS("CGModel.InitializeLocalVars")
        %return str
    %endif
    %if FcnIsStdContainerAndMatrixNotUsingStdArray(bo) || LibIsStdStringDataType(LibCGTypeToSLType(bo.CGTypeIdx))
        %% don't touch string types
        %return str
    %endif
    %assign cgIdx = bo.CGTypeIdx
    %if ISFIELD(bo, "ContainerCGTypeIdx")
        %assign cgIdx = bo.ContainerCGTypeIdx
    %endif
    %assign groundval = ""
    %assign slTypeIdx = LibCGTypeToSLType(cgIdx)
    %assign groundval = LibGetGroundInitFromId(slTypeIdx)
    %assert(!ISEMPTY(groundval) && !WHITE_SPACE(groundval))
    %if LibGetRecordSymbolicWidth(bo) != "1" || SLibCGTypeIsComplexStrict(cgIdx)
        %% Use braces for matrix/complex
        %assign groundval = "{%<groundval>}"
    %endif
    %return LibGetCppBracedInitStr(str + " = %<groundval>")
%endfunction

%% Function: FcnDeclareAccessedLocalVariableGivenType ==============================================
%% Description:
%%      A routine to declare all accessed local variables according to the
%%      types, localBlockOutput or localDWork. Once they
%%      are declared, the "DeclareInFcnScope" field for these block outputs is
%%      reset to zero.
%%
%% Syntax:
%%      FcnDeclareAccessedLocalVariableGivenType(system, type)
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tmg1317695_VC1.m
%% TopTester: test/toolbox/rtw/targets/AUTOSAR/Variants/inlineVariants/tInlineVariants13.m
%%
%function FcnDeclareAccessedLocalVariableGivenType(system, type) void
    %assign LocalBO_Buf = ""
    %assign tid01Eq =  ISEQUAL(SolverType, "FixedStep") && FixedStepOpts.TID01EQ

    %assign activeFcn = FcnGetActiveFcnForDecl()
    %assign declareInFcnScope = "DeclareIn" + activeFcn + "FcnScope"

    %foreach tid = NumSampleTimes
        %if SLibPartitionGroupingSystem(system) && SLibSystemFcnPeriodicRateGrouping(system ,activeFcn)
            %assign pidVec = SLibGetPidFromTid(tid)
            %foreach i = SIZE(pidVec, 1)
                %assign LocalBO_Buf%<tid>%<pidVec[i]> = ""
            %endforeach
        %else
            %assign LocalBO_Buf%<tid> = ""
        %endif
    %endforeach

    %switch type
      %case "LocalBlockOuput"
        %assign NumFlatFields = system.Variables.LocalBlockIODef.NumFlatFields
        %assign FirstLocation = system.Variables.LocalBlockIODef.FirstLocation
        %break
      %case "LocalDWork"
        %assign NumFlatFields = system.Interface.LocalSDWorkArgDef.NumFlatFields
        %assign FirstLocation = system.Interface.LocalSDWorkArgDef.FirstLocation
        %break
    %endswitch

    %if NumFlatFields > 0
        %assign numLocs = 0
        %foreach idx = NumFlatFields
            %assign ifCond = ""
            %assign endIfCond = ""
            %switch type
              %case "LocalBlockOuput"
                %assign localBO = BlockOutputs.LocalBlockOutput[FirstLocation + idx]
                %assign ifCond = SLibIfVariantCondition(localBO)
                %assign endIfCond = SLibEndIfVariantCondition(localBO)
                %break
              %case "LocalDWork"
                %assign localBO = DWorks.DWork[FirstLocation + idx]
                %assign ifCond = SLibIfVariantCondition(localBO)
                %assign endIfCond = SLibEndIfVariantCondition(localBO)

                %% For rapid accelerator parallel ForEach subsystem, local scratch DWork
                %% defined to use as iteration variable should not be declared because
                %% this variable has been moved to as an argument to the function.
                %if SLibNeedHandleParallelForEachSS(system, activeFcn)
                    %if (FirstLocation + idx) == IDNUM(system.IndexingSigSrc)[1]
                        %continue
                    %endif
                %endif

                %if SLibOmitRecord(localBO)
                    %continue
                %endif
                %break
            %endswitch

            %if localBO.%<declareInFcnScope> == 0 || localBO.VarGroupVarIdx > -1
                %assert localBO.%<declareInFcnScope> == 0
                %continue
            %endif

            %%
            %assign numLocs = numLocs+1
            %with localBO
                %openfile tmpBuf
                %assign optDims = LibGetRecordVectorDims(localBO)
                %assign dataType = SLibGetRecordOptStdDataTypeName(localBO, "", TLC_TRUE)
                %assign id = LibGetRecordIdentifier(localBO)
                %%yz %<dataType> %<tLocalBlockIO>_%<id>%<optDims>;

                %assign constrStr = ""
                %if FcnIsStdContainerAndMatrixNotUsingStdArray(localBO)
                    %% pass size to std::vector constructor
                    %assign cgTypeIdx = SLibGetRecordContainerCGTypeIdx(localBO)
                    %assign constrStr = "(" + LibCGTypeSymbolicWidth(cgTypeIdx) + ")"
                %endif

                %if localBO.Autosar4p0ImplicitRead == "yes"
                    %assert SLibAutosarActive()
                    %assign constPrefix = SLibAutosarGetPtrConstPrefix()
                    %<constPrefix> %<dataType> *%<id>;
                %elseif localBO.DeclareAsPointer == "no"
                    %if ISFIELD(localBO, "Alignment")
                        %% if it is struct type, emit the definition regardless of alignment value
                        %if localBO.Alignment == -1 || ...
                            LibCGTypeIsStruct(localBO.CGTypeIdx) || ...
                            LibCGTypeIsComplex(localBO.CGTypeIdx)
                            %if !EXISTS(localBO.initialValue)
                                %<FcnAddInitStringIfSupported("%<dataType> %<id>%<optDims>%<constrStr>", localBO)>;
                            %else
                                %assign initStr = "%<dataType> %<id>%<optDims> = %<localBO.initialValue>;"
                                %<LibGetCppBracedInitStr(initStr)>
                            %endif
                        %elseif localAlign
                            %assign align = SLibGetAlignmentSyntax(::CompiledModel.Name, ...
                                id, dataType, localBO.Alignment, "DATA_ALIGNMENT_LOCAL_VAR")
                            %<FcnAddInitStringIfSupported("%<align> %<dataType> %<id>%<optDims>%<constrStr>", localBO)>;
                        %endif
                    %else
                        %<dataType> %<id>%<optDims>%<constrStr>;
                    %endif
                %else
                    %assert SLibAutosarActive()
                    %assign constPrefix = SLibAutosarGetPtrConstPrefix()
                    %if LibGetRecordIsMatrix(localBO)
                        %<FcnAddInitStringIfSupported("%<constPrefix> %<dataType> (*%<id>)%<optDims>",localBO)>;
                    %else
                        %<FcnAddInitStringIfSupported("%<constPrefix> %<dataType> *%<id>", localBO)>;
                    %endif
                %endif
                %closefile tmpBuf
                %assign tmpBuf = SLibWrapBody(ifCond, tmpBuf, endIfCond)
                %if !SLibSystemFcnIsRateGroupType(activeFcn)
                    %assign LocalBO_Buf0 = LocalBO_Buf0 + tmpBuf
                %else
                    %assign TIDlen = SIZE(TID,1)
                    %assign bufferIncludedForTID0 = TLC_FALSE
                    %assign thisFieldHasBeenAdded = TLC_FALSE
                    %foreach tidIdx = TIDlen
                        %assign tid = (TYPE(TID) == "Vector") ? TID[tidIdx]:TID
                        %assign pid = (TYPE(partition) == "Vector") ? partition[tidIdx] : partition
                        %% When tid is negative, then we may reach the code
                        %% %assign LocalBO_Buf%<tid> = LocalBO_Buf%<tid> + tmpBuf
                        %% and it will fail because LocalBO_Buf-x does not exist. We
                        %% should not put it in LocalBO_Buf0 either, because negative tid
                        %% does not mean period sample time. We should just ignore it.
                        %if TYPE(tid) == "Number" && tid < 0
                            %continue
                        %endif
                        %if TYPE(tid) == "Number" && !LibAsynchronousTriggeredTID(tid) && !SLibSystemFcnPeriodicRateGrouping(system ,"Output")
                            %if !thisFieldHasBeenAdded
                                %assign LocalBO_Buf%<tid> = LocalBO_Buf%<tid> + tmpBuf
                                %assign thisFieldHasBeenAdded = TLC_TRUE
                            %endif
                        %elseif TYPE(tid) == "Number" && tid > tid01Eq
                            %if pid != -1
                                %assign LocalBO_Buf%<tid>%<pid> = LocalBO_Buf%<tid>%<pid> + tmpBuf
                            %else
                                %assign LocalBO_Buf%<tid> = LocalBO_Buf%<tid> + tmpBuf
                            %endif
                        %elseif !bufferIncludedForTID0
                            %if pid != -1
                                %assign LocalBO_Buf0%<pid> = LocalBO_Buf0%<pid> + tmpBuf
                            %else
                                %assign LocalBO_Buf0 = LocalBO_Buf0 + tmpBuf
                            %endif
                            %assign bufferIncludedForTID0 = TLC_TRUE
                        %endif
                    %endforeach
                %endif
            %endwith
            %% Reset the DeclareInFcnScope flag to zero
            %assign localBO.%<declareInFcnScope> = 0
        %endforeach

        %% return a string for a non-rate-grouping fcn,
        %% instead of a vector (for rate-grouping fcns).
        %if !SLibSystemFcnIsRateGroupType(activeFcn)
            %if !WHITE_SPACE(LocalBO_Buf0)
                %switch type
                  %case "LocalBlockOuput"
                    %return "/* local block i/o variables */\n" + ...
                        LocalBO_Buf0 + "\n"
                    %%break
                  %case "LocalDWork"
                    %return "/* local scratch DWork variables */\n" + ...
                        LocalBO_Buf0 + "\n"
                    %%break
                %endswitch
            %else
                %return ""
            %endif
        %endif

        %%
        %assign Multirate_LocalBOBuf = []
        %if SLibPartitionGroupingSystem(system)
            %foreach taskIdx = SLibGetNumPartitions()
                %assign Multirate_LocalBOBuf = Multirate_LocalBOBuf + ""
            %endforeach
        %else
            %foreach Tid = NumSampleTimes
                %assign Multirate_LocalBOBuf = Multirate_LocalBOBuf + ""
            %endforeach
        %endif

        %% LocalBO of sync tid
        %if SLibSystemFcnPeriodicRateGrouping(system ,"Output")
            %assign bufIdx = 0
            %foreach Tid = NumRuntimeExportedRates
                %if SLibPartitionGroupingSystem(system)
                    %% Buffer the local block io in the following order
                    %%   TID 0 PID 0
                    %%   ...
                    %%   TID 0 PID n
                    %%   ...
                    %%   TID m PID 1
                    %%   ...
                    %%   TID m PID n
                    %% This make the code caching logic compatible for
                    %% both rate grouping and partition grouping
                    %assign pidVec = SLibGetPidFromTid(Tid)
                    %foreach i = SIZE(pidVec, 1)
                        %if !WHITE_SPACE(LocalBO_Buf%<Tid>%<pidVec[i]>)
                            %switch type
                              %case "LocalBlockOuput"
                                %assign tmpBuffer = "/* local block i/o variables */\n" ...
                                    +  LocalBO_Buf%<Tid>%<pidVec[i]> + "\n"
                                %break
                              %case "LocalDWork"
                                %assign tmpBuffer = "/* local scratch DWork variables */\n" ...
                                    +  LocalBO_Buf%<Tid>%<pidVec[i]> + "\n"
                                %break
                            %endswitch
                        %else
                            %assign tmpBuffer = ""
                        %endif
                        %assign Multirate_LocalBOBuf[bufIdx] = tmpBuffer
                        %assign bufIdx = bufIdx + 1
                    %endforeach
                %elseif !WHITE_SPACE(LocalBO_Buf%<Tid>)
                    %switch type
                      %case "LocalBlockOuput"
                        %assign tmpBuffer = "/* local block i/o variables */\n" ...
                            +  LocalBO_Buf%<Tid> + "\n"
                        %break
                      %case "LocalDWork"
                        %assign tmpBuffer = "/* local scratch DWork variables */\n" ...
                            +  LocalBO_Buf%<Tid> + "\n"
                        %break
                    %endswitch
                %else
                    %assign tmpBuffer = ""
                %endif
                %if !SLibPartitionGroupingSystem(system)
                    %assign Multirate_LocalBOBuf[Tid] = tmpBuffer
                %endif
            %endforeach
            %assign Multirate_LocalBOBuf[0] = ...
                LocalBO_Buf + Multirate_LocalBOBuf[0]
        %elseif !LibAsynchronousTriggeredTID(LibGetSubsystemTID(system,TLC_TRUE))
            %openfile tmpBuffer
            %%
            %% The following section is for testing purpose only. We write out
            %% number of local variables into code comments if
            %% BufferReuseCrossBoundaryTesting feature is ON
            %%
            %if FEVAL("feature", "BufferReuseCrossBoundaryTesting") == 1
                /* Total number of local variables in mdlOutput is %<numLocs> */
            %endif
            %%
            %if !WHITE_SPACE(LocalBO_Buf)
                %<LocalBO_Buf>
            %endif
            %foreach Tid = NumRuntimeExportedRates
                %assign tmpBuf = LocalBO_Buf%<Tid>
                %<tmpBuf>
            %endforeach
            %closefile tmpBuffer
            %openfile mr_localBOBuf
            %if !WHITE_SPACE(tmpBuffer)
                %switch type
                  %case "LocalBlockOuput"
                    /* local block i/o variables */
                    %break
                  %case "LocalDWork"
                    /* local scratch DWork variables */
                    %break
                %endswitch
                %<tmpBuffer>
            %endif
            %closefile mr_localBOBuf
            %assign Multirate_LocalBOBuf[0] = mr_localBOBuf
        %endif

        %% LocalBO of async tid
        %assign numAsyncTasks = LibGetNumAsyncTasks() + SLibGetNumUnionSampleTimes()
        %foreach tidIdx = numAsyncTasks
            %assign tid = NumRuntimeExportedRates + tidIdx

            %% The Union sample time is virtual when it is used in the BIMO context
            %% i.e. for branched inputs/outputs and multi-caller fcn-call subsystem in
            %% non-export-function models. These union rates don't contain only legacy
            %% async rates. We do not generate task code for these Union rates.
            %if SLibUnionSampletimeTID(tid) && ...
                ::CompiledModel.SampleTime[tid].UnionRateHasTask == "no"
                %continue
            %endif

            %if SLibPartitionGroupingSystem(system)
                %% Skip parameter change or init/term events, since it has been inlined to step,
                %% respectively initialize/terminate functions.
                %if SLibParameterChangeEventTID(tid) || SLibModelWideEventTID(tid)
                    %continue
                %endif

                %assign bufIdx = SLibGetNumPartitions() - numAsyncTasks + tidIdx
                %assign pidVec = SLibGetPidFromTid(tid)
                %assert SIZE(pidVec, 1) == 1
                %if !WHITE_SPACE(LocalBO_Buf%<tid>%<pidVec[0]>)
                    %switch type
                      %case "LocalBlockOuput"
                        %assign tmpBuffer = "/* local block i/o variables */\n" ...
                            +  LocalBO_Buf%<tid>%<pidVec[0]> + "\n"
                        %break
                      %case "LocalDWork"
                        %assign tmpBuffer = "/* local scratch DWork variables */\n" ...
                            +  LocalBO_Buf%<tid>%<pidVec[0]> + "\n"
                        %break
                    %endswitch
                %else
                    %assign tmpBuffer = ""
                %endif
                %assign Multirate_LocalBOBuf[bufIdx] = tmpBuffer
            %else
                %if !WHITE_SPACE(LocalBO_Buf%<tid>)
                    %switch type
                      %case "LocalBlockOuput"
                        %assign tmpBuffer = "/* local block i/o variables */\n" ...
                            +  LocalBO_Buf%<tid> + "\n"
                        %break
                      %case "LocalDWork"
                        %assign tmpBuffer = "/* local scratch DWork variables */\n" ...
                            +  LocalBO_Buf%<tid> + "\n"
                        %break
                    %endswitch
                %else
                    %assign tmpBuffer = ""
                %endif
                %assign Multirate_LocalBOBuf[tid] = tmpBuffer
            %endif
        %endforeach

        %return Multirate_LocalBOBuf  %% return a vector.
    %endif

    %return "" %% return an empty string
%endfunction %% FcnDeclareAccessedLocalVariableGivenType

%% Function: SLibGenTerminateBody ==================================================================
%% Abstract:
%%      Caches all terminate code
%% TopTester: test/toolbox/simulink/variants/var-vss-sigobj/tVSSSigObj.m
%%
%function SLibGenTerminateBody() void
    %% Cache subsystems
    %assign ::BlockFcn = "Terminate"
    %foreach sysIdx = NumSystems-1
        %if (!LibIsSystemTerminateCached(System[sysIdx]))
            %<FcnGenSystemTerminate(System[sysIdx])>
        %endif
    %endforeach

    %% we don't need to generate terminate function for
    %% the root subsystem if current target is
    %% model reference target.
    %if !IsModelReferenceTarget()
        %assign rootSystem = ::CompiledModel.System[NumSystems-1]

        %% Cache terminate function
        %% DSP Blockset uses terminate to manage it's database
        %<FcnGenBodyTerminateFcnCache(rootSystem)>
    %endif
    %assign ::BlockFcn = "Unknown"
%endfunction


%% Function: SLibGetNumericTID==============================================
%% Abstract:
%%      get numeric TID. if TID is triggered, return TriggerTID of the block.
%%   If it is constant, return 0, if it subsystem. return subsystemTID.
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc/tVariantSource3.m
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tmVSSfeedingInactiveVS_VC1.m
%%
%function SLibGetNumericTID(block)
    %assign tid = ""
    %with block
        %assert TYPE(TID) != "Vector"
        %if TYPE(TID) == "Number"
            %assign tid = TID
        %elseif ISEQUAL(TID,"triggered")
            %assign tid = TriggerTID[0]
        %elseif ISEQUAL(TID,"constant")
            %assign tid = 0
        %elseif ISEQUAL(TID,"Subsystem")
            %assign tid = ISFIELD(block, "TriggerTID") ? ...
                TriggerTID[0] : SubsystemTID
            %assign tid = ISEQUAL(tid,"constant") ? ...
                0 : tid
            %if TYPE(tid) == "Vector" && firstEntryOfTsMapIsGCD == "yes"
                %assign tid = tid[0]
            %endif
        %endif
    %endwith
    %return tid
%endfunction

%% Function FcnGenAsyncTopSSCode ===================================
%% Abstract:
%%     This function generates code for Async tid Top Subsystem.
%%
%%  This function is called after code generation of root system.
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tMdlRefWithFcnOnDataAsVSSChoice.m
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tmg1396738_inlined_VC1.m
%% TopTester: test/toolbox/rtw/targets/AUTOSAR/Variants/inlineVariants/tInlineVariants10.m
%% TopTester: test/toolbox/simulink/variants/var-general/tVariantGecks.m
%%
%function FcnGenAsyncTopSSCode() void
    %assert !IsModelReferenceTarget()
    %assign orgBlockFcn = ::BlockFcn
    %openfile retBuffer
    %assign ::BlockFcn = "OutputUpdate"
    %assign rootSystem = ::CompiledModel.System[NumSystems-1]

    %foreach idx = LibGetNumAsyncTasks()  + SLibGetNumUnionSampleTimes()
        %assign tid = idx + NumRuntimeExportedRates

        %% The Union sample time is virtual when it is used in the BIMO context
        %% i.e. for branched inputs/outputs and multi-caller fcn-call subsystem in
        %% non-export-function models. These union rates don't contain only legacy
        %% async rates. We do not generate task code for these Union rates.
        %if SLibUnionSampletimeTID(tid) && ...
            ::CompiledModel.SampleTime[tid].UnionRateHasTask == "no"
            %continue
        %endif

        %% %if SampleTime[tid].IsVirtualTs == "yes"
        %%   %continue
        %%  %endif
        %% If the sample time owner is SimEvents, time management code is generated for union ts
        %% all union ts will work under one clock.

        %if SampleTime[tid].IsUnionTs == "yes" || SLibMultiCallerLegacyAsynchronousTID(tid)

            %% The Union sample time is virtual when it is used in the BIMO context
            %% i.e. for branched inputs/outputs and multi-caller fcn-call subsystem in
            %% non-export-function models. These union rates don't contain only legacy
            %% async rates.
            %if SampleTime[tid].IsUnionTs == "yes" && SampleTime[tid].UnionRateHasTask == "no"
                %continue
            %endif

            %% No need to generate entry function prototype if it's not needed by the multi-caller
            %% async rate
            %if SLibMultiCallerLegacyAsynchronousTID(tid) && ...
                FcnIsPrototypeConstructedInIR(rootSystem, ::BlockFcn, tid)
                %continue
            %endif

            %if ISFIELD(SampleTime[tid],"TaskEntryFcnProtoType")
                %assign fcnProtoType = SampleTime[tid].TaskEntryFcnProtoType
            %else
                %% G1208670: Don't generate functions for union sample time if the it's
                %% an export function model, or is a temporary model generated during
                %% conversion from export function-call subsystems to an export function
                %% model.
                %if SLibIsExportFcnDiagram() || SLibIsTempModelGeneratedToExportFcn()
                    %continue
                %endif
                %if CodeFormat == "S-Function"
                    %assign fcnProtoType = "void %<::CompiledModel.Name>_ASYNC%<tid>(%<::tSimStructType>* %<::tSimStruct>, int %<::tControlPortIdx>, int %<::tTID>)"
                %else
                    %assign fcnProtoType = "void %<::CompiledModel.Name>_ASYNC%<tid>(int %<::tControlPortIdx>)"
                %endif
            %endif
            %if ISFIELD(SampleTime[tid],"EventTaskTimeClock")
                %<fcnProtoType> {
                    %<FcnGenerateTimeManagementForAsyncTs("Outputs", tid,"top")>
                    {
                        %<SLibDumpOutputUpdateCodeForAsyncTid(tid)>
                    }
                    %<FcnGenerateTimeManagementForAsyncTs("Outputs", tid,"bottom")>
                }
            %else
                %<fcnProtoType> {
                    %<SLibDumpOutputUpdateCodeForAsyncTid(tid)>
                }
            %endif
            %<LibAddToSystemField(rootSystem, "SystemFcnPrototype","%<fcnProtoType>;")>
        %elseif SampleTime[tid].EventSourceType == "MessageService"
            %if !ISFIELD(SampleTime[tid], "EntryFcnName") || ISEMPTY(SampleTime[tid].EntryFcnName)
                %if CodeFormat == "S-Function"
                    %assign fcnProtoType = "void %<::CompiledModel.Name>_ASYNC%<tid>(%<::tSimStructType>* %<::tSimStruct>, int %<::tControlPortIdx>, int %<::tTID>)"
                %else
                    %assign fcnProtoType = "void %<::CompiledModel.Name>_ASYNC%<tid>(int %<::tControlPortIdx>)"
                %endif
            %else
                %continue
            %endif
            %openfile codeBody
            %<SLibDumpOutputUpdateCodeForAsyncTid(tid)>
            %closefile codeBody
            %if !WHITE_SPACE(codeBody)
                %<fcnProtoType> {
                    %<FcnGenerateTimeManagementForAsyncTs("Outputs", tid,"top")>
                    {
                        %<codeBody>
                    }
                    %<FcnGenerateTimeManagementForAsyncTs("Outputs", tid,"bottom")>
                }
            %endif
            %<LibAddToSystemField(rootSystem, "SystemFcnPrototype","%<fcnProtoType>;")>
        %elseif SampleTime[tid].EventSourceType == "SLMessages"
            %if !Accelerator
                %assign fcnProtoType = "void %<::CompiledModel.Name>_ASYNC%<tid>(int %<::tControlPortIdx>)"
                %<fcnProtoType> {
                    %<FcnGenerateTimeManagementForAsyncTs("Outputs", tid,"top")>
                    %<SLibDumpOutputUpdateCodeForAsyncTid(tid)>
                    %<FcnGenerateTimeManagementForAsyncTs("Outputs", tid,"bottom")>
                }
                %<LibAddToSystemField(rootSystem, "SystemFcnPrototype","%<fcnProtoType>;")>
            %endif
        %elseif SampleTime[tid].EventSourceType == "PlainEvent"
            %assign fcnProtoType = "void %<::CompiledModel.Name>_EVENT%<tid>()"
            %<fcnProtoType> {
                %<FcnGenerateTimeManagementForAsyncTs("Outputs", tid,"top")>
                %<SLibDumpOutputUpdateCodeForAsyncTid(tid)>
                %<FcnGenerateTimeManagementForAsyncTs("Outputs", tid,"bottom")>
            }
            %<LibAddToSystemField(rootSystem, "SystemFcnPrototype","%<fcnProtoType>;")>
        %elseif SLibResetOrResetWithInitEventTID(tid) && !Accelerator && !isRAccel
            %openfile resetFcnBodyBuffer
            %assign rootSystem =::CompiledModel.System[NumSystems-1]
            %assign rootSystem.CurrentTID = tid
            %assign fcnParams = SLibModelFcnArgs("Output",TLC_FALSE,tid)
            %assign fcnReturns = "void"
            %assign fcnName = SampleTime[tid].EntryFcnName

            %if SLibAutosarActive()
                %assign resetRunnable = FcnGetAutosarResetRunnable(tid)
                %if !ISEMPTY(resetRunnable)
                    %assign fcnName = resetRunnable.Symbol
                    %assign memsecUUID = SLibGetFcnMemSecUUIDForFunction("Reset", "%<SampleTime[tid].EventSourceName>")
                    %assign fcnReturns = SLibAutosarCompilerAbstractionForFcnDeclRtnType(fcnReturns, "FuncCalledByRTE", memsecUUID)
                    %assign fcnProtoType = "%<fcnReturns> %<fcnName>(%<fcnParams>)"
                %else
                    %continue
                %endif
            %else
                %assign namespace = ""
                %if GenerateClassInterface
                    %assign className = CGMODEL_ACCESS("CGModel.getClassName")
                    %assign namespace = "%<className>::"
                %endif
                %assign fcnProtoType = "%<fcnReturns> %<namespace>%<fcnName>(%<fcnParams>)"
            %endif
            %openfile codeBody
            %<SLibDumpOutputUpdateCodeForAsyncTid(tid)>
            %closefile codeBody
            %assign prevNSFlag = rootSystem.SystemNamespaceFlag
            %if SLibSystemNeedsNamespace(rootSystem)

                %<SLibEmitNamespaceStartForSystem(rootSystem)>
            %endif
            %if CGMODEL_ACCESS("CGModel.isIndividualFunctionMappingEnabled") || SLibAutosarActive()
                %<SLibGetFcnMemSecPragmaForFunction(fcnName, "Reset", "%<SampleTime[tid].EventSourceName>", "Pre")>
            %else
                %<SLibGetFcnMemSecPragmaForSystem(fcnName, "MemSecFuncExecute", "Pre", rootSystem)>
            %endif
            %<fcnProtoType> {
                %if !WHITE_SPACE(codeBody)
                    %if SLibGenModelDataInitForReinitializeFunction(tid)
                        %% This section generates the reinitialization code
                        %% for model-wide data inside the model_reinit() func.
                        %% These model-wide persistent data including
                        %% block I/O, states, external inputs/outputs, previous zc, etc.
                        %% we need to call SLibDumpLocalVariablesForBlockFcn after
                        %% SLibDumpERTAndModelrefInitMemoryCode because
                        %% FcnArgNeeded tracks variables used previously.
                        %assign tmpBlkFcn = ::BlockFcn
                        %assign originalTid = rootSystem.CurrentTID
                        %assign ::BlockFcn = "ModelInitialize"
                        %openfile localReinit
                        %% Only need the dwork
                        %% External Input, External Output and PrevZc
                        %% are handled by cgir
                        %<SLibDumpERTAndModelrefInitMemoryCode(TLC_FALSE, TLC_TRUE, 0)>
                        %% Since we don't own the external input
                        %% DO NOT reinit it NOW. SupportResetWithInit
                        %%assign ret = SLibAppendInitExternalInputsTLC(0, 0, -1)
                        %%assign tlcBuffer = ret[0]
                        %% <tlcBuffer> \
                        %assign ret = SLibAppendInitExternalOutputsTLC(0, 0, -1)
                        %assign tlcBuffer = ret[0]
                        %<tlcBuffer> \
                        %closefile localReinit
                        %assign ::BlockFcn = tmpBlkFcn
                        %assign rootSystem.CurrentTID = originalTid
                        %openfile localVariables
                        %if MultiInstanceERTCode && !GenerateClassInterface
                            %<SLibDumpLocalVariablesForBlockFcn(rootSystem, "ModelInitialize")> \
                        %endif
                        %closefile localVariables
                        %if !WHITE_SPACE(localReinit)
                            /* model persistent data reinitialization */
                            {
                                %if !WHITE_SPACE(localVariables)
                                    %<localVariables>
                                %endif
                                %<localReinit>
                            }
                        %endif
                    %endif
                    %<codeBody>
                %else
                    /* (no output/update code required) */
                %endif
            }
            %if CGMODEL_ACCESS("CGModel.isIndividualFunctionMappingEnabled") || SLibAutosarActive()
                %<SLibGetFcnMemSecPragmaForFunction(fcnName, "Reset", "%<SampleTime[tid].EventSourceName>", "Post")>
            %else
                %<SLibGetFcnMemSecPragmaForSystem(fcnName, "MemSecFuncExecute", "Post", rootSystem)>
            %endif
            %if prevNSFlag == 0
                %<SLibEmitNamespaceCloseForSystem(rootSystem)>
            %endif
            %closefile resetFcnBodyBuffer
            %<SLibPrintEntryPointFcnToFileUsingFcnName(fcnName, resetFcnBodyBuffer, "Definition")>
        %elseif SLibParameterChangeEventTID(tid) && !Accelerator && !isRAccel
            %% Under the feature control of ParameterService. If the code for parameter change event is
            %% inlined in CGIR, the code body should be empty.
            %% Do Nothing
        %else
            %assign block = FcnGetTaskTopSfcnBlock(tid)
            %if WHITE_SPACE(block)
                %continue
            %endif
            %assign system = System[block.BlkSysIdx]
            %if !ISFIELD(block, "GenCodeForTopAsyncSS")
                %continue
            %endif
            %if block.GenCodeForTopAsyncSS
                %continue
            %else
                %assign block.GenCodeForTopAsyncSS = TLC_TRUE
            %endif
            %if block.SFunctionType == "TLC"
                %openfile tmpBuffer
                %with system
                    %with block
                        %assign ::BlockFcn = "OutputUpdate"
                        %<generateNonExprOutput(block, system, "", 0, TLC_FALSE)> \
                        %% For model reference with function-call inputs, also
                        %% generate the enable, disable and initialize
                        %if IsModelReferenceTarget() || SLibIsExportFcnDiagram()
                            %assign ::BlockFcn = "Enable"
                            %<GENERATE(block, "Enable", system)> \
                            %assign ::BlockFcn = "Disable"
                            %<GENERATE(block, "Disable", system)> \
                        %endif
                    %endwith
                %endwith
                %closefile tmpBuffer
                %if !WHITE_SPACE(tmpBuffer)
                    %if !ISFIELD(block, "AsyncCallerGenCode")
                        %assign warnTxt = ...
                            "The following code generated from sfunction %<block.Name>"...
                            "will be discarded \n"...
                            "%<tmpBuffer> \n"...
                            "Flag AsyncSSCallerGenCode must be added to asynchronous "...
                            "sfunction %<block.Name> in BlockInstanceSetup function "...
                            "if the asynchronous caller itself generates code. "...
                            "Please see vxtask1.tlc for example. "
                        %<LibReportWarning(warnTxt)>
                    %endif
                %endif
                %assign fcnProtoType = ""
                %if ISFIELD(block, "taskFcnName")
                    %assign fcnProtoType = "void %<block.taskFcnName>(void)"
                %elseif ISFIELD(block,"SFcnParamSettings") && ...
                    ISFIELD(block.SFcnParamSettings,"ISRNames")
                    %assign elm       = ::CompiledModel.SampleTime[tid].AsyncSfcnBlkElm
                    %assign fcnProtoType = "void %<block.SFcnParamSettings.ISRNames[elm]>(void)"
                %endif
                %if !WHITE_SPACE(fcnProtoType)
                    %<LibAddToSystemField(rootSystem, "SystemFcnPrototype","%<fcnProtoType>;")>
                %endif
            %endif
        %endif
    %endforeach
    %assign ::BlockFcn = orgBlockFcn
    %closefile retBuffer
    %return retBuffer
%endfunction

%% Fucntion: SLibGenerateModuleFcn =================================================================
%% Abstract:
%%
%function SLibGenerateModuleFcn(module, fcnType) void
    %assign    block = FcnRootOpaqueBlock()
    %assign fileName = module.TLCFileName + "_" + fcnType
    %assign  fcnBuff = ""
    %openfile fcnBuff

    %<GENERATE_TYPE(block, fcnType, fileName)>
    %closefile fcnBuff
    %assign unused = UNLOAD_GENERATE_TYPE(block, fileName)
    %return fcnBuff
%endfunction %% SLibGenerateModuleFcn

%% Function: SLibGenOneInputOneOutputFcnCallInfoForNonFinitesForSystem =============================
%% Abstract: Invoke the function SLibGenOneInputOneOutputFcnCallInfo
%%      for the respective non finite value if it's required by the system
%%
%function SLibGenOneInputOneOutputFcnCallInfoForNonFinitesForSystem(aSystemIdx) void
    %if IsRealInfRequired(aSystemIdx)
        %assign typeId = CGMODEL_ACCESS("CGModel.System.GetTypeIdForRealInf",aSystemIdx)
        %assign dummy = SLibGenOneInputOneOutputFcnCallInfo("getInf",tSS_VOID, typeId,"")
    %endif
    %if IsRealMinusInfRequired(aSystemIdx)
        %assign typeId = CGMODEL_ACCESS("CGModel.System.GetTypeIdForRealMinusInf",aSystemIdx)
        %assign dummy = SLibGenOneInputOneOutputFcnCallInfo("getMinusInf",tSS_VOID, typeId,"")
    %endif
    %if IsRealNaNRequired(aSystemIdx)
        %assign typeId = CGMODEL_ACCESS("CGModel.System.GetTypeIdForRealNaN",aSystemIdx)
        %assign dummy = SLibGenOneInputOneOutputFcnCallInfo("getNaN",tSS_VOID, typeId,"")
    %endif
%endfunction %% SLibGenOneInputOneOutputFcnCallInfoForNonFinitesForSystem

%% Function: SLibGenOneInputOneOutputFcnCallInfoForNonFinites ======================================
%% Abstract: Loop over all the systems and call the function
%%    SLibGenOneInputOneOutputFcnCallInfoForNonFinitesForSystem
%%
%function SLibGenOneInputOneOutputFcnCallInfoForNonFinites() void
    %foreach sysIdx = ::CompiledModel.NumSystems
        %assign system = ::CompiledModel.System[sysIdx]
        %assign prevModuleIdx = ::CurrentModuleIdx
        %assign ::CurrentModuleIdx = system.CGIRModuleIdx
        %<SLibGenOneInputOneOutputFcnCallInfoForNonFinitesForSystem(sysIdx)>
        %assign ::CurrentModuleIdx = prevModuleIdx
    %endforeach
%endfunction %% SLibGenOneInputOneOutputFcnCallInfoForNonFinites

%% Function: SLibGenBodyCache ======================================================================
%% Abstract:
%%      Caches all body code (minus the terminate code since mallocs occur
%%      in the registration and block instance code).
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants_subsys.m
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tmIterSys_GotoFromBlock_VC1.m
%% TopTester: test/toolbox/simulink/variants/modelVariants/tVariantsBasic.m
%%
%function SLibGenBodyCache() void

    %selectfile STDOUT
    %if RTWVerbose
%%}}
### Caching model source code
%%{{
    %endif
    %flushfile STDOUT
    %selectfile NULL_FILE
    %if Accelerator
        %<LibAddToSystem(System[NumSystems-1], "FcnCallSubsystemPtrs", ...
            SLibSetupFCSubsystemPtrs())>
    %endif

    %% Cache all custom registered symbols
    %<SLibAddTLCCompileStatsCheckPoint(TLC_TRUE,"Generate custom registered symbols")>
    %with RTWCGModules
        %assign skipLast = IsModelReferenceTarget()
        %foreach modIdx = NumRTWCGModules
            %if skipLast && modIdx == NumRTWCGModules-1
                %break
            %endif
            %assign module = RTWCGModule[modIdx]
            %if ISFIELD(module, "CGSystemIdx")
                %assign  fileSys = System[module.CGSystemIdx]
                %if module.HasConstants
                    %assign constDef = SLibGenerateModuleFcn(module, "ModuleConstants")
                    %<SLibCacheSystemCodeToFile("sys_data_define", fileSys, ...
                        constDef)>
                %endif
                %if module.HasPublicTypes
                    %assign typeDef = SLibGenerateModuleFcn(module, "PublicModuleTypes")
                    %assign typeDefHFile = SLibGetFileRecForCode("mdl_data_typedef")
                    %if !WHITE_SPACE(typeDef)
                        %<SLibSetModelFileAttribute(typeDefHFile, "Typedefs", typeDef)>
                        %<SLibSetModelFileDeferredIncludeCoderTypes(typeDefHFile, TLC_TRUE)>
                    %endif
                %endif
                %if module.HasExportedTypes
                    %assign typeDef = SLibGenerateModuleFcn(module, "ExportedModuleTypes")
                    %<SLibCacheCodeToFile("baseMdl_data_typedef", typeDef)>
                %endif
                %if module.HasVariables
                    %assign varDecl  = SLibGenerateModuleFcn(module, "ModuleVariables")
                    %<SLibCacheSystemCodeToFile("sys_data_decl", fileSys, varDecl)>
                %endif
            %endif
        %endforeach
    %endwith %% RTWCGModules

    %<SLibAddTLCCompileStatsCheckPoint(TLC_FALSE,"Generate custom registered symbols")>

    %<SLibAddTLCCompileStatsCheckPoint(TLC_TRUE,"Generate system body cache for all modules")>

    %assign skipLast = IsModelReferenceTarget()

    %foreach modIdx = RTWCGModules.NumRTWCGModules
        %%%
        %% When generating model reference target, we do not need to generate
        %% code for root. (After cleanup, we should be abled to skip
        %% code generation for root)
        %%

        %if skipLast && modIdx == RTWCGModules.NumRTWCGModules - 1
            %break
        %endif
        %assert -1 == ::CurrentModuleIdx
        %assign ::CurrentModuleIdx = modIdx
        %assign module = RTWCGModules.RTWCGModule[modIdx]


        %if ISFIELD(module, "CGSystemIdx")
            %<FcnGenBodySysCache(module)>
        %elseif modIdx == RTWCGModules.NumRTWCGModules - 1
            %% Root system module
            %addtorecord module CGSystemIdx NumSystems-1
            %<FcnGenBodySysCache(module)>
        %endif
        %<SLibUnloadTLCInterface(module)>

        %assert ::CurrentModuleIdx == modIdx
        %assign ::CurrentModuleIdx = -1
    %endforeach
    %<SLibGenOneInputOneOutputFcnCallInfoForNonFinites()>
    %<SLibAddTLCCompileStatsCheckPoint(TLC_FALSE,"Generate system body cache for all modules")>

    %<SLibAddTLCCompileStatsCheckPoint(TLC_TRUE,"Generate async tid for top subsystem")>
    %<SLibAddTLCCompileStatsCheckPoint(TLC_FALSE,"Generate async tid for top subsystem")>

    %<SLibAddTLCCompileStatsCheckPoint(TLC_TRUE,"Generate data typedef for discrete derivative signals")>
    %<SLibGetNonContDerivSig()>
    %<SLibAddTLCCompileStatsCheckPoint(TLC_FALSE,"Generate data typedef for discrete derivative signals")>

    %<SLibAddTLCCompileStatsCheckPoint(TLC_TRUE,"Load fixed-point utilities")>
    %<FixPt_LoadFixPtUtils()>
    %<SLibAddTLCCompileStatsCheckPoint(TLC_FALSE,"Load fixed-point utilities")>


%endfunction %% SLibGenBodyCache

%% Function: FcnOutputFilePath =====================================================================
%% Abstract:
%%       Given a coder types filename, return the path to that file
%function FcnOutputFilePath(coderTypesFilename) void
    %if !ISEMPTY(::CompiledModel.GenUtilsPath)
        %assign coderTypesFilename = FULLFILE(::CompiledModel.GenUtilsPath,coderTypesFilename)
    %endif
    %return coderTypesFilename
%endfunction

%% Function: SLibFormatCoderTypesFile ==============================================================
%% Abstract:
%%      Formats coder types file
%% TopTester: test/toolbox/simulink/variants/var-vss-sigobj/tVSSSigObj.m
%%
%function SLibFormatCoderTypesFile(fileKey, fileName, filePath) void
    %if !::AnsiDataTypeName.tlcAddBanner_%<fileKey>
        %assign fileRec = SLibGetFileRecForCode(fileKey + "_hdr")
        %<SLibSetModelFileAttribute(fileRec, "Filter", 1)>
        %<SLibAddGeneratedFileToList(filePath, "utility", "header","")>
    %else
        %openfile fileContent
        %include filePath
        %closefile fileContent
        %<SLibCacheCodeToFile(fileKey + "_defines", fileContent)>
        %assign fileRec = SLibGetFileRecForCode(fileKey + "_hdr")
        %<LibSetSourceFileOutputDirectory(fileRec, GenUtilsPath)>
        %openfile fileBanner_buffer
%%}}
/*
* %<fileName>
*
%<SLibCommonUtilHeaderInfo()>\
*/
%%{{
        %closefile fileBanner_buffer
        %<SLibCacheCodeToFile(fileKey + "_hdr_ban", fileBanner_buffer)>
    %endif
%endfunction


%% Function: SLibFormatHalfTypesFile ===============================================================
%% Abstract:
%%      Formats half_type.h and half_type.c files
%%
%function SLibFormatHalfTypesFile() void
    %% half_type.h
    %if ISFIELD(::AnsiDataTypeName, "tlcAddBanner_halfType_hdr")
        %<SLibAddGeneratedFileToList(SLibCoderHalfTypeHdrFilePath(), "utility", "header", "")>
        %assign filePath = SLibCoderHalfTypeHdrFilePath()
        %openfile fileContent
        %include filePath
        %closefile fileContent
        %<SLibCacheCodeToFile("halfType_hdr_defines", fileContent)>
        %assign fileRec = SLibGetFileRecForCode("halfType_hdr")
        %<LibSetSourceFileOutputDirectory(fileRec, GenUtilsPath)>
        %openfile buf
        /*
        * %<SLibCoderHalfTypeHdrFilename()>
        *
        %<SLibCommonUtilHeaderInfo()>\
        */
        %closefile buf
        %<SLibCacheUtilCodeToFile("halfType_hdr_ban", fileRec, buf)>
    %endif

    %% half_type.c
    %if ISFIELD(::AnsiDataTypeName, "tlcAddBanner_halfType_src")
        %<SLibAddGeneratedFileToList(SLibCoderHalfTypeSrcFilePath(), "utility", "source", "")>
        %assign filePath = SLibCoderHalfTypeSrcFilePath()
        %openfile fileContent
        %include filePath
        %closefile fileContent
        %<SLibCacheCodeToFile("halfType_src_defines", fileContent)>
        %assign fileRec = SLibGetFileRecForCode("halfType_src")
        %openfile buf
        /*
        * %<SLibCoderHalfTypeSrcFilename()>
        *
        %<SLibCommonUtilHeaderInfo()>\
        */
        %closefile buf
        %<SLibCacheUtilCodeToFile("halfType_src_ban", fileRec, buf)>

    %endif
%endfunction

%% Function: SLibFormatImageTypesFile ==============================================================
%% Abstract:
%%      Formats image_type.h and image_type.c files
%%
%function SLibFormatImageTypesFile() void
    %% image_type.h
    %if ISFIELD(::AnsiDataTypeName, "tlcAddBanner_imageType_hdr")
        %<SLibAddGeneratedFileToList(SLibCoderImageTypeHdrFilePath(), "utility", "header", "")>
        %assign filePath = SLibCoderImageTypeHdrFilePath()
        %openfile fileContent
        %include filePath
        %closefile fileContent
        %<SLibCacheCodeToFile("imageType_hdr_defines", fileContent)>
        %assign fileRec = SLibGetFileRecForCode("imageType_hdr")
        %<LibSetSourceFileOutputDirectory(fileRec, GenUtilsPath)>
        %openfile buf
        /*
        * %<SLibCoderImageTypeHdrFilename()>
        *
        %<SLibCommonUtilHeaderInfo()>\
        */
        %closefile buf
        %<SLibCacheUtilCodeToFile("imageType_hdr_ban", fileRec, buf)>
    %endif

    %% image_type.c
    %if ISFIELD(::AnsiDataTypeName, "tlcAddBanner_imageType_src")
        %<SLibAddGeneratedFileToList(SLibCoderImageTypeSrcFilePath(), "utility", "source", "")>
        %assign filePath = SLibCoderImageTypeSrcFilePath()
        %openfile fileContent
        %include filePath
        %closefile fileContent
        %<SLibCacheCodeToFile("imageType_src_defines", fileContent)>
        %assign fileRec = SLibGetFileRecForCode("imageType_src")
        %openfile buf
        /*
        * %<SLibCoderImageTypeSrcFilename()>
        *
        %<SLibCommonUtilHeaderInfo()>\
        */
        %closefile buf
        %<SLibCacheUtilCodeToFile("imageType_src_ban", fileRec, buf)>

    %endif
%endfunction

%% Function: FcnGenAndCacheZeroCrossingTypes =======================================================
%% Abstract:
%%      Generate and cache zero_crossing_types.h, if need
%function FcnGenAndCacheZeroCrossingTypes() void

    %assign ::needZeroCrossingTypes = ...
        ::CompiledModel.ZeroCrossingDefinitionsRequired==1 || ...
        SLibRTModelNeedsZCTypes()==TLC_TRUE

    %if needZeroCrossingTypes
        %assign isSFunctionCodeFormat = (::CompiledModel.CodeFormat == "S-Function")
        %if isSFunctionCodeFormat
            %assign zeroCrossingFileNoPath = "simstruc_types.h"
        %else
            %assign zeroCrossingFileNoPath = SLibCoderZerocrossingTypesFilename()
        %endif

        %% Generate zero crossing_types.h
        %assign fixedWidthIntHeader = CGMODEL_ACCESS("FileRepository.getHeaderForBasicTypesFixedWidthInt")
        %assign zcTypesUpdated = FEVAL("coder.internal.genZcTypesHeader", ...
            SLibCoderZerocrossingTypesFilePath(), fixedWidthIntHeader, LibGetDataTypeNameFromId(::CompiledModel.tSS_UINT8))
        %addtorecord ::AnsiDataTypeName %<"tlcAddBanner_zerocrossingTypes"> zcTypesUpdated
        %<SLibFormatCoderTypesFile("zerocrossingTypes", zeroCrossingFileNoPath, SLibCoderZerocrossingTypesFilePath())>

        %% Update global symbol table
        %<SLibUpdateGlobalSymbolTableForFile(zeroCrossingFileNoPath, "ZCDirection")>
        %<SLibUpdateGlobalSymbolTableForFile(zeroCrossingFileNoPath, "ZCSigState")>
        %<SLibUpdateGlobalSymbolTableForFile(zeroCrossingFileNoPath, "ZCEventType")>
    %endif
%endfunction

%% Function: FcnFormatComplexTypes =================================================================
%% Abstract:
%%      Format complex_types.h
%function FcnFormatComplexTypes() void
    %assign complexTypesFileNoPath = SLibCoderComplexTypesFilename()
    %addtorecord ::AnsiDataTypeName %<"tlcAddBanner_complexTypes"> TLC_TRUE
    %<SLibFormatCoderTypesFile("complexTypes", complexTypesFileNoPath, ...
        SLibCoderComplexTypesFilePath())>
%endfunction

%% Function: SLibGenHeaderCache ====================================================================
%% Abstract:
%%      Caches all system header files.
%%
%% TopTester: test/toolbox/fixpoint/fixpt_autoscale/MLFB/apply_workflow/system_tests
%% TopTester: test/toolbox/simulink/variants/var-bus-general/tBusModelRef.m
%function SLibGenHeaderCache() void
    %% Generate ANSI data type name info and rtwtypes.h. Need to pass whether full or
    %% minimized (ERT) version of rtwtypes.h is desired as well as the location to place
    %% rtwtypes.h.

    %% Include IR based usage of multiword types.
    %assign multiwordBits = ::CompiledModel.LargestMultiwordBits
    %if ::CompiledModel.DeclaredFixedPointWordSizeUsage > multiwordBits
        %if SLibIsERTTarget() && (::CompiledModel.ModelReferenceTargetType != "SIM") && ...
            ConfigSet.MultiwordTypeDef == "User defined"

            %<SLibReportErrorWithIdAndArgs("RTW:tlc:MWLenIssue", ...
                ["%<::CompiledModel.DeclaredFixedPointWordSizeUsage>", "%<multiwordBits>", ...
                "%<::CompiledModel.DeclaredFixedPointWordSizeUsage>"])>

        %else
            %assign multiwordBits = ::CompiledModel.DeclaredFixedPointWordSizeUsage
        %endif
    %endif

    %% Generate coder types files
    %<SLibAddTLCCompileStatsCheckPoint(TLC_TRUE,"Generate rtwtypes.h")> %% sbcheck: ok(TLCTYPES)

    %assign hostBasedSimTarget = SLibIsHostBasedSimulationTarget()

    %assign needMdlrefTypes = (IsModelReferenceTarget() || ...
        HasModelReferenceBlocks()) && ::tMdlRefTimingBridgeAccessed

    %assign hasMessages = EXISTS(CompiledModel.SupportSLMessagesRegistration)

    %assign needHalfPrecisionType = %<LibIsHalfPrecisionUsed()>

    %assign ::AnsiDataTypeName = FEVAL("coder.internal.wrapGenRTWTYPESDOTH", ...
        LibGetModelName(), GenUtilsPath, ...
        GenUtilsSrcInSharedLocation, multiwordBits, needMdlrefTypes, ...
        TLC_FALSE, hostBasedSimTarget, hasMessages, ...
        needHalfPrecisionType, ::UsingTimerService)
    %if TYPE(::AnsiDataTypeName) != "Scope"
        %<LibReportError("Error occurred during call from TLC to coder.internal.wrapGenRTWTYPESDOTH")>
    %endif
    %assign needBuiltinTypeidTypes = ::AnsiDataTypeName.builtin_typeid_types
    %assign needMultiWordTypes = ::AnsiDataTypeName.multiword_types
    %assign needSeparateComplexTypes = ::AnsiDataTypeName.complex_types && ...
        ::IsUsingLanguageStandardTypes
    %assign needReplacementTypesInt = ::AnsiDataTypeName.tlcAddBanner_replacementIntTypes
    %assign needReplacementTypesBool = ::AnsiDataTypeName.tlcAddBanner_replacementBoolType
    %assign needReplacementTypesOther = ::AnsiDataTypeName.tlcAddBanner_replacementOtherTypes

    %<SLibAddTLCCompileStatsCheckPoint(TLC_FALSE,"Generate rtwtypes.h")> %% sbcheck: ok(TLCTYPES)

    %if !::IsUsingLanguageStandardTypes
        %<SLibFormatCoderTypesFile("rtwtypes", "rtwtypes.h", SLibCoderRtwtypesFilePath())> %% sbcheck: ok(TLCTYPES)
    %endif

    %<FcnUpdateGlobalSymbolsForEmbeddedHardwareTypes()>

    %if needMdlrefTypes
        %<SLibFormatCoderTypesFile("mdlrefTypes", SLibCoderModelReferenceTypesFilename(), SLibCoderModelReferenceTypesFilePath())>
    %endif

    %if needBuiltinTypeidTypes
        %% Dump Fixpt Odd Size Typedefs
        %% Dump SS_INT* macros
        %% These are not required if needBuiltinTypeidTypes is false
        %assign typesFile = SLibGetFileRecForCode("mdl_data_typedef")
        %openfile tmpBuffer
        %<LibDumpFixptOddSizeTypedefs()>
        %closefile tmpBuffer
        %if !WHITE_SPACE(tmpBuffer)
            %<SLibSetModelFileDeferredIncludeCoderTypes(typesFile, TLC_TRUE)>
            %<SLibSetModelFileAttribute(typesFile, "Typedefs", tmpBuffer)>
        %endif
        %<SLibFormatCoderTypesFile("builtinTypeidTypes", SLibCoderBuiltinTypeidTypesFilename(), SLibCoderBuiltinTypeidTypesFilePath())>
    %endif

    %if needMultiWordTypes
        %<SLibFormatCoderTypesFile("multiwordTypes", SLibCoderMultiwordTypesFilename(), SLibCoderMultiwordTypesFilePath())>
    %endif

    %if needReplacementTypesInt
        %<SLibFormatCoderTypesFile("replacementIntTypes", SLibCoderReplacementIntTypesFilename(), SLibCoderReplacementIntTypesFilePath())>
    %endif

    %if needReplacementTypesBool
        %<SLibFormatCoderTypesFile("replacementBoolType", SLibCoderReplacementBoolTypeFilename(), SLibCoderReplacementBoolTypeFilePath())>
    %endif

    %if needReplacementTypesOther
        %<SLibFormatCoderTypesFile("replacementOtherTypes", SLibCoderReplacementOtherTypesFilename(), SLibCoderReplacementOtherTypesFilePath())>
    %endif

    %% Generate and cache zero_crossing_types.h, if needed
    %<FcnGenAndCacheZeroCrossingTypes()>

    %% Format complex_types.h
    %if needSeparateComplexTypes
        %<FcnFormatComplexTypes()>
    %endif

    %if needHalfPrecisionType
        %<SLibFormatHalfTypesFile()>
    %endif

    %assign needImageType = %<SLibDeclareImageTypeUsage()>
    %if needImageType
        %<SLibFormatImageTypesFile()>
    %endif

    %% Obtain basic types headers rtwtypes.h, stdbool.h, stdint.h,
    %% cstdint according to language standard settings
    %%
    %% TopTester: test/toolbox/rtw/targets/ert/tLangStandardTypes.m
    %% TopTester: test/toolbox/rtw/targets/ert/tResolvedTypesTlc.m
    %assign usedFilenames = SLibCoderBasicTypesFilenames()

    %assign usedNumericFilenames = SLibCoderBasicTypesFilenames()
    %if needMdlrefTypes
        %assign usedFilenames = usedFilenames + SLibCoderModelReferenceTypesFilename()
    %endif
    %if needBuiltinTypeidTypes
        %assign usedFilenames = usedFilenames + SLibCoderBuiltinTypeidTypesFilename()
    %endif
    %if needMultiWordTypes
        %assign usedFilenames = usedFilenames + SLibCoderMultiwordTypesFilename()
        %assign usedNumericFilenames = usedNumericFilenames + SLibCoderMultiwordTypesFilename()
    %endif
    %if needZeroCrossingTypes
        %assign usedFilenames = usedFilenames + SLibCoderZerocrossingTypesFilename()
        %assign usedNumericFilenames = usedNumericFilenames + SLibCoderZerocrossingTypesFilename()
    %endif
    %if needHalfPrecisionType
        %assign usedFilenames = usedFilenames + SLibCoderHalfTypeHdrFilename()
        %assign usedNumericFilenames = usedNumericFilenames + SLibCoderHalfTypeHdrFilename()
    %endif
    %if needImageType
        %assign usedFilenames = usedFilenames + SLibCoderImageTypeHdrFilename()
        %assign usedNumericFilenames = usedNumericFilenames + SLibCoderImageTypeHdrFilename()
    %endif

    %addtorecord ::CompiledModel.CoderTypesInfo UsedFilenames usedFilenames
    %addtorecord ::CompiledModel.CoderTypesInfo UsedNumericFilenames usedNumericFilenames

    %% Cache system headers
    %<SLibAddTLCCompileStatsCheckPoint(TLC_TRUE,"Generate system headers cache for all modules")>
    %foreach sysIdx = NumSystems
        %assign system = System[sysIdx]
        %assign skip = IsModelReferenceTarget() && sysIdx == NumSystems -1
        %if !skip
            %assert (!system.StandaloneSubsystem || StandaloneSSSupported)

            %%%<SLibAddTLCCompileStatsCheckPoint(TLC_TRUE,"Generate utility includes")>
            %<LibCacheUtilityIncludes(sysIdx)>
            %%%<SLibAddTLCCompileStatsCheckPoint(TLC_FALSE,"Generate utility includes")>

            %%%<SLibAddTLCCompileStatsCheckPoint(TLC_TRUE,"Generate system includes")>
            %<LibCacheSystemIncludes(sysIdx)>
            %%%<SLibAddTLCCompileStatsCheckPoint(TLC_FALSE,"Generate system includes")>

            %%%<SLibAddTLCCompileStatsCheckPoint(TLC_TRUE,"Generate shared type includes")>
            %<LibCacheSharedTypeIncludes(sysIdx)>
            %%%<SLibAddTLCCompileStatsCheckPoint(TLC_FALSE,"Generate shared type includes")>

            %%%<SLibAddTLCCompileStatsCheckPoint(TLC_TRUE,"Generate shared data includes")>
            %<LibCacheSharedDataIncludes(sysIdx)>
            %%%<SLibAddTLCCompileStatsCheckPoint(TLC_FALSE,"Generate shared data includes")>

            %%%<SLibAddTLCCompileStatsCheckPoint(TLC_TRUE,"Generate block i/o struct def")>
            %<LibCacheSystemBlkIOStructDef(sysIdx)>
            %%%<SLibAddTLCCompileStatsCheckPoint(TLC_FALSE,"Generate block i/o struct def")>

            %if ((CodeFormat != "S-Function") || Accelerator)
                %%%<SLibAddTLCCompileStatsCheckPoint(TLC_TRUE,"Generate dwork struct def")>
                %<LibCacheSystemDWorkStructDef(sysIdx)>
                %%%<SLibAddTLCCompileStatsCheckPoint(TLC_FALSE,"Generate dwork struct def")>
            %endif
            %%%<SLibAddTLCCompileStatsCheckPoint(TLC_TRUE,"Generate cstates struct def")>
            %<LibCacheSystemCStatesStructDef(sysIdx)>
            %%%<SLibAddTLCCompileStatsCheckPoint(TLC_FALSE,"Generate cstates struct def")>

            %% The global (model-wide) periodic state vector is only generated at the root level.
            %if (sysIdx == GetBaseSystemIdx())
                %%%<SLibAddTLCCompileStatsCheckPoint(TLC_TRUE,"Generate periodic state vector global def")>
                %<LibCacheSystemPeriodicCStatesStructDef(sysIdx)>
                %%%<SLibAddTLCCompileStatsCheckPoint(TLC_FALSE,"Generate periodic state vector global def")>
            %endif

            %%%<SLibAddTLCCompileStatsCheckPoint(TLC_TRUE,"Generate state derivative struct def")>
            %<LibCacheSystemStateDerivStructDef(sysIdx)>
            %%%<SLibAddTLCCompileStatsCheckPoint(TLC_FALSE,"Generate state derivative struct def")>

            %%%<SLibAddTLCCompileStatsCheckPoint(TLC_TRUE,"Generate state disabled struct def")>
            %<LibCacheSystemStateDisabledStructDef(sysIdx)>
            %%%<SLibAddTLCCompileStatsCheckPoint(TLC_FALSE,"Generate state disabled struct def")>

            %%%<SLibAddTLCCompileStatsCheckPoint(TLC_TRUE,"Generate state absolute tolerance struct def")>
            %<LibCacheSystemCStateAbsoluteToleranceStructDef(sysIdx)>
            %%%<SLibAddTLCCompileStatsCheckPoint(TLC_FALSE,"Generate state absolute tolerance struct def")>

            %%%<SLibAddTLCCompileStatsCheckPoint(TLC_TRUE,"Generate state perturb min struct def")>
            %<LibCacheSystemCStatePerturbMinStructDef(sysIdx)>
            %%%<SLibAddTLCCompileStatsCheckPoint(TLC_FALSE,"Generate state perturb min struct def")>

            %%%<SLibAddTLCCompileStatsCheckPoint(TLC_TRUE,"Generate state perturb max struct def")>
            %<LibCacheSystemCStatePerturbMaxStructDef(sysIdx)>
            %%%<SLibAddTLCCompileStatsCheckPoint(TLC_FALSE,"Generate state perturb max struct def")>
            %%%<SLibAddTLCCompileStatsCheckPoint(TLC_TRUE,"Generate zero-crossing signal value struct def")>


            %<LibCacheSystemZCSignalValueStructDef(sysIdx)>
            %%%<SLibAddTLCCompileStatsCheckPoint(TLC_FALSE,"Generate zero-crossing signal value struct def")>

            %%%<SLibAddTLCCompileStatsCheckPoint(TLC_TRUE,"Generate zero-crossing enable struct def")>
            %<LibCacheSystemZCEStructDef(sysIdx)>
            %%%<SLibAddTLCCompileStatsCheckPoint(TLC_FALSE,"Generate zero-crossing enable struct def")>
            %%%<SLibAddTLCCompileStatsCheckPoint(TLC_TRUE,"Generate Coder Data Group struct defs")>
            %<LibCacheSystemCoderDataGroupStructDefs(sysIdx)>
            %%%<SLibAddTLCCompileStatsCheckPoint(TLC_FALSE,"Generate Coder Data Group struct defs")>
            %if (ModelIsLinearlyImplicit == "yes")

                %% The global (model-wide) mass matrix is only generated at the root level.
                %if (sysIdx == GetBaseSystemIdx())
                    %%%<SLibAddTLCCompileStatsCheckPoint(TLC_TRUE,"Generate mass matrix global def")>
                    %<LibCacheSystemMassMatrixGlobalDef(sysIdx)>
                    %%%<SLibAddTLCCompileStatsCheckPoint(TLC_FALSE,"Generate mass matrix global def")>
                %endif

            %endif
        %endif
    %endforeach
    %<SLibAddTLCCompileStatsCheckPoint(TLC_FALSE,"Generate system headers cache for all modules")>

    %if SLibIsERTTarget()
        %<SLibCachSymbolicDimensionConstraints()>
    %endif

    %% ===========================================================================
    %% Create the the ERT S-Function rtwtypes.h file
    %%
    %if GenerateErtSFunction
        %assign needHalfPrecisionType = TLC_FALSE
        %assign gPath = FEVAL("rtwprivate", "rtwattic","getBuildDir")
        %assign ertSfcnRtwtypesBaseName = SLibGetFileNameForCode("rtwtypes_hdr") + "_sf"
        %assign ertSfcnRtwtypesFileName = ertSfcnRtwtypesBaseName + ".h"
        %assign ertSfcnRtwtypesFilePath = FULLFILE(gPath,ertSfcnRtwtypesFileName)
        %assign ::AnsiDataTypeName = FEVAL("coder.internal.wrapGenRTWTYPESDOTH", ...
            LibGetModelName(), gPath, ...
            TLC_FALSE, 0, TLC_FALSE, TLC_TRUE, hostBasedSimTarget, ...
            TLC_FALSE, needHalfPrecisionType, ::UsingTimerService)
        %if TYPE(::AnsiDataTypeName) != "Scope"
            %<LibReportError("Error occurred during call from TLC to coder.internal.wrapGenRTWTYPESDOTH")>
        %endif
        %openfile contentWithBanner
        /*
        * %<ertSfcnRtwtypesFileName>
        *
        %<SLibCommonUtilHeaderInfo()>\
        */

        %include ertSfcnRtwtypesFilePath
        %closefile contentWithBanner
        %openfile fileWithBanner = ertSfcnRtwtypesFilePath
        %<contentWithBanner>
        %closefile fileWithBanner
    %endif

%endfunction

%function SLibGenConstBlkIOCache() void
    %%
    %% Those structures get accessed in the commonreglib and
    %% this might alter the contents.
    %%
    %assign numSys = GetNumSystemsForCodeGen()
    %foreach sysIdx = numSys
        %<LibCacheSystemConstBlkIOStructDef(sysIdx)>
    %endforeach
%endfunction

%function FcnGetPublicBufferForSSClass(system) Output
    %return LibGetSystemField(system, "ClassMemberMethodPrototype")

%endfunction


%% Function: SLibExtModeHostOnlyStub ===============================================================
%% Abstract:
%%  Stubs out system that only runs on host (for external mode).
%%
%function SLibExtModeHostOnlyStub(system) void
    %if ISFIELD(system,"StartFcn")
        %<LibSetSystemField(system, "CachedStartFcn", "")>
    %endif
    %if ISFIELD(system,"EnableFcn")
        %<LibSetSystemField(system, "CachedEnableFcn", "")>
    %endif
    %if ISFIELD(system,"SetupRuntimeResourcesFcn")
        %<LibSetSystemField(system, "CachedSetupRuntimeResourcesFcn", "")>
    %endif
    %if ISFIELD(system,"InitializeFcn")
        %<LibSetSystemField(system, "CachedInitializeFcn", "")>
    %endif
    %if ISFIELD(system,"SystemInitializeFcn")
        %<LibSetSystemField(system, "CachedSystemInitializeFcn", "")>
    %endif
    %if ISFIELD(system,"SystemResetFcn")
        %<LibSetSystemField(system, "CachedSystemResetFcn", "")>
    %endif
    %if ISFIELD(system,"OutputFcn")
        %<LibSetSystemField(system, "CachedOutputFcn", "")>
    %endif
    %if ISFIELD(system,"OutputUpdateFcn")
        %<LibSetSystemField(system, "CachedOutputFcn", "")>
        %<LibSetSystemField(system, "CachedUpdateFcn", "")>
    %endif
    %if ISFIELD(system,"UpdateFcn")
        %<LibSetSystemField(system, "CachedUpdateFcn", "")>
    %endif
    %if ISFIELD(system,"DerivativeFcn")
        %<LibSetSystemField(system, "CachedDerivativeFcn", "")>
    %endif
    %if ISFIELD(system,"ProjectionFcn")
        %<LibSetSystemField(system, "CachedProjectionFcn", "")>
    %endif
    %if ISFIELD(system,"ForcingFunctionFcn")
        %<LibSetSystemField(system, "CachedForcingFunctionFcn", "")>
    %endif
    %if ISFIELD(system,"MassMatrixFcn")
        %<LibSetSystemField(system, "CachedMassMatrixFcn", "")>
    %endif
    %if ISFIELD(system,"InitSystemMatricesFcn")
        %<LibSetSystemField(system, "CachedInitSystemMatricesFcn", "")>
    %endif
    %if ISFIELD(system,"ZeroCrossingFcn")
        %<LibSetSystemField(system, "CachedZeroCrossingFcn", "")>
    %endif
    %if ISFIELD(system,"DisableFcn")
        %<LibSetSystemField(system, "CachedDisableFcn", "")>
    %endif
    %if ISFIELD(system,"CleanupRuntimeResourcesFcn")
        %<LibSetSystemField(system, "CachedCleanupRuntimeResourcesFcn", "")>
    %endif
    %if ISFIELD(system,"TerminateFcn")
        %<LibSetSystemField(system, "CachedTerminateFcn", "")>
    %endif
    %if ISFIELD(system,"ConstCodeFcn")
        %<LibSetSystemField(system, "CachedConstCodeFcn", "")>
    %endif
%endfunction %% SLibExtModeHostOnlyStub

%function FcnUpdateGlobalSymbolsForEmbeddedHardwareTypes() void
    %assign fixedWidthIntHeader = CGMODEL_ACCESS("FileRepository.getHeaderForBasicTypesFixedWidthInt")
    %<SLibUpdateGlobalSymbolTableForFile(fixedWidthIntHeader, LibGetDataTypeNameFromId(::CompiledModel.tSS_UINT8))>
    %<SLibUpdateGlobalSymbolTableForFile(fixedWidthIntHeader, LibGetDataTypeNameFromId(::CompiledModel.tSS_INT8))>
    %<SLibUpdateGlobalSymbolTableForFile(fixedWidthIntHeader, LibGetDataTypeNameFromId(::CompiledModel.tSS_UINT16))>
    %<SLibUpdateGlobalSymbolTableForFile(fixedWidthIntHeader, LibGetDataTypeNameFromId(::CompiledModel.tSS_INT16))>
    %<SLibUpdateGlobalSymbolTableForFile(fixedWidthIntHeader, LibGetDataTypeNameFromId(::CompiledModel.tSS_UINT32))>
    %<SLibUpdateGlobalSymbolTableForFile(fixedWidthIntHeader, LibGetDataTypeNameFromId(::CompiledModel.tSS_INT32))>
    %if FcnUseNative64BitIntegers()
        %<SLibUpdateGlobalSymbolTableForFile(fixedWidthIntHeader, LibGetDataTypeNameFromId(::CompiledModel.tSS_UINT64))>
        %<SLibUpdateGlobalSymbolTableForFile(fixedWidthIntHeader, LibGetDataTypeNameFromId(::CompiledModel.tSS_INT64))>
    %endif
%endfunction

%endif %% _COMMONBODLIB_

%% [EOF] commonbodlib.tlc
