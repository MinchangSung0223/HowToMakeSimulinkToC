%% ============================================================================
%% File : commonprmlib.tlc
%%
%% Abstract:
%%   This system file produces the structure instances.
%%
%%
%% Copyright 1994-2024 The MathWorks, Inc.
%%
%% ============================================================================
%%TopTester: test/toolbox/simulink/blocks/CPPCodeGen/tsmlk_core_cpp_coverage.m

%selectfile NULL_FILE

%if EXISTS(_COMMONPRMLIB_) == 0
%assign _COMMONPRMLIB_ = 1

%realformat "CONCISE"

%% ============================================================================
%% Create global cache variables to hold each structure instance
%% ============================================================================

%<LibAddToCompiledModel("BlockIOInstance", 0)>
%<LibAddToCompiledModel("ConstBlockIOInstance", 0)>
%<LibAddToCompiledModel("ExportedGlobalSignalsInstance", 0)>
%<LibAddToCompiledModel("CustomReusableSignalsInstance", 0)>
%<LibAddToCompiledModel("ExportedGlobalDWorkInstance", 0)>
%<LibAddToCompiledModel("ContStatesInstance", 0)>
%<LibAddToCompiledModel("ContStatesDisabledInstance", 0)>
%<LibAddToCompiledModel("PeriodicContStatesInstance", 0)>
%<LibAddToCompiledModel("PeriodicStateIndInstance", 0)>
%<LibAddToCompiledModel("PeriodicStateRngInstance", 0)>

%<LibAddToCompiledModel("MassMatricesGlobalInstance", 0)>

%<LibAddToCompiledModel("DWorkInstance", 0)>
%<LibAddToCompiledModel("CoderDataGroupInstance", 0)>
%<LibAddToCompiledModel("PrevZCStatesInstance", 0)>
%<LibAddToCompiledModel("ExternalInputsInstance", 0)>
%<LibAddToCompiledModel("ExternalOutputsInstance", 0)>
%<LibAddToCompiledModel("ExternalInputSizesInstance", 0)>
%<LibAddToCompiledModel("ExternalOutputSizesInstance", 0)>

%% Function: SLibPragmaIdentifierRegexp ============================================================
%% Abstract:
%%  This function does a regular expression search and replace.
%%  It substitutes "$N" with identifier.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants3.m
%%
%function SLibPragmaIdentifierRegexp(pragmastring, identifier) void
    %if ISEMPTY(pragmastring)
        %return pragmastring
    %endif
    %return STRREP( pragmastring, "$N", identifier)
%endfunction


%% Function: SLibApplyMemSecToDataDecl =============================================================
%% This function is called for model level data.
%% MemSecPackage won't be a field unless it's an ERT target so we
%% don't worry about the pragmas unless it exists.
%function SLibApplyMemSecToDataDecl(declaration, mstype, identifier) void
    %return FcnApplyMemSecToDataDefnForSystem(...
        declaration, mstype, identifier, ::CompiledModel.CoderDictionary.DefaultMemorySections, TLC_TRUE, TLC_TRUE)
%endfunction


%% Function: SLibApplyMemSecToDataDeclForSystem ====================================================
%% Abstract:
%%   This function creates a data declartion.  Rather than inserting a
%%   definition directly, data should now go through this central mechanism
%%   to add memory section things like pragmas, modifiers, etc.
%%
%function SLibApplyMemSecToDataDeclForSystem(declaration, mstype, identifier, system, isModelData) void
    %return FcnApplyMemSecToDataDefnForSystem(declaration, mstype, identifier, system, isModelData, TLC_TRUE)
%endfunction


%% Function: SLibApplyMemSecToDataDefn =============================================================
%% Abstract:
%%   This function returns memory section definition for model level data.
%%
%function SLibApplyMemSecToDataDefn(definition, mstype, identifier) void
    %return FcnApplyMemSecToDataDefnForSystem(...
        definition, mstype, identifier, ::CompiledModel.CoderDictionary.DefaultMemorySections, TLC_TRUE, TLC_FALSE)
%endfunction
%% Function: FcnGetMemSecPkgForSubsystem ===========================================================
%% Abstract:
%%   This function returns package name for memory sections used for this
%%   Subsystem. MemSecPackage is from Coder Dictionary (if exists), or from ConfigSet
%%
%function FcnGetMemSecPkgForSubsystem(system) void
    %if ISEMPTY(system) || ISEMPTY(::CompiledModel.CoderDictionary.DefaultMemorySections)
        %return ""
    %endif
    %if ISFIELD(system, "SubsystemMemSecPkg")
        %assign aSystemMemSecPkg = system.SubsystemMemSecPkg
    %else
        %assign aSystemMemSecPkg = ::CompiledModel.CoderDictionary.DefaultMemorySections.MemSecPackage
    %endif
    %return aSystemMemSecPkg
%endfunction

%% Function: FcnGetMemSecDefnInfo ==================================================================
%% Abstract:
%%   This function returns MS Defn info for legacy as well as new memory section
%% based on memory section name and it's package name
%%
%function FcnGetMemSecDefnInfo(memsecname, aMemSecPkg, isLegacy) void

    %createrecord msDefnInfo { \
        PragmaPerVar TLC_FALSE \
        PrePragma "" \
        PostPragma "" \
        Comment "" \
        IsConst TLC_FALSE \
        IsVolatile TLC_FALSE \
        Qualifier "" \
    }
    %assign applyMemSec = FcnApplyMemSec()
    %if ISEMPTY(memsecname) || !applyMemSec
        %return msDefnInfo
    %endif
    %if TYPE(memsecname) != "String"
        %% New memory section
        %% For System defaults and subsystems we directly write complete memory section
        %% information
        %assign msDefn = memsecname
        %assign msDefnInfo.PrePragma = FcnHandleNewLineForMemSec(msDefn.PrePragma)
        %assign msDefnInfo.PostPragma = FcnHandleNewLineForMemSec(msDefn.PostPragma)
        %assign msDefnInfo.Comment = FcnHandleNewLineForMemSec(msDefn.Comment)

        %assign msDefnInfo.PragmaPerVar = ISFIELD(msDefn, "PragmaPerVar") && msDefn.PragmaPerVar
        %assign msDefnInfo.IsConst = msDefn.IsConst
        %assign msDefnInfo.IsVolatile = msDefn.IsVolatile
        %assign msDefnInfo.Qualifier = msDefn.Qualifier

    %elseif memsecname != "Default"
        %if isLegacy
            %assign msDefn = SLibGetInternalMemorySectionDefForName(memsecname, aMemSecPkg)
            %assign msDefnInfo.PrePragma = FcnHandleNewLineForMemSec(msDefn.PrePragma)
            %assign msDefnInfo.PostPragma = FcnHandleNewLineForMemSec(msDefn.PostPragma)
            %assign msDefnInfo.Comment = FcnHandleNewLineForMemSec(msDefn.Comment)

            %assign msDefnInfo.PragmaPerVar = ISFIELD(msDefn, "PragmaPerVar") && msDefn.PragmaPerVar
            %assign msDefnInfo.IsConst = msDefn.IsConst
            %assign msDefnInfo.IsVolatile = msDefn.IsVolatile
            %assign msDefnInfo.Qualifier = msDefn.Qualifier
        %else
            %% New Memory section case where for Coder group we write only UUID
            %% information
            %assign msDefnInfo.PragmaPerVar = CGMODEL_ACCESS("MemorySection.PragmaPerVar", memsecname)
            %assign msDefnInfo.PrePragma = FcnHandleNewLineForMemSec(CGMODEL_ACCESS("MemorySection.PrePragma", memsecname))
            %assign msDefnInfo.PostPragma = FcnHandleNewLineForMemSec(CGMODEL_ACCESS("MemorySection.PostPragma", memsecname))
            %assign msDefnInfo.Comment = FcnHandleNewLineForMemSec(CGMODEL_ACCESS("MemorySection.Comment", memsecname))
        %endif
    %endif
    %return msDefnInfo
%endfunction
%% Function: FcnApplyMemSecToDataDefnForSystem =====================================================
%% Abstract:
%%   Helper function
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants3.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tvss_code_variants.m
%%
%function FcnApplyMemSecToDataDefnForSystem(definition, mstype, identifier, system, isModelData, isDecl) void

    %assign msDefn = []
    %assign applyMemSec = FcnApplyMemSec()
    %assign memsecname = ""
    %if (applyMemSec)
        %switch mstype
          %case "MemSecDataConstants"
            %assign memsecname = system.MemSecDataConstants
            %break
          %case "MemSecDataInternal"
            %assign memsecname = system.MemSecDataInternal
            %break
          %case "MemSecDataInputs"
            %assign memsecname = system.MemSecDataInputs
            %break
          %case "MemSecDataOutputs"
            %assign memsecname = system.MemSecDataOutputs
            %break
          %case "MemSecDataParameters"
            %assign memsecname = system.MemSecDataParameters
            %break
          %default
            %<LibReportFatalError(...
                "Invalid mstype in function: SLibApplyMemSecToDataDefn")>
        %endswitch
    %endif
    %assign msDefn = FcnGetMemSecDefnInfo(memsecname, FcnGetMemSecPkgForSubsystem(system), TYPE(memsecname) == "String")
    %openfile buffer
    %% Believe it or not, "system" can actually be the configset, in which
    %% case we are dealing with model data and we skip the net preprocessor
    %% condition stuff.
    %if !isModelData
        %<SLibIfSystemVariantCondition(system)>
    %endif
    %createrecord qualifierInfo { \
        IsConst msDefn.IsConst \
        IsVolatile msDefn.IsVolatile \
        Qualifier msDefn.Qualifier \
    }
    %createrecord msInfo { \
        PragmaPerVar msDefn.PragmaPerVar \
        PrePragma msDefn.PrePragma \
        PostPragma msDefn.PostPragma \
        Comment msDefn.Comment \
    }
    %<SLibCreateDefinitionStatement(definition, msInfo, qualifierInfo, ...
        identifier, TLC_FALSE, isDecl, TLC_TRUE, TLC_TRUE, "", "")>
    %if !isModelData
        %<SLibEndIfSystemVariantCondition(system)>
    %endif
    %closefile buffer
    %return buffer
%endfunction

%function FcnGenParameterDefNotHandledInVarGroup(prm) void
    %return ""
%endfunction


%% Function: SLibApplyMemSecToDataDefnForSystem ====================================================
%% Abstract:
%%   This function creates a data definition.  Rather than inserting a
%%   definition directly, data should now go through this central mechanism
%%   to add memory section things like pragmas, modifiers, etc.
%%
%function SLibApplyMemSecToDataDefnForSystem(definition, mstype, identifier, system, isModelData) void
    %return FcnApplyMemSecToDataDefnForSystem(definition, mstype, identifier, system, isModelData, TLC_FALSE)
%endfunction

%% This function is called for model level functions.
%% MemSecPackage won't be a field unless it's an ERT target so we
%% don't worry about the pragmas unless it exists.
%function SLibGetFcnMemSecPragmaOnDecl(identifier, mstype, preorpost) void
    %return SLibGetFcnMemSecPragmaForSystemOnDecl(...
        identifier, mstype, preorpost, ::CompiledModel.CoderDictionary.DefaultMemorySections)
%endfunction

%% Function: SLibGetFcnMemSecPragmaForAccessMethod =================================================
%% Abstract:
%%   This function returns a pragma string for Access Method definition.
%%   Depending upon the arguments, it creates a pre or post pragma.
%%   It also does $N substitution within the pragma.
%%
%function SLibGetFcnMemSecPragmaForAccessMethod(fcn, preorpost) void

    %assign msDefn = ""

    %% Don't add pragmas for a model reference target
    %% Only add pragmas if we're using an ert target
    %% if the mstype doesnt exist in system, we should be inside
    %% the <root> system instead of a subsystem.

    %assign applyMemSec = FcnApplyMemSec()
    %if(!applyMemSec)
        %return ""
    %endif

    %assert ISFIELD(fcn, "AccessFunctionMemorySectionUUID")
    %assign memsecuuid = fcn.AccessFunctionMemorySectionUUID

    %% retrieve the memory section data from CGModel
    %assign pragmaPerVar = CGMODEL_ACCESS("MemorySection.PragmaPerVar", memsecuuid)
    %assign prePragma = FcnHandleNewLineForMemSec(CGMODEL_ACCESS("MemorySection.PrePragma", memsecuuid))
    %assign postPragma = FcnHandleNewLineForMemSec(CGMODEL_ACCESS("MemorySection.PostPragma", memsecuuid))
    %assign comment = FcnHandleNewLineForMemSec(CGMODEL_ACCESS("MemorySection.Comment", memsecuuid))

    %assign pragma = ""
    %switch preorpost
      %case "Pre"
        %openfile pragma
        %if !WHITE_SPACE(comment)
            %<comment>
        %endif
        %if !WHITE_SPACE(prePragma)
            %<SLibPragmaIdentifierRegexp(prePragma,  fcn.Name)>
        %endif
        %closefile pragma
        %break
      %case "Post"
        %openfile pragma
        %if !WHITE_SPACE(postPragma)
            %<SLibPragmaIdentifierRegexp(postPragma, fcn.Name)>
        %endif
        %closefile pragma
        %break
      %default
        %<LibReportFatalError(...
            "Invalid preorpost in function: SLibGetFcnMemSecPragmaForSystem")>
    %endswitch
    %return pragma

%endfunction

%% Function: SLibGetFcnMemSecPragmaForSystemOnDecl =================================================
%% Abstract:
%%   This function returns a pragma string.  Depending upon the
%%   arguments, it creates a pre or post pragma.  It also does
%%   $N substitution within the pragma.
%%
%function SLibGetFcnMemSecPragmaForSystemOnDecl(identifier, mstype, preorpost, system) void

    %if !SLibIsPragmaOnDecls()
        %return ""
    %endif

    %return SLibGetFcnMemSecPragmaForSystem(identifier, mstype, preorpost, system)

%endfunction

%% Function: SLibApplyMemSecToDataDefn =============================================================
%% Abstract:
%%   This function returns pragmas for model level functions.
%%
%function SLibGetFcnMemSecPragma(identifier, mstype, preorpost) void
    %return SLibGetFcnMemSecPragmaForSystem(...
        identifier, mstype, preorpost, ::CompiledModel.CoderDictionary.DefaultMemorySections)
%endfunction

%% Function: SLibGetFcnMemSecUUIDForFunction =======================================================
%% Abstract:
%%   This function returns the UUID of a memory section associated with an
%%   entry-point function.
%%   For AUTOSAR target, the UUID is the short-name of the SwAddrMethod
%%
%function SLibGetFcnMemSecUUIDForFunction(fcnType, fcnId) void
    %assign memsecUUID = ""

    %switch fcnType
      %case "Initialize"
        %assign memsecUUID = CGMODEL_ACCESS("CGModel.getModelEntryMemorySection", "Initialize", "")
        %break
      %case "Terminate"
        %assign memsecUUID = CGMODEL_ACCESS("CGModel.getModelEntryMemorySection", "Terminate", "")
        %break
      %case "Reset"
        %assign memsecUUID = CGMODEL_ACCESS("CGModel.getModelEntryMemorySection", "Reset", "%<fcnId>")
        %break
      %case "Step"
        %assign memsecUUID = CGMODEL_ACCESS("CGModel.getModelEntryMemorySection", "Step", "%<fcnId>")
        %break
      %case "Output"
        %assign memsecUUID = CGMODEL_ACCESS("CGModel.getModelEntryMemorySection", "Output", "%<fcnId>")
        %break
      %case "Update"
        %assign memsecUUID = CGMODEL_ACCESS("CGModel.getModelEntryMemorySection", "Update", "%<fcnId>")
        %break
      %case "FcnCallInport"
        %assign memsecUUID = CGMODEL_ACCESS("CGModel.getModelEntryMemorySection", "FcnCallInport", "%<fcnId>")
        %break
      %case "SimulinkFunction"
        %assign memsecUUID = CGMODEL_ACCESS("CGModel.getModelEntryMemorySection", "SimulinkFunction", "%<fcnId>")
        %break
      %case "UNKNOWN"
        %assign memsecUUID = CGMODEL_ACCESS("CGModel.getModelEntryMemorySection", "UNKNOWN", "%<fcnId>")
        %break
      %default
        %<LibReportFatalError(...
            "SLibGetFcnMemSecUUIDForFunction: Invalid : fcnType" + fcnType)>
    %endswitch

    %return memsecUUID
%endfunction

%% Function: SLibGetFcnMemSecPragmaForSystem =======================================================
%% Abstract:
%%   This function returns a pragma string.  Depending upon the
%%   arguments, it creates a pre or post pragma.  It also does
%%   $N substitution within the pragma.
%%
%function SLibGetFcnMemSecPragmaForFunction(identifier, fcnType, fcnId, preorpost) void
    %assign pragma = ""

    %% Only add pragmas if we're using an ert target
    %assign applyMemSec = FcnApplyMemSec()
    %if(!applyMemSec)
        %return ""
    %endif

    %if !CGMODEL_ACCESS("CGModel.isIndividualFunctionMappingEnabled") && !SLibAutosarActive()
        %% Return early if autosar or C individual function mappings is not enabled
        %return ""
    %endif

    %assign memsecUUID = SLibGetFcnMemSecUUIDForFunction(fcnType, fcnId)

    %if !ISEMPTY(memsecUUID)
        %assign msDefn = SLibGetMemorySectionForUUID(memsecUUID)
        %if CGMODEL_ACCESS("MemorySection.IsLegacy", memsecUUID)
            %% For legacy memory section, get definition from class name
            %assign msPkg = CGMODEL_ACCESS("MemorySection.Package", memsecUUID)
            %assign msDefn = SLibGetMemorySectionDefForName(msPkg, msDefn)
        %endif

        %switch preorpost
          %case "Pre"
            %openfile pragma
            %if !WHITE_SPACE(msDefn.Comment)
                %<msDefn.Comment>
            %endif
            %if !WHITE_SPACE(msDefn.PrePragma)
                %<SLibPragmaIdentifierRegexp(msDefn.PrePragma,  identifier)>
            %endif
            %closefile pragma
            %break
          %case "Post"
            %openfile pragma
            %if !WHITE_SPACE(msDefn.PostPragma)
                %<SLibPragmaIdentifierRegexp(msDefn.PostPragma, identifier)>
            %endif
            %closefile pragma
            %break
          %default
            %<LibReportFatalError(...
                "Invalid preorpost in function: SLibGetFcnMemSecPragmaForFunction")>
        %endswitch

    %endif

    %return pragma

%endfunction


%% Function: SLibGetFcnMemSecPragmaForSystem =======================================================
%% Abstract:
%%   This function returns a pragma string.  Depending upon the
%%   arguments, it creates a pre or post pragma.  It also does
%%   $N substitution within the pragma.
%%
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants3.m
%% Topteser: test/toolbox/simulink/variants/var-vss-sigobj/tVSSSigObj.m
%%
%function SLibGetFcnMemSecPragmaForSystem(identifier, mstype, preorpost, system) void

    %assign msDefn = ""

    %% Don't add pragmas for a model reference target
    %% Only add pragmas if we're using an ert target
    %% if the mstype doesnt exist in system, we should be inside
    %% the <root> system instead of a subsystem.

    %assign applyMemSec = FcnApplyMemSec()
    %if(!applyMemSec)
        %return ""
    %endif
    %switch mstype
      %case "MemSecFuncInitTerm"
        %assign memsecname = system.MemSecFuncInitTerm
        %break
      %case "MemSecFuncExecute"
        %assign memsecname = system.MemSecFuncExecute
        %break
      %case "MemSecFuncSharedUtil"
        %assign memsecname = system.MemSecFuncSharedUtil
        %break
      %default
        %<LibReportFatalError(...
            "SLibGetFcnMemSecPragmaForSystem: Invalid mstype: " + mstype)>
    %endswitch

    %if TYPE(memsecname) != "String"
        %% New memory section
        %assign msDefn = memsecname
        %assign prePragma = FcnHandleNewLineForMemSec(msDefn.PrePragma)
        %assign postPragma = FcnHandleNewLineForMemSec(msDefn.PostPragma)
        %assign comment = FcnHandleNewLineForMemSec(msDefn.Comment)

        %switch preorpost
          %case "Pre"
            %openfile pragma
            %if !WHITE_SPACE(comment)
                %<comment>
            %endif
            %if !WHITE_SPACE(prePragma)
                %<SLibPragmaIdentifierRegexp(prePragma,  identifier)>
            %endif
            %closefile pragma
            %break
          %case "Post"
            %openfile pragma
            %if !WHITE_SPACE(postPragma)
                %<SLibPragmaIdentifierRegexp(postPragma, identifier)>
            %endif
            %closefile pragma
            %break
          %default
            %<LibReportFatalError(...
                "Invalid preorpost in function: SLibGetFcnMemSecPragmaForSystem")>
        %endswitch
        %return pragma
    %else
        %% Legacy Memory Section
        %if !ISEMPTY(memsecname) && (memsecname != "Default")
            %% MemSecPackage is from Coder Dictionary (if exists), or from ConfigSet
            %assign aSystemMemSecPkg = FcnGetMemSecPkgForSubsystem(system)
            %assign msDefn = SLibGetInternalMemorySectionDefForName(memsecname, aSystemMemSecPkg)
            %switch preorpost
              %case "Pre"
                %openfile pragma
                %if !WHITE_SPACE(msDefn.Comment)
                    %<msDefn.Comment>
                %endif
                %if !WHITE_SPACE(msDefn.PrePragma)
                    %<SLibPragmaIdentifierRegexp(msDefn.PrePragma,  identifier)>
                %endif
                %closefile pragma
                %break
              %case "Post"
                %openfile pragma
                %if !WHITE_SPACE(msDefn.PostPragma)
                    %<SLibPragmaIdentifierRegexp(msDefn.PostPragma, identifier)>
                %endif
                %closefile pragma
                %break
              %default
                %<LibReportFatalError(...
                    "Invalid preorpost in function: SLibGetFcnMemSecPragmaForSystem")>
            %endswitch
            %return pragma
        %endif
    %endif
    %return ""
%endfunction


%% Function: SLibCreateDefinitionStatement
%% Abstract: Create a definition statement that places pragmas above
%%           and below if msDefn is defined
%%
%% TopTester: test/toolbox/simulink/variants/var-general/tVariantGecks2.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants3.m
%%
%function SLibCreateDefinitionStatement(definition, msInfo, qualifierInfo, ...
    identifier, includeQualifier, isDecl, isFirstElement, isLastElement, ppIf, ppEndIf) void
    %if isDecl
        %assign extern = "extern "
    %else
        %assign extern = ""
    %endif

    %assign qualifier = ""
    %if includeQualifier
        %if qualifierInfo.IsConst
            %assign qualifier = qualifier + "const "
        %endif
        %if qualifierInfo.IsVolatile
            %assign qualifier = qualifier + "volatile "
        %endif
        %if !ISEMPTY(qualifierInfo.Qualifier)
            %assign qualifier = qualifier + qualifierInfo.Qualifier + " "
        %endif
    %endif

    %if ISEMPTY(msInfo)
        %if ISEMPTY(definition)
            %return ppIf + "\n" + qualifier + definition + "\n" + ppEndIf
        %endif
        %return ppIf + "\n" + extern + qualifier + definition + "\n" + ppEndIf + "\n"

    %else
        %assign prepragma = ""
        %assign postpragma = ""
        %if(ISFIELD(msInfo, "PragmaPerVar") && msInfo.PragmaPerVar)
            %if !isDecl || (SLibIsPragmaOnDecls())
                %assign prepragma =  ...
                    SLibPragmaIdentifierRegexp(msInfo.PrePragma,  identifier)
                %assign postpragma = ...
                    SLibPragmaIdentifierRegexp(msInfo.PostPragma, identifier)
            %endif
        %else
            %if isFirstElement
                %assign prepragma = msInfo.PrePragma
            %endif
            %if isLastElement
                %assign postpragma = msInfo.PostPragma
            %endif
        %endif
        %openfile buffer
        %if !WHITE_SPACE(msInfo.Comment) && isFirstElement
            %<msInfo.Comment>
        %endif
        %if !WHITE_SPACE(prepragma)
            %<prepragma>
        %endif
        %if !WHITE_SPACE(ppIf)
            %<ppIf>
        %endif
        %<extern>%<qualifier>%<definition>
        %if !WHITE_SPACE(ppIf)
            %<ppEndIf>
        %endif

        %if !WHITE_SPACE(postpragma)
            %<postpragma>
        %endif
        %closefile buffer

        %return buffer
    %endif
%endfunction

%% Function: SLibBHMParamIsUsed ====================================================================
%% Abstract:
%%  Given a BHM block and a parameter index, return TLC_TRUE if it is
%%  used.
%%
%function SLibBHMParamIsUsed(block, paramIdx) void
    %assign mdlParamIdx = block.Parameter[paramIdx]._idx

    %if mdlParamIdx == -1
        %return TLC_FALSE
    %else
        %return TLC_TRUE
    %endif
%endfunction

%% Function: SLibGetBlockParamIdentifier ===========================================================
%% Abstract:
%%  Given a BHM block and a parameter index, return the alias (if any)
%%  or the name of the parameter if no alias exists.
%%
%function SLibGetBlockParamIdentifier(block, paramIdx) void
    %return SLibBHMParamGetIdentifier(block, paramIdx)
%endfunction %%SLibGetBlockParamIdentifier

%% Function: SLibBHMParamGetIdentifier =============================================================
%% Abstract:
%%  Given a BHM parameter record identified by a BHM block record and
%%  a parameter index, return the alias (if any) or the name of the
%%  parameter if no alias exists.
%%
%function SLibBHMParamGetIdentifier(block, paramIdx) void
    %assert SLibBHMParamIsUsed(block, paramIdx)

    %% Get the model parameter index
    %assign mdlParamIdx = block.Parameter[paramIdx]._idx

    %% Dereference the BHM parameter to the Model Parameter
    %assign mdlParam = ::CompiledModel.ModelParameters.Parameter[mdlParamIdx]

    %% Get the record identifier
    %assign paramIdentifier = LibGetRecordIdentifier(mdlParam)

    %% Return the record identifier
    %return paramIdentifier
%endfunction %%SLibBHMParamGetIdentifier

%% Function: SLibBHMParamIsGlobal ==================================================================
%% Abstract:
%%  Given a BHM parameter record identified by a BHM block record and
%%  parameter index, returns TLC_TRUE if it represents a parameter in the
%%  global scope. This function returns TLC_FALSE if it represents either a
%%  block parameter or a model-scoped parameter
%%
%function SLibBHMParamIsGlobal (block, paramIdx) void
    %assert SLibBHMParamIsUsed(block, paramIdx)
    %assign bhmParam = block.Parameter[paramIdx]
    %assign mdlParam = ::CompiledModel.ModelParameters.Parameter[bhmParam._idx]
    %if mdlParam.IsGlobal
        %return TLC_TRUE
    %else
        %return TLC_FALSE
    %endif
%endfunction %% SLibBHMParamIsGlobal

%% Function: SLibBHMParamIsInGMMModelParameters ====================================================
%% Abstract:
%%  Given a BHM parameter record identified by a BHM block record and
%%  a parameter index, returns TLC_TRUE if it represents a reference
%%  to a model parameter that appears in the ModelParameters record of
%%  the GlobalMemoryMap.
%%
%function SLibBHMParamIsInGMMModelParameters(block, paramIdx) void
    %assert SLibBHMParamIsUsed(block, paramIdx)
    %assign bhmParam = block.Parameter[paramIdx]
    %if bhmParam.IsReference
        %assign mdlParam = ::CompiledModel.ModelParameters.Parameter[bhmParam._idx]
        %if ISEQUAL(mdlParam.IsPseudoWorkspaceVar,"yes")
            %return TLC_FALSE
        %elseif mdlParam.GraphicalSource[0] == 0 && mdlParam.GraphicalSource[1] == -1
            %% Model arguments are not in GMM, they are identified by the
            %% unique graphical source [0,-1].
            %return TLC_FALSE
        %else
            %return TLC_TRUE
        %endif
    %else
        %return TLC_FALSE
    %endif
%endfunction %%SLibBHMParamIsInGMMModelParameters

%% Function: SLibBHMParamGetSource =================================================================
%% Abstract:
%%  Given a BHM parameter record identified by a BHM block record and
%%  parameter index, returns the BHM index of the block that owns
%%  this parameter.
%%
%%  1. If the parameter represents a referenced model parameter, this
%%     function returns [-1 -1].
%%  2. If the parameter represents a referenced model argument, this
%%     function returns [0 -1].
%%  3. If the parameter represents a referenced mask parameter, this
%%     function returns the BHM index of the block where the mask
%%     parameter is specified.
%%  4. If the parameter represents a block or mask parameter (not a
%%     reference), this function returns the BHM index of the
%%     block that was passed in.
%%
%function SLibBHMParamGetSource(block, paramIdx) void
    %assert SLibBHMParamIsUsed(block, paramIdx)
    %assign bhmParam = block.Parameter[paramIdx]
    %assign mdlParam = ::CompiledModel.ModelParameters.Parameter[bhmParam._idx]
    %return mdlParam.GraphicalSource
%endfunction %%SLibBHMParamGetSource

%% Function: SLibBHMParamIsUsedInTrivialExpression =================================================
%% Abstract:
%%  Given a BHM parameter record identified by a BHM block record and
%%  parameter index, returns TLC_TRUE if it represents a model or mask
%%  parameter referenced in a trivial block parameter expression.
%%  A trivial expression is an expression that only contains a MATLAB
%%  identifier or a reference to a single structure field, an array
%%  element, or a combination of the two.
%%
%%  For example, "MyVar", "MyStruct.FieldA.FieldB" and "MyStruct.FieldA(3)"
%%  are considered trivial expression, but "MyVar+1" and
%%  "sin(MyStruct.FieldA)" are not.
%%
%%  Specifically, this function returns TLC_TRUE in the following two
%%  cases:
%%    1. The BHM parameter record does not represent a reference.
%%    2. The BHM parameter record represents a model or mask parameter
%%       referenced in a trivial expression (that only consists of the
%%       name of the model parameter).
%%
%function SLibBHMParamIsUsedInTrivialExpression(block, paramIdx) void
    %assert SLibBHMParamIsUsed(block, paramIdx)
    %assign bhmParam = block.Parameter[paramIdx]
    %if bhmParam.IsUsedInTrivialExpr
        %return TLC_TRUE
    %else
        %return TLC_FALSE
    %endif
%endfunction %% SLibBHMParamIsUsedInTrivialExpression

%% Function: SLibBHMParamGetUsedElement ============================================================
%% Abstract:
%%  Given a BHM parameter record identified by a BHM block record and
%%  parameter index, returns a string representing the referenced element.
%%
%%  This function returns an empty string under any of the following
%%  conditions:
%%    1. The BHM parameter record does not represent a reference.
%%    2. The BHM parameter record represents a reference but the model
%%       or mask parameter being referenced is neither a structure nor
%%       an array.
%%
%function SLibBHMParamGetUsedElement(block, paramIdx) void
    %assert SLibBHMParamIsUsed(block, paramIdx)
    %assign bhmParam = block.Parameter[paramIdx]
    %return bhmParam.UsedElement
%endfunction %% SLibBHMParamGetUsedElement

%% Function: SLibBHMParamGetInitialValue ===========================================================
%% Abstract:
%%  Given a BHM parameter record identified by a BHM block record and
%%  parameter index, returns the initial value of this parameter.
%%
%%  The initial value is in string format following the C syntax for
%%  initializing variables.
%%
%function SLibBHMParamGetInitialValue(block, paramIdx) void
    %assert SLibBHMParamIsUsed(block, paramIdx)
    %assign mdlParamIdx = block.Parameter[paramIdx]._idx
    %assign mdlParam = ::CompiledModel.ModelParameters.Parameter[mdlParamIdx]
    %return LibParameterInstanceInitStr(mdlParam)
%endfunction %% SLibBHMParamGetInitialValue

%% Function: FcnGetMemorySectionAttribute ==========================================================
%% Abstract:
%%   Helper function for checking attributes of memory section for data group
%%   (such as "IsConst" and "IsVolatile".
%%
%% Interpretation of system:
%%   -1:        Root-level system (use memory sections from the ConfigSet)
%%   Otherwise: Standalone subsystem using data
%%
%% TopTester: test/toolbox/simulink/variants/var-general/tVariantGecks2.m
%%
%function FcnGetMemorySectionAttribute(system, memSecGroup, attribute) void

    %if TYPE(system) != "Scope"
        %assert(system == -1)
        %assign system = ::CompiledModel.CoderDictionary.DefaultMemorySections
    %endif

    %if SLibAreInternalMemorySectionsDefined()
        %assign memsecname = system.%<memSecGroup>
        %if TYPE(memsecname) != "String"
            %% New memory section
            %return memsecname.%<attribute>
        %elseif !ISEMPTY(memsecname) && (memsecname != "Default")
            %% Legacy Memory Section
            %assign aSystemMemSecPkg = FcnGetMemSecPkgForSubsystem(system)
            %assign msDefn = SLibGetInternalMemorySectionDefForName(memsecname, aSystemMemSecPkg)
            %return msDefn.%<attribute>
        %endif
    %endif

    %return TLC_FALSE
%endfunction

%% Function: SLibGetGlobalConstantMemorySectionHasVolatile =========================================
%% Abstract:
%%   This function returns true if memory sections are available for this build
%%   and the MemSecDataConstants property has the volatile qualifier selected.
%%
%function SLibGetGlobalConstantMemorySectionHasVolatile() void
    %return FcnGetMemorySectionAttribute(-1, "MemSecDataConstants", "IsVolatile")
%endfunction

%% Function: FcnGetQualifiersForData ===============================================================
%% Abstract:
%%   Return the qualifiers for general data structures (e.g., Block I/O)
%%   based on memory section specified in Configuration Parameters dialog.
%%
%% Interpretation of system:
%%   -1:        Root-level system (use memory sections from the ConfigSet)
%%   Otherwise: Standalone subsystem using data
%%
%% Interpretation of canBeConst:
%%   0: Cannot be const
%%   1: Can be const (but not required)
%%   2: Must be const
%%
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tmg1208119_SSwithZeroActiveVC_VC1.m
%%
%function FcnGetQualifiersForData(system, name, mstype, canBeConst) void
    %assign qualifiers = ""

    %if (canBeConst == 2) %% MUST BE CONST
        %assign qualifiers = "const "

    %elseif FcnGetMemorySectionAttribute(system, mstype, "IsConst")
        %% Memory section specifies that data should be constant

        %if (canBeConst == 1) %% CAN BE CONST
            %assign qualifiers = "const "

        %else %% CANNOT BE CONST
            %<SLibReportWarningWithIdAndArgs("RTW:tlc:CannotAddConstToData", name)>
        %endif
    %endif

    %if FcnGetMemorySectionAttribute(system, mstype, "IsVolatile")
        %assign qualifiers = qualifiers + "volatile "
    %endif

    %return qualifiers
%endfunction

%% Function: FcnGetQualifiersForConstantData =======================================================
%% Abstract:
%%   Wrapper around FcnGetQualifiersForData for constants.
%%
%function FcnGetQualifiersForConstantData(system, name) void
    %return FcnGetQualifiersForData(system, name, "MemSecDataConstants", 2)
%endfunction

%% Function: SLibGetGroundQualifiers ===============================================================
%% Abstract:
%%   Wrapper around FcnGetQualifiersForConstantData for data type grounds.
%%
%function SLibGetGroundQualifiers() void
    %return FcnGetQualifiersForConstantData(-1, "data type ground values")
%endfunction

%% Function: SLibGetConstParamQualifiers ===========================================================
%% Abstract:
%%   Wrapper around FcnGetQualifiersForConstantData for ConstP structure.
%%
%function SLibGetConstParamQualifiers() void
    %return FcnGetQualifiersForConstantData(-1, ::tConstParamStruct)
%endfunction

%% Function: SLibGetConstParamWithInitQualifiers ===================================================
%% Abstract:
%%   Wrapper around FcnGetQualifiersForData for ConstParamWithInit.
%%
%function SLibGetConstParamWithInitQualifiers() void
    %return FcnGetQualifiersForData(-1, ::tConstParamWithInitStruct, "MemSecDataConstants", 0)
%endfunction

%% Function: SLibGetConstBlockIOQualifiers =========================================================
%% Abstract:
%%   Return the qualifiers for ConstBlockIO structure.
%%
%% NOTE: If ConstBlockIO contains non-finite data then it cannot be const.
%%
%function SLibGetConstBlockIOQualifiers() void
    %if SLibCanConstBlockIOBeConst()
        %return FcnGetQualifiersForConstantData(-1, ::tConstBlockIOStruct)
    %else
        %return FcnGetQualifiersForData(-1, ::tConstBlockIOStruct, "MemSecDataConstants", 0)
    %endif
%endfunction

%% Function: SLibGetConstBlockIOForSystemQualifiers ================================================
%% Abstract:
%%   Return the qualifiers for ConstBlockIO structure of standalone subsystem.
%%
%% NOTE: If ConstBlockIO contains non-finite data then it cannot be const.
%%
%function SLibGetConstBlockIOForSystemQualifiers(system) void
    %if SLibCanConstBlockIOForSystemBeConst(system)
        %return FcnGetQualifiersForConstantData(system, ::tConstBlockIOStruct)
    %else
        %return FcnGetQualifiersForData(system, ::tConstBlockIOStruct, "MemSecDataConstants", 0)
    %endif
%endfunction

%% Function: SLibCanConstBlockIOBeConst ============================================================
%% Abstract:
%%   Return true if we can put the const qualifier on ConstBlockIO structure.
%%   We cannot do this if there is any non-finite initialization.
%%
%function SLibCanConstBlockIOBeConst() void
    %return ISEMPTY(::CompiledModel.NonFiniteBlockIOAssignmentsCache)
%endfunction

%% Function: SLibCanConstBlockIOForSystemBeConst ===================================================
%% Abstract:
%%   Return true if we can put the const qualifier on ConstBlockIO structure
%%   for standalone subsystem.
%%   We cannot do this if there is any non-finite initialization.
%%
%function SLibCanConstBlockIOForSystemBeConst(system) void
    %return ISEMPTY(LibGetSystemField(system, "CachedNonFiniteBlockIOAssignments"))
%endfunction

%% Function: LibCacheModelStructureInstance ========================================================
%% Abstract:
%%   This function creates the guts of each structure instance.  It should
%%   be called after all code is generated, and just prior to final model
%%   registration.
%% TopTester: test/toolbox/simulink/variants/var-general/tVariantGecks2.m
%%
%function LibCacheModelStructureInstance() void
    %<LibCacheBlockIOInstance()>
    %<LibCacheConstBlockIOInstance()>
    %<LibCacheExportedGlobalSignalsInstance()>
    %<LibCacheCustomReusableSignalsInstance()>
    %<LibCacheExportedGlobalDWorkInstance()>
    %<LibCacheContStatesInstance()>             %% may not be used
    %<LibCacheContStatesDisabledInstance()>     %% may not be used
    %<LibCachePeriodicContStatesInstance()>     %% may not be used
    %<LibCacheMassMatricesInstance()>           %% may not be used
    %<LibCacheCoderDataGroupInstance()>
    %if CodeFormat != "S-Function" || Accelerator
        %<LibCacheDWorkInstance()>
    %endif
    %<LibCachePrevZCStatesInstance()>
    %if !SLibAutosarActive()
        %if !SLibHasRootInportCoderGroup()
            %<LibCacheExternalInputsInstance()>
            %<LibCacheExternalInputSizesInstance()>
        %endif
        %if !SLibHasRootOutportCoderGroup()
            %<LibCacheExternalOutputsInstance()>
            %<LibCacheExternalOutputSizesInstance()>
        %endif
    %endif
%endfunction


%% Function FcnGenerateNonFiniteParamValue =====================================
%% Abstract:
%%   Generates the string for a non-finite parameter element initialization
%%   and places it in the non-finite assignment buffer.
%%
%%   Notes:
%%     Assumes block is in scope
%% TopTester: test/toolbox/simulink/coreblocks/lib_MathOperations/Product/rtw/tNumerics_dtprod3.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants2.m
%%
%function FcnGenerateNonFiniteParamValue(mdlParam, lvalue, ridx, cidx) void
    %assign dTypeId   = LibGetRecordContainerDataTypeId(mdlParam)
    %assign complex   = LibGetRecordIsComplex(mdlParam)

    %% Real Part
    %%
    %% parameter has already been included in rtP so we don't need
    %% to worry about that part of LibBlockMatrixParameter;  Also, that implies
    %% that the parameter must have storage class auto so we don't need to worry
    %% about that.
    %assign rval = ...
        SLibParameterValue(lvalue, dTypeId, complex, ridx,"%<tRealPart>%<cidx>")
    %assign nRows = SIZE(lvalue, 0)
    %assign nCols = SIZE(lvalue, 1)
    %assign indexStr = SLibGet2dArrayIndexer(0, nRows, "", "", ridx, ...
        nCols, "", "", cidx, !SLibIsContainerCGTypeND(mdlParam))

    %if (complex)
        %assign accessor = ".%<tRealPart>"
    %else
        %assign accessor = ""
    %endif
    %if mdlParam.StorageClass == "Custom"
        %openfile tmpStr
        %if mdlParam.CustomStorageClassVersion > 1
            %<LibAccessCustomData(mdlParam, "set", indexStr, accessor, rval)>
        %else
            %assign lhs = LibCustomData(mdlParam, "contents", indexStr, accessor)
            %<lhs> = %<rval>;
        %endif
        %closefile tmpStr
    %else
        %assign lhs = FcnAccessModelParameter(mdlParam, indexStr)
        %assign tmpStr = "%<lhs>%<accessor> = %<rval>;\n"
    %endif
    %assign vcRecord = SLibGetDataInlineVariantNetConditions(mdlParam)
    %assign ifCond = vcRecord.ifCond
    %assign ifEndCond = vcRecord.endIfCond
    %assign tmpStr = ifCond + "\n" + tmpStr + "\n" + ifEndCond + "\n"
    %assign tmpStr = SLibWrapVariantCondition(mdlParam, tmpStr)

    %<SLibCacheNonFiniteParamAssignment(mdlParam, tmpStr)>

    %% Imaginary Part

    %if complex

        %% parameter has already been included in rtP so we don't need
        %% to worry about that part of LibBlockMatrixParameter;  Also, that implies
        %% that the parameter must have storage class auto so we don't need to worry
        %% about that.
        %if mdlParam.StorageClass == "Custom"
            %openfile tmpStr
            %if mdlParam.CustomStorageClassVersion > 1
                %<LibAccessCustomData(mdlParam, "set", indexStr, tImagPart, ival)>
            %else
                %assign lhs = LibCustomData(mdlParam, "contents", indexStr, tImagPart)
                %<lhs> = %<ival>;
            %endif
            %closefile tmpStr
        %else
            %assign ival = ...
                SLibParameterValue(lvalue, dTypeId, complex, ridx,"%<tImagPart>%<cidx>")
            %assign tmpStr = "%<lhs>.%<tImagPart> = %<ival>;\n"
        %endif
        %<SLibCacheNonFiniteParamAssignment(mdlParam, tmpStr)>

    %endif

    %return 1
%endfunction %% FcnGenerateNonFiniteParamValue


%% Function: SLibGenMacroStrForModelPrm ============================================================
%% Abstract:
%%   Generate the macro string for an Model Parameter
%% TopTester: test/toolbox/simulink/blocks/lib_Sources/Ground/rtw/tStringSupport.m
%%
%function SLibGenMacroStrForModelPrm(mdlParam, indices, complex, reim, ...
    accessType) void

    %assign macroStr = ""
    %if complex
        %if reim == tRealPart
            %assign macroStr = "_RE"
        %elseif reim == tImagPart
            %assign macroStr = "_IM"
        %else
            %assign errTxt = "Unhandled case in SLibGenMacroStrForModelPrm"
            %<LibBlockReportFatalError([], errTxt)>
        %endif
    %else
        %assign macroStr = ""
    %endif

    %if SLibGetWidthOfValueFromParamRec(mdlParam) > 1
        %if accessType == "Vector"
            %assign pIdx   = indices[0]
            %assign macroStr = "_EL_%<pIdx>%<macroStr>"
        %else
            %assign rIdx = indices[0]
            %assign cIdx = indices[1]
            %assign macroStr = "_R_%<rIdx>_C_%<cIdx>%<macroStr>"
        %endif
    %endif

    %if ISFIELD(mdlParam,"TruncatedId")
        %assign macroStr = "%<mdlParam.TruncatedId>%<macroStr>"
    %else
        %assign remLength = ::CompiledModel.ConfigSet.MaxIdLength - SIZE(macroStr)[1]
        %assign identifier = tConstPrms + "_" + LibGetRecordIdentifier(mdlParam)
        %assign truncatedMdlPrm = LibRequestIDWithLength(identifier, TLC_TRUE, TLC_FALSE, remLength)
        %addtorecord mdlParam TruncatedId truncatedMdlPrm
        %assign macroStr = "%<truncatedMdlPrm>%<macroStr>"
    %endif
    %return macroStr
%endfunction %% SLibGenMacroStrForModelPrm

%% Function: FcnGetModelVectPrmVal =================================================================
%% Abstract:
%%   Get the indexed value of the specified vector model parameter
%%
%function FcnGetModelVectPrmVal(mdlParam, sigIndexer, pIdx, complex, reim, choiceIdx) void
    %return FcnGetVectPrmValueCore(mdlParam, sigIndexer, pIdx, complex, reim, 0, choiceIdx)
%endfunction



%% Function: FcnGetModelMatrixPrmVal ===============================================================
%% Abstract:
%%   Get the indexed value of the specified matrix model parameter
%%
%function FcnGetModelMatrixPrmVal(mdlParam, ridx, cidx, complex, reim) void
    %assign value = SLibGetValueFromParamRec(mdlParam, TLC_TRUE)
    %assign dtype = LibGetRecordContainerDataTypeId(mdlParam)
    %return FcnGetMatrixPrmValueCore(value, dtype, ridx, cidx, complex, reim, 0)
%endfunction



%% Function: SLibGenModelConstPrmMacroAccess =======================================================
%% Abstract:
%%   Generate an access based on the fact that a macro will be generated for
%%   the given model parameter
%% TopTester: test/toolbox/simulink/blocks/CPPCodeGen/tsmlk_core_cpp_coverage.m
%% TopTester: test/toolbox/simulink/blocks/lib_Sources/Ground/rtw/tStringSupport.m
%%
%function SLibGenModelConstPrmMacroAccess(mdlParam, sigIndexer, indices, ...
    complex, reim, accessType) void

    %if (SLibGenMacroForPrm(mdlParam) && !SLibCurrentlyGeneratingSharedFcn())
        %if accessType == "Matrix" && !ISFIELD(mdlParam, "MacroAccessAsMatrix")
            %addtorecord mdlParam MacroAccessAsMatrix 1
        %endif

        %if accessType == "Vector" && !ISFIELD(mdlParam, "MacroAccessAsVector")
            %addtorecord mdlParam MacroAccessAsVector 1
        %endif
        %assign retStr = SLibGenMacroStrForModelPrm(mdlParam, indices, complex, ...
            reim, accessType)
        %if ::CurrentFunctionIdx >= 0 && ::CurrentModuleIdx >= 0
            %assign sourceFile = SLibGetFullFileNameForSystemCode("sys_fcn_defn", ...
                SLibGetModuleFileNameOwnerSystemIdx(::CurrentModuleIdx))
            %<SLibUpdateLocalSymbolTableForFile(sourceFile, mdlParam.TruncatedId)>
        %endif
        %return retStr
    %else
        %% Get the value to inform code gen of non-finites. Throw away value for now
        %if accessType == "Matrix"
            %return FcnGetModelMatrixPrmVal(mdlParam, indices[0], ...
                indices[1], complex, reim)
        %else
            %return FcnGetModelVectPrmVal(mdlParam, sigIndexer, indices[0], ...
                complex, reim, 0)
        %endif
    %endif
%endfunction %% SLibGenModelConstPrmMacroAccess


%% Function: SLibGenConstRTPForPrm =================================================================
%% Abstract:
%%   Tells if a model parameter should be a const RTP
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%%
%function SLibGenConstRTPForPrm(mdlParam) void
    %if mdlParam.InConstSection
        %% we generate constRTP (#define) in some cases for parameters with Auto storage class
        %% and model parameter tunability is set to 'inlined'. VariantControls used in startup/runtime
        %% activation context is tunable
        %if SLibIsVariantControlWithRuntimeSemantic(mdlParam)
            %return TLC_TRUE
        %endif
        %assert (mdlParam.Tunable == "no")
        %assert (!mdlParam.InConstWithInitSection)
        %return TLC_TRUE
    %else
        %return TLC_FALSE
    %endif
%endfunction


%% Function: SLibGenConstPrmWithInit ===============================================================
%% Abstract:
%%   Tells if a model parameter should be a const RTP
%%
%function SLibGenConstPrmWithInit(mdlParam) void
    %if mdlParam.InConstWithInitSection
        %assert (mdlParam.Tunable == "no")
        %assert (!mdlParam.InConstSection)
        %return TLC_TRUE
    %else
        %return TLC_FALSE
    %endif
%endfunction

%% Function: FcnConstParamUnpooledAndAccessedOutsideSharedFcn
%% Abstract:
%%   Returns true under the following conditions:
%%   1. This constant value is accessed outside of a shared function, and
%%   2. The particular instance of this parameter is being accessed outside
%%      a shared function.
%%   Since we try to unpool constants within a model for readability purposes
%%   this function determines whether this particular instance of a constant
%%   is being accessed outside a shared function. If so, we could provide
%%   a macro definition for it.
%function FcnConstParamAccessedOutsideSharedFcn(mdlParam) void
    %assign firstInstanceParam = ::CompiledModel.ModelParameters.Parameter[mdlParam.FirstInstanceConstIdx]
    %if (!SLibConstParamReferencedOnlyBySharedFcn(firstInstanceParam) && ...
        SLibConstParamAccessedOutsideSharedFcn(mdlParam))
        %return TLC_TRUE
    %else
        %return TLC_FALSE
    %endif
%endfunction

%% Function: FcnParamAccessedBySharedFcn
%% Abstract:
%%   Returns whether a constant parameter is accessed by a
%%   shared function.
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function FcnConstParamAccessedBySharedFcn(mdlParam) void
    %% If the engine did not mark the parameter with a first-instance constant
    %% index, then it's not a shared constant (and not accessed by a shared
    %% function.
    %if !(ISFIELD(mdlParam, "FirstInstanceConstIdx"))
        %return TLC_FALSE
    %endif

    %% If it is a shared constant, check its RLS references. If it has any,
    %% then check if this particular instance is being accessed outside an RLS.
    %% If it is, then return true, because we're interested in the instance.
    %assign firstInstanceParam = ::CompiledModel.ModelParameters.Parameter[mdlParam.FirstInstanceConstIdx]
    %if (ISFIELD(firstInstanceParam, "RLSReferences") && ...
        SIZE(firstInstanceParam.RLSReferences, 1) > 0)
        %if FcnConstParamAccessedOutsideSharedFcn(mdlParam)
            %return TLC_FALSE
        %else
            %return TLC_TRUE
        %endif
    %else
        %return TLC_FALSE
    %endif
%endfunction


%% Function: SLibGenMacroForPrm ====================================================================
%% Abstract:
%%   Tells if a model parameter should have an associated macro
%%
%function SLibGenMacroForPrm(mdlParam) void
    %assign isStruct = LibIsStructDataType(LibGetDataTypeStorageIdFromId(LibGetRecordDataTypeId(mdlParam)))
    %assign refBySharedFcn = FcnConstParamAccessedBySharedFcn(mdlParam)
    %% Macro should be generated for inlined variant parameter
    %assign retVal = (SLibGenConstRTPForPrm(mdlParam) && ...
        InlinedPrmAccess == "Macros") && !isStruct && !refBySharedFcn || ...
        SLibIsVariantParameter(mdlParam)
    %return retVal
%endfunction

%% Function: SLibGnerateFormattedSymbolicValue =====================================================
%% Abstract:
%%      Returns the formatted initialization symbolic value with an optional
%%      comment for a given model parameter record
%% TopTester: test/toolbox/rtw/targets/AUTOSAR/Variants/dimensionVariants/tLUTCalParam.m
%%
%function SLibGnerateFormattedSymbolicValue(prmVal, vectorComment) Output
    %if !WHITE_SPACE(vectorComment)
        %assign vectorComment =  " /* %<vectorComment> */\n"
    %endif
    %assign nRows = SIZE(prmVal, 0)
    %assert (nRows == 1)
    %% This is a scalar value. Adds comments at the end.
    %if !ISEQUAL(TYPE(prmVal), "Vector")
        %<prmVal>%<vectorComment>\
        %return
    %endif
    %% This is a vector value. Adds comments at the beginning.
    %assign nCols = SIZE(prmVal, 1)
    %assert (nCols >= 1)
    %assign symVal = "{"
    %foreach colIdx = nCols
        %assign symVal = symVal + prmVal[colIdx]
        %if colIdx < nCols - 1
            %assign symVal = symVal + ", "
        %endif
    %endforeach
    %assign symVal = symVal + "}"
    %<vectorComment>
    %<symVal>\
%endfunction

%%Function: SLibGetFormattedPrmValueHelper ===========================================
%% Abstract: Helper function to return the formatted initialization value with an
%%      optional comment for a given model parameter record.
%%      This function takes in the model parameter choice index as argument
%%      For variant parameters, each choice can have a different value.
%%
%function SLibGetFormattedPrmValueHelper(mdlParam, vectorComment, choiceIdx) void

    %if CGMODEL_ACCESS("CGModel.IsLUTObjWithPointerFields", SLibGetModelParameterIndex(mdlParam))
        %return SLibLUTObjectWithSynthRTPsInit(mdlParam)
    %endif

    %assign dType = LibGetRecordContainerDataTypeId(mdlParam)
    %if LibIsStructWithSimulinkPointerDataType(dType)
        %return SLibLUTObjectWithoutSynthRTPsInit(mdlParam)
    %endif

    %assign prmVal  = SLibPrepParameterCore(mdlParam, TLC_TRUE)
    %assign mdlPrmValue = SLibGetValueFromParamRec(mdlParam, TLC_TRUE)
    %if SLibIsVariantParameter(mdlParam)
        %assign mdlPrmValue = SLibGetVariantParamValueForChoice(mdlParam, choiceIdx)
        %assign prmVal = SLibPrepParameterCoreFromValue(mdlParam, mdlPrmValue)
    %endif

    %openfile valueString
    %%
    %% generate parameters using built-in function
    %% for [1x1] or (1), use scalar
    %% for [1xn] or [nx1], use (n)
    %% perform fixups for boolean params
    %%
    %assign dTypeId = LibGetRecordDataTypeId(mdlParam)
    %if ISFIELD(mdlParam, "IsSymbolicValue")
        %assign mdlPrmExpression = GetValueExpressionFromParamRec(mdlParam)
        %if WHITE_SPACE(mdlPrmExpression)
            %<SLibGnerateFormattedSymbolicValue(prmVal, vectorComment)> \
        %else
            %if !WHITE_SPACE(vectorComment)
                %<vectorComment>
            %endif
            %<mdlPrmExpression>\
        %endif
        %%
    %elseif (ISSLDATAREF(mdlPrmValue) || ...
        LibIsHalfDataType(dTypeId) || ...
        LibIsBuiltInDataType(LibGetDataTypeStorageIdFromId(dTypeId)) && !LibIsEnumDataType(dTypeId))
        %% dataref parameter are handled internally by tlc compiler
        %assign prmNonFiniteIndices = GENERATE_FORMATTED_VALUE(prmVal, vectorComment, 0, ...
            SLibIsNdIndexingFeatureOn() || SLibIsContainerCGTypeND(mdlParam))
        %if !LibIsBuiltInDataType(LibGetDataTypeStorageIdFromId(dTypeId)) && ...
            !LibIsHalfDataType(dTypeId) && ...
            ISSLDATAREF(mdlPrmValue) && ...
            prmNonFiniteIndices[0][0] >= 0
            %assign longmsg ="\nNonfinite value in structure parameter %<mdlParam.Identifier> is not supported for code generation."\
            + " To proceed, you could either:\n" + "  (1) Reassign a finite value to any field whose value is Inf or NaN.\n"\
            + " or \n"\
            + "  (2) Add a dummy field of a cell array of a string to the structure parameter, for example, %<mdlParam.Identifier>.dummy = {'ForceInline'}."\
            + " However, this workaround disables tunability of this variable."
            %<LibReportError(longmsg)>
        %endif
        %if prmNonFiniteIndices[0][0] >= 0
            %% Nonfinite values used so indicate that nonfinite files need to be generated
            %assign retValUnused = %<CGMODEL_ACCESS("CGModel.nonfiniteSupportNeeded", TLC_TRUE)>
        %endif
        %if !SLibSupportNonfiniteLiterals() && (prmNonFiniteIndices[0][0] >= 0)
            %%
            %% Handle nonfinites:
            %%   defined only for Real or Real32
            %foreach idx = SIZE(prmNonFiniteIndices,0)
                %% Note that prmNonFiniteIndices is calculated on the prepped prmVal.  This
                %% prmVal may have a dimension stripped, e.g. if mdlPrmValue is 4x1 then
                %% prmVal is 1x4.  Thus down inside FcnGenerateNonFiniteParamValue we need to
                %% work with the prepped prmVal, or the indices in prmNonFiniteIndices may
                %% be invalid.  However, we still need to pass mdlParam to the function
                %% since we access other info in it, e.g. storage class.
                %assign ret = FcnGenerateNonFiniteParamValue(mdlParam, prmVal, ...
                    prmNonFiniteIndices[idx][0], prmNonFiniteIndices[idx][1])
            %endforeach
        %endif
    %else
        %assign storageTypeId =  LibGetRecordContainerDataTypeId(mdlParam)
        %if !WHITE_SPACE(vectorComment)
            %assign vectorComment = " /* %<vectorComment> */"
        %endif
        %assign width = LibGetRecordWidth(mdlParam)
        %%
        %if LibIsStringDataType(dTypeId)
            %%
            %% We need to add quotes for string literals
            %% String comes first because its width can be 1 or more
            %%
            %if !WHITE_SPACE(vectorComment)
                %<vectorComment>
            %endif
            %<prmVal>\
        %elseif width == 1
            %if LibIsNonBuiltInTypeNeededForFixpt(dTypeId)
                %if LibGetRecordIsComplex(mdlParam)
                    {%<FcnGetNonBuiltInRe(prmVal)>, %<FcnGetNonBuiltInIm(prmVal)>}
                %else
                    %% Fixpt biglong word(33+) is a string
                    %if !WHITE_SPACE(vectorComment)
                        %<vectorComment>
                    %endif
                    %<SLibGetFormattedValueFromId(storageTypeId, prmVal)>\
                %endif
            %elseif LibIsEnumDataType(dTypeId)
                %%
                %% Write out the enum string instead of the ordinal number
                %%
                %if !WHITE_SPACE(vectorComment)
                    %<vectorComment>
                %endif
                %if %<SLibParamIsVariantControlParamInVariantCondition(mdlParam)> == 1
                    %<SLibEnumeralPreprocessorSymbol(dTypeId, prmVal)>\
                %else
                    %<SLibGetEnumTypeCodeGenStringFromIndex(dTypeId, prmVal)>\
                %endif
            %else
                %% User-defined (custom) data type
                %% ==> Always initialize using ground value
                %if !WHITE_SPACE(vectorComment)
                    %<vectorComment>
                %endif
                %<LibGetGroundInitFromId(storageTypeId)>\
            %endif
        %else
            %assign nRows = SIZE(mdlPrmValue, 0)
            %assign nCols = SIZE(mdlPrmValue, 1)
            %assign isRM = %<CGMODEL_ACCESS("CGModel.IsRowMajor")>
            %assign isNd = SLibIsContainerCGTypeND(mdlParam) && ...
                nRows > 1 && nCols > 1 %% Truly nD
            %% For vector/matrix parameters, comment goes before initial values
            %if !WHITE_SPACE(vectorComment)
                %<vectorComment>
            %endif
            {\
                %if isRM
                    %% row major
                    %foreach row = nRows
                        %if row > 0
                            , \
                        %endif
                        %if isNd
                            {\
                        %endif
                        %foreach col = nCols
                            %if col > 0
                                , \
                            %endif
                            %<SLibEmitMatrixValue(mdlPrmValue, dTypeId, row, col, LibGetRecordIsComplex(mdlParam), storageTypeId)>\
                        %endforeach    %%col
                        %if isNd
                        }\
                        %endif
                    %endforeach  %%row
                %else
                    %% col major
                    %foreach col = nCols
                        %foreach row = nRows
                            %if col > 0 || row > 0
                                , \
                            %endif
                            %<SLibEmitMatrixValue(mdlPrmValue, dTypeId, row, col, LibGetRecordIsComplex(mdlParam), storageTypeId)>\
                        %endforeach  %%row
                    %endforeach    %%col
                %endif
            }\
        %endif
    %endif
    %closefile valueString

    %if SLibIsContainerCGTypeStdContainer(mdlParam) && ...
        ISEQUAL(TYPE(prmVal), "Vector") && ...
        (ISFIELD(mdlParam, "IsSymbolicValue") || SIZE(prmVal, 0) != 1 || SIZE(prmVal, 1) != 1)
        %% add an additional {} around std container, this is required when the base type is struct or complex type
        %return WHITE_SPACE(vectorComment) ? "{ " +  valueString + " }" : "{\n" +  valueString + "\n}\n"
    %else
        %return valueString
    %endif
%endfunction %% SLibGetFormattedPrmValueHelper


%% Function: SLibGetFormattedPrmValue ==============================================================
%% Abstract:
%%      Returns the formatted initialization value with an optional comment
%%      for a given model parameter record
%%
%% TopTester: test/toolbox/simulink/blocks/lib_LookupTables/LookupTable2D/rtw/tNumerics_rtw_look2.m
%% TopTester: test/toolbox/simulink/variants/var-general/tVariantGecks5.m
%% TopTester: test/toolbox/rtw/targets/AUTOSAR/Variants/dimensionVariants/tLUTCalParam.m
%% TopTester: test/toolbox/simulink/variants/var-general/tEnumVariants.m
%% TopTester: test/toolbox/simulink/variants/var-inline-general/tCSCDefine.m
%% TopTester: test/toolbox/simulink/blocks/lib_Sources/Ground/rtw/tStringSupport.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants2.m
%%
%function SLibGetFormattedPrmValue(mdlParam, vectorComment) void
    %if ISFIELD(mdlParam, "LUTObjectFieldValues")
        %<SLibCacheLUTPointerDataInitBuf(mdlParam)>
        %return SLibLUTObjectWithSynthRTPsInit(mdlParam)
    %endif

    %% For non-variant parameters, choice index is zero
    %assign choiceIdx = 0
    %assign prmFormattedValue = SLibGetFormattedPrmValueHelper(mdlParam, vectorComment, choiceIdx)
    %return prmFormattedValue
%endfunction %% SLibGetFormattedPrmValue

%% Function: LibParameterInstanceInitStr ===========================================================
%% Abstract:
%%   Generates the initialization string for a parameter instance
%%
%function LibParameterInstanceInitStr(mdlParam) void

    %assign comment = ""
    %assign initStr = SLibGetFormattedPrmValue(mdlParam, comment)
    %return initStr
%endfunction

%% Function: LibParameterInstanceInitStrPerChoice ==================================================
%% Abstract:
%%   Generates the initialization string for a variant parameter choice
%%
%function LibParameterInstanceInitStrPerChoice(mdlParamIdx, choiceIdx) void
    %assign mdlParam = ::CompiledModel.ModelParameters.Parameter[mdlParamIdx]
    %assign comment = ""
    %if SLibIsVariantParameter(mdlParam)
        %assign initStr = SLibGetFormattedPrmValueHelper(mdlParam, "", choiceIdx)
    %else
        %assign initStr = SLibGetFormattedPrmValue(mdlParam, comment)
    %endif

    %return initStr
%endfunction %%LibParameterInstanceInitStrPerChoice

%% Function: SLibCommentParameterInstances =========================================================
%% Abstract:
%%   Return whether or not to generate comments for parameter instances
%%
%function SLibCommentParameterInstances() void
    %assign comments = 0
    %if ::CompiledModel.ForceParamTrailComments || ...
        ::CompiledModel.NumBlockParams < 1000
        %assign comments = 1
    %endif
    %return comments
%endfunction

%% Function: LibCacheBlockIOInstance ===============================================================
%% Abstract:
%%   Caches the BlockIO instance.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/rtw/targets/AUTOSAR/Variants/tValueVariants.m
%%
%function LibCacheBlockIOInstance() void
    %if !IsModelReferenceTarget() && !LibBlockIOStructIsEmpty()
        %% there's definitely something in the BlockIO structure so instantiate it.
        %if SLibAutosarCompilerAbstractionRequired()
            %assign definition = "%<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, ::tBlockIOType, TLC_FALSE, TLC_FALSE, LibGetBlockIOStruct(), "DataGlobal")>;"
        %else
            %assign definition = "%<::tBlockIOType> %<LibGetBlockIOStruct()>;"
        %endif

        %openfile buffer
        %<SLibAddPreStructDeclarePragma(LibGetBlockIOStruct())>\
        %<SLibApplyMemSecToDataDefn(definition, "MemSecDataInternal", "%<LibGetBlockIOStruct()>")>\
        %<SLibAddPostStructDeclarePragma(LibGetBlockIOStruct())>\
        %closefile buffer

        %assign ::CompiledModel.BlockIOInstance = buffer
    %else
        %assign ::CompiledModel.BlockIOInstance = ""
    %endif
%endfunction  %% LibCacheBlockIOInstance

%% Function: FcnCheckForInitSrcModelRef ============================================================
%% Abstract:
%%   If the owner of a record initializes the data, but the source
%%   of the initial value is different, then error out (g2284700)
%%
%function FcnCheckForInitSrcModelRef(record, dataOwner)  void

    %% We are only interested in internal signals, not external inputs and
    %% external outputs
    %if (record.RecordType != "BlockOutput")
        %return
    %endif

    %% If data ownership is not enabled, don't bother
    %if (!SLibIsERTTarget() || ...
        (::CompiledModel.ConfigSet.EnableDataOwnership == TLC_FALSE))
        %return
    %endif

    %if (IsModelReferenceTarget())
        %if record.DrivesModelRefRootOutport == "yes"
            %return
        %endif
    %else
        %if (record.DrivesRootOutport == "yes")
            %return
        %endif
    %endif

    %% Don't bother if we can't figure out the source of the signal
    %if !ISFIELD(record,"SigSrc")
        %return
    %endif

    %assign sourceBlock = System[record.SigSrc[0]].Block[record.SigSrc[2]]

    %% If the signal source is not a model reference block, don't bother
    %if (sourceBlock.Type != "ModelReference")
        %return
    %endif

    %% If the source of the data's initial value is not the owner and
    %% neither is the current top model, error out, otherwise the owner
    %% will initialize the data to the wrong value.
    %assign currentModelName = LibGetModelName()
    %assign sourceModelName = sourceBlock.ParamSettings.ReferencedModelName
    %if ((currentModelName != dataOwner) && (sourceModelName != dataOwner))
        %assign errorArgs = ["%<record.Identifier>", "%<dataOwner>", "%<sourceModelName>", "%<currentModelName>"]
        %<SLibReportErrorWithIdAndArgs("Simulink:mpt:MPTOwnerIncorrectInitialization", errorArgs)>
    %endif

%endfunction


%% Function: SLibWriteOutInstForSignalRec ==========================================================
%% Abstract:
%%   Determine whether to write out instantiation code for a specific signal.
%%
%% For model reference, we do not write out instantiation code for
%% data that are instantiated by the top model:
%% - root-level inputs/outputs
%% - variable size information for root inputs/outputs
%% - global data store memory
%%
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%% TopTester: test/toolbox/simulink/variants/var-general/tVariantGecks6.m
%%
%function SLibWriteOutInstForSignalRec(record, forDataInitialization) void
    %assign retVal = TLC_FALSE

    %% Check assumptions
    %assign rootSystem = ::CompiledModel.System[NumSystems-1]
    %assign reqInsts = LibGetSystemField(rootSystem,"ReqRootPrmHdrDataInsts")
    %assign isSignal = ((record.RecordType == "BlockOutput") ...
        || (record.RecordType == "ExternalInput") ...
        || (record.RecordType == "ExternalOutput")...
        || (record.RecordType == "ZcSignalInfo"))
    %assign isDWork  = (record.RecordType == "DWork")
    %assert((reqInsts.ExpGlobalSigsInst  && isSignal) || ...
        (reqInsts.ExpGlobalDworkInst && isDWork))

    %% If Owner is specified, honor it when we are instantiating data
    %% not initializing it.
    %if ((SLibIsERTTarget()) && ...
        (::CompiledModel.ConfigSet.EnableDataOwnership == TLC_TRUE) && ...
        (record.StorageClass == "Custom"))
        %assign cscDefn   = SLibGetCSCDefForData(record)
        %assign props     = LibGetCustomStorageAttributes(record)
        %assign dataOwner = LibGetInstanceSpecificProp(cscDefn, props, "Owner")
        %if !ISEMPTY(dataOwner)
            %if (forDataInitialization)
                %<FcnCheckForInitSrcModelRef(record,dataOwner)>
            %endif
            %return dataOwner == LibGetModelName()
        %endif
    %endif
    %if (IsModelReferenceTarget())
        %% Skip data that are instantiated by the top model:
        %% - root-level inputs/outputs
        %% - variable size information for root inputs/outputs
        %% - global data store memory
        %% unless this is introduced by the usage of a reusable CSC signal
        %switch (record.RecordType)
          %case "ZcSignalInfo"
            %assign retVal = TLC_TRUE
            %break
          %case "ExternalInput"
            %if SLibIsAuxBufferForReusableCSC(record)
                %assign retVal = TLC_TRUE
            %else
                %assign retVal = TLC_FALSE
            %endif
            %break
          %case "BlockOutput"
            %if SLibIsAuxBufferForReusableCSC(record)
                %assign retVal = TLC_TRUE
            %else
                %assign retVal = (record.DrivesModelRefRootOutport == "no")
            %endif
            %break
          %case "DWork"
            %if SLibIsAuxBufferForReusableCSC(record)
                %assign retVal = TLC_TRUE
            %else
                %assign retVal = (!record.GlobalDSM && ...
                    !record.DrivesModelRefRootOutportSize && ...
                    !record.ModelRefRootInportSize)
            %endif
            %break
          %default
            %assert TLC_FALSE  %% unhandled case
            %break
        %endswitch
    %else
        %assign retVal = TLC_TRUE
    %endif

    %return retVal

%endfunction

%% Function: LibGlobalDefinitionWithAlignment ======================================================
%% Abstract:
%%   Generate a definition with alignment directive positioned at the right place.
%function LibGlobalDefinitionWithAlignment(plainDef, comment, align) void
    %openfile buf
    %switch(globalDAFlag.position)
      %case "DATA_ALIGNMENT_PRECEDING_STATEMENT"
        %<align>
        %<plainDef> %<comment>
        %break
      %case "DATA_ALIGNMENT_FOLLOWING_STATEMENT"
        %<plainDef> %<comment>
        %<align>
        %break
      %case "DATA_ALIGNMENT_PREDIRECTIVE"
        %<align> %<plainDef> %<comment>
        %break
      %case "DATA_ALIGNMENT_POSTDIRECTIVE"
        %<plainDef> %<align> %<comment>
        %break
      %default
        %assert TLC_FALSE  %% unhandled case
        %break
    %endswitch
    %closefile buf
    %return buf
%endfunction

%% Function: LibCacheExportedGlobalSignalsInstance =================================================
%% Abstract:
%%   Caches the exported global signals.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%%
%function LibCacheExportedGlobalSignalsInstance() void
    %if ::CompiledModel.NumExportedGlobalSignals > 0
        %assign sourceFileName = SLibGetFileNameForCode("mdl_data_defn") + "." + ::LangFileExt
        %openfile buffer
        %% root inports
        %if (ExternalInputs.NumExportedGlobalSignals > 0)
            %foreach idx = ExternalInputs.NumExternalInputs
                %assign ei = ExternalInputs.ExternalInput[idx]
                %if ((ei.StorageClass == "ExportedGlobal") && ...
                    (SLibWriteOutInstForSignalRec(ei, TLC_FALSE)) && !ISFIELD(ei,"Inactive"))
                    %assign descStr = SLibGetDescriptionForData(ei)
                    %assign descStr = WHITE_SPACE(descStr) ? "" : "\n* " + descStr + "\n"
                    %%
                    %assign comment  = "/* '%<ei.BlockName>'%<descStr> */"
                    %assign dataType = SLibGetRecordContainerOptStdTypeName(ei, TLC_TRUE)
                    %assign optDims = LibGetRecordVectorDims(ei)
                    %assign id = LibGetRecordIdentifier(ei)
                    %assign vcRecord = SLibGetDataInlineVariantNetConditions(ei)
                    %assign ifCond = vcRecord.ifCond
                    %assign ifEndCond = vcRecord.endIfCond

                    %assign traceMarker = SLibAddBlockTrace(ei.BlockName)
                    %<SLibTraceBegin(traceMarker)>
                    %if SLibAutosarCompilerAbstractionRequired()
                        %assign definition = ...
                            "%<ei.StorageTypeQualifier> %<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, dataType, TLC_FALSE, "%<id>%<optDims>", "DataGlobal")>;"
                    %else
                        %assign definition = ...
                            "%<ei.StorageTypeQualifier> %<dataType> %<id>%<optDims>;"
                    %endif
                    %if(ei.Alignment > 0 && !LibCGTypeIsComplex(ei.CGTypeIdx))
                        %assign align = SLibGetAlignmentSyntax(::CompiledModel.Name, id, dataType, ...
                            ei.Alignment, "DATA_ALIGNMENT_GLOBAL_VAR")
                        %<ifCond>
                        %<LibGlobalDefinitionWithAlignment(definition, comment, align)>
                        %<ifEndCond>
                    %else
                        %<ifCond>
                        %<definition> %<comment>
                        %<ifEndCond>
                    %endif
                    %<SLibTraceEnd(traceMarker)>
                    %<SLibUpdateLocalSymbolTableForFile(sourceFileName, id)>
                %endif
            %endforeach
        %endif
        %% root outports
        %if (ExternalOutputs.NumExportedGlobalSignals > 0)
            %foreach idx = ExternalOutputs.NumExternalOutputs
                %assign eo = ExternalOutputs.ExternalOutput[idx]
                %if ((eo.StorageClass == "ExportedGlobal") && (SLibWriteOutInstForSignalRec(eo, TLC_FALSE)) && !ISFIELD(eo,"Inactive"))
                    %assign descStr = SLibGetDescriptionForData(eo)
                    %assign descStr = WHITE_SPACE(descStr) ? "" : "\n* " + descStr + "\n"
                    %%
                    %assign comment  = "/* '%<eo.BlockName>'%<descStr> */"
                    %assign dataType = SLibGetRecordContainerOptStdTypeName(eo, TLC_TRUE)
                    %assign optDims = LibGetRecordVectorDims(eo)
                    %assign id = LibGetRecordIdentifier(eo)
                    %assign TypeQualifier = eo.Object.ObjectProperties.CoderInfo.Object.ObjectProperties.TypeQualifier


                    %assign traceMarker = SLibAddBlockTrace(eo.BlockName)
                    %<SLibTraceBegin(traceMarker)>
                    %assign vcRecord = SLibGetDataInlineVariantNetConditions(eo)
                    %assign ifCond = vcRecord.ifCond
                    %assign ifEndCond = vcRecord.endIfCond

                    %if SLibAutosarCompilerAbstractionRequired()
                        %assign definition = ...
                            "%<TypeQualifier> %<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, dataType, TLC_FALSE, "%<id>%<optDims>", "DataGlobal")>;"
                    %else
                        %assign definition = ...
                            "%<TypeQualifier> %<dataType> %<id>%<optDims>;"
                    %endif
                    %if(eo.Alignment > 0 && !LibCGTypeIsComplex(eo.CGTypeIdx))
                        %assign align = SLibGetAlignmentSyntax(::CompiledModel.Name, id, dataType, ...
                            eo.Alignment, "DATA_ALIGNMENT_GLOBAL_VAR")

                        %<ifCond>
                        %<LibGlobalDefinitionWithAlignment(definition, comment, align)>
                        %<ifEndCond>
                    %else
                        %<ifCond>
                        %<definition> %<comment>
                        %<ifEndCond>
                    %endif
                    %<SLibTraceEnd(traceMarker)>
                    %<SLibUpdateLocalSymbolTableForFile(sourceFileName, id)>
                %endif
            %endforeach
        %endif
        %% block io
        %if BlockOutputs.NumExportedGlobalSignals > 0
            %foreach boIdx = BlockOutputs.NumExternalBlockOutputs
                %assign bo = BlockOutputs.ExternalBlockOutput[boIdx]
                %% - Write out instantiation lines for ExportedGlobal signals.
                %% - Exclude those signals that drive model reference root outports
                %%   because memory for these will be allocated by the top model.
                %if ((bo.StorageClass == "ExportedGlobal") && ...
                    (SLibWriteOutInstForSignalRec(bo, TLC_FALSE)))
                    %assign id = LibGetRecordIdentifier(bo)
                    %with bo
                        %assert !ISEMPTY(SigSrc)
                        %assign blkName = SLibReferencedBy(bo)
                        %%
                        %assign descStr = SLibGetDescriptionForData(bo)
                        %assign descStr = WHITE_SPACE(descStr) ? "" : "\n* " + descStr + "\n"
                        %%
                        %assign comment  = "/* %<blkName>%<descStr> */"
                        %assign dataType = SLibGetRecordContainerOptStdTypeName(bo, TLC_TRUE)
                        %assign optDims = LibGetRecordVectorDims(bo)

                        %assign traceMarker = SLibAddBlockTrace(blkName)
                        %<SLibTraceBegin(traceMarker)>
                        %if SLibAutosarCompilerAbstractionRequired()
                            %assign definition = ...
                                " %<bo.StorageTypeQualifier> %<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, dataType, TLC_FALSE, TLC_FALSE, "%<id>%<optDims>", "DataGlobal")>;"
                        %else
                            %assign definition = ...
                                "%<bo.StorageTypeQualifier> %<dataType> %<id>%<optDims>;"
                        %endif

                        %assign vcRecord = SLibGetDataInlineVariantNetConditions(bo)
                        %assign ifCond = vcRecord.ifCond
                        %assign ifEndCond = vcRecord.endIfCond
                        %<ifCond>
                        %if(bo.Alignment > 0 && !LibCGTypeIsComplex(bo.CGTypeIdx))
                            %assign align = SLibGetAlignmentSyntax(::CompiledModel.Name, bo.Identifier, dataType, ...
                                bo.Alignment, "DATA_ALIGNMENT_GLOBAL_VAR")
                            %<LibGlobalDefinitionWithAlignment(definition, comment, align)>
                        %else
                            %<definition> %<comment>
                        %endif
                        %<SLibTraceEnd(traceMarker)>
                        %<ifEndCond>
                        %<SLibUpdateLocalSymbolTableForFile(sourceFileName, id)>
                    %endwith
                %endif
            %endforeach
        %endif
        %closefile buffer
        %assign ::CompiledModel.ExportedGlobalSignalsInstance = buffer
    %else
        %assign ::CompiledModel.ExportedGlobalSignalsInstance = ""
    %endif
%endfunction  %% LibCacheExportedGlobalSignalsInstance

%% Function: LibCacheCustomReusableSignalsInstance =================================================
%% Abstract:
%%   Caches the (1) Reusable CSC or
%%              (2) AutoSar or
%%              (3) FPC signal.
%% TopTester: test/toolbox/simulink/variants/var-simulinkfcns/tAutoInherit.m
%%
%function LibCacheCustomReusableSignalsInstance() void
    %if ::CompiledModel.NumInPlaceOPTSignals > 0 || ...
        ::CompiledModel.NumCustomDWork > 0
        %assign sourceFileName = SLibGetFileNameForCode("mdl_data_defn") + "." + ::LangFileExt
        %openfile buffer
        %% root inports
        %if (ExternalInputs.NumInPlaceOPTSignals > 0)
            %foreach idx = ExternalInputs.NumExternalInputs
                %assign ei = ExternalInputs.ExternalInput[idx]
                %if (SLibIsAuxBufferForReusableCSCOrAutoSarOrFPC(ei) && ...
                    SLibWriteOutInstForSignalRec(ei, TLC_FALSE))
                    %assign descStr = SLibGetDescriptionForData(ei)
                    %assign descStr = WHITE_SPACE(descStr) ? "" : "\n* " + descStr + "\n"
                    %%
                    %assign comment  = "/* '%<ei.BlockName>'%<descStr> */"
                    %assign optWidth = LibGetRecordVectorDims(ei)
                    %% ReuseBufferName is the identifier
                    %assign id = ei.ReuseBufferName
                    %assign identifier = ei.Identifier

                    %assign useStdContainerName = TLC_FALSE
                    %if !ISEMPTY(optWidth) && SLibIsContainerCGTypeStdContainer(ei)
                        %assign optWidth = ""
                        %assign useStdContainerName = TLC_TRUE
                    %endif

                    %assign dataType = SLibGetRecordContainerOptStdTypeName(ei, useStdContainerName)

                    %if SLibAutosarCompilerAbstractionRequired()
                        %assign definition = ...
                            "%<ei.StorageTypeQualifier> %<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, dataType, TLC_FALSE, TLC_FALSE, "%<id>%<optWidth>", "DataGlobal")>;"
                    %else
                        %assign definition = ...
                            "%<ei.StorageTypeQualifier> %<dataType> %<id>%<optWidth>;"
                    %endif
                    %if ISFIELD(ei, "AutosarPRPortVarIdx")
                        %assign commentForExtraGlobal = "/* Global variable introduced due to SenderReceiver mapping */"
                    %else
                        %assign commentForExtraGlobal = "/* Reusable CSC signals \n * Global signal due to the usage of Reusable CSC signal: %<identifier> */"
                    %endif
                    %<commentForExtraGlobal>
                    %if(ei.Alignment > 0 && !LibCGTypeIsComplex(ei.CGTypeIdx))
                        %assign align = SLibGetAlignmentSyntax(::CompiledModel.Name, id, dataType, ...
                            ei.Alignment, "DATA_ALIGNMENT_GLOBAL_VAR")
                        %<LibGlobalDefinitionWithAlignment(definition, comment, align)>
                    %else
                        %<definition> %<comment>
                    %endif
                    %<SLibUpdateLocalSymbolTableForFile(sourceFileName, id)>
                %endif
            %endforeach
        %endif
        %% root outports
        %foreach idx = ExternalOutputs.NumExternalOutputs
            %assign ei = ExternalOutputs.ExternalOutput[idx]
            %if (SLibIsAuxBufferForAutoSarOrFPC(ei) && ...
                SLibWriteOutInstForSignalRec(ei, TLC_FALSE))
                %assign descStr = SLibGetDescriptionForData(ei)
                %assign descStr = WHITE_SPACE(descStr) ? "" : "\n* " + descStr + "\n"
                %%
                %assign comment  = "/* '%<ei.BlockName>'%<descStr> */"
                %assign optWidth = LibOptionalVectorWidth(LibGetRecordWidth(ei))
                %% ReuseBufferName is the identifier
                %assign id = ei.ReuseBufferName
                %assign identifier = ei.Identifier

                %assign useStdContainerName = TLC_FALSE
                %if !ISEMPTY(optWidth) && SLibIsContainerCGTypeStdContainer(ei)
                    %assign optWidth = ""
                    %assign useStdContainerName = TLC_TRUE
                %endif

                %assign dataType = SLibGetRecordContainerOptStdTypeName(ei, useStdContainerName)

                %if SLibAutosarCompilerAbstractionRequired()
                    %assign definition = ...
                        "%<ei.StorageTypeQualifier> %<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, dataType, TLC_FALSE, TLC_FALSE, "%<id>%<optWidth>", "DataGlobal")>;"
                %else
                    %assign definition = ...
                        "%<ei.StorageTypeQualifier> %<dataType> %<id>%<optWidth>;"
                %endif
                %assign commentForExtraGlobal = "/* Global variable introduced due to SenderReceiver mapping */"
                %<commentForExtraGlobal>
                %if(ei.Alignment > 0 && !LibCGTypeIsComplex(ei.CGTypeIdx))
                    %assign align = SLibGetAlignmentSyntax(::CompiledModel.Name, id, dataType, ...
                        ei.Alignment, "DATA_ALIGNMENT_GLOBAL_VAR")
                    %<LibGlobalDefinitionWithAlignment(definition, comment, align)>
                %else
                    %<definition> %<comment>
                %endif
                %<SLibUpdateLocalSymbolTableForFile(sourceFileName, id)>
            %endif
        %endforeach
        %% block io
        %if BlockOutputs.NumInPlaceOPTSignals > 0
            %foreach boIdx = BlockOutputs.NumExternalBlockOutputs
                %assign bo = BlockOutputs.ExternalBlockOutput[boIdx]
                %% - Write out instantiation lines for ExportedGlobal signals.
                %% - Exclude those signals that drive model reference root outports
                %%   because memory for these will be allocated by the top model.
                %if (SLibIsAuxBufferForReusableCSCOrAutoSarOrFPC(bo) && ...
                    (SLibWriteOutInstForSignalRec(bo, TLC_FALSE)))
                    %% ReuseBufferName is the identifier
                    %assign id = bo.ReuseBufferName
                    %assign identifier = bo.Identifier
                    %with bo
                        %assert !ISEMPTY(SigSrc)
                        %assign blkName = SLibReferencedBy(bo)
                        %%
                        %assign descStr = SLibGetDescriptionForData(bo)
                        %assign descStr = WHITE_SPACE(descStr) ? "" : "\n* " + descStr + "\n"
                        %%
                        %assign comment  = "/* %<blkName>%<descStr> */"
                        %assign optWidth = LibGetRecordVectorDims(bo)

                        %assign useStdContainerName = TLC_FALSE
                        %if !ISEMPTY(optWidth) && SLibIsContainerCGTypeStdContainer(bo)
                            %assign optWidth = ""
                            %assign useStdContainerName = TLC_TRUE
                        %endif

                        %assign dataType = SLibGetRecordContainerOptStdTypeName(bo, useStdContainerName)

                        %if SLibAutosarCompilerAbstractionRequired()
                            %assign definition = ...
                                " %<bo.StorageTypeQualifier> %<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, dataType, TLC_FALSE, TLC_FALSE, "%<id>%<optWidth>", "DataGlobal")>;"
                        %else
                            %assign definition = ...
                                "%<bo.StorageTypeQualifier> %<dataType> %<id>%<optWidth>;"
                        %endif
                        %if ISFIELD(bo, "AutosarPRPortVarIdx")
                            %assign commentForExtraGlobal = "/* Global variable introduced due to SenderReceiver mapping */"
                        %else
                            %assign commentForExtraGlobal = "/* Reusable CSC signals \n * Global signal due to the usage of Reusable CSC signal: %<identifier> */"
                        %endif
                        %% Ensure that additional buffers inserted for reusable cscs have corresponding guarding
                        %%TopTester: matlab/test/toolbox/simulink/variants/var-global-dataguarding/tReusableSignalsAndStates.m -testspec:TestPoint_mReusableGlobalBuffer
                        %assign vcRecord = SLibGetDataInlineVariantNetConditions(bo)
                        %assign ifCond = vcRecord.ifCond
                        %assign ifEndCond = vcRecord.endIfCond
                        %<ifCond>
                        %<commentForExtraGlobal>
                        %if(bo.Alignment > 0 && !LibCGTypeIsComplex(bo.CGTypeIdx))
                            %assign align = SLibGetAlignmentSyntax(::CompiledModel.Name, bo.Identifier, dataType, ...
                                bo.Alignment, "DATA_ALIGNMENT_GLOBAL_VAR")
                            %<LibGlobalDefinitionWithAlignment(definition, comment, align)>
                        %else
                            %<definition> %<comment>
                        %endif
                        %<ifEndCond>
                        %<SLibUpdateLocalSymbolTableForFile(sourceFileName, id)>
                    %endwith
                %endif
            %endforeach
        %endif
        %% dwork
        %if ::CompiledModel.NumCustomDWork > 0
            %foreach idx = ::CompiledModel.DWorks.NumDWorks
                %assign dw = ::CompiledModel.DWorks.DWork[idx]
                %if (SLibIsAuxBufferForReusableCSCOrAutoSarOrFPC(dw) && ...
                    SLibWriteOutInstForSignalRec(dw, TLC_FALSE))
                    %assign commentForExtraGlobal = "/* Reusable CSC signals \n * Global signal due to the usage of Reusable CSC signal: %<dw.Identifier> */"
                    %<commentForExtraGlobal>
                    %assign tempid = dw.Identifier
                    %assign dw.Identifier = dw.ReuseBufferName
                    %<FcnGenerateBlockDWorkExternalDeclaration(dw)>\
                    %<SLibUpdateLocalSymbolTableForFile(sourceFileName, LibGetRecordIdentifier(dw))>
                    %assign dw.Identifier = tempid
                %endif
            %endforeach
        %endif
        %closefile buffer
        %assign ::CompiledModel.CustomReusableSignalsInstance = buffer
    %else
        %assign ::CompiledModel.CustomReusableSignalsInstance = ""
    %endif
%endfunction  %% LibCacheCustomReusableSignalsInstance


%% Function: FcnGenerateBlockDWorkExternalDeclaration ==============================================
%% Abstract:
%%   Generate the declaration of an external dwork for a block
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants2.m
%%
%function FcnGenerateBlockDWorkExternalDeclaration(dwRec) Output
    %with dwRec
        %%
        %assign descStr = SLibGetDescriptionForData(dwRec)
        %assign descStr = WHITE_SPACE(descStr) ? "" : "\n* " + descStr + "\n"
        %%
        %assign comment = "/* " + SLibReferencedBy(dwRec) + descStr + " */"
        %if LibHasCustomStorage(dwRec) && ...
            (!SLibGetIsReusable(dwRec) ||  ...
            !ISFIELD(dwRec, "ReuseBufferName"))
            %<LibReportError("Custom dwork should be defined elsewhere")>
        %else
            %assign dataType = SLibGetRecordContainerOptStdTypeName(dwRec, TLC_TRUE)
            %assign star = (dwRec.StorageClass == "ImportedExternPointer") ? ...
                "*" : ""
            %assign optDims = (dwRec.StorageClass == "ImportedExternPointer") ? ...
                "" : LibGetRecordVectorDims(dwRec)
            %assign typeQualifier = dwRec.StorageTypeQualifier
            %assign id = LibGetRecordIdentifier(dwRec)
            %assign initStr = ""
            %if dwRec.SharedLocalDSMForHasBeenInit
                %assign initStr = " = " + GET_TYPE_ID_REPLACEMENT("false")
            %endif
            %if SLibAutosarCompilerAbstractionRequired()
                %assign definition = ...
                    "%<typeQualifier> %<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, dataType, (dwRec.StorageClass == "ImportedExternPointer"), TLC_FALSE, "%<id>%<optDims>", "DataGlobal")>; "
            %else
                %assign definition = ...
                    "%<typeQualifier> %<dataType> %<star>%<id>%<optDims>%<initStr>; "
            %endif
            %assign definition = LibGetCppBracedInitStr(definition)
            %assign vcRecord = SLibGetDataInlineVariantNetConditions(dwRec)
            %assign ifCond = vcRecord.ifCond
            %assign ifEndCond = vcRecord.endIfCond
            %%TopTester: matlab/test/toolbox/simulink/variants/var-global-dataguarding/tExportedGlobalStates.m -testspec:TestPoint_StatesInVSS
            %<ifCond>
            %assign blockTraceMarker = ""
            %if CGMODEL_ACCESS("CGModel.getDataDefinitionTraceIsEnabled") && SLibGraphicalBlockExist(dwRec)
                %assign blockTraceMarker = SLibAddBlockTrace("%<SLibGrBlockName(dwRec.GrSrc)>")
                %<SLibTraceBegin(blockTraceMarker)>
            %endif
            %if dwRec.Alignment > 0 && !LibCGTypeIsComplex(dwRec.CGTypeIdx)
                %assign align = SLibGetAlignmentSyntax(::CompiledModel.Name, id, dataType, ...
                    dwRec.Alignment, "DATA_ALIGNMENT_GLOBAL_VAR")
                %<LibGlobalDefinitionWithAlignment(definition, comment, align)>
            %else
                %<definition> %<comment>
            %endif
            %<SLibTraceEnd(blockTraceMarker)>
            %<ifEndCond>
        %endif
    %endwith
%endfunction


%% Function: LibCacheExportedGlobalDWorkInstance ===================================================
%% Abstract:
%%   Caches the exported global DWork.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants2.m
%%
%function LibCacheExportedGlobalDWorkInstance() void
    %if ::CompiledModel.NumExportedGlobalDWork > 0
        %assign numDWorks = ::CompiledModel.DWorks.NumDWorks
        %assign sourceFileName = SLibGetFileNameForCode("mdl_data_defn") + "." + ::LangFileExt
        %%
        %openfile buffer
        %foreach dwIdx = numDWorks
            %selectfile buffer
            %assign dwRec = ::CompiledModel.DWorks.DWork[dwIdx]
            %% For model reference target, we do not write out instantiation code for
            %% global DSM and dwork size of VarDims root outport.
            %if ((dwRec.StorageClass == "ExportedGlobal") && ...
                SLibWriteOutInstForSignalRec(dwRec, TLC_FALSE))
                %<FcnGenerateBlockDWorkExternalDeclaration(dwRec)>\
                %<SLibUpdateLocalSymbolTableForFile(sourceFileName, LibGetRecordIdentifier(dwRec))>
            %endif
        %endforeach
        %closefile buffer
        %assign ::CompiledModel.ExportedGlobalDWorkInstance = buffer
    %else
        %assign ::CompiledModel.ExportedGlobalDWorkInstance = ""
    %endif
%endfunction  %% LibCacheExportedGlobalDWorkInstance

%% Function: LocalFcnGetNonFiniteFcnCall ===========================================================
%% Abstract:
%%   Get the function call to return the value corresponding to the
%%   given nonFinite value.
%%
%function LocalFcnGetNonFiniteFcnCall(nonFiniteVal,bo, aCategory) void
    %assert !ISFINITE(nonFiniteVal)
    %assign dTypeId    = SLibGetRecordDataTypeId(bo)
    %assign dtId       = LibGetDataTypeIdAliasedThruToFromId(dTypeId)
    %assign isSingle   = (DataTypes.DataType[dtId].DTName == "single")
    %% Half value is already formatted. There is no equivalent library call like single/double
    %if LibIsHalfDataType(dTypeId)
        %return nonFiniteVal
    %endif
    %assign sourceFile = SLibGetVarGroupInstDefinitionFile(aCategory)
    %assign includeHdr = !SLibIsCompactFileFormat() || ::CompiledModel.GenUtilsSrcInSharedLocation == 1

    %if ISNAN(nonFiniteVal)
        %if !isSingle
            %assign callInfo = SLibGenOneInputOneOutputFcnCallInfo("getNaN",tSS_VOID,tSS_DOUBLE,"")
            %if includeHdr && ISEMPTY(callInfo.HeaderFile)
                %% use the default header file if not compact file packaging
                %<SLibUpdateHeadersNeededByFile(sourceFile, "rtGetNaN.h")>
            %endif
        %else
            %assign callInfo = SLibGenOneInputOneOutputFcnCallInfo("getNaN",tSS_VOID,tSS_SINGLE,"")
            %if includeHdr && ISEMPTY(callInfo.HeaderFile)
                %<SLibUpdateHeadersNeededByFile(sourceFile, "rtGetNaNF.h")>
            %endif
        %endif
    %elseif ISINF(nonFiniteVal) && nonFiniteVal > 0
        %if !isSingle
            %assign callInfo = SLibGenOneInputOneOutputFcnCallInfo("getInf",tSS_VOID,tSS_DOUBLE,"")
            %if includeHdr && ISEMPTY(callInfo.HeaderFile)
                %<SLibUpdateHeadersNeededByFile(sourceFile, "rtGetInf.h")>
            %endif
        %else
            %assign callInfo = SLibGenOneInputOneOutputFcnCallInfo("getInf",tSS_VOID,tSS_SINGLE,"")
            %if includeHdr && ISEMPTY(callInfo.HeaderFile)
                %<SLibUpdateHeadersNeededByFile(sourceFile, "rtGetInfF.h")>
            %endif
        %endif
    %elseif ISINF(nonFiniteVal) && nonFiniteVal < 0
        %if !isSingle
            %assign callInfo = SLibGenOneInputOneOutputFcnCallInfo("getMinusInf",tSS_VOID,tSS_DOUBLE,"")
            %if includeHdr && ISEMPTY(callInfo.HeaderFile)
                %<SLibUpdateHeadersNeededByFile(sourceFile, "rtGetMinusInf.h")>
            %endif
        %else
            %assign callInfo = SLibGenOneInputOneOutputFcnCallInfo("getMinusInf",tSS_VOID,tSS_SINGLE,"")
            %if includeHdr && ISEMPTY(callInfo.HeaderFile)
                %<SLibUpdateHeadersNeededByFile(sourceFile, "rtGetMinusInfF.h")>
            %endif
        %endif
    %else
        %assert TLC_FALSE
    %endif

    %return callInfo.Expr

%endfunction %% LocalFcnGetNonFiniteFcnCall


%% Function: FcnGetCPPConstBlockIOInitValues =======================================================
%% Abstract:
%%   Special handling is needed for creating initial values for non-finite
%%   numbers when the target langauge is C++.
%% TopTester: test/toolbox/simulink/blocks/CPPCodeGen/tsmlk_core_cpp_coverage.m
%%
%function FcnGetCPPConstBlockIOInitValues(bo,initValues, aCategory) void
    %assert ::GenCPP
    %assign sigWidth = LibGetRecordWidth(bo)
    %assign complex = LibGetRecordIsComplex(bo)
    %assign numEles = SIZE(initValues,1)
    %assign comma = ","
    %openfile initBuf
    %if sigWidth > 1
        {
    %endif

    %foreach ind = numEles
        %assign ele = initValues[ind]
        %if TYPE(ele) == "String" || ISFINITE(ele)
            %if TYPE(ele) != "String"
                %assign dummyVal = GENERATE_FORMATTED_VALUE(ele,"", 0, ...
                    SLibIsNdIndexingFeatureOn())
            %else
                %<ele>
            %endif
            %if sigWidth > 1 && ind < (numEles-1)
                %<comma>
            %endif
        %else
            %% Is Non-finite number

            %if complex
                {
                    %assign rval = REAL(ele)
                    %assign ival = IMAG(ele)

                    %if TYPE(rval) != "String" && !ISFINITE(rval)
                        %assign rinitval = LocalFcnGetNonFiniteFcnCall(rval,bo, aCategory)
                        %<rinitval>,
                    %else
                        %if TYPE(rval) != "String"
                            %assign dummyVal = GENERATE_FORMATTED_VALUE(rval,"", 0, ...
                                SLibIsNdIndexingFeatureOn())
                        %else
                            %<ele>
                        %endif
                        %<comma>
                    %endif

                    %if TYPE(ival) != "String" && !ISFINITE(ival)
                        %assign iinitval = LocalFcnGetNonFiniteFcnCall(ival,bo, aCategory)
                        %<iinitval>
                    %else
                        %if TYPE(ival) != "String"
                            %assign dummyVal = GENERATE_FORMATTED_VALUE(ival,"", 0, ...
                                SLibIsNdIndexingFeatureOn())
                        %else
                            %<ival>
                        %endif

                    %endif
                }
            %else
                %assign initval = LocalFcnGetNonFiniteFcnCall(ele,bo, aCategory)
                %<initval>
            %endif

            %if sigWidth > 1 && ind < (numEles-1)
                %<comma>
            %endif
        %endif
    %endforeach

    %if sigWidth > 1
    }
    %endif
    %closefile initBuf

    %return initBuf

%endfunction %% FcnGetCPPConstBlockIOInitValues


%% Function: FcnGenerateNonFiniteConstBlockIOValue =================================================
%% Abstract:
%%   Generates the string for a non-finite Const Block IO element initialization
%%   and places it in the non-finite assignment buffer.
%% TopTester: test/toolbox/simulink/coreblocks/lib_MathOperations/Gain/rtw/tNumerics_Gainblk_blas_misc.m
%%
%function FcnGenerateNonFiniteConstBlockIOValue(bo, rowidx, colidx) void
    %assign value = bo.InitialValue
    %assign nCols = SIZE(value, 1)
    %assign complex = LibGetRecordIsComplex(bo)

    %if bo.DoNotConstify == 0
        %assign bo.DoNotConstify = 1
    %endif

    %if (TYPE(value) == "Vector" && nCols > 1)
        %assign value = value[colidx]
    %elseif (TYPE(value) == "Vector")
        %assign value = value[0]
    %else
        %% Scalar or Matrix type for initial values are not supported
        %assert TLC_FALSE
    %endif

    %assign dTypeId    = SLibGetRecordDataTypeId(bo)
    %assign baseSysIdx = GetBaseSystemIdx()
    %assign varGroupIdx  = bo.VarGroupIdx[0]
    %assign varGroup    = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
    %assign sysIdx      = varGroup.SysIdx
    %assign instanceIdx = varGroup.InstanceIdx
    %assign identiPath =  SLibCGIRVarGroupPath(varGroupIdx,baseSysIdx,TLC_FALSE)

    %if LibGetRecordWidth(bo) > 1
        %assign sigIndexer = ...
            SLibGet1DArrayIndexer(LibGetRecordWidth(bo), "", "",  colidx)
    %else
        %assign sigIndexer = ""
    %endif
    %%TopTester: test/toolbox/simulink/variants/var-global-dataguarding/tConstBlockIO.m -testspec:TestPoint_mCBIOWithNonFinites
    %assign vcRecord = SLibGetDataInlineVariantNetConditions(bo)
    %assign ifCond = vcRecord.ifCond
    %assign endIfCond = vcRecord.endIfCond

    %if complex
        %assign rval        = REAL(value)
        %assign ival        = IMAG(value)
        %if !ISFINITE(rval)
            %assign str = identiPath + LibGetRecordIdentifier(bo) + sigIndexer + "." + tRealPart
            %assign str = str + " = %<rval>;\n"
            %assign str = ifCond + "\n" + str + "\n" + endIfCond + "\n"
            %if !::GenCPP
                %<SLibCacheNonFiniteConstBIOAssignment(sysIdx, instanceIdx, str)>\
            %endif
            %<LibNeedRealNonFinite(rval)>\
        %endif
        %if !ISFINITE(ival)
            %assign str = identiPath + LibGetRecordIdentifier(bo) + sigIndexer + "." + tImagPart
            %assign str = str + " = %<ival>;\n"
            %assign str = ifCond + "\n" + str + "\n" + endIfCond + "\n"
            %if !::GenCPP
                %<SLibCacheNonFiniteConstBIOAssignment(sysIdx, instanceIdx, str)>\
            %endif
            %<LibNeedRealNonFinite(ival)>\
        %endif
    %else
        %assign str = identiPath + LibGetRecordIdentifier(bo) + sigIndexer
        %assign str = str + " = %<value>;\n"
        %assign str = ifCond + "\n" + str + "\n" + endIfCond + "\n"
        %if !::GenCPP
            %<SLibCacheNonFiniteConstBIOAssignment(sysIdx, instanceIdx, str)>\
        %endif
        %<LibNeedRealNonFinite(value)>\
    %endif
%endfunction %% FcnGenerateNonFiniteConstBlockIOValue

%% Function: SLibGetConstBlockOutputValue ==========================================================
%% Abstract:
%%   Returns the initialization value for a constant block output.
%% TopTester: test/toolbox/simulink/blocks/CPPCodeGen/tsmlk_core_cpp_coverage.m
%% TopTester: test/toolbox/simulink/blocks/lib_Sources/Ground/rtw/tStringSupport.m
%%
%function SLibGetConstBlockOutputValue(aConstBlockOutput, aCategory) void
    %assign   isComplex = LibGetRecordIsComplex(aConstBlockOutput)
    %assign    sigWidth = LibGetRecordWidth(aConstBlockOutput)
    %assign      boBuff = ""
    %openfile boBuff
    %with aConstBlockOutput
        %assign initValues = ISEMPTY(InitialValue) ...
            ? CustomInitialValue : InitialValue
        %assign initWidth = SIZE(initValues,1)
        %assign dtypeIdx = LibCGTypeToSLType(CGTypeIdx)
        %% Need to check for string values first
        %% The following check for fixpt types does not tell the difference
        %% Also, width does not make a difference for string data
        %if LibIsStringDataType(dtypeIdx)
            %<initValues> \
        %elseif sigWidth > 1
            %% built-in function GENERATE_FORMATTED_VALUE had been extended
            %% to support 33+ fixpt types
            %if !ISSLDATAREF(initValues) ...
                && ISEQUAL(TYPE(initValues[0]),"String")
                { \
                    %% Handle strings outside of GENERATE_FORMATTED_VALUE:
                    %%   o Scalar expansion of initValues is supported
                    %%   o Nonfinite initialization is not supported
                    %foreach idx = sigWidth
                        %assign suffix = (idx == sigWidth-1) ? "" : ","
                        %assign initIdx = (initWidth == 1) ? 0 : idx
                        %% multiword complex 1+2i is in the format of
                        %% " {0x1UL, 0x0UL} + {0x2UL, 0x0UL} i"
                        %assign initRe = FcnGetNonBuiltInRe(initValues[initIdx])
                        %assign initIm = FcnGetNonBuiltInIm(initValues[initIdx])
                        %if isComplex && ISSUBSTRING(initValues[initIdx],"i")
                            %assign initValue = "{%<initRe>, %<initIm>}"
                        %else
                            %assign initValue = initRe
                        %endif
                        %<initValue>%<suffix> \
                    %endforeach
                } \
            %elseif LibIsEnumDataType(dtypeIdx)
                %%
                %% Write out the enum string instead of the underlying number
                %%
                { \
                    %foreach idx = sigWidth
                        %assign suffix = (idx == sigWidth-1) ? "" : ","
                        %<SLibGetEnumTypeCodeGenStringFromValue(dtypeIdx, initValues[idx])>%<suffix> \
                    %endforeach
                } \
            %elseif LibDataTypeIsBus(dtypeIdx)
                { \
                    %foreach idx = sigWidth
                        %assign suffix = (idx == sigWidth-1) ? "" : ","
                        %assign initStr = "{%<initValues[idx]>}"
                        %<initStr>%<suffix> \
                    %endforeach
                } \
            %else
                %% Support SigWidth == initWidth
                %% (scalar expanding not supported)
                %assert initWidth > 1
                %openfile tempBuf
                %if SLibIsNdIndexingFeatureOn()
                    %assign cBIONonFiniteIndices = ...
                        GENERATE_FORMATTED_VALUE(initValues,"", 0)
                %else
                    %assign cBIONonFiniteIndices = ...
                        GENERATE_FORMATTED_VALUE(initValues,"")
                %endif
                %closefile tempBuf
                %if !::GenCPP || (isComplex && ISEQUAL(TYPE(initValues[0]),"String"))
                    %<tempBuf> \
                    %undef tempBuf
                %else
                    %% Special handling of nonFinite number initialization
                    %% for C++ target language
                    %assign initCPP = ...
                        FcnGetCPPConstBlockIOInitValues(aConstBlockOutput, initValues, aCategory)
                    %<initCPP> \
                %endif
                %if !SLibSupportNonfiniteLiterals() && (cBIONonFiniteIndices[0][0] >= 0)
                    %% Handle nonfinites for Real or Real32
                    %foreach idx = SIZE(cBIONonFiniteIndices,0)
                        %<FcnGenerateNonFiniteConstBlockIOValue(aConstBlockOutput,...
                            cBIONonFiniteIndices[idx][0],cBIONonFiniteIndices[idx][1])> \
                    %endforeach
                %endif
            %endif
        %else
            %% Single element Vector
            %if !ISSLDATAREF(initValues) && ...
                ISEQUAL(TYPE(initValues[0]),"String")
                %assign initValue = initValues[0]
                %% multiword complex 1+2i is in the format of " {0x1UL, 0x0UL} + {0x2UL, 0x0UL} i"
                %assign initRe = FcnGetNonBuiltInRe(initValue)
                %assign initIm = FcnGetNonBuiltInIm(initValue)
                %if isComplex && ISSUBSTRING(initValue,"i")
                    %assign initStr = "{%<initRe>, %<initIm>}"
                %else
                    %assign initStr = initRe
                %endif
                %<initStr> \
            %elseif LibIsEnumDataType(dtypeIdx)
                %%
                %% Write out the enum string instead of the underlying number
                %%
                %<SLibGetEnumTypeCodeGenStringFromValue(dtypeIdx, initValues[0])> \
            %elseif LibDataTypeIsBus(dtypeIdx)
                %assign initStr = "{%<initValues[0]>}"
                %<initStr> \
            %else
                %openfile tempBuf
                %if SLibIsNdIndexingFeatureOn()
                    %if LibDataTypeIsBoolean(dtypeIdx) && initValues[0] == 0
                        %assign cBIONonFiniteIndices = ...
                            GENERATE_FORMATTED_VALUE(TLC_FALSE,"",0)
                    %elseif LibDataTypeIsBoolean(dtypeIdx) && initValues[0] == 1
                        %assign cBIONonFiniteIndices = ...
                            GENERATE_FORMATTED_VALUE(TLC_TRUE,"",0)
                    %else
                        %assign cBIONonFiniteIndices = ...
                            GENERATE_FORMATTED_VALUE(initValues[0],"",0)
                    %endif
                %else
                    %if LibDataTypeIsBoolean(dtypeIdx) && initValues[0] == 0
                        %assign cBIONonFiniteIndices = ...
                            GENERATE_FORMATTED_VALUE(TLC_FALSE,"")
                    %elseif LibDataTypeIsBoolean(dtypeIdx) && initValues[0] == 1
                        %assign cBIONonFiniteIndices = ...
                            GENERATE_FORMATTED_VALUE(TLC_TRUE,"")
                    %else
                        %assign cBIONonFiniteIndices = ...
                            GENERATE_FORMATTED_VALUE(initValues[0],"")
                    %endif
                %endif
                %closefile tempBuf
                %if !::GenCPP
                    %<tempBuf> \
                    %undef tempBuf
                %else
                    %% Special handling of nonFinite number initialization
                    %% for C++ target language
                    %assign initCPP = ...
                        FcnGetCPPConstBlockIOInitValues(aConstBlockOutput, initValues, aCategory)
                    %<initCPP> \
                %endif
                %if !SLibSupportNonfiniteLiterals() && (cBIONonFiniteIndices[0][0] >= 0)
                    %% Handle nonfinites for Real or Real32
                    %<FcnGenerateNonFiniteConstBlockIOValue(aConstBlockOutput,...
                        cBIONonFiniteIndices[0][0],cBIONonFiniteIndices[0][1])> \
                %endif
            %endif
        %endif
    %endwith %% aConstBlockOutput
    %closefile boBuff
    %if SLibIsContainerCGTypeStdContainer(aConstBlockOutput)
        %% add an additional {} around std container, this is required when the base type is struct or complex type
        %return "{ " + boBuff + "\n}"
    %else
        %return boBuff
    %endif
%endfunction %% SLibGetConstBlockOutputValue



%% Function: SLibGetStandAloneInitName =============================================================
%% Abstract:
%%   Returns the standalone system init section for a given vargroup.
%%
%function SLibGetStandAloneInitName(aVargroupIdx) void
    %assign aVarGroupCategory = LibGetVarGroupCategory(aVargroupIdx)

    %switch aVarGroupCategory
      %case "Parameter"
      %case "ConstParameter"
      %case "ConstParameterWithInit"
        %return "StandaloneParameterInit"
      %case "ConstBlockIO"
        %return "StandaloneConstBlockIOInit"
      %default
        %break
    %endswitch
    %return "StandaloneDataInit"
%endfunction %% SLibGetStandAloneInitName


%% Function: SLibGetVarGroupInitComma ==============================================================
%% Abstract:
%%   Returns the comma value for a given var group initialization
%%
%function SLibGetVarGroupInitComma(varGroupName, hasAnyElement) void
    %assign res = ""

    %% If we're not sure that an element has been defined, we need to
    %% let the preprocessor include the comma only if necessary
    %if !hasAnyElement
        %assign res = SLibWrapDefinedHasElement(varGroupName, ",")

        %% If we know there's a preveious element, we need a comma
    %else
        %assign res = ",\n"

    %endif

    %return res
%endfunction %% SLibGetVarGroupInitComma

%% Function: FcnGetDynamicDataInitFromCGType =======================================================
%% Abstract:
%%   Returns the initialization for dynamic data from the cgTypeIdx
%%
%function FcnGetDynamicDataInitFromCGType(cgTypeIdx) void
    %assign value = ""
    %if SLibEmitRecordInCoderDataGroupStruct(cgTypeIdx)
        %if LibCGTypeIsChar(cgTypeIdx)
            %assign groundValue = "'a'"
            %assign cmplx = TLC_FALSE
        %else
            %assign dtypeId = LibCGTypeToSLType(cgTypeIdx)
            %assign groundValue = SLibGetGroundValueFromId(dtypeId)
            %assign cmplx = LibCGTypeIsComplex(cgTypeIdx)
        %endif
        %% Symbolic dimensions are not supported for static initializers of elements
        %assert !ISFIELD(::CompiledModel.CGTypes.CGType[cgTypeIdx], "SymbolicWidth")

        %% Create the non-guarded body of the initialization
        %assign value = SLibExpandGroundForStaticInit(STRING(LibCGTypeWidth(cgTypeIdx)), ...
            TLC_FALSE, cmplx, groundValue)
    %endif
    %return value
%endfunction

%% Function: SLibGetDynamicDataInit ================================================================
%% Abstract:
%%   Returns the initialization for dynamic data, like Dwork, BlockIO, or ZCEvent
%%
%function SLibGetDynamicDataInit(recType, recIdx, loopData, structExplode, initVect) void
    %assign res = ""
    %assign dataRec = SLibGetDataRecForVarGroupMember(recType, recIdx)
    %assign cgTypeIdx = LibGetRecordCGTypeIdx(dataRec)
    %if SLibEmitRecordInCoderDataGroupStruct(cgTypeIdx) && ...
        (recType != "ZE" || dataRec.NeedsEvent || Accelerator)
        %% Create the non-guarded body of the initialization
        %assign value = FcnGetDynamicDataInitFromCGType(cgTypeIdx)
        %if structExplode
            %assign initVect.data = initVect.data + value
        %endif
        %openfile body
        %<value>
        %if loopData.insertComma
            ,
        %endif
        %% see g1453062
        %assign loopData.hasUnconditionalElement = loopData.hasUnconditionalElement || !SLibHasVariantCondition(dataRec)
        %%assign loopData.hasUnconditionalElement = TLC_TRUE
        %if !loopData.hasUnconditionalElement && loopData.needsrtunused
            %<loopData.defineHasElement>
        %endif

        %closefile body

        %% Guard the body, if needed
        %% see g1453062
        %assign dataBody = SLibWrapVariantCondition(dataRec, body)

        %openfile res
        %%<dataBody>
        %closefile res
        %assign loopData.numElements = loopData.numElements + 1
    %endif
    %return res
%endfunction

%% Function: SLibGetRTMInit ========================================================================
%% Abstract:
%%   Returns the initialization for an element of RTM
%%
%function SLibGetRTMInit(aVarGroupIdx, recIdx, loopData, structExplode, initVect) void
    %assign res = ""
    %assign rtmVarGroup = ::CompiledModel.VarGroups.VarGroup[aVarGroupIdx]
    %assign elemCGTypeIdx = SLibVarGroupElementType(aVarGroupIdx, recIdx)

    %assign value = FcnGetDynamicDataInitFromCGType(elemCGTypeIdx)
    %if structExplode
        %assign initVect.data = initVect.data + value
    %endif
    %assign comma = loopData.insertComma ? ",\n" : ""

    %assign loopData.hasUnconditionalElement = TLC_TRUE
    %assign loopData.numElements = loopData.numElements + 1
    %return "%<value>" + comma
%endfunction

%% Function: SLibGetConstBlockOutputInit ===========================================================
%% Abstract:
%%   Returns the initialization for a given const block output
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants3.m
%% TopTester: test/toolbox/simulink/variants/var-global-dataguarding/tConstBlockIO.m
%%
%function SLibGetConstBlockOutputInit(cboIdx, loopData, structExplode, initVect, aCategory) void
    %assign res = ""

    %assign bo = ::CompiledModel.BlockOutputs.ConstBlockOutput[cboIdx]
    %%
    %% If padder is active, all fields are forced to be in the
    %% const prm structure. This is because the padding
    %% has already been computed in Simulink assuming that all
    %% fields are going to be in the structure.
    %%
    %if bo.RequiredInConstBlockIO == 1 || ::CompiledModel.PadderActive
        %assign value = SLibGetConstBlockOutputValue(bo, aCategory)
        %if structExplode
            %assign initVect.data = initVect.data + value
        %endif
        %openfile body
        %assign bodyContent = value
        %if loopData.insertComma
            %assign bodyContent = bodyContent + ","
        %endif

        %if GenerateComments
            %assign blkComment = SLibGrBlockCommentName(bo.GrSrc)
            %if !ISEMPTY(blkComment)
                %assign bodyContent = bodyContent + "/* %<blkComment> */"
            %endif
        %endif
        %<bodyContent>
        %assign loopData.hasUnconditionalElement = loopData.hasUnconditionalElement || !SLibHasVariantCondition(bo)
        %if !loopData.hasUnconditionalElement && loopData.needsrtunused
            %<loopData.defineHasElement>
        %endif
        %closefile body
        %assign res = SLibWrapVariantCondition(bo, body)
        %assign loopData.numElements = loopData.numElements + 1
    %endif %% bo.RequiredInConstBlockIO

    %return res
%endfunction %% SLibGetConstBlockOutputInit


%% Function: SLibGetParameterInit ==================================================================
%% Abstract:
%%   Returns the initialization for a given parameter
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants3.m
%% TopTester: test/toolbox/rtw/targets/AUTOSAR/Variants/inlineVariants/tInlineVariants13.m
%%
%function SLibGetParameterInit(parameterIdx, loopData, structExplode, initVect) void
    %assign res = ""

    %assign prm = ::CompiledModel.ModelParameters.Parameter[parameterIdx]

    %assert !SLibIsParamUnstructured(prm)

    %% Parameters can store multiple values
    %%   Get the current value
    %if (SLibGetWidthOfValueFromParamRec(prm) > 0) && !SLibOmitRecord(prm)
        %assign prmWidth = LibGetRecordWidth(prm)
        %% If we're doing struct explosion, the comment will need to be added later
        %if SLibCommentParameterInstances() && !structExplode
            %assign comment = SLibGenModelPrmDefnComment(prm)
        %else
            %assign comment = ""
        %endif

        %% Create the value wrapped in preprocessor conditionals for variant parameters
        %if loopData.perChoice
            %assign value = SLibGetParameterInitValueForChoice(prm, prmWidth, parameterIdx, comment, loopData.choiceIdx)
        %else
            %assign value = SLibGetParameterInitValueWithVariantCondition(prm, prmWidth, parameterIdx, comment)
        %endif

        %if structExplode
            %assign initVect.data = initVect.data + value
        %endif
        %assign body = ""
        %openfile body
        %if prmWidth == 1 && !WHITE_SPACE(comment)
            /* %<comment> */
        %endif
        %<value> \
        %if loopData.insertComma
            , \
        %endif

        %% see g1453062
        %assign loopData.hasUnconditionalElement = loopData.hasUnconditionalElement || !SLibHasVariantCondition(prm)
        %%assign loopData.hasUnconditionalElement = TLC_TRUE
        %if !loopData.hasUnconditionalElement && loopData.needsrtunused
            %<loopData.defineHasElement>
        %endif
        %closefile body
        %% Guard the body, if needed
        %% see g1453062
        %assign res = SLibWrapVariantCondition(prm, body) %% parameter body
        %assign loopData.numElements = loopData.numElements + prmWidth
    %endif

    %% Parameters can store multiple values.
    %%   This increments the internal counter so that we examine each value in turn
    %assign numPrmValues = SLibGetNumModelParameterValues(prm)
    %if numPrmValues > 0
        %assign prm.ValueAccessIdx = prm.ValueAccessIdx + 1
        %if prm.ValueAccessIdx == numPrmValues
            %assign prm.ValueAccessIdx = 0
        %endif
    %endif

    %return res
%endfunction %% SLibGetParameterInit


%% Function: SLibGetPaddingInit ====================================================================
%% Abstract:
%%   Returns the initialization for a given padding
%% TopTester: test/toolbox/simulink/coreblocks/lib_MathOperations/Gain/rtw/tGainblk_blas_misc.m
%%
%function SLibGetPaddingInit(paddingIdx, loopData, structExplode, initVect) void
    %assign padInit = "{"
    %foreach loopIdx = paddingIdx
        %assign padInit = padInit + "'a'"
        %if loopIdx != paddingIdx - 1
            %assign padInit = padInit + ","
        %endif
    %endforeach
    %assign padInit = padInit +"}"

    %if structExplode
        %assign initVect.data = initVect.data + padInit
    %endif

    %if loopData.insertComma
        %return padInit + ","
    %endif

    %return padInit
%endfunction %% SLibGetPaddingInit

%function SLibGetVargroupElementInit(varGroupIdx, startComment, inlineResult) void
    %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
    %assign elementInit = inlineResult
    %if LibCGTypeIsMatrix(varGroup.CGTypeIdx)
        %assign numValueSets = LibCGTypeWidth(varGroup.CGTypeIdx)
        %assign element = "{ " + inlineResult + " } "
        %assign elementInit = element
        %foreach valueIdx = numValueSets-1
            %assign elementInit = elementInit + ",\n" + element
        %endforeach
    %endif
    %return startComment + " { " + elementInit + " }\n"
%endfunction

%% Function: SLibGetSubVarGroupInitValue ===========================================================
%% Abstract:
%%   Returns the initialization for a given subsystem vargroup
%%
%function SLibGetSubsystemVarGroupInitValue(subsystemVargroupIdx, loopData, structExplode, initVect, aCategory) void
    %% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tmParameterStructure.m
    %% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants2.m
    %assign res = ""
    %assign subVarGroup = ::CompiledModel.VarGroups.VarGroup[subsystemVargroupIdx]

    %assign childSystem = ::CompiledModel.System[subVarGroup.SysIdx]
    %assign rootSystem = ::CompiledModel.System[NumSystems-1]
    %if childSystem != rootSystem
        %assign cs = childSystem.CallSites[subVarGroup.InstanceIdx]
        %assign blk = ::CompiledModel.System[cs[2]].Block[cs[3]]
        %% check that the vargroup represents a valid subsystem
        %assert blk.Type == "SubSystem"
    %else
        %createrecord blk {}
    %endif
    %assert 0 == childSystem.StandaloneSubsystem

    %% get the initialization for the sub-vargroup
    %assign inlineRes = SLibGetVarGroupInitValue(subsystemVargroupIdx, aCategory)

    %% if the initialization isn't empty
    %if inlineRes[1] > 0

        %% Get the preprocessor conditionals for variant subsystems

        %if ISEMPTY(blk)
            %assign ppIf = ""
            %assign ppFi = ""
            %assign startComment = ""
            %assign endComment = ""
        %else
            %assign blkName = LibGetBlockName(blk)
            %assign startComment = "/* Start of '%<blkName>' */"
            %assign endComment = "/* End of '%<blkName>' */"
            %%This has to be consistent with the guarding in opaquelib.tlc, which
            %% guards the definitions of the data
            %% TopTester: test/toolbox/simulink/variants/var-inline-vsrc/tmReuse_InplaceVariants.m
            %% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tSameDataWithAndWithoutIV.m
            %assign vcRecord = SLibGetInlineSystemRelativeConditionFromVarGroup(subVarGroup)
            %assign ppIf = ""
            %assign ppFi = ""
            %if vcRecord.hasConds
                %assign ppIf = vcRecord.ifCond
                %assign ppFi = vcRecord.endIfCond
            %endif
        %endif
        %assign elementInit = SLibGetVargroupElementInit(subsystemVargroupIdx, ...
            startComment, inlineRes[0])
        %% define the body of the initialization
        %if structExplode
            %assign initVect.data = initVect.data + elementInit
        %endif
        %if loopData.insertComma
            %assign endComment = ",\n" + endComment
        %endif
        %assign body = elementInit + endComment
        %%
        %% set this up so we know if we have conditionals wrapping this vargroup
        %assign vcRecord = SLibVariantConditionRecord()
        %if subVarGroup.Category != "ConstBlockIO" && subVarGroup.Category != "ZCEvent"
            %assign vcRecord = SLibGetInlineSystemNetConditionFromVarGroup(subVarGroup)
        %endif
        %%
        %% see g1453062
        %assign loopData.hasUnconditionalElement = loopData.hasUnconditionalElement || (!vcRecord.hasConds && ISEMPTY(ppIf))
        %%assign loopData.hasUnconditionalElement = loopData.hasUnconditionalElement || ISEMPTY(ppIf)
        %%
        %if !loopData.hasUnconditionalElement
            %if loopData.needsrtunused
                %assign body = body + "\n" + loopData.defineHasElement + "\n"
            %else
                %assign body = body + "\n"
            %endif
        %endif
        %%

        %% wrap the body in appropriate conditionals
        %assign subsystemBody = SLibWrapBody(ppIf, body, ppFi)
        %if !ISEMPTY(vcRecord)
            %if vcRecord.hasConds
                %% see g1453062
                %assign subsystemBody = SLibWrapBody(vcRecord.ifCond, subsystemBody, vcRecord.endIfCond)
            %endif
        %endif

        %assign res = subsystemBody

        %assign loopData.numElements = loopData.numElements + inlineRes[1]
    %endif

    %return res
%endfunction %% SLibGetSubsystemVarGroupInitValue

%% Function: SLibGetReferencedCoderGroupInit =======================================================
%% Abstract:
%%   Returns the initialization for a reference to a coder group
%%
%function SLibGetReferencedCoderGroupInit(recIdx, loopData, structExplode, initVect) void
    %assign group = ::CompiledModel.CoderDataGroup[recIdx]
    %assign value = "&(" + SLibCoderDataGroupInstance(group) + ")"
    %if structExplode
        %assign initVect.data = initVect.data + value
    %endif
    %assign res = value
    %if loopData.insertComma
        %assign res = res + ", "
    %endif
    %return res
%endfunction

%% Function: SLibGetCoderDataGroupInitValue ========================================================
%% Abstract:
%%   Returns the initialization for a given coder data group
%%
%function SLibGetCoderDataGroupInitValue(coderDataGroupIdx, loopData, structExplode, initVect, aVarGroupIdx) void
    %assign res = ""
    %assign varGroup = ::CompiledModel.VarGroups.VarGroup[aVarGroupIdx]
    %assign group = FcnGetCoderGroupForVarGroup(varGroup)
    %assign childDataGroup = FcnGetChildDataGroup(group, coderDataGroupIdx)
    %assert childDataGroup.AsStructure == "InParent"
    %assign mdlrefBlock = ::CompiledModel.ModelReferenceBlocks[childDataGroup.CompiledModelBlockIndex]
    %assign grBlkIndex = [ %<mdlrefBlock[3]>, %<mdlrefBlock[4]> ]

    %assign value = childDataGroup.Initializer
    %if structExplode
        %assign initVect.data = initVect.data + value
    %endif
    %openfile body
    %assign bodyContent = value
    %if loopData.insertComma
        %assign bodyContent = bodyContent + ", "
    %endif

    %<bodyContent>
    %assign vcCond = ISFIELD(childDataGroup, "NetVariantCondition") ? ...
        childDataGroup.NetVariantCondition : ""
    %assign isNonVariant = ISEMPTY(vcCond)

    %assign loopData.hasUnconditionalElement = loopData.hasUnconditionalElement || isNonVariant
    %if !loopData.hasUnconditionalElement && loopData.needsrtunused
        %<loopData.defineHasElement>
    %endif
    %closefile body
    %%Now wrap it in #if. We don't need to worry about passing #endif always as SLibWrapBody return early
    %%if empty #if cond
    %assign dataBody = SLibWrapBody(SLibIfVariantConditionForm(vcCond),body,"#endif")
    %assign loopData.numElements = loopData.numElements + 1
    %return dataBody
%endfunction %% SLibGetCoderDataGroupInitValue

%% Function: SLibGetVarGroupBankInit
%% Abstract:
%%      Get initialization value for vargroups that are emitted as parameter banks
%function SLibGetVarGroupBankInit(aVarGroupIdx, aCategory, aBankSize) void
    %assign retValue = ["", 0, TLC_FALSE]
    %assign initBuff = ""
    %foreach choiceIdx = aBankSize
        %assign retValue = SLibGetVarGroupInitHelper(aVarGroupIdx, aCategory, TLC_TRUE, choiceIdx)
        %assign initBuff = initBuff + "{" + retValue[0] + "}"
        %if choiceIdx != aBankSize-1
            %assign initBuff = initBuff + ", "
        %endif
    %endforeach

    %assign retValue[0] = initBuff
    %return retValue
%endfunction %% SLibGetVarGroupBankInit

%% Function: SLibGetVarGroupInitHelper =============================================================
%% Abstract:
%%   Returns the initialization value for a given constant VarGroup.
%% TopTester: test/toolbox/simulink/coreblocks/lib_MathOperations/Gain/rtw/tGainblk_blas_misc.m
%%
%function SLibGetVarGroupInitHelper(aVarGroupIdx, aCategory, aPerChoice, aChoiceIdx) void
    %assign retValue = ["", 0, []]
    %assign varGroup = ::CompiledModel.VarGroups.VarGroup[aVarGroupIdx]
    %assign comma = ""
    %assign varGroupName = varGroup.Name
    %assign structExplode = !varGroup.PackageAsStruct
    %assign prmsUsingSymbolicValue = []
    %% For the structures with rt_unused, we need to initialize that element while initializing
    %% the structure. We use "0" for initializing the rt_unused element. But if the structure will
    %% never go empty, then we can eliminate this "0" from getting adding up in the structure initialization.
    %% Adding this needsrtunused information to loopData.
    %% TopTester: test/toolbox/simulink/variants/var-defaultvariant/t_mReusableFns_1.m
    %% TopTester: test/toolbox/simulink/variants/var-defaultvariant/t_mReusableFns_2.m
    %createrecord initVect { data [] }
    %assign hasAnyElement = TLC_FALSE
    %createrecord loopData { insertComma TLC_TRUE; hasUnconditionalElement TLC_FALSE; ...
        defineHasElement SLibVarGroupHasElementDefine(varGroup); numElements 0; ...
        needsrtunused LibStructureNeedsRt_Unused(aVarGroupIdx); perChoice aPerChoice; choiceIdx aChoiceIdx}
    %assign initBuff = ""
    %openfile initBuff
    %foreach elemIdx = varGroup.NumVarGroupElements
        %assign idnum  = IDNUM(varGroup.VarGroupElements[elemIdx])
        %assign recType = idnum[0]
        %assign recIdx  = idnum[1]

        %assign loopData.insertComma = elemIdx < varGroup.IndexOfLastNonEmptyMember || !SLibVarGroupIsStruct(aVarGroupIdx)

        %switch recType
          %case "LDW"
          %case "W"
          %case "U"
          %case "Y"
          %case "B"
          %case "ZE"
            %<SLibGetDynamicDataInit(recType, recIdx, loopData, structExplode, initVect)>
            %break
          %case "RCDG"
            %<SLibGetReferencedCoderGroupInit(recIdx, loopData, structExplode, initVect)>
            %break
          %case "C"
            %<SLibGetConstBlockOutputInit(recIdx, loopData, structExplode, initVect, aCategory)>
            %break
          %case "P"
            %<SLibGetParameterInit(recIdx, loopData, structExplode, initVect)>
            %assign prm = ::CompiledModel.ModelParameters.Parameter[recIdx]
            %if ISFIELD(prm, "IsSymbolicValue")
                %assign prmsUsingSymbolicValue = %<prmsUsingSymbolicValue> + SLibGetModelParameterIndex(prm)
            %endif
            %break
          %case "PD"
            %<SLibGetPaddingInit(recIdx, loopData, structExplode, initVect)>
            %assign hasAnyElement = TLC_TRUE
            %break
          %case "VG"
            %<SLibGetSubsystemVarGroupInitValue(recIdx, loopData, structExplode, initVect, aCategory)>
            %break
          %case "PCDG"
            %<SLibGetCoderDataGroupInitValue(recIdx, loopData, structExplode, initVect, aVarGroupIdx)>
            %break
          %default
            %assert "RTM" == recType
            %if "RTM" == recType
                %<SLibGetRTMInit(aVarGroupIdx, recIdx, loopData, structExplode, initVect)>
            %endif
        %endswitch
    %endforeach

    %% if any elements were initialized, but they're all surrounded by preprocessor
    %% directives we need to insert an initialization for the dummy element
    %if !loopData.hasUnconditionalElement && (loopData.numElements > 0) && loopData.needsrtunused
        %<SLibWrapUndefinedHasElement(varGroup, "0")>
    %endif

    %closefile initBuff

    %if structExplode
        %assign retValue[0] = initVect.data
    %else
        %assign retValue[0] = initBuff
    %endif
    %assign retValue[1] = loopData.numElements
    %assign retValue[2] = prmsUsingSymbolicValue

    %return retValue
%endfunction %% SLibGetVarGroupInitHelper

%% Function: SLibGetVarGroupInitValue ==============================================================
%% Abstract:
%%   Returns the initialization value for a given constant VarGroup.
%%
%function SLibGetVarGroupInitValue(aVarGroupIdx, aCategory) void
    %assign varGroup = ::CompiledModel.VarGroups.VarGroup[aVarGroupIdx]
    %assign bankSize = 0
    %if ISFIELD(varGroup, "BankSize")
        %assign bankSize = varGroup.BankSize
    %endif
    %if bankSize > 0
        %return SLibGetVarGroupBankInit(aVarGroupIdx, aCategory, bankSize)
    %else
        %return SLibGetVarGroupInitHelper(aVarGroupIdx, aCategory, TLC_FALSE, 0)
    %endif
%endfunction %% SLibGetVarGroupInitValue

%% Function: SLibCacheConstVarGroupInstances =======================================================
%% Abstract:
%%   Caches all standalone constant vargroup instance initialization strings
%%   and returns the initlization string for the base system.
%% TopTester: test/toolbox/simulink/variants/var-vss-sigobj/tVSSSigObj.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants3.m
%%
%function SLibCacheConstVarGroupInstances(aCategory) void
    %assign  baseSystemIdx = GetBaseSystemIdx()
    %assign indexFieldName = aCategory + "VarGroupIndex"
    %%
    %% We first generate the constant block IO initialization for all
    %% standalone systems
    %%
    %foreach sysIdx = baseSystemIdx
        %assign system = ::CompiledModel.System[sysIdx]
        %if system.StandaloneSubsystem
            %if ISFIELD(system, indexFieldName)
                %assign varGroupIdx = GETFIELD(system, indexFieldName)
                %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIdx[0]]
                %assign res = SLibGetVarGroupInitValue(varGroupIdx[0], aCategory)
                %assign fieldName = SLibGetStandAloneInitName(varGroupIdx[0])
                %<LibSetSystemField(system, fieldName, res[0])>
            %endif
        %endif
    %endforeach
    %%
    %% Then we generate the constant block IO initialization for the base
    %% system
    %%
    %assign res = ["", 0]
    %assign system = ::CompiledModel.System[baseSystemIdx]
    %if ISFIELD(system, indexFieldName)
        %assign varGroupIdx = GETFIELD(system, indexFieldName)
        %assign tmpRes = SLibGetVarGroupInitValue(varGroupIdx[0], aCategory)
        %assign res[0] = tmpRes[0]
        %assign res[1] = tmpRes[1]
        %assign prmsUsingSymbolicValue = tmpRes[2]
        %if !ISEMPTY(prmsUsingSymbolicValue)
            %assign fileName = SLibGetVarGroupInstDefinitionFile(aCategory)
            %<SLibUpdateHeadersNeededByParamsUsingSymbolicValue(prmsUsingSymbolicValue, fileName)>
        %endif
    %endif
    %return res
%endfunction %% SLibCacheConstVarGroupInstances

%% Function: LibCacheConstBlockIOInstance ==========================================================
%% Abstract:
%%   Caches the ConstBlockIO instance, and since all its fields are invariant
%%   it is initialized at this time.
%%
%function LibCacheConstBlockIOInstance() void

    %if ::CompiledModel.BlockOutputs.NumConstBlockOutputs > 0
        %assign val = SLibCacheConstVarGroupInstances("ConstBlockIO")
        %assign ::CompiledModel.ConstBlockIOInstance = val[0]
    %else
        %assign ::CompiledModel.ConstBlockIOInstance = ""
    %endif
%endfunction  %% LibConstCacheBlockIOInstance


%% Function: LibCacheContStatesInstance ============================================================
%% Abstract:
%%   Caches the continuous States instance.
%%
%% Disabled states are only used for fixed-step zero crossing right now (g2436420).  In
%% the future, we may additionally support the use case of disabled states for models
%% with mass matrix and conditionally executed subsystems, see g463624.
%function LibCacheContStatesInstance() void
    %if (NumContStates - SLibGetNumLocallyControlledCStates()) > 0 && !LibIsDeploymentDiagram()
        %if SLibAutosarCompilerAbstractionRequired()
            %assign definition = "%<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, ::tContStateType, TLC_FALSE, TLC_FALSE, LibGetContinuousStateStruct(), "DataGlobal")>;"
        %else
            %assign definition = "%<::tContStateType> %<LibGetContinuousStateStruct()>;"
        %endif
        %assign ::CompiledModel.ContStatesInstance = ...
            SLibApplyMemSecToDataDefn(definition, "MemSecDataInternal", "%<LibGetContinuousStateStruct()>")
    %else
        %assign ::CompiledModel.ContStatesInstance = ""
    %endif
%endfunction  %% LibCacheContStatesInstance

%% Function: LibCacheContStatesDisabledInstance ====================================================
%% Abstract:
%%   Caches the continuous States instance.
%%
%function LibCacheContStatesDisabledInstance() void
    %if (NumContStates - SLibGetNumLocallyControlledCStates()) > 0 && !LibIsDeploymentDiagram()
        %if SLibAutosarCompilerAbstractionRequired()
            %assign definition = "%<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, ::tXdisType, TLC_FALSE, TLC_FALSE, LibGetContinuousStateDisabledStruct(), "DataGlobal")>;"
        %else
            %assign definition = "%<::tXdisType> %<LibGetContinuousStateDisabledStruct()>;"
        %endif
        %assign ::CompiledModel.ContStatesDisabledInstance = ...
            SLibApplyMemSecToDataDefn(definition, "MemSecDataInternal", "%<LibGetContinuousStateDisabledStruct()>")
    %else
        %assign ::CompiledModel.ContStatesDisabledInstance = ""
    %endif
%endfunction  %% LibCacheContStatesDisabledInstance


%% Function: LibCachePeriodicContStatesInstance
%% Abstract:
%%   Caches the periodic continuous states instance.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants3.m
%%
%function LibCachePeriodicContStatesInstance() void
    %if ((NumPeriodicContStates > 0) && !LibIsDeploymentDiagram())
        %assign pstatesInd =  LibGetPeriodicContStateIndices()
        %assign pstatesRng =  LibGetPeriodicContStateRanges()
        %if SLibAutosarCompilerAbstractionRequired()
            %assign defind = "%<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, ::tPeriodicStateIndType, TLC_FALSE, TLC_FALSE, pstatesInd, "DataGlobal")>;"
            %assign defrng = "%<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, ::tPeriodicStateRngType, TLC_FALSE, TLC_FALSE, pstatesRng, "DataGlobal")>;"
        %else
            %assign defind = "%<::tPeriodicStateIndType> %<pstatesInd>;"
            %assign defrng = "%<::tPeriodicStateRngType> %<pstatesRng>;"
        %endif
        %assign ::CompiledModel.PeriodicStateIndInstance = SLibApplyMemSecToDataDefn(defind, "MemSecDataInternal", "%<pstatesInd>")
        %assign ::CompiledModel.PeriodicStateRngInstance = SLibApplyMemSecToDataDefn(defrng, "MemSecDataInternal", "%<pstatesRng>")
    %else
        %assign ::CompiledModel.PeriodicStateIndInstance = ""
        %assign ::CompiledModel.PeriodicStateRngInstance = ""
    %endif
%endfunction  %% LibCachePeriodicContStatesInstance


%% Function: LibCacheMassMatricesInstance ==========================================================
%% Abstract:
%%   Caches the Mass Matrices (local) Ir, Jc, Pr structures instance, as well as
%%   global Ir,Jc,Pr.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants3.m
%%
%function LibCacheMassMatricesInstance() void
    %if ((SLibGetModelIsLinearlyImplicit() == "yes") && !SLibIsDeploymentDiagramWithNoTopSolver())
        %if (SLibAutosarCompilerAbstractionRequired())
            %assign definitionGlobal = "%<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, ::tMassMatrixGlobalType, TLC_FALSE, TLC_FALSE, LibGetMassMatrixGlobal(), "DataGlobal")>;"
        %else
            %assign definitionGlobal = "%<::tMassMatrixGlobalType> %<LibGetMassMatrixGlobal()>;"
        %endif
        %assign ::CompiledModel.MassMatricesGlobalInstance = ...
            SLibApplyMemSecToDataDefn(definitionGlobal, "MemSecDataInternal", "%<LibGetMassMatrixGlobal()>")
    %else
        %assign ::CompiledModel.MassMatricesGlobalInstance = ""
    %endif
%endfunction  %% LibCacheMassMatricesInstance

%% Function: LibCacheCoderDataGroupInstance ========================================================
%% Abstract:
%%   Cache Coder Data Group instance definitions that are dynamically
%%   initialized
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants3.m
%%
%function LibCacheCoderDataGroupInstance() void
    %assign ::CompiledModel.CoderDataGroupInstance = ""
    %if !IsModelReferenceTarget()
        %% Emit definitions of dynamic initialized, exported coder data groups in model_data.c[pp]
        %createrecord groupFilter { \
            Static TLC_FALSE \
            Dynamic TLC_TRUE \
            NoneInit TLC_FALSE \
            AccessStandalone TLC_TRUE \
            AccessInSelf !MultiInstanceERTCode || ::GenerateClassInterface \
            AccessInParent !MultiInstanceERTCode || ::GenerateClassInterface \
            Exported TLC_TRUE \
            Imported  %<::CompiledModel.GenerateImportedDataGroupsTypes> \
            SkipModelData TLC_FALSE \
            EmitToTestBuffer %<::CompiledModel.GenerateImportedDataGroupsTypes> \
        }
        %assign buffer = SLibDeclareCoderDataGroupInstances(::CompiledModel.System[GetBaseSystemIdx()],"",groupFilter)
        %assign ::CompiledModel.CoderDataGroupInstance = ::CompiledModel.CoderDataGroupInstance + buffer
    %endif
%endfunction

%% Function: LibCacheDWorkInstance =================================================================
%% Abstract:
%%   Caches the States instance.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants3.m
%% TopTester: test/toolbox/rtw/targets/AUTOSAR/Variants/tValueVariants.m
%%
%function LibCacheDWorkInstance() void
    %if !LibDWorkStructIsEmpty()
        %if SLibAutosarCompilerAbstractionRequired()
            %assign definition = "%<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, ::tDWorkType, TLC_FALSE, TLC_FALSE, LibGetDWorkStruct(), "DataGlobal")>;"
        %else
            %assign definition = "%<::tDWorkType> %<LibGetDWorkStruct()>;"
        %endif

        %openfile buffer
        %<SLibAddPreStructDeclarePragma(LibGetDWorkStruct())>\
        %<SLibApplyMemSecToDataDefn(definition, "MemSecDataInternal", "%<LibGetDWorkStruct()>")>\
        %<SLibAddPostStructDeclarePragma(LibGetDWorkStruct())>\
        %closefile buffer

        %assign ::CompiledModel.DWorkInstance = buffer
    %else
        %assign ::CompiledModel.DWorkInstance = ""
    %endif
%endfunction  %% LibCacheDWorkInstance


%% Function: LibCachePrevZCStatesInstance ==========================================================
%% Abstract:
%%   Caches the States instance.
%% TopTester: test/toolbox/rtw/targets/AUTOSAR/Variants/dimensionVariants/tDimensionVariants.m
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortEnable.m
%%
%function LibCachePrevZCStatesInstance() void
    %if NumZCEvents > 0 && !LibPrevZCStatesStructIsEmpty()
        %if SLibAutosarCompilerAbstractionRequired()
            %assign definition = "%<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, ::tPrevZCStateType, TLC_FALSE, TLC_FALSE, LibGetPreviousZCStruct(), "DataGlobal")>;"
        %else
            %assign definition = "%<::tPrevZCStateType> %<LibGetPreviousZCStruct()>;"
        %endif
        %assign ::CompiledModel.PrevZCStatesInstance = ...
            SLibApplyMemSecToDataDefn(definition, "MemSecDataInternal", "%<LibGetPreviousZCStruct()>")
    %else
        %assign ::CompiledModel.PrevZCStatesInstance = ""
    %endif
%endfunction  %% LibCachePrevZCStatesInstance


%% Function: LibCacheExternalInputsInstance ========================================================
%% Abstract:
%%   Caches the external inputs instance.
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%% TopTester: test/toolbox/simulink/variants/var-vss-outputwhenunconnected/tOutWhenUnconnected.m
%%
%function LibCacheExternalInputsInstance() void
    %if ExternalInputs.NumAutoSignals > 0
        %assign modelInputsInRootInportVector = 0
        %foreach idx = ExternalInputs.NumExternalInputs
            %assign extIn = ExternalInputs.ExternalInput[idx]
            %% ignore inactive port; note that the Inactive field is there that means it is inactive: no need to check its value
            %if (ISFIELD(extIn, "Inactive"))
                %continue
            %endif

            %% ignore external port that is accessed by an access function
            %if (ISFIELD(extIn, "UseAccessFunctions")   && extIn.UseAccessFunctions == 1)
                %continue
            %endif

            %% ignore external ports that pass messages
            %if (ISFIELD(extIn, "IsMessage") && extIn.IsMessage == 1 && ...
                !Accelerator && !isRSim && !isRAccel && ...
                !SLibAutosarCompilerAbstractionRequired())
                %continue
            %endif

            %% If this signal belongs to a coderDataGroupVarGroup, don't include it
            %% with the root inputs struct
            %if(SLibDataRecordIsInCoderGroup(extIn))
                %continue
            %endif

            %if extIn.StorageClass == "Auto" && ...
                (!SLibFcnProtoCtrlActive() || extIn.RequiresGlobalAccess == "yes")
                %% Don't do anything for data types with size 0.
                %assign slBaseTypeIdx  = LibCGTypeSLBaseType(extIn.CGTypeIdx)
                %if (slBaseTypeIdx >= 0) && (LibGetDataTypeSLSizeFromId(slBaseTypeIdx) == 0)
                    %continue
                %endif

                %assign modelInputsInRootInportVector = ...
                    modelInputsInRootInportVector + 1
            %endif
        %endforeach
        %if modelInputsInRootInportVector > 0
            %if SLibAutosarCompilerAbstractionRequired()
                %assign definition = "%<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, ::tInputType, TLC_FALSE, TLC_FALSE, LibGetExternalInputStruct(), "DataGlobal")>;"
            %else
                %assign definition = "%<::tInputType> %<LibGetExternalInputStruct()>;"
            %endif

            %openfile buffer
            %<SLibAddPreStructDeclarePragma(LibGetExternalInputStruct())>\
            %<SLibApplyMemSecToDataDefn(definition, "MemSecDataInputs", "%<LibGetExternalInputStruct()>")>\
            %<SLibAddPostStructDeclarePragma(LibGetExternalInputStruct())>\
            %closefile buffer

            %assign ::CompiledModel.ExternalInputsInstance = buffer
        %else
            %assign ::CompiledModel.ExternalInputsInstance = ""
        %endif
    %else
        %assign ::CompiledModel.ExternalInputsInstance = ""
    %endif
%endfunction  %% LibCacheExternalInputsInstance


%% Function: LibCacheExternalOutputsInstance =======================================================
%% Abstract:
%%   Caches the external outputs instance.
%% TopTester: test/toolbox/simulink/variants/var-vss-outputwhenunconnected/tOutWhenUnconnected.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants3.m
%%
%function LibCacheExternalOutputsInstance() void
    %if ExternalOutputs.NumAutoSignals > 0
        %assign modelOutputsInRootOutportVector = 0
        %foreach idx = ExternalOutputs.NumExternalOutputs
            %assign extOut       = ExternalOutputs.ExternalOutput[idx]
            %assign sysIdx       = extOut.Block[0]
            %assign blkIdx       = extOut.Block[1]
            %assign outportBlock = System[sysIdx].Block[blkIdx]
            %% ignore inactive port; note that the Inactive field is there that means it is inactive: no need to check its value
            %if (ISFIELD(outportBlock, "Inactive"))
                %continue
            %endif

            %% ignore external port that is accessed by an access function
            %if (ISFIELD(extOut, "UseAccessFunctions")   && extOut.UseAccessFunctions == 1)
                %continue
            %endif

            %% If this signal belongs to a coderDataGroupVarGroup, don't include it
            %% with the root outputs struct
            %if(SLibDataRecordIsInCoderGroup(extOut))
                %continue
            %endif

            %% ignore external ports that pass messages
            %if (ISFIELD(extOut, "IsMessage") && extOut.IsMessage == 1 && ...
                !Accelerator && !isRSim && !isRAccel && ...
                !SLibAutosarCompilerAbstractionRequired())
                %continue
            %endif

            %if !SLibExternalOutputIsVirtual(outportBlock)  && extOut.StorageClass == "Auto" && ...
                (!SLibFcnProtoCtrlActive() || extOut.RequiresGlobalAccess == "yes")
                %assign modelOutputsInRootOutportVector = ...
                    modelOutputsInRootOutportVector + 1
            %endif
        %endforeach
        %if modelOutputsInRootOutportVector > 0
            %if SLibAutosarCompilerAbstractionRequired()
                %assign definition = "%<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, tOutputType, TLC_FALSE, TLC_FALSE, LibGetExternalOutputStruct(), "DataGlobal")>;"
            %else
                %assign definition = "%<tOutputType> %<LibGetExternalOutputStruct()>;"
            %endif

            %openfile buffer
            %<SLibAddPreStructDeclarePragma(LibGetExternalOutputStruct())>\
            %<SLibApplyMemSecToDataDefn(definition, "MemSecDataOutputs", "%<LibGetExternalOutputStruct()>")>\
            %<SLibAddPostStructDeclarePragma(LibGetExternalOutputStruct())>\
            %closefile buffer

            %assign ::CompiledModel.ExternalOutputsInstance = buffer

        %else
            %assign ::CompiledModel.ExternalOutputsInstance = ""
        %endif
    %else
        %assign ::CompiledModel.ExternalOutputsInstance = ""
    %endif
%endfunction  %% LibCacheExternalOutputsInstance

%% this one is much simpler than external input instance
%% generation because we are only supporting normal
%% build.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants3.m
%%
%function LibCacheExternalInputSizesInstance() void
    %assign modelInputsInRootInportSizeVector = 0
    %if ExternalInputs.NumAutoSignals > 0
        %foreach idx = ExternalInputs.NumExternalInputs
            %assign extIn = ExternalInputs.ExternalInput[idx]
            %if ISFIELD(extIn, "SizeVarGroupIdx")
                %% Don't do anything for data types with size 0.
                %assign slBaseTypeIdx  = LibCGTypeSLBaseType(extIn.CGTypeIdx)
                %if (slBaseTypeIdx >= 0) && (LibGetDataTypeSLSizeFromId(slBaseTypeIdx) == 0)
                    %continue
                %endif

                %assign modelInputsInRootInportSizeVector = ...
                    modelInputsInRootInportSizeVector + 1
            %endif
        %endforeach
    %endif
    %if modelInputsInRootInportSizeVector > 0
        %assign definition = "%<::tInputSizeType> %<::tInputSize>;"

        %openfile buffer
        %<SLibAddPreStructDeclarePragma(::tInputSize)> \
        %<SLibApplyMemSecToDataDefn(definition, "MemSecDataInputs", ::tInputSize)> \
        %<SLibAddPostStructDeclarePragma(::tInputSize)> \
        %closefile buffer

        %assign ::CompiledModel.ExternalInputSizesInstance = buffer
    %else
        %assign ::CompiledModel.ExternalInputSizesInstance = ""
    %endif
%endfunction

%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants3.m
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-sim/tg1167032.m
%%
%function LibCacheExternalOutputSizesInstance() void
    %assign modelOutputsInRootOutportSizeVector = 0
    %if NumModelOutputs > 0
        %foreach idx = ExternalOutputs.NumExternalOutputs
            %assign extOut       = ExternalOutputs.ExternalOutput[idx]
            %assign sysIdx       = extOut.Block[0]
            %assign blkIdx       = extOut.Block[1]
            %assign outportBlock = System[sysIdx].Block[blkIdx]
            %if !SLibExternalOutputIsVirtual(outportBlock) && ...
                ISFIELD(extOut, "HasVarDims")
                %assign modelOutputsInRootOutportSizeVector = ...
                    modelOutputsInRootOutportSizeVector + 1
            %endif
        %endforeach
    %endif

    %if modelOutputsInRootOutportSizeVector > 0
        %assign definition = "%<tOutputSizeType> %<tOutputSize>;"

        %openfile buffer
        %<SLibAddPreStructDeclarePragma(LibGetExternalOutputStruct())>\
        %<SLibApplyMemSecToDataDefn(definition, "MemSecDataOutputs", "%<LibGetExternalOutputStruct()>")>\
        %<SLibAddPostStructDeclarePragma(LibGetExternalOutputStruct())>\
        %closefile buffer

        %assign ::CompiledModel.ExternalOutputSizesInstance = buffer
    %else
        %assign ::CompiledModel.ExternalOutputSizesInstance = ""
    %endif
%endfunction %%LibCacheExternalOutputSizesInstance

%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants3.m
%%
%function FcnGetBlockParameterForCommentGeneration(mdlParam, refByIdx) void
    %if ISFIELD(mdlParam, "BHMPrmIdx")
        %assign graphSysIdx = mdlParam.GraphicalRef[refByIdx][0]
        %assign graphBlkIdx = mdlParam.GraphicalRef[refByIdx][1]
        %assign graphPrmIdx = mdlParam.BHMPrmIdx
        %if graphSysIdx != -1 && graphBlkIdx != -1 && graphPrmIdx != -1
            %assign block  = ::CompiledModel.BlockHierarchyMap.Subsystem[graphSysIdx].Block[graphBlkIdx]
            %return block.Parameter[graphPrmIdx]
        %endif
    %endif
    %assign sysIdx = mdlParam.ReferencedBy[refByIdx][0]
    %assign blkIdx = mdlParam.ReferencedBy[refByIdx][2]
    %assign prmIdx = mdlParam.ReferencedBy[refByIdx][3]
    %assign block  = System[sysIdx].Block[blkIdx]
    %return block.Parameter[prmIdx]
%endfunction

%function FcnUpdateCommentForSynthesizedPointerParameter(mdlParam, currentComment) void
    %if !CGMODEL_ACCESS("CGModel.IsSynthesizedPointerParameter", SLibGetModelParameterIndex(mdlParam))
        %return currentComment
    %endif
    %% Use special name for synthesized parameters that are used to statically initalize a pointer field of a struct
    %return CGMODEL_ACCESS("CGModel.GetCommentForSynthesizedPointerParameter", SLibGetModelParameterIndex(mdlParam))
%endfunction

%% Function: SLibGenModelPrmDefnComment ============================================================
%% Abstract:
%%   Generate the comment for a model parameter.
%%
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants3.m
%% TopTester: test/toolbox/simulink/variants/var-inline-vsink/tmVarSinkRateTransBlk_VC1.m
%% TopTester: test/toolbox/simulink/variants/var-general/tvariant_merge.m
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tVariantSource6.m
%% TopTester: test/toolbox/rtw/targets/AUTOSAR/Variants/inlineVariants/tIvModelBlockSil_2.m
%%
%function SLibGenModelPrmDefnComment(mdlParam) void
    %assign pName = LibGetRecordIdentifier(mdlParam)

    %assign customStr = ""
    %assign typeStr = ""

    %if ISEMPTY(mdlParam.WorkspaceVarName)
        %assign nRefBlkPrms = SIZE(mdlParam.ReferencedBy, 0)

        %% It is possible for a tunable model parameer not to have a name but
        %% is referenced by multiple block paramters. Such is the case for
        %% tunable pseudo workspace parameters created for parameters on
        %% reusable subsystems that do not contain tunable expressions.
        %if nRefBlkPrms > 1 && mdlParam.Tunable == "no"
            %% Pooled model parameter
            %% (not a workspace variable but used by multiple block parameters)

            %foreach refByIdx = nRefBlkPrms
                %assign sysIdx = mdlParam.ReferencedBy[refByIdx][0]
                %assign blkIdx = mdlParam.ReferencedBy[refByIdx][2]
                %assign prmIdx = mdlParam.ReferencedBy[refByIdx][3]
                %assign block  = System[sysIdx].Block[blkIdx]

                %if (block.Type == "SubSystem")
                    %% We don't have separate expressions for mask parameters
                    %assign typeStr = "Pooled Parameter (Mixed Expressions)\n"
                    %break
                %endif

                %%assign blkPrm = block.Parameter[prmIdx]
                %assign blkPrm = FcnGetBlockParameterForCommentGeneration(mdlParam, refByIdx)

                %% Parameter could be a run-time parameter or collapsed expression.
                %switch blkPrm.StringType
                  %case "Expression"
                    %assign instanceStr = blkPrm.String
                    %break
                  %case "Computed"
                    %assign instanceStr = blkPrm.StringTransformed
                    %break
                  %default
                    %% Should never get here.
                    %assert TLC_FALSE
                %endswitch

                %if (refByIdx == 0)
                    %assign exprStr = instanceStr
                    %assign typeStr = "Pooled Parameter (Expression: %<exprStr>)\n"
                %elseif (instanceStr != exprStr)
                    %% Expressions are not all the same
                    %assign typeStr = "Pooled Parameter (Mixed Expressions)\n"
                    %break
                %endif
            %endforeach

        %else
            %if mdlParam.IsPseudoWorkspaceVar == "yes" && mdlParam.Tunable == "yes"
                %assign typeStr = "Mask Parameter: %<pName>\n"
            %else
                %% Model parameter used by only one block parameter
                %assign sysIdx = mdlParam.ReferencedBy[0][0]
                %assign blkIdx = mdlParam.ReferencedBy[0][2]
                %assign prmIdx = mdlParam.ReferencedBy[0][3]
                %assign block  = System[sysIdx].Block[blkIdx]

                %if block.Type != "SubSystem"
                    %assign blkPrm = FcnGetBlockParameterForCommentGeneration(mdlParam, 0)

                    %% Parameter could be a run-time parameter or collapsed expression.
                    %switch blkPrm.StringType
                      %case "Expression"
                        %assign typeStr = "Expression: %<blkPrm.String>\n"
                        %break
                      %case "Computed"
                        %assign typeStr = "Computed Parameter: %<pName>\n"
                        %break
                      %default
                        %% Should never get here.
                        %assert TLC_FALSE
                    %endswitch

                    %if ISFIELD(blkPrm,"DefSideComment")
                        %assign customStr = "* Comment: %<blkPrm.DefSideComment>\n"
                    %endif
                %else
                    %% Mask Parameter
                    %assign typeStr = "Mask Parameter: %<pName>\n"
                %endif
            %endif
        %endif
    %else
        %% Parameter corresponds to a workspace variable.
        %% ==> Use the WorkspaceVarName in comment because the parameter may have
        %%     an alias name or the identifier may be mangled (if not tunable).
        %assign typeStr = "Variable: %<mdlParam.WorkspaceVarName>\n"
    %endif

    %assign numBlocks = SIZE(mdlParam.GraphicalRef, 0)
    %assert (numBlocks > 0)

    %if numBlocks == 1
        %assign enhanceComment = ""
        %assign sysIdx = mdlParam.ReferencedBy[0][0]
        %assign blkIdx = mdlParam.ReferencedBy[0][2]
        %assign prmIdx = mdlParam.ReferencedBy[0][3]
        %if ::CompiledModel.SLCI == "on" && (mdlParam.StorageClass == "Auto")...
            && sysIdx >= 0 && blkIdx >= 0 && prmIdx >= 0
            %if System[sysIdx].Block[blkIdx].Type == "SubSystem"
                %if ISFIELD(System[sysIdx].Block[blkIdx].CallSiteInfo, "CanonicalPrmArg")
                    %assign prmName = "System parameter #" + ...
                        "%<System[sysIdx].Block[blkIdx].CallSiteInfo.CanonicalPrmArg[prmIdx].ChildPrmArgIdx>"
                %else
                    %assign prmName = "System mask parameter #%<prmIdx>"
                %endif
            %else
                %assign blkPrm = FcnGetBlockParameterForCommentGeneration(mdlParam, 0)
                %assign prmName = blkPrm.Name
            %endif
            %assign prmName = FcnUpdateCommentForSynthesizedPointerParameter(mdlParam, prmName)
            %assign enhanceComment = " (Parameter: " + prmName + ")"
        %endif
        %assign blkName = SLibGrBlockCommentName(mdlParam.GraphicalRef[0])
        %assign referencedByStr = "* Referenced by: %<blkName>%<enhanceComment>\n"
    %else
        %assign referencedByStr = "* Referenced by:\n"
        %foreach idx = numBlocks
            %assign enhanceComment = ""
            %assign sysIdx = mdlParam.ReferencedBy[idx][0]
            %assign blkIdx = mdlParam.ReferencedBy[idx][2]
            %assign prmIdx = mdlParam.ReferencedBy[idx][3]
            %if ::CompiledModel.SLCI == "on" && (mdlParam.StorageClass == "Auto")...
                && sysIdx >= 0 && blkIdx >= 0 && prmIdx >= 0
                %if System[sysIdx].Block[blkIdx].Type == "SubSystem"
                    %if ISFIELD(System[sysIdx].Block[blkIdx].CallSiteInfo, "CanonicalPrmArg")
                        %assign prmName = "System parameter #" + ...
                            "%<System[sysIdx].Block[blkIdx].CallSiteInfo.CanonicalPrmArg[prmIdx].ChildPrmArgIdx>"
                    %else
                        %assign prmName = "System mask parameter #%<prmIdx>"
                    %endif
                %else
                    %assign blkPrm = FcnGetBlockParameterForCommentGeneration(mdlParam, idx)
                    %assign prmName = blkPrm.Name
                %endif
                %assign prmName = FcnUpdateCommentForSynthesizedPointerParameter(mdlParam, prmName)
                %assign enhanceComment = " (Parameter: " + prmName + ")"
            %endif
            %assign blkName = SLibGrBlockCommentName(mdlParam.GraphicalRef[idx])
            %if ISEMPTY(blkName) && ISEMPTY(enhanceComment)
                %continue
            %endif
            %assign referencedByStr = referencedByStr + "*   %<blkName>%<enhanceComment>\n"
        %endforeach
    %endif

    %assign descStr = SLibGetDescriptionForData(mdlParam)
    %assign descStr = ISEMPTY(descStr) ? "" : "* " + descStr + "\n"

    %assign comment = ...
        "%<typeStr> " ...
        "%<customStr> " ...
        "%<referencedByStr> " ...
        "%<descStr> "

    %return comment
%endfunction %% SLibGenModelPrmDefnComment


%% Function: SLibGenModelParamDecl =================================================================
%% Abstract:
%%   Generates a parameter declaration for placement in model parameter
%%   structure, rtP.  Also works for declaration of imported, exported, or
%%   custom parameters.
%%
%%   The function uses all information from the ModelParameters table
%%   instead of referencing back to the block parameter.
%%
%%   Arguments:
%%        mdlParam - A Parameter record from the ModelParameters table
%%        applyPragma - TLC_TURE/TLC_FALSE to indicate whether to add pragma
%%
%%   Returns:
%%        A string declaring the given parameter e.g.
%%        real_T a;                /* Comments */
%%        int8_T myGain_Gain[10];  /* Comments */
%%
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants2.m
%% TopTester: test/toolbox/rtw/targets/AUTOSAR/Variants/dimensionVariants/tDimensionVariants2.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%%
%function SLibGenModelParamDecl(mdlParam, applyPragma) void
    %% parameter name
    %assign pName = SLibGetModelParamName(mdlParam)

    %assign vcRecord = SLibGetDataInlineVariantNetConditions(mdlParam)
    %assign ppIf = vcRecord.ifCond
    %assign ppEndIf = vcRecord.endIfCond

    %% Ignore empty parameters
    %assign width = SLibGetWidthOfValueFromParamRec(mdlParam)
    %if width == 0
        %return ""
    %endif

    %assign useStdContainerName = TLC_FALSE
    %assign hasSymbolicWidth = LibRecordHasSymbolicWidth(mdlParam)
    %assign isStringParam = ISFIELD(mdlParam, "OriginalDataTypeIdx") && ...
        LibIsStringDataType(mdlParam.OriginalDataTypeIdx)

    %if (hasSymbolicWidth || width > 1) && SLibIsContainerCGTypeStdContainer(mdlParam)
        %assign useStdContainerName = TLC_TRUE
        %assign optDims = ""
    %elseif isStringParam
        %% Emit dimension for string parameters (char_T[] or std::string)
        %if LibIsStdStringDataType(mdlParam.OriginalDataTypeIdx)
            %assign optDims = "" %% Treat std::string as scalar
        %else
            %assign optDims = LibGetRecordVectorDims(mdlParam)
        %endif
    %elseif hasSymbolicWidth || SLibIsNdIndexingFeatureOn() || SLibIsContainerCGTypeND(mdlParam)
        %assign optDims = LibGetRecordVectorDims(mdlParam)
    %elseif width > 1
        %assign optDims = "[%<width>]"
    %else %% Scalar
        %assign optDims = ""
    %endif

    %if LibHasCustomStorage(mdlParam)
        %openfile buffer
        %<ppIf>
        %<LibCustomData(mdlParam,"declare",optDims,"")>
        %<ppEndIf>
        %closefile buffer
        %return buffer
    %endif

    %% data type
    %assign dataType = SLibGetRecordContainerOptStdTypeName(mdlParam, useStdContainerName)
    %% side comment
    %assign comment = SLibGenModelPrmDefnComment(mdlParam)

    %% storage class
    %switch mdlParam.StorageClass
      %case "Auto"
      %case "Auto_SFCN"
        %if SLibIsParamUnstructured(mdlParam)
            %assign externStr = "extern "
        %else
            %assign externStr = ""
        %endif
        %assign star = ""
        %break
      %case "ExportedGlobal"
      %case "ImportedExtern"
        %assign externStr = "extern "
        %assign star = ""
        %break
      %case "ImportedExternPointer"
        %assign externStr = "extern "
        %assign star = "*"
        %assign optDims = ""
        %break
      %case "Custom"
        %assign errTxt = "Should not get here; should have exited local fcn above"
        %<LibReportFatalError(errTxt)>
      %default
        %assign errTxt = "Unknown storage class: %<mdlParam.StorageClass>"
        %<LibReportFatalError(errTxt)>
    %endswitch

    %% type qualifier
    %assign tq = mdlParam.TypeQualifier

    %% declaration string
    %if (mdlParam.DefinedInLegacyCode == 0)
        %if SLibAutosarCompilerAbstractionRequired() && !MultiInstanceERTCode
            %% Compiler abstractions will not be applied for constant-memory
            %% parameters in a multi-instance SWC
            %assign declaration = ...
                "%<tq> %<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, dataType, (mdlParam.StorageClass == "ImportedExternPointer"), TLC_FALSE, "%<pName>%<optDims>", "DataGlobal")>; /* %<comment> */"
        %else
            %assign declaration = ...
                "%<tq> %<dataType> %<star>%<pName>%<optDims>; /* %<comment> */\n"
        %endif
        %assign elemNameTraceMarker = ""
        %if !ISFIELD(mdlParam, "VarGroupIdx")
            %% More explicit differentiation between individual mapping & default mapping tracked by g1822926
            %assign elemNameTraceMarker = SLibAddTrace2("StorageClassSource", "Individual", "ModelDataSource", "%<mdlParam.Identifier>")
        %endif
        %assign traceMarker = SLibAddTrace2("ModelElemCategory", "%<SLibGetModelElemCategoryForParam(mdlParam)>", "StorageClass", "%<mdlParam.StorageClass>")
        %assign blockTraceMarker = SLibAddBlockTrace(comment)
        %assign declaration = " %<SLibTraceBegin(elemNameTraceMarker)> %<SLibTraceBegin(traceMarker)> %<SLibTraceBegin(blockTraceMarker)> %<declaration> %<SLibTraceEnd(blockTraceMarker)> %<SLibTraceEnd(traceMarker)> %<SLibTraceEnd(elemNameTraceMarker)> "
    %else
        %assign declaration = ""
    %endif

    %if (applyPragma == TLC_TRUE)
        %assign declaration = SLibApplyMemSecToDataDecl(declaration, "MemSecDataParameters", "%<pName>")
    %else
        %assign declaration = externStr + declaration
    %endif

    %assign declaration = ppIf + "\n" + declaration + "\n" + ppEndIf + "\n"

    %return declaration
%endfunction %% SLibGenModelParamDecl

%% Function: SLibGetParameterVisibility ============================================================
%% Abstract:
%%  Get the visiblity of a parameter for ClassInterface code generation
%% Argument:
%%   mdlParam - A Parameter record from the ModelParameters table
%% Returns:
%%   C++ visibility of the parameter
%%
%function SLibGetParameterVisibility(mdlParam) void
    %assert(GenerateClassInterface)
    %assert(ISFIELD(mdlParam, "VarGroupIdx"))
    %assign vg = ::CompiledModel.VarGroups.VarGroup[mdlParam.VarGroupIdx[0]]
    %if vg.Category == "Parameter"
        %return CPPBlockParamsVisibility
    %else
        %assert(SLibIsCoderGroupVarGroup(vg))
        %return FcnGetCoderGroupVisibility(vg.CoderDataGroupIndex)
    %endif
%endfunction

%% Function: SLibGetDefinitionFileRecordForParameter ===============================================
%% Abstract:
%%   Get the definition file record for a parameter
%% Argument:
%%   mdlParam - A Parameter record from the ModelParameters table
%% Returns:
%%   definition file record with extension, or empty if it does not exist
%%
%function SLibGetDefinitionFileRecordForParameter(mdlParam) void
    %if ISFIELD(mdlParam, "FilePackaging")
        %return ::CompiledModel.DataObjectUsage.File[mdlParam.FilePackaging.DefineFile]
    %else
        %return ""
    %endif
%endfunction

%% Function: SLibGetDefinitionFileNameForParameter =================================================
%% Abstract:
%%   Get the definition file name for a parameter
%% Argument:
%%   mdlParam - A Parameter record from the ModelParameters table
%% Returns:
%%   definition file name with extension
%%
%function SLibGetDefinitionFileNameForParameter(mdlParam) void
    %if !ISFIELD(mdlParam, "FilePackaging")
        %assert(mdlParam.StorageClass == "Auto")
        %assign name = SLibGetFileNameForCode("mdldata_data_defn")
    %else
        %assign rec = SLibGetDefinitionFileRecordForParameter(mdlParam)
        %assign name = rec.Name
    %endif
    %return name + "." + ::LangFileExt
%endfunction

%% Function: SLibLUTObjectWithSynthRTPsInit ========================================================
%% Abstract:
%%   Generate initialization string for LUT object with pointer fields
%%   with synthesized RTPs for arrays with the pointers point to.
%% Argument:
%%   mdlParam - A Parameter record from the ModelParameters table
%% Returns:
%%   initialization string for LUT object with pointer fields
%%
%function SLibLUTObjectWithSynthRTPsInit(mdlParam) void
    %assert(ISFIELD(mdlParam, "IsLUTObject") && mdlParam.IsLUTObject == 1)
    %assign lutObjTypeIdx = mdlParam.OriginalDataTypeIdx
    %assert(LibIsStructDataType(lutObjTypeIdx))
    %assign numElems = LibDataTypeNumElements(mdlParam.OriginalDataTypeIdx)
    %assign val = "{ "
    %assign finalNIdx = -1
    %foreach elIdx = numElems
        %% The CGMODDEL_ACCESS returns either a string or a number:
        %% If it's a string, it's the true value of a scalar field
        %% If it's a number, it's the index of the entry in ModelParameters that has the true data
        %assign idxOrVal = CGMODEL_ACCESS("CGModel.GetTrueDataIndexOrScalarFieldValueForPointerLUTObj", SLibGetModelParameterIndex(mdlParam), elIdx)
        %assign isIdx = TYPE(idxOrVal) == "Number"
        %assign toPrint = ""
        %if isIdx
            %% initPrm is the synthesized parameter with the true value
            %assign initPrm = ModelParameters.Parameter[idxOrVal]
            %assign toPrint = FcnAccessModelParameter(initPrm, "")
            %if GenerateClassInterface
                %% If it's C++ class, verify we can access the synthesized parameter
                %% and append namespace if neccessary
                %if ISFIELD(initPrm, "VarGroupIdx")
                    %assert(SLibGetParameterVisibility(initPrm) == "Public")
                    %assign vg = ::CompiledModel.VarGroups.VarGroup[initPrm.VarGroupIdx[0]]
                    %assign vis = ""
                    %if SLibIsModelTypesModelClassNamespace()
                        %% Append namespace for synthesized parameter
                        %assign ns = ::CPPClassName
                        %if EXISTS(::NamespaceName) && !WHITE_SPACE(::NamespaceName != "")
                            %assign ns = ::NamespaceName + "::" + ns
                            %assign toPrint = ns + "::" + toPrint
                        %endif
                    %endif
                %endif
            %endif
            %% Get root struct name for referenced parameter
            %if initPrm.StorageClass == "Auto"
                %assign referencedParamName = FcnGetAutoParamIdentifier(initPrm)
            %else
                %assign referencedParamName = LibGetRecordIdentifier(initPrm)
            %endif
            %assign varName = FcnGetIdentifierFromFullPath(referencedParamName)
            %% Get file name for user-visible non-synthesized parameter
            %assign fileName = SLibGetDefinitionFileNameForParameter(mdlParam)
            %assign defFileRec = SLibGetDefinitionFileRecordForParameter(mdlParam)
            %if !ISEMPTY(defFileRec) && defFileRec.IsCustom == "yes" && LibUseOldFilePackagingInfrastructure()
                %% If mdlParam's file is custom, error if we're not using the new file packaging infrastructure
                %% as we need it to get the correct includes
                %<SLibReportErrorWithIdAndArgs("Simulink:Data:SimulinkLUTWithStorageClassAndCustomHeader", LibGetRecordVarName(mdlParam))>
            %endif
            %% Tell the file packaging infrastructure that mdlParam's file
            %% will access the synthesized parameter variable for includes
            %<SLibUpdateLocalSymbolTableForFile(fileName, varName)>
        %else
            %assert(TYPE(idxOrVal) == "String")
            %assign toPrint = idxOrVal
        %endif
        %assert(!ISEMPTY(toPrint))
        %assign val = val + SLibStructElementInit(mdlParam.OriginalDataTypeIdx, elIdx, toPrint)
    %endforeach
    %assign val = val + " }"
    %return val
%endfunction


%function SLibGetBusPointerDataInitBuf() void
    %if ISFIELD(::CompiledModel, "BusPointerDataInitBuf")
        %return ::CompiledModel.BusPointerDataInitBuf
    %else
        %return ""
    %endif
%endfunction

%% Function: SLibGenUnstrModelParamInstance ========================================================
%% Abstract:
%%   Generates the code for instantiating exported unstructured parameters.
%%
%%   The function uses all information from the ModelParameters table
%%   instead of referencing back to the block parameter.
%%
%%   Arguments:
%%        mdlParam - A Parameter record from the ModelParameters table
%%        applyPragma - TLC_TRUE/TLC_FALSE to indicate whether to add pragma
%%        mdlParamIdx - Parameter index of the model parameter in Parameters array
%%        choiceIdx - This input argument is used for variant parameters.
%%             For non-variant parameters, its value will be -1.
%%             Also, when variant parameters are not grouped together, its value will be -1.
%%   Returns:
%%        A string instantiating the given parameter e.g.
%%        real_T Kp = 5.0;          /* Comments */
%%
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants2.m
%%
%function SLibGenUnstrModelParamInstance(mdlParam, applyPragma, mdlParamIdx, choiceIdx) void
    %assign vcRecord = SLibGetDataInlineVariantNetConditions(mdlParam)
    %assign ifCond = vcRecord.ifCond
    %assign ifEndCond = vcRecord.endIfCond


    %if (mdlParam.StorageClass == "ExportedGlobal")
        %assign pName = LibGetRecordIdentifier(mdlParam)
    %elseif ((mdlParam.StorageClass == "Auto") && ...
        SLibIsParamUnstructured(mdlParam))
        %assign pName = FcnGetAutoParamIdentifier(mdlParam)
        %if ISFIELD(mdlParam,"RegisteredIdentifier")
            %assign pName = mdlParam.RegisteredIdentifier
        %else
            %assign pName = LibRequestID(pName, TLC_TRUE, TLC_TRUE)
            %addtorecord mdlParam RegisteredIdentifier pName
        %endif
    %else
        %assign errTxt = "SLibGenUnstrModelParamInstance only supports " + ...
            "exported unstructured parameters."
        %<LibReportFatalError(errTxt)>
    %endif

    %% Ignore empty parameters
    %if SLibGetWidthOfValueFromParamRec(mdlParam) == 0
        %return ""
    %endif

    %assign ptrDataDef = ""
    %if ISFIELD(mdlParam, "LUTObjectFieldValues")
        %% Initialization of LUT object with pointer fields and the data arrays
        %assign initStr = SLibLUTObjectWithSynthRTPsInit(mdlParam)
    %else
        %% Initialization string
        %assign initStr = LibParameterInstanceInitStr(mdlParam)
    %endif

    %if !WHITE_SPACE(initStr)
        %assign useStdContainerName = TLC_FALSE

        %% Size
        %assign exportedPrmsWithSymbDimsFeat = CGMODEL_ACCESS("CGModel.ExportedPrmsWithSymbolicDims")
        %assign isStringParam = ISFIELD(mdlParam, "OriginalDataTypeIdx") && LibIsStringDataType(mdlParam.OriginalDataTypeIdx)
        %if SLibIsNdIndexingFeatureOn() || SLibIsContainerCGTypeND(mdlParam) || isStringParam
            %assign optDims = LibCGTypeSymbolicVectorDims(mdlParam.CGTypeIdx)
        %elseif LibRecordHasSymbolicWidth(mdlParam) && exportedPrmsWithSymbDimsFeat
            %assign optDims = "[%<LibGetRecordSymbolicWidth(mdlParam)>]"
        %else
            %assign prmSize = SLibGetSizeOfValueFromParamRec(mdlParam)
            %assign nRows   = prmSize[0]
            %assign nCols   = prmSize[1]
            %assign optDims = LibOptionalMatrixDims(nRows, nCols)
            %if !ISEMPTY(optDims) && SLibIsContainerCGTypeStdContainer(mdlParam)
                %assign optDims = ""
                %assign useStdContainerName = TLC_TRUE
            %endif
        %endif

        %% Data type
        %assign dataType = SLibGetRecordContainerOptStdTypeName(mdlParam, useStdContainerName)

        %% type qualifier
        %assign tq = mdlParam.TypeQualifier

        %% alignment
        %assign align = ""

        %if mdlParam.Alignment > 0 && !LibDataTypeIsBus(mdlParam.OriginalDataTypeIdx) && !LibGetRecordIsComplex(mdlParam)
            %assign align = SLibGetAlignmentSyntax(::CompiledModel.Name, pName, dataType, ...
                mdlParam.Alignment, "DATA_ALIGNMENT_GLOBAL_VAR")
        %endif

        %% side comment
        %assign comment = SLibGenModelPrmDefnComment(mdlParam)

        %if (IsModelReferenceSimTarget() && !SLibIsGeneratingSimTargetForProtectedModel())
            %assign optimizedInitStr = ""
        %else
            %assign optimizedInitStr = " = %<initStr>"
        %endif

        %% Variant Parameter handling
        %assign numelVarChoices = CGMODEL_ACCESS("CGModel.GetNumberOfVariantChoices", mdlParamIdx)
        %assign generateChoices = CGMODEL_ACCESS("CGModel.GenerateParameterChoices")
        %if (numelVarChoices == 0) || (!generateChoices)
            %if SLibAutosarCompilerAbstractionRequired() && !MultiInstanceERTCode
                %% Compiler abstractions will not be applied for constant-memory
                %% parameters in a multi-instance SWC
                %assign definition = ...
                    "%<align> %<tq> %<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, dataType, TLC_FALSE, TLC_FALSE, "%<pName>%<optDims>", "DataGlobal")>%<optimizedInitStr>;"
                %assign definition = ...
                    "%<LibGetCppBracedInitStr(definition)> /* %<comment> */"
            %else
                %assign definition = ...
                    "%<align> %<tq> %<dataType> %<pName>%<optDims>%<optimizedInitStr>;"
                %assign definition = ...
                    "%<LibGetCppBracedInitStr(definition)> /* %<comment> */\n"
            %endif
        %else
            %% If the parameter has variant choices, we need to generate multiple definitions corresponding to each choice
            %createrecord paramInfo {pName pName; optimizedInitStr optimizedInitStr; tq tq; comment comment; align align; dataType dataType; optDims optDims}
            %assign definition = SLibGenDefnForVariantPrm(mdlParam, paramInfo, mdlParamIdx, choiceIdx)
        %endif

        %if CGMODEL_ACCESS("CGModel.getDataDefinitionTraceIsEnabled")
            %assign blockTraceMarker = SLibAddBlockTrace(comment)
            %assign definition = " %<SLibTraceBegin(blockTraceMarker)> %<definition> %<SLibTraceEnd(blockTraceMarker)> "
        %endif

        %% global data guarding of non-variant parameters
        %if choiceIdx == -1
            %assign definition = ifCond + "\n" + definition  + "\n" + ifEndCond + "\n"
        %endif

        %if !WHITE_SPACE(ptrDataDef)
            %assign definition = ptrDataDef + definition
        %endif

        %if (applyPragma == TLC_TRUE)
            %return SLibApplyMemSecToDataDefn(definition, "MemSecDataParameters", "%<pName>")
        %else
            %return definition
        %endif
    %else
        %return ""
    %endif
%endfunction %% FcnGenUnstrModelParamInstance

%% Function SLibGenDefnForVariantPrm =============================================================
%% Abstract:
%% Provides separate paths for grouped and ungrouped variant parameters
%% Generate definition for input choice index
%function SLibGenDefnForVariantPrm(mdlParam, paramInfo, mdlParamIdx, choiceIdx) void
    %if choiceIdx != -1
        %% Generate definition only for current choice
        %% TopTester: test/toolbox/simulink/variants/var-parameter/tVPrmGrouping.m
        %return SLibGenDefnForVPrmChoice(mdlParam, paramInfo, mdlParamIdx, choiceIdx)
    %else
        %% General definition for all choices of the parameters
        %% TopTester: test/toolbox/simulink/variants/var-parameter/tDataTypeOnBlockParams.m
        %return SLibGenDefnForAllVPrmChoices(mdlParam, paramInfo, mdlParamIdx)
    %endif
%endfunction %%SLibGenDefnForVariantPrm

%% Function: SLibGenDefnForVPrmChoice ==============================================================
%% Abstract:
%% Generate definition for variant parameter choice
%function  SLibGenDefnForVPrmChoice(mdlParam, paramInfo, mdlParamIdx, choiceIdx) void
    %% If the parameter has variant choices, we need to generate multiple definitions corresponding to each choice
    %% If feature on (query to cgmodel to check if feature is on)
    %assign choiceValue = LibParameterInstanceInitStrPerChoice(mdlParamIdx, choiceIdx)
    %assign choicedefinition = ...
        "%<paramInfo.align> %<paramInfo.tq> %<paramInfo.dataType> %<paramInfo.pName>%<paramInfo.optDims> = %<choiceValue>;"
    %assign choicedefinition = ...
        "%<LibGetCppBracedInitStr(choicedefinition)> /* %<paramInfo.comment> */\n"
    %return choicedefinition
%endfunction %% SLibGenDefnForVPrmChoice

%% Function: SLibGenDefnForAllVPrmChoices ==========================================================
%% Abstract:
%% Generate instance for variant parameters with Grouping feature control flag off
%% The definition will contain all choices guarded with ppIf conditions
%function  SLibGenDefnForAllVPrmChoices(mdlParam, paramInfo, mdlParamIdx) void
    %% If the parameter has variant choices, we need to generate multiple definitions corresponding to each choice
    %assign definition = ""
    %assign numelVarChoices = CGMODEL_ACCESS("CGModel.GetNumberOfVariantChoices", mdlParamIdx)
    %assign generateChoices = CGMODEL_ACCESS("CGModel.GenerateParameterChoices")
    %foreach choiceIdx = numelVarChoices
        %assign choiceCondition = CGMODEL_ACCESS("CGModel.GetParameterChoiceCondition", mdlParamIdx, choiceIdx)
        %assign choicedefinition = SLibGenDefnForVPrmChoice(mdlParam, paramInfo, mdlParamIdx, choiceIdx)
        %assign definition = definition + SLibWrapVariantVariableCondition(choicedefinition, choiceCondition, choiceIdx, numelVarChoices)
    %endforeach
    %return definition
%endfunction %% SLibGenDefnForAllVPrmChoices

%% Function: SLibShouldGenUnstrDefn
%% Abstract:
%%  Return true if parameter definition should be generated as unstructured
%%  In model reference hierarchy, definition should be generated only for top model.
%function SLibShouldGenUnstrDefn(mdlParam) void
    %assign reqInsts    = LibGetSystemField(rootSystem,"ReqRootPrmHdrDataInsts")
    %return (reqInsts.ExpGlobalPrmsInst || mdlParam.IsGlobal == TLC_FALSE)
%endfunction

%function SLibCheckForAutoUnstrForVPrm(mdlParam)
    %return mdlParam.StorageClass == "Auto" && SLibIsParamUnstructured(mdlParam)
%endfunction

%% Function: SLibUpdateLocalSymbolTableAndSymbolicValue
%% Abstract:
%%  Update the local symbol table and headers for symbolc value
%function SLibUpdateLocalSymbolTableAndSymbolicValue(sourceFile, mdlParam, buffer) void
    %assign shouldUpdateSymTable = !WHITE_SPACE(buffer)
    %if mdlParam.StorageClass != "ExportedGlobal"
        %assign shouldUpdateSymTable = shouldUpdateSymTable && !IsModelReferenceTarget()
    %endif
    %if shouldUpdateSymTable
        %<SLibUpdateLocalSymbolTableForFile(sourceFile, SLibGetModelParamName(mdlParam))>
        %if ISFIELD(mdlParam, "IsSymbolicValue")
            %assign paramIdx = []
            %assign paramIdx = paramIdx + %<SLibGetModelParameterIndex(mdlParam)>
            %<SLibUpdateHeadersNeededByParamsUsingSymbolicValue(paramIdx, sourceFile)>
        %endif
    %endif
%endfunction %% SLibUpdateLocalSymbolTableAndSymbolicValue


%% Function: SLibModelHasVarParam
%% Abstract:
%% returns true if the parameter is a variant parameter
%function SLibModelHasVarParam() void
    %return (CGMODEL_ACCESS("CGModel.GetModelHasVariantParameters"))
%endfunction

%% Function: SLibGenGroupedVPrmsBuffer
%% Abstract:
%%   Generates code for unstructured variant parameters which are grouped using variant conditions.
%%   Loops over all variant parameters having ExportedGlobal storage class.
%% other storage classes are handled in data_customdata.tlc
%% TopTester: matlab/test/toolbox/simulink/variants/var-parameter/tRemoveRedundantNetIfCond.m
%% TopTester: matlab/test/toolbox/simulink/variants/var-parameter/tVPrmGrouping.m
%function SLibGenGroupedVPrmsBuffer(storageClass, applyPragma, skippedIdxs, startIdx) void
    %assign concatLocalAndNetIds = CGMODEL_ACCESS("CGModel.GetConcatLocalAndNetIdsForSC", storageClass)
    %assign groupedVPrmDefn = ""
    %assign mdlParam = ""
    %assign mdlPrmIdx = 0
    %assign netSize = SIZE(concatLocalAndNetIds,1)
    %foreach concatIdx = netSize
        %assign netGenDefn = TLC_FALSE
        %assign definition = ""
        %assign localCondStrs = CGMODEL_ACCESS("CGModel.GetLocalCondsForNetCond", concatLocalAndNetIds[concatIdx], storageClass)
        %assign localSize = SIZE(localCondStrs,1)
        %foreach localCondIdx = localSize
            %assign choicedefinition = ""
            %assign mdlPrmVec = CGMODEL_ACCESS("CGModel.GetModelPrmIdxVec", concatLocalAndNetIds[concatIdx], storageClass, localCondStrs[localCondIdx])
            %assign choiceVec = CGMODEL_ACCESS("CGModel.GetChoiceIdxVec", concatLocalAndNetIds[concatIdx], storageClass, localCondStrs[localCondIdx])
            %foreach idx = SIZE(mdlPrmVec,1)
                %assign mdlPrmIdx = mdlPrmVec[idx]
                %assign choiceIdx = choiceVec[idx]
                %assign mdlParam = Parameter[mdlPrmIdx]
                %% check if the parameter is from global workspace
                %assign genDefn = (skippedIdxs[mdlPrmIdx - startIdx] == 1)
                %assign netGenDefn = genDefn || netGenDefn
                %if !genDefn
                    %continue
                %endif
                %% generating choice definition
                %assign choicedefinition = choicedefinition + SLibGenUnstrModelParamInstance(mdlParam, applyPragma, mdlPrmIdx, choiceIdx)
                %% updating local symbol table
                %if choiceIdx == localSize -1
                    SLibUpdateLocalSymbolTableAndSymbolicValue(mdlParam, choicedefinition)
                %endif
            %endforeach %% for each choice
            %if netGenDefn
                %assign definition = definition + SLibWrapVariantVariableCondition(choicedefinition,localCondStrs[localCondIdx], localCondIdx, localSize)
            %endif
        %endforeach %% for each local condition
        %if netGenDefn
            %if CGMODEL_ACCESS("CGModel.IsNetConditionGuardNeeded", mdlPrmIdx)
                %assign vcRecord = SLibGetDataInlineVariantNetConditions(mdlParam)
                %assign ifCond = vcRecord.ifCond
                %assign ifEndCond = vcRecord.endIfCond
                %assign groupedVPrmDefn = groupedVPrmDefn + ifCond + "\n" + definition  + "\n" + ifEndCond + "\n"
            %else
                %assign groupedVPrmDefn = groupedVPrmDefn + definition
            %endif
        %endif
    %endforeach %% for each net condition
    %return groupedVPrmDefn
%endfunction %% SLibGenGroupedVPrmsBuffer


%% Function: SLibIsModelParamConst =================================================================
%% Abstract:
%%   Returns true if the ModelParameter is:
%%   - StorageClass "Custom", and has "const" in its CSC/MemSec qualifier
%%   - or, has "const" in its TypeQualifier
%%
%function SLibIsModelParamConst(mdlPrm) void
    %if mdlPrm.StorageClass == "Custom"
        %assign msDefn = SLibGetMemorySectionDefForData(mdlPrm)
        %assert !ISEMPTY(msDefn)
        %assign qualifier = SLibGetQualifier(msDefn)
    %else
        %assign qualifier = mdlPrm.TypeQualifier
    %endif

    %if !WHITE_SPACE(qualifier)
        %if ISSUBSTRING(qualifier, "const")
            %return TLC_TRUE
        %endif
    %endif

    %return TLC_FALSE
%endfunction

%% Function: SLibIsModelParamMacro =================================================================
%% Abstract:
%%   Returns true if the ModelParameter is #define macro
%%
%function SLibIsModelParamMacro(mdlPrm) void
    %if mdlPrm.StorageClass == "Custom"
        %assign cscDefn = mdlPrm.CSCDefn
        %assign dataInit = SLibGetDataInitForData(cscDefn, mdlPrm)
        %return dataInit == "Macro"
    %else
        %return TLC_FALSE
    %endif
%endfunction

%% Function: SLibIsModelParamFileOrAutoScope =======================================================
%% Abstract:
%%   Returns true if the ModelParameter DataScope is "File" or "Auto"
%%
%function SLibIsModelParamFileOrAutoScope(mdlPrm) void
    %if mdlPrm.StorageClass == "Custom"
        %assign cscDefn = mdlPrm.CSCDefn
        %assign dataScope = SLibGetDataScope(cscDefn, mdlPrm)
        %return (dataScope == "File" || dataScope == "Auto")
    %else
        %return TLC_FALSE
    %endif
%endfunction

%% Function: LibCoderDataGroupInstanceIsEmpty ======================================================
%% Abstract:
%%   Determine if the DWork instance cache is empty
%%
%function LibCoderDataGroupInstanceIsEmpty() void
    %<LibTrapCacheAssert(CoderDataGroupInstance)>
    %return WHITE_SPACE(CoderDataGroupInstance)
%endfunction


%% Function: LibDumpCoderDataGroupInstance =========================================================
%% Abstract:
%%   Place the DWork instance cache in the output stream.
%%
%function LibDumpCoderDataGroupInstance() Output
    %<LibTrapCacheAssert(CoderDataGroupInstance)>\
    %<CoderDataGroupInstance>\
    %<SLibResetTLCGlobal("CoderDataGroupInstance")>\
%endfunction


%% Function: LibDWorkInstanceIsEmpty ===============================================================
%% Abstract:
%%   Determine if the DWork instance cache is empty
%%
%function LibDWorkInstanceIsEmpty() void
    %<LibTrapCacheAssert(DWorkInstance)>
    %return WHITE_SPACE(DWorkInstance)
%endfunction


%% Function: LibDumpDWorkInstance ==================================================================
%% Abstract:
%%   Place the DWork instance cache in the output stream.
%%
%function LibDumpDWorkInstance() Output
    %<LibTrapCacheAssert(DWorkInstance)>\
    %<DWorkInstance>\
    %<SLibResetTLCGlobal("DWorkInstance")>\
%endfunction


%% Function: LibPrevZCStatesInstanceIsEmpty ========================================================
%% Abstract:
%%   Determine if the previous zc states instance cache is empty
%%
%function LibPrevZCStatesInstanceIsEmpty() void
    %<LibTrapCacheAssert(PrevZCStatesInstance)>
    %return WHITE_SPACE(PrevZCStatesInstance)
%endfunction


%% Function: LibDumpPrevZCStatesInstance ===========================================================
%% Abstract:
%%   Place the ZCStates instance cache in the output stream.
%%
%function LibDumpPrevZCStatesInstance() Output
    %<LibTrapCacheAssert(PrevZCStatesInstance)>\
    %<PrevZCStatesInstance>\
    %<SLibResetTLCGlobal("PrevZCStatesInstance")>\
%endfunction


%% Function: LibExternalInputsInstanceIsEmpty ======================================================
%% Abstract:
%%   Determine if the external inputs instance cache is empty
%%
%function LibExternalInputsInstanceIsEmpty() void
    %if SLibAutosarActive() || SLibHasRootInportCoderGroup()
        %return TLC_TRUE
    %else
        %<LibTrapCacheAssert(ExternalInputsInstance)>
        %return WHITE_SPACE(ExternalInputsInstance)
    %endif
%endfunction


%% Function: LibDumpExternalInputsInstance =========================================================
%% Abstract:
%%   Place the external inputs instance cache in the output stream.
%%
%function LibDumpExternalInputsInstance() Output
    %<LibTrapCacheAssert(ExternalInputsInstance)>\
    %<ExternalInputsInstance>\
    %<SLibResetTLCGlobal("ExternalInputsInstance")>\
%endfunction

%% Function: LibExternalInputSizesInstanceIsEmpty ==================================================
%% Abstract:
%%   Determine if the external input sizes instance cache is empty
%%
%function LibExternalInputSizesInstanceIsEmpty() void
    %if SLibAutosarActive()
        %return TLC_TRUE
    %else
        %<LibTrapCacheAssert(ExternalInputSizesInstance)>
        %return WHITE_SPACE(ExternalInputSizesInstance)
    %endif
%endfunction


%% Function: LibDumpExternalInputSizesInstance =====================================================
%% Abstract:
%%   Place the external input sizes instance cache in the output stream.
%%
%function LibDumpExternalInputSizesInstance() Output
    %<LibTrapCacheAssert(ExternalInputSizesInstance)>\
    %<ExternalInputSizesInstance>\
    %<SLibResetTLCGlobal("ExternalInputSizesInstance")>\
%endfunction

%% Function: LibExternalOutputsInstanceIsEmpty =====================================================
%% Abstract:
%%   Determine if the external outputs instance cache is empty
%%
%function LibExternalOutputsInstanceIsEmpty() void
    %if SLibAutosarActive() || SLibHasRootOutportCoderGroup()
        %return TLC_TRUE
    %else
        %<LibTrapCacheAssert(ExternalOutputsInstance)>
        %return WHITE_SPACE(ExternalOutputsInstance)
    %endif
%endfunction


%% Function: LibDumpExternalOutputsInstance ========================================================
%% Abstract:
%%   Place the external outputs instance cache in the output stream.
%%
%function LibDumpExternalOutputsInstance() Output
    %<LibTrapCacheAssert(ExternalOutputsInstance)>\
    %<ExternalOutputsInstance>\
    %<SLibResetTLCGlobal("ExternalOutputsInstance")>\
%endfunction

%function LibExternalOutputSizesInstanceIsEmpty() void
    %if SLibAutosarActive()
        %return TLC_TRUE
    %else
        %<LibTrapCacheAssert(ExternalOutputSizesInstance)>
        %return WHITE_SPACE(ExternalOutputSizesInstance)
    %endif
%endfunction

%function LibDumpExternalOutputSizesInstance() Output
    %<LibTrapCacheAssert(ExternalOutputSizesInstance)>\
    %<ExternalOutputSizesInstance>\
    %<SLibResetTLCGlobal("ExternalOutputSizesInstance")>\
%endfunction

%% Function: LibContStatesInstanceIsEmpty ==========================================================
%% Abstract:
%%   Determine if the continuous states instance cache is empty
%%
%function LibContStatesInstanceIsEmpty() void
    %<LibTrapCacheAssert(ContStatesInstance)>
    %return WHITE_SPACE(ContStatesInstance)
%endfunction


%% Function: LibDumpContStatesInstance =============================================================
%% Abstract:
%%   Place the continuous states instance cache in the output stream.
%%
%function LibDumpContStatesInstance() Output
    %<LibTrapCacheAssert(ContStatesInstance)>\
    %<ContStatesInstance>\
    %<SLibResetTLCGlobal("ContStatesInstance")>\
%endfunction

%% Function: LibContStatesDisabledInstanceIsEmpty ==================================================
%% Abstract:
%%   Determine if the  disabled states instance cache is empty
%%
%function LibContStatesDisabledInstanceIsEmpty() void
    %<LibTrapCacheAssert(ContStatesDisabledInstance)>
    %return WHITE_SPACE(ContStatesDisabledInstance)
%endfunction

%% Function: LibDumpContStatesDisabledInstance =====================================================
%% Abstract:
%%   Place the disabled states  instance cache in the output stream.
%%
%function LibDumpContStatesDisabledInstance() Output
    %<LibTrapCacheAssert(ContStatesDisabledInstance)>\
    %<ContStatesDisabledInstance>\
    %<SLibResetTLCGlobal("ContStatesDisabledInstance")>\
%endfunction

%% Function: LibPeriodicContStatesInstanceIsEmpty
%% Abstract:
%%   Determine if the periodic continuous states instance cache is empty
%%
%function LibPeriodicContStatesInstanceIsEmpty() void
    %<LibTrapCacheAssert(PeriodicStateIndInstance)>
    %<LibTrapCacheAssert(PeriodicStateRngInstance)>
    %return WHITE_SPACE(PeriodicStateIndInstance) && WHITE_SPACE(PeriodicStateRngInstance)
%endfunction

%% Function: LibDumpPeriodicContStatesInstance
%% Abstract:
%%   Place the periodic continuous states instance cache in the output stream.
%%
%function LibDumpPeriodicContStatesInstance() Output
    %<LibTrapCacheAssert(PeriodicStateIndInstance)>\
    %<LibTrapCacheAssert(PeriodicStateRngInstance)>\
    %<PeriodicStateIndInstance>\
    %<PeriodicStateRngInstance>\
    %<SLibResetTLCGlobal("PeriodicStateIndInstance")>\
    %<SLibResetTLCGlobal("PeriodicStateRngInstance")>\
%endfunction


%% Function: LibMassMatricesLocalInstanceIsEmpty ===================================================
%% Abstract:
%%   Determine if any of the mass matrices instance caches is empty
%%
%function LibMassMatricesInstanceIsEmpty() void

    %<LibTrapCacheAssert(MassMatricesGlobalInstance)>
    %return ( WHITE_SPACE(MassMatricesGlobalInstance) )

%endfunction


%% Function: LibDumpMassMatricesInstance ===========================================================
%% Abstract:
%%   Place the mass matrices instance caches in the output stream.
%%
%function LibDumpMassMatricesInstance() Output

    %<LibTrapCacheAssert(MassMatricesGlobalInstance)>\
    %<MassMatricesGlobalInstance>\
    %<SLibResetTLCGlobal("MassMatricesGlobalInstance")>\

%endfunction

%% Function: LibBlockIOInstanceIsEmpty =============================================================
%% Abstract:
%%   Determine if the block I/O instance instance cache is empty
%%
%function LibBlockIOInstanceIsEmpty() void
    %<LibTrapCacheAssert(BlockIOInstance)>
    %return LibBlockIOStructIsEmpty()
%endfunction


%% Function: LibDumpBlockIOInstance ================================================================
%% Abstract:
%%   Place the block I/O instance cache in the output stream.
%%
%function LibDumpBlockIOInstance() Output
    %<LibTrapCacheAssert(BlockIOInstance)>\
    %<BlockIOInstance>\
    %<SLibResetTLCGlobal("BlockIOInstance")>\
%endfunction


%% Function: LibConstBlockIOInstanceIsEmpty ========================================================
%% Abstract:
%%   Determine if the const block I/O instance instance cache is empty
%%
%function LibConstBlockIOInstanceIsEmpty() void
    %<LibTrapCacheAssert(ConstBlockIOInstance)>
    %return WHITE_SPACE(ConstBlockIOInstance)
%endfunction


%% Function: LibDumpConstBlockIOInstance ===========================================================
%% Abstract:
%%   Place the const block I/O instance cache in the output stream.
%%
%function LibDumpConstBlockIOInstance() Output
    %<LibTrapCacheAssert(ConstBlockIOInstance)>\
    %<ConstBlockIOInstance>\
    %<SLibResetTLCGlobal("ConstBlockIOInstance")>\
%endfunction


%% Function: LibExportedGlobalSignalsInstanceIsEmpty ===============================================
%% Abstract:
%%   Determine if the exported global signals instance instance cache is empty
%%
%function LibExportedGlobalSignalsInstanceIsEmpty() void
    %<LibTrapCacheAssert(ExportedGlobalSignalsInstance)>
    %return WHITE_SPACE(ExportedGlobalSignalsInstance)
%endfunction


%% Function: LibDumpExportedGlobalSignalsInstance ==================================================
%% Abstract:
%%   Place the exported global signals instance cache in the output stream.
%%
%function LibDumpExportedGlobalSignalsInstance() Output
    %<LibTrapCacheAssert(ExportedGlobalSignalsInstance)>\
    %<ExportedGlobalSignalsInstance>\

    %<SLibResetTLCGlobal("ExportedGlobalSignalsInstance")>\
%endfunction

%% Function: LibCustomReusableSignalsInstanceIsEmpty ===============================================
%% Abstract:
%%   Determine if the exported global signals instance instance cache is empty
%%
%function LibCustomReusableSignalsInstanceIsEmpty() void
    %<LibTrapCacheAssert(CustomReusableSignalsInstance)>
    %return WHITE_SPACE(CustomReusableSignalsInstance)
%endfunction


%% Function: LibDumpCustomReusableSignalsInstance ==================================================
%% Abstract:
%%   Place the exported global signals instance cache in the output stream.
%%
%function LibDumpCustomReusableSignalsInstance() Output
    %<LibTrapCacheAssert(CustomReusableSignalsInstance)>\
    %<CustomReusableSignalsInstance>\

    %<SLibResetTLCGlobal("ExportedGlobalSignalsInstance")>\
%endfunction


%% Function: LibExportedGlobalDWorkInstanceIsEmpty =================================================
%% Abstract:
%%   Determine if the exported global dwork instance instance cache is empty
%%
%function LibExportedGlobalDWorkInstanceIsEmpty() void
    %<LibTrapCacheAssert(ExportedGlobalDWorkInstance)>
    %return WHITE_SPACE(ExportedGlobalDWorkInstance)
%endfunction


%% Function: LibDumpExportedGlobalDWorkInstance ====================================================
%% Abstract:
%%   Place the exported global dwork instance cache in the output stream.
%%
%function LibDumpExportedGlobalDWorkInstance() Output
    %<LibTrapCacheAssert(ExportedGlobalDWorkInstance)>\
    %<ExportedGlobalDWorkInstance>\

    %<SLibResetTLCGlobal("ExportedGlobalDWorkInstance")>\
%endfunction

%function SLibGetModelParamName(mdlParam) void
    %assign pName = LibGetRecordIdentifier(mdlParam)
    %if (mdlParam.StorageClass == "Auto" || mdlParam.StorageClass == "Auto_SFCN") && ...
        SLibIsParamUnstructured(mdlParam)
        %assign pName = FcnGetAutoParamIdentifier(mdlParam)
    %endif
    %return pName
%endfunction

%function FcnGetModelParamCGTypeIdx(mdlParam) void
    %assign useStdContainer = TLC_FALSE
    %assign hasSymbolicWidth = LibRecordHasSymbolicWidth(mdlParam)
    %assign width = SLibGetWidthOfValueFromParamRec(mdlParam)
    %if (hasSymbolicWidth || width > 1) && SLibIsContainerCGTypeStdContainer(mdlParam)
        %assign useStdContainer = TLC_TRUE
    %endif
    %return SLibGetRecordContainerOptStdCGTypeIdx(mdlParam, useStdContainer)
%endfunction

%function FcnUpdateModelParamDeclFilePackaging(mdlParam, headerFile) void
    %<SLibUpdateGlobalSymbolTableForFile(headerFile, SLibGetModelParamName(mdlParam))>
    %<SLibUpdateCGTypeUsedByFile(headerFile, FcnGetModelParamCGTypeIdx(mdlParam))>
%endfunction

%endif %% _COMMONPRMLIB_

%% [EOF] commonprmlib.tlc
