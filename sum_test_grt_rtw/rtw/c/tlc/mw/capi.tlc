%assign tempSLfeature = CGMODEL_ACCESS("CGModel.CAPIEmitMethod")

%% ============================================================================
%% Abstract:
%%      This system file creates C API files model_capi.c and model_capi.h.
%%      The API facilitates Block IO Signal monitoring and/or Parameter Tuning.
%%
%% Copyright 1994-2023 The MathWorks, Inc.
%%

%if EXISTS(::_CAPI_) == 0
%assign ::_CAPI_ = 1

%include "capilib.tlc"


%% Function FcnGetCAPIGroupInfo ========================================
%% Abstract :
%%   return concatenated list of group args for C API
%function FcnGetCAPIGroupInfo(args, infoType) void
    %assign groupInfo = ""
    %foreach idx = ::CompiledModel.NumCoderDataGroups
        %assign groupInfo = groupInfo + args.group%<infoType>[idx]
    %endforeach
    %return groupInfo
%endfunction

%% Function SLibWriteToCAPIFilesCpp ========================================
%% Abstract :
%% TopTester: test/toolbox/simulink/variants/var-general/tStringSupport.m
%function SLibWriteToCAPIFilesCpp() void
    %assign isMultiInstanceERTOrModelReference = IsMultiInstanceERTOrModelReference()
    %assign isModelReferenceSimTarget = IsModelReferenceSimTarget()
    %assign fcnDynamicAPI = FcnDynamicAPI()
    %assign fcnCAPIRootIOSupport = FcnCAPIRootIOSupport()
    %with ::CompiledModel.GlobalMemoryMap
        %with BlockHierarchyMap
            %assign useDatasetLoggingHier = TLC_FALSE
            %assign numLogHierSigs = 0
            %if IsModelReferenceSimTarget() && EXISTS(NumSignalHierLoggingInfo) && (NumSignalHierLoggingInfo > 0)
                %assign useDatasetLoggingHier = TLC_TRUE
                %assign numLogHierSigs = NumSignalHierLoggingInfo
            %endif
            %if IsModelReferenceSimTarget() && EXISTS(NumStateflowSigLogInfo) && (NumStateflowSigLogInfo > 0)
                %assign numStateflowLoggedSigs = NumStateflowSigLogInfo
                %assign stateflowLoggedSigsName = "rtStateflowChartLoggingInfo"
            %else
                %assign numStateflowLoggedSigs = 0
                %assign stateflowLoggedSigsName = SLibGetNullDefinitionFromTfl()
            %endif %% Dataset logging hierarchy info
            %assign sysRanDWorkLen  = SIZE(SubsystemRanBC.SysRanDWork, 1)
            %assign existsNumSignalHierarchyDescriptors = EXISTS(NumSignalHierarchyDescriptors)
            %%assign tContextSystems = "rtContextSystems"
            %%assign loggingInfoLen  = SIZE(loggingInfoStartIdx, 1)
        %endwith  %% BlockHierarchyMap
    %endwith %% ::CompiledModel.GlobalMemoryMap

    %%calling matlab function
    %assign ::tempRepo = FEVAL("genCapiInCpp","%<::CompiledModel.Name>",isMultiInstanceERTOrModelReference,...
        isModelReferenceSimTarget,fcnDynamicAPI,RTWCAPISignals,RTWCAPIParams,RTWCAPIStates,...
        RTWCAPIRootIO,UsingMalloc,useDatasetLoggingHier,numLogHierSigs,numStateflowLoggedSigs,...
        stateflowLoggedSigsName,sysRanDWorkLen,fcnCAPIRootIOSupport,existsNumSignalHierarchyDescriptors,"")
%endfunction %% SLibWriteToCAPIFilesCpp()

%% Function SLibWriteToCAPIFiles ========================================
%% Abstract :
%%   This function creates model_capi.c and model_capi.h files
%%     o For ERT based target, the files are written using code generation
%%       templates. The _capi.c file uses ERTSrcFileBannerTemplate and
%%       _capi.h file uses ERTHdrFileBannerTemplate
%%     o For non-ERT or ModelReference target, the code templates are
%%       ignored and a lightweight template is used to write
%%       the files to disk
%%
%function SLibWriteToCAPIFiles() void

    %realformat "CONCISE"

    %<SetCurrentUtilsIncludesIdx("capi_src_util_incl")>

    %% Put necessary includes in model.h file
    %openfile includesBuf
    %if ::isRAccel || IsModelReferenceSimTarget()
        %assign modelMapHeader = "rtw_modelmap_simtarget.h"
        %assign modelMapHeaderWithPath = modelMapHeader
    %else
        %assign modelMapHeader = "rtw_modelmap.h"
        %assign modelMapHeaderWithPath = "$(MATLAB_ROOT)/rtw/c/src/" + modelMapHeader
    %endif
    #include "%<modelMapHeader>"
    %<SLibAddToStaticHeaders(modelMapHeaderWithPath)>
    %closefile includesBuf

    %% also include modelMapHeader in private file if RemoveMdlrefHideChild is on.
    %<SLibCacheCodeToFile("baseMdl_hdr_incl", includesBuf)>
    %if RemoveNonEmptyHideChildSymbol()
        %<SLibCacheCodeToFile("mdl_priv_hdr_incl", includesBuf)>
    %endif
    %if ::isRAccel || IsModelReferenceSimTarget()
        %<SLibUpdateHeadersNeededByFile(SLibGetFullFileNameForCode("baseMdl_hdr_incl"), "rtw_modelmap_simtarget.h")>
        %if RemoveNonEmptyHideChildSymbol()
            %<SLibUpdateHeadersNeededByFile(SLibGetFullFileNameForCode("mdl_priv_hdr_incl"), "rtw_modelmap_simtarget.h")>
        %endif
    %else
        %<SLibUpdateHeadersNeededByFile(SLibGetFullFileNameForCode("baseMdl_hdr_incl"), "rtw_modelmap.h")>
        %if RemoveNonEmptyHideChildSymbol()
            %<SLibUpdateHeadersNeededByFile(SLibGetFullFileNameForCode("mdl_priv_hdr_incl"), "rtw_modelmap.h")>
        %endif
    %endif

    %assign HeaderFile = LibGetMdlCapiHdrBaseName()
    %% Put necessary includes in model.c(pp) file
    %assign srcFileName = SLibGetFullFileNameForCode("baseMdl_src_incl")
    %openfile includesBuf
    %if ((::CompiledModel.RTWStatesLogging==1) || (RTWCAPISignals==1)) && ...
        MatFileLogging
        #include "rt_logging_mmi.h"
        %<SLibUpdateHeadersNeededByFile(srcFileName, "rt_logging_mmi.h")>
    %endif
    #include "%<HeaderFile>.h"
    %closefile includesBuf
    %<SLibCacheCodeToFile("baseMdl_src_incl", includesBuf)>
    %<SLibUpdateHeadersNeededByFile(srcFileName, "%<HeaderFile>.h")>

    %% If necessary, add logging utility files to list of model sources
    %if ((::CompiledModel.RTWStatesLogging==1) || (RTWCAPISignals==1)) && ...
        MatFileLogging
        %if ::isRAccel || IsModelReferenceSimTarget()
        %else
            %<SLibAddToStaticSources("rt_logging_mmi.c")>
            %<SLibAddToStaticSources("rtw_modelmap_utils.c")>
        %endif
    %endif

    %% Generate Interface API (GlobalMemoryMap) for non custom storage class data
    %<SLibMapData()>

    %% Create Source file model_capi.c(pp) to cache Signals/parameters/states
    %% and data maps

    %% Add neccesary includes to model_capi.c - Create the Include Buffer
    %assign baseSysIdx = GetBaseSystemIdx()
    %assign baseName   = SLibGetSystemOutputHdrFileBaseName(System[baseSysIdx])
    %openfile tmpCAPI_C_Includes
    %<FcnWriteCAPIHeadersandDefines(baseName)>
    %closefile tmpCAPI_C_Includes
    %<SLibCacheCodeToFile("capi_src_custom_incl", tmpCAPI_C_Includes)>

    %% Decide whether you want to write capi files directly to disk or store
    %% them in buffers and expand later via code templates.
    %%
    %% Code Templates are used for ERT targets, unless WriteCAPIUsingTemplates is off.
    %% The WriteCAPIUsingTemplates flag is set via ConfigSet->TLC options.
    %if SLibIsERTTarget()
        %if (WriteCAPIUsingTemplates == 0)
            %assign useTemplates = TLC_FALSE
        %else
            %assign useTemplates = TLC_TRUE
        %endif
    %else
        %assign useTemplates   = TLC_FALSE
    %endif

    %%for generating C-API in cpp
    %if tempSLfeature==1 || tempSLfeature==2
        %assign useTemplates = TLC_TRUE
    %endif

    %%for generating C-API in cpp
    %if tempSLfeature==1
        %assign isMultiInstanceERTOrModelReference = IsMultiInstanceERTOrModelReference()
        %assign isModelReferenceSimTarget = IsModelReferenceSimTarget()
        %assign fcnDynamicAPI = FcnDynamicAPI()
        %assign fcnCAPIRootIOSupport = FcnCAPIRootIOSupport()
        %with ::CompiledModel.GlobalMemoryMap
            %with BlockHierarchyMap
                %assign useDatasetLoggingHier = TLC_FALSE
                %assign numLogHierSigs = 0
                %if IsModelReferenceSimTarget() && EXISTS(NumSignalHierLoggingInfo) && (NumSignalHierLoggingInfo > 0)
                    %assign useDatasetLoggingHier = TLC_TRUE
                    %assign numLogHierSigs = NumSignalHierLoggingInfo
                %endif
                %if IsModelReferenceSimTarget() && EXISTS(NumStateflowSigLogInfo) && (NumStateflowSigLogInfo > 0)
                    %assign numStateflowLoggedSigs = NumStateflowSigLogInfo
                    %assign stateflowLoggedSigsName = "rtStateflowChartLoggingInfo"
                %else
                    %assign numStateflowLoggedSigs = 0
                    %assign stateflowLoggedSigsName = SLibGetNullDefinitionFromTfl()
                %endif %% Dataset logging hierarchy info
                %assign sysRanDWorkLen  = SIZE(SubsystemRanBC.SysRanDWork, 1)
                %assign existsNumSignalHierarchyDescriptors = EXISTS(NumSignalHierarchyDescriptors)
                %%assign tContextSystems = "rtContextSystems"
                %%assign loggingInfoLen  = SIZE(loggingInfoStartIdx, 1)
            %endwith  %% BlockHierarchyMap
        %endwith %% ::CompiledModel.GlobalMemoryMap

        %%calling matlab function
        %assign ::tempRepo = FEVAL("genCapiInCpp","%<::CompiledModel.Name>",isMultiInstanceERTOrModelReference,...
            isModelReferenceSimTarget,fcnDynamicAPI,RTWCAPISignals,RTWCAPIParams,RTWCAPIStates,...
            RTWCAPIRootIO,UsingMalloc,useDatasetLoggingHier,numLogHierSigs,numStateflowLoggedSigs,...
            stateflowLoggedSigsName,sysRanDWorkLen,fcnCAPIRootIOSupport,existsNumSignalHierarchyDescriptors,"")
    %endif

    %if (useTemplates)
        %% if using templates, store the CAPI structures in the Functions section
        %% of the model_capi.c file
        %openfile tmpCAPI_Functions
        %<FcnWriteCAPIStructures(tmpCAPI_Functions)>
        %closefile tmpCAPI_Functions

        %<SLibCacheCodeToFile("capi_fcn_defn", tmpCAPI_Functions)>

    %else
        %% if not using templates, write directly to disk
        %assign FileName  = SLibGetFileNameForCode("mdl_capi_src") + ".%<::LangFileExt>"
        %assign FileType  = "source"

        %<LibWriteToStandardOutput("### Writing %<FileType> file %<FileName>")>
        %openfile outputFile = FileName
        /*
        * %<FileName>
        *
        %<SLibCommonHeaderInfo()>\
        */

        %<tmpCAPI_C_Includes>\
        %<FcnWriteCAPIStructures(outputFile)>

        /* EOF: %<FileName> */
        %closefile outputFile
        %% Set the filter to 1, to prevent re-writing to disk
        %assign capiCFile = SLibGetFileRecForCode("mdl_capi_src")
        %<SLibSetModelFileAttribute(capiCFile, "Filter", 1)>
        %<SLibAddGeneratedFileToList(FileName,"interface","source","")>
    %endif




    %% Do not early return before resetting this global
    %<SetCurrentUtilsIncludesIdx("")>

    %% Create Header file model_capi.h and place extern function prototypes
    %% Include model.h in model_capi.h
    %assign baseSysIdx = GetBaseSystemIdx()
    %assign baseName   = SLibGetSystemOutputHdrFileBaseName(System[baseSysIdx])
    %openfile tmpCAPI_H_Includes

    #include "%<baseName>.h"
    %if RemoveNonEmptyHideChildSymbol()
        %<SLibIncludePrivateHeader()>
    %endif

    %closefile tmpCAPI_H_Includes
    %<SLibCacheCodeToFile("capi_hdr_incl", tmpCAPI_H_Includes)>
    %% Add a function prototype in model_capi.h
    %assign curBlockFcn = ::BlockFcn
    %assign ::BlockFcn = "InitializeDataMapInfo"

    %openfile tmpCAPI_H_Extern

    %assign args = ::CompiledModel.CAPIFunctionArgs
    %assign typePrefix = SLibGetModelTypesNamespacePrefix()
    %if IsModelReferenceSimTarget()
        %assign dwDecl = ""
        %if args.isDwArgDeclSame
            %assign dwDecl = args.dwArg
        %endif
        %assign genCoderGroupArgsForClassOnly = !RTMMdlRefHasLocalSolver()
        %<LibExternInFcnDecls()>void %<FcnGetModelInitializeDataMapInfoName()>(%<typePrefix>%<::tSimStructType> *const %<::tSimStruct>
        %<args.uArg>%<args.bArg>%<args.pArg>%<dwDecl>%<args.xArg>%<args.ssArg>%<FcnGetCAPIGroupInfo(args, "Arg")>, void *sysRanPtr, int contextTid);
        %<SLibUpdateHeadersNeededByFile(SLibGetFullFileNameForCode("capi_ext_fcn_decl"), "%<baseName>.h")>\
        %if RemoveNonEmptyHideChildSymbol()
            %if !ISEMPTY(SLibGetFileNameForCode("mdl_priv_hdr"))
                %assign privHdr = SLibGetFileNameForCode("mdl_priv_hdr") + ".h"
                %<SLibUpdateHeadersNeededByFile(SLibGetFullFileNameForCode("capi_ext_fcn_decl"), privHdr)>
            %endif
        %endif
    %else
        %assign simstructDecl = ""
        %if (::isRAccel || isRSim) && !IsModelReferenceTarget()
            %% In rapid accelerator and rsim, _capi.h includes model.h, which externs the root simstruct
            %% Having the simstruct as an argument here will shadow the extern declaration
        %else
            %if MultiInstanceERTCode || IsModelReferenceTarget()
                %assign simstructDecl = "%<typePrefix>%<::tSimStructType> *const %<::tSimStruct>"
            %endif
        %endif
        %assign dwDecl = ""
        %if args.isDwArgDeclSame
            %assign dwDecl = args.dwArg
        %endif
        %assign fcnArgs = "%<simstructDecl>%<args.uArg>%<args.bArg>%<args.pArg>%<dwDecl>%<args.xArg>%<args.ssArg>%<FcnGetCAPIGroupInfo(args, "Arg")>"
        %if ISEMPTY(fcnArgs)
            %assign fcnArgs = "void"
        %else
            %<SLibUpdateHeadersNeededByFile(SLibGetFullFileNameForCode("capi_ext_fcn_decl"), "%<baseName>.h")>\
            %if RemoveNonEmptyHideChildSymbol()
                %if !ISEMPTY(SLibGetFileNameForCode("mdl_priv_hdr"))
                    %assign privHdr = SLibGetFileNameForCode("mdl_priv_hdr") + ".h"
                    %<SLibUpdateHeadersNeededByFile(SLibGetFullFileNameForCode("capi_ext_fcn_decl"), privHdr)>
                %endif
            %endif
        %endif
        %<LibExternInFcnDecls()>void %<FcnGetModelInitializeDataMapInfoName()>(%<fcnArgs>);

        %<SLibUpdateGlobalSymbolTableForFile(SLibGetFullFileNameForCode("capi_ext_fcn_decl"), FcnGetModelInitializeDataMapInfoName())>
    %endif
    %closefile tmpCAPI_H_Extern
    %assign ::BlockFcn = curBlockFcn

    %<SLibCacheCodeToFile("capi_ext_fcn_decl", tmpCAPI_H_Extern)>

    %if EXISTS(::HostCAPINeeded)
        %<FcnWriteHostHeader()>
    %endif

    %if (useTemplates)
        %% Do nothing. The buffers are already created
    %else
        %% Write model_capi.h directly yo disk.
        %assign capiHFile = SLibGetFileRecForCode("mdl_capi_hdr")
        %assign hFileIdx = capiHFile.Index
        %assign HeaderFile = LibGetMdlCapiHdrBaseName()
        %assign FileName = "%<HeaderFile>.h"
        %assign FileType = "header"
        %assign FileTag  = LibGetModelFileTag(hFileIdx)

        %<LibWriteToStandardOutput("### Writing %<FileType> file %<FileName>")>

        %openfile outputFile = FileName
        /*
        * %<FileName>
        *
        %<SLibCommonHeaderInfo()>\
        */

        %assign includeGuard = SLibGenerateIncludeGuardMacro(FileTag)
        #ifndef %<includeGuard>
        #define %<includeGuard>

        %<tmpCAPI_H_Includes>\
        %<tmpCAPI_H_Extern>\

        #endif /* %<includeGuard> */

        /* EOF: %<FileName> */
        %closefile outputFile
        %<SLibSetModelFileAttribute(capiHFile, "Filter", 1)>
        %<SLibAddGeneratedFileToList(FileName,"interface","header","")>
    %endif
%endfunction %% SLibWriteToCAPIFiles()

%function FcnSetAddrMapInfoWithLogging(im, addr, loggingFcn, comments, ppIf, ppFi, incNumActiveSignals) void
    %assign im.NumDataAddr = im.NumDataAddr + 1
    %assign im.AddrMap = im.AddrMap + addr
    %assign im.LoggingFcns = im.LoggingFcns + loggingFcn
    %assign im.AddrMapComments = im.AddrMapComments + comments
    %assign im.AddrMapIf = im.AddrMapIf + ppIf
    %assign im.AddrMapEndIf = im.AddrMapEndIf + ppFi

    %assign im.NumActiveSignalsDuringCodegen = im.NumActiveSignalsDuringCodegen + incNumActiveSignals

%endfunction

%function FcnSetAddrMapInfo(im, addr, comments, ppIf, ppFi, incNumActiveSignals) void
    %assign im.NumDataAddr = im.NumDataAddr + 1
    %assign im.AddrMap = im.AddrMap + addr
    %assign im.AddrMapComments = im.AddrMapComments + comments
    %assign im.AddrMapIf = im.AddrMapIf + ppIf
    %assign im.AddrMapEndIf = im.AddrMapEndIf + ppFi

    %assign im.NumActiveSignalsDuringCodegen = im.NumActiveSignalsDuringCodegen + incNumActiveSignals

%endfunction

%% Function FcnWriteCAPIStructures ========================================
%% Abstract:
%%   This function implements the bulk of CAPI functionality. It loops over
%%   signals/parameters/states and creates associated structures.
%%
%function FcnWriteCAPIStructures(capiFile) Output
    %assign booleanType = LibGetDataTypeNameFromId(::CompiledModel.tSS_BOOLEAN)
    %assign intType = LibGetDataTypeNameFromId(::CompiledModel.tSS_INTEGER)
    %assign realType = LibGetDataTypeNameFromId(::CompiledModel.tSS_DOUBLE)
    %% Create a record for storing the maps.  The record will be accessed and
    %% updated during the generation of Signal/Parameter maps and
    %% DataType/DimensionMap/DimensionArray/DataAddr/FixPt maps. Here is a
    %% brief on what the fields represent
    %%     xyzMap -  buffer array containing elements of xyz Structure
    %%     xyzMapComments - comments on the elements in the xyz structure
    %%     Numfield - Counter to count the number of "fields" for maps
    %%     xyzKeys  - Hash tables for xyz structure
    %% Notes:
    %%     During Initialization
    %%     o bufer arrays and comments are empty
    %%     o counters (Num...) are zero except NumFixPoint. NumFixPoint=1 as
    %%       the first element in rtFixPt structure is RESERVED for non-fixed
    %%       point data
    %%     o keys are empty records

    %createrecord                 \
    InstMap {                     \
        DataTypeMap            [];  \
        DimensionMap           [];  \
        DimensionMapIf         [];  \
        DimensionMapEndIf      [];  \
        AddrMap                [];  \
        LoggingFcns            [];  \
        AddrMapComments        [];  \
        AddrMapIf              [];  \
        AddrMapEndIf           [];  \
        FixPointMap            [];  \
        LogSignalsBuf          [];  \
        DimArray               [];  \
        DimArrayComments       [];  \
        ElemMap                [];  \
        SampleTimeMap          [];  \
        DoublesMap             [];  \
        GroundsMap             [];  \
        NumBlockParams          0;  \
        NumVariableParams       0;  \
        NumBIOSignals           0;  \
        NumBlockStates          0;  \
        NumRootInputs           0;  \
        NumRootOutputs          0;  \
        NumFixPoint             1;  \
        NumDataTypes            0;  \
        NumDimensionMaps        0;  \
        NumDimArray             0;  \
        NumDataAddr             0;  \
        NumActiveSignalsDuringCodegen             -1;  \
        NumLogSignals           0;  \
        NumElements             1;  \
        NumSampleTimes          0;  \
        NumDoubles              0;  \
        NumGrounds              0;  \
        VarDimsAddrMap         [];  \
        VarDimsAddrMapIf       [];  \
        VarDimsAddrMapEndIf    [];  \
        NumVarDimsAddr          0;  \
        FxpKeys {                   \
        }                           \
        DTypeKeys  {                \
        }                           \
        DimKeys    {                \
        }                           \
        DimArrayKeys {              \
        }                           \
        ElementKeys {               \
        }                           \
        STimeKeys {                 \
        }                           \
        DoubleKeys {                \
        }                           \
        VarDimsAddrKeys {           \
        }                           \
        GroundKeys{                 \
        }                           \
    }
    %assign im = InstMap

    %% Local record for keeping counters of global data in C-API. The counters
    %% will be updated while we loop over signals/params/states. After the loop,
    %% the counter will be used used to determine if an argument is required
    %% in the initialize function. For e.g if (NumBIOSignals == 0), then rtB
    %% will not be passed as an argument to the C-API initialize function.
    %%
    %createrecord InCAPI {        \
        NumBlockParams          0;  \
        NumVariableParams       0;  \
        NumBIOSignals           0;  \
        NumGrndSignals          0;  \
        NumExtInputs            0;  \
        NumSFLocals             0;  \
        NumDiscStates           0;  \
        NumContStates           0;  \
        NumVarDimsSignals       0;  \
        NumRootInputs           0;  \
        NumRootOutputs          0;  \
        NumBlockSignalsMergedByGlobalDwork          0   \
    }

    %addtorecord InCAPI NumDataGroupElements ...
        Vector(%<::CompiledModel.NumCoderDataGroups>) [0@%<::CompiledModel.NumCoderDataGroups>]

    %% initialization for C-API Hooks
    %assign CAPIHooks = FcnCAPIHookInit()

    %assign loggingInfoStartIdx  = []
    %assign loggingInfoBlockPath = []
    %assign loggingInfoPortIndex = []
    %assign loggingInfoSysNum    = []

    %assign nulldef       = SLibGetNullDefinitionFromTfl()
    %assign addrMapIndex = "addressMapIndex"
    %assign addrMapIndexPP = addrMapIndex + "++"
    %assign dynamicInit = ""
    %assign numSignals = "mmiStatic.Signals.numSignals"
    %assign numStates = "mmiStatic.States.numStates"
    %assign numBlockParams = "mmiStatic.Params.numBlockParameters"
    %assign numModelParams = "mmiStatic.Params.numModelParameters"
    %assign numRootInputs = "mmiStatic.Signals.numRootInputs"
    %assign numRootOutputs = "mmiStatic.Signals.numRootOutputs"
    %assign numSignalsPP = numSignals + "++"
    %assign numStatesPP = numStates + "++"
    %assign numBlockParamsPP = numBlockParams + "++"
    %assign numModelParamsPP = numModelParams + "++"
    %assign numRootInputsPP = numRootInputs + "++"
    %assign numRootOutputsPP = numRootOutputs + "++"

    %%Initialize to C declaration of false, which allows using simplify from C expression function
    %assign getAddrMapIdxVarCond = "0"

    %% Multi Instance storage qualifier
    %assign constKeyword =  IsMultiInstanceERTOrModelReference() || FcnDynamicAPI() ? ...
        "" : "const"

    %assign needsAddressMapIndexVar = TLC_FALSE

    %assign isRM = %<CGMODEL_ACCESS("CGModel.IsRowMajor")>

    %% Check if model Name has to be prefixed to structs
    %assign prefix       =  (::PrefixModelToStructs) ? "%<Name>_" : ""

    %assign equalSign = LibGetDataInitEqualSign()
    %assign scalarTokens = LibGetScalarDataInitTokens()

    %%------------SLRTSPECIALCASE---------------
    %assign ::skipSubSystem  = TLC_FALSE %%skip subsystems
    %assign ::skipwideFxPt   = TLC_FALSE %%skip double word
    %assign ::skipComplex    = TLC_FALSE %%skip complex
    %assign ::skipStruct     = TLC_FALSE %%skip structured
    %assign ::skipBusCreator = TLC_FALSE %%skip bus creator
    %assign ::skipIsProtected = TLC_FALSE
    %if EXISTS(slrt)
        %<init_slrt(capiFile)>
    %endif
    %%------------SLRTSPECIALCASE---------------

    %% BlockHierarchyMap Loop =============================================
    %% The BlockHierarchyMap provides a in memory representation of the
    %% graphical model.
    %% For details refer to matlabroot/rtw/c/tlc/mw/graphmaplib.tlc
    %% The BlockSignal and BlockTuning structures are produced by looping
    %% through the Block records in BlockHierarchyMap.
    %% Begin BlockHierarchy Loop
    %with ::CompiledModel.GlobalMemoryMap
        %with BlockHierarchyMap
            %if RTWCAPISignals == 1
                %% Internal testing facility
                %if EXISTS(capiSigTestFile)
                    %include "%<capiSigTestFile>"
                %endif
                %if tempSLfeature==1 || tempSLfeature==2
                    %openfile datalogging
                %endif
                %% Bus Hierarchy Logging Information for Dataset Logging
                %assign useDatasetLoggingHier = TLC_FALSE
                %if IsModelReferenceSimTarget() && EXISTS(NumSignalHierLoggingInfo) && (NumSignalHierLoggingInfo > 0)
                    %assign useDatasetLoggingHier = TLC_TRUE
                    %assign numLogHierSigs = NumSignalHierLoggingInfo
                    %<FcnWriteDatasetLoggingHier()>
                %endif %% Dataset logging hierarchy info
                %% Stateflow Logging Information for Dataset Logging
                %if IsModelReferenceSimTarget() && EXISTS(NumStateflowSigLogInfo) && (NumStateflowSigLogInfo > 0)
                    %assign numStateflowLoggedSigs = NumStateflowSigLogInfo
                    %<FcnWriteDatasetLoggingSFSignals()>
                    %assign stateflowLoggedSigsName = "rtStateflowChartLoggingInfo"
                %else
                    %assign numStateflowLoggedSigs = 0
                    %assign stateflowLoggedSigsName = nulldef
                %endif %% Dataset logging hierarchy info
                %if tempSLfeature==1 || tempSLfeature==2
                    %closefile datalogging
                    %<SLibCacheCodeToFile("capi_struct_defn", datalogging)>
                %endif

                %%for generating C-API in cpp
                %if tempSLfeature==0 || tempSLfeature==2

                    %if tempSLfeature==2
                        %openfile filterBlkOutputbuf
                    %endif

                    %% Start Signal structure Arrays
                    /* Block output signal information */
                    static %<constKeyword> %<tBlockSignalsType> %<tBlockSignals>[]%<equalSign>{

                        /* addrMapIndex, sysNum, blockPath,
                        * signalName, portNumber, dataTypeIndex, dimIndex, fxpIndex, sTimeIndex
                        */

                        %assign portObj = SLibCreateDummyPortRecord()
                        %assign busIdx = 0
                        %% Set the bus hierarchy flag
                        %assign busHier = TLC_FALSE
                        %assign firstTime = TLC_TRUE
                        %% Signal Hierarchy descriptors are added to the RTW file only when the bdroot property
                        %% "IncludeBusHierarchyInRTWFileBlockHierarchyMap" is turned on, else by default it is set to off.
                        %if IsModelReferenceSimTarget() && !useDatasetLoggingHier && EXISTS(NumSignalHierarchyDescriptors)
                            %% Generate Bus hierarchy structures for modeldatalogs format logging only
                            %assign busHier = TLC_TRUE
                            %assign busIndexVector = Matrix(1,2) [ [-1, -1] ]
                        %endif
                        %%
                        %% Step 1: First process the SignalHierarchyDescriptors
                        %%
                        %if busHier
                            %foreach shdIdx = NumSignalHierarchyDescriptors
                                %with SignalHierarchyDescriptor[shdIdx]
                                    %if ISFIELD(SignalHierarchyDescriptor[shdIdx], "Virtual")
                                        %assign virtBlock = (SignalHierarchyDescriptor[shdIdx].Virtual > 0)
                                    %else
                                        %assign virtBlock = TLC_FALSE
                                    %endif
                                    %% sysIdx: The subsystem index containing the block that produces this bus signal
                                    %assign sysIdx   = SubsystemIdx
                                    %% Currently, the number of HierarchyNodes in a SHD is always one. Assert this here
                                    %% We have left the NumHierarchyNode loop below intact since there may be multiple
                                    %% HierarchyNodes in the future
                                    %if NumHierarchyNodes != 1
                                        %<LibBLockReportFatalError([], "More than one HierarchyNode found for an SHD")>
                                    %endif
                                    %foreach hnIdx = NumHierarchyNodes
                                        %with HierarchyNode[hnIdx]
                                            %if NumRegions > 1 || Type == "BusCreator" || ISFIELD(Region[0], "SigHierIdx")
                                                %addtorecord HierarchyNode[hnIdx] rtwCAPIBusIdx busIdx
                                                %assign busIdx = busIdx + 1
                                                %if firstTime
                                                    %assign busIndexVector[0] = [%<shdIdx>, 0]
                                                    %assign firstTime = TLC_FALSE
                                                %else
                                                    %assign busIndexVector = busIndexVector + [%<shdIdx>, 0]
                                                %endif
                                                %continue
                                            %endif
                                            %assign portObj.SignalSrc = Region[0]._Source
                                            %assert !ISFIELD(Region[0],"BusSelElIdx")
                                            %assign regionOffset      = Region[0].Offset
                                            %assign regionDimensions  = Region[0].Dimensions
                                            %assign sigRec = SLibGetSourceRecord(portObj, 0)
                                            %assign regionIsGround = TLC_FALSE
                                            %assign constString = ""
                                            %assign ppIf = ""
                                            %assign ppFi = ""
                                            %if (::skipIsProtected)
                                                %continue
                                            %endif
                                            %% Skip function-call outputs
                                            %% See geck
                                            %if !(ISEMPTY(sigRec))
                                                %if (RTWCAPITestPtSignals == 1) && ...
                                                    (sigRec.TestPoint !="yes")
                                                    %continue
                                                %endif
                                                %if (sigRec.Invariant == "yes") && ...
                                                    !IsMultiInstanceERTOrModelReference()
                                                    %assign constString = "(void *) "
                                                %endif
                                                %if TYPE(sigRec.TID) != "Number" && ...
                                                    TYPE(sigRec.TID) == "String"
                                                    %% Check for non-sampled signals
                                                    %if sigRec.TID != "constant" && ...
                                                        sigRec.TID != "trigger"
                                                        %% Skip signals other than constant and triggered
                                                        %continue
                                                    %endif
                                                %endif
                                                %if sigRec.MemoryMapIdx[2] == -1
                                                    %% Skip  Local or reuse data
                                                    %continue
                                                %else
                                                    %assign structIdx  = sigRec.MemoryMapIdx[0]
                                                    %assign secIdx     = sigRec.MemoryMapIdx[1]
                                                    %assign dataIdx    = sigRec.MemoryMapIdx[2]
                                                    %if secIdx == -1
                                                        %% Unstructured data
                                                        %assign data = UnstructuredData.Data[dataIdx]
                                                        %assign isComplex   = data.IsComplex
                                                        %assign dataTypeIdx = data.DataTypeIdx
                                                        %assign isPointer   = (data.Access == "indirect") ? 1 : 0
                                                    %elseif structIdx == -1
                                                        %% Custom data
                                                        %assign data = CustomData[secIdx].Data[dataIdx]
                                                        %if !FcnCSCSupportsCAPI(data)
                                                            %continue
                                                        %endif
                                                        %assign isComplex   = data.IsComplex
                                                        %assign dataTypeIdx = data.DataTypeIdx
                                                        %assign isPointer   = (data.Access == "indirect") ? 1 : 0
                                                        %assign constString = "(void *) "
                                                    %else
                                                        %% Structured data
                                                        %assign section     = ...
                                                            StructuredData[structIdx].Section[secIdx]
                                                        %assign data        = section.Data[dataIdx]
                                                        %assign dataTypeIdx = section.DataTypeIdx
                                                        %assign isComplex   = section.IsComplex
                                                        %% data access is "direct"
                                                        %assign isPointer   = TLC_FALSE
                                                    %endif
                                                    %assign ppIf = data.PPIf
                                                    %assign ppFi = data.PPEndIf
                                                %endif %% Non-Local Data
                                                %% For Root Inport blocks that produce a bus, an offset into
                                                %% the rtU structure will be specified in the Region. The
                                                %% data type and complexity of the rtU element will also be
                                                %% specified. Use this information instead of the data type
                                                %% information from the GlobalMemoryMap entry for the inport
                                                %% data type
                                                %if data.IsStruct
                                                    %if ISFIELD(Region[0], "IsComplex")
                                                        %assign isComplex = 1
                                                    %endif
                                                    %if ISFIELD(Region[0], "DataTypeId")
                                                        %assign dataTypeIdx = Region[0].DataTypeId
                                                    %endif
                                                %endif
                                                %if !FcnDataSupportsCAPI(data)
                                                    %continue
                                                %endif
                                                %assign dataAddress = data.BaseAddr
                                                %assign dataIsFixPt = data.IsFixedPoint
                                                %assign dataIsStruct = data.IsStruct
                                            %elseif ISFIELD(Region[0], "GroundDataTypeIdx")
                                                %assign regionIsGround = TLC_TRUE
                                                %assign dataTypeIdx = Region[0].GroundDataTypeIdx
                                                %assign isComplex   = Region[0].GroundIsComplex
                                                %assign isPointer   = TLC_FALSE
                                                %assign dataAddress  = ...
                                                    FcnGetCAPIGroundAddr(im, dataTypeIdx, isComplex, regionDimensions)
                                                %assign dataIsFixPt = TLC_FALSE %% assume false
                                                %assign dataIsStruct = TLC_FALSE %% GROUND signals cannot be structures
                                            %else
                                                %% just skip this record - skip signals with no memory
                                                %% info. Most likely fcn-call signal or ground signal
                                                %% with no additional information.
                                                %continue
                                            %endif
                                            %%
                                            %<FcnOptionallyAddModelRefCanonicalInputNeededByCAPIFlag(sigRec)>
                                            %%
                                            %% Address
                                            %assign addrMapIdx        = im.NumDataAddr
                                            %% Add the index for later
                                            %assert !ISFIELD(HierarchyNode[hnIdx], "rtwCAPIAddrMapIdx")
                                            %addtorecord HierarchyNode[hnIdx] rtwCAPIAddrMapIdx addrMapIdx
                                            %if isPointer
                                                %assign sigAddress      = dataAddress
                                                %assign comments = "%<im.NumDataAddr>: Signal Pointer"
                                            %elseif (regionOffset > 0)
                                                %% For virtual Blocks, e.g Demux
                                                %% compensate for the offset
                                                %if isComplex
                                                    %assign regionOffset  = regionOffset*2
                                                %endif
                                                %assign castString = ""
                                                %if dataIsStruct
                                                    %assign castString = "(char *)"
                                                %endif
                                                %assign sigAddress      = "%<castString> %<dataAddress>"
                                                %if !WHITE_SPACE(castString)
                                                    %assign sigAddress = FcnReplaceCCastWithStaticCastForCPP(sigAddress)
                                                %endif
                                                %assign sigAddress      = constString + ...
                                                    "(%<sigAddress> + %<regionOffset>)"
                                                %assign comments = "%<im.NumDataAddr>: Signal"
                                            %else
                                                %assign sigAddress = constString + dataAddress
                                                %assign comments = "%<im.NumDataAddr>: Signal"
                                            %endif
                                            %% Block Path
                                            %if !(regionIsGround && Region[0].GroundIsSynthesized)
                                                %if GrSrc[0] != -1
                                                    %assign grPath  = SLibMangledGrBlockPath(GrSrc)
                                                %else
                                                    %assert ISFIELD(SignalHierarchyDescriptor[shdIdx], "FullBlockPath") == TLC_TRUE
                                                    %assign grPath = FullBlockPath
                                                %endif
                                                %assign blkPath  = FcnReturnCompliantBlockPath(grPath, "Signal")
                                            %else
                                                %assign grPath = ""
                                                %assign blkPath = ""
                                            %endif
                                            %assign isActiveDuringCodegen = 1
                                            %if(!ISEMPTY(sigRec) && ISFIELD(sigRec,"isActiveDuringCodegen"))
                                                %assign isActiveDuringCodegen = sigRec.isActiveDuringCodegen
                                            %endif
                                            %if isRM
                                                %<FcnSetAddrMapInfoWithLogging(im, sigAddress, "", comments, ppIf, ppFi, isActiveDuringCodegen)>
                                            %else
                                                %<FcnSetAddrMapInfo(im, sigAddress, comments, ppIf, ppFi, isActiveDuringCodegen)>
                                            %endif
                                            %% Signal Label
                                            %assign sigLabel = HierarchyNode[hnIdx].SignalLabel
                                            %% Data Type
                                            %assign dataTypeMapIdx = ...
                                                FcnGetDataTypeMapIdx(dataTypeIdx,isComplex,isPointer,im)
                                            %% Dimension
                                            %if virtBlock || ISFIELD(Region[0], "PartialSrcRegion")
                                                %assign dimMapIdx    = ...
                                                    FcnGetVirtSigDimensionMapIdx(regionDimensions,im, ppIf, ppFi)
                                            %else
                                                %assign dimMapIdx = FcnGetDimensionMapIdx(data,im, ppIf, ppFi)
                                            %endif
                                            %% Fixed Point
                                            %if dataIsFixPt
                                                %assign fxpMapIdx = FcnGetFxpMapIdx(data,im)
                                            %else
                                                %assign fxpMapIdx = 0
                                            %endif
                                            %% sample time index
                                            %if !ISEMPTY(sigRec) && (sigRec.FrameData == "yes")
                                                %assign isFrame =  1
                                            %else
                                                %assign isFrame =  0
                                            %endif
                                            %if !ISEMPTY(sigRec)
                                                %if TYPE(sigRec.TID) == "Number" || TYPE(sigRec.TID) == "Vector"
                                                    %assign tID      = sigRec.TID
                                                    %assign sTimeIdx = FcnGetSampTimeIdx(tID,isFrame,im)
                                                %elseif sigRec.TID == "constant"
                                                    %assign tID      = -2
                                                    %assign sTimeIdx = FcnGetSampTimeIdx(tID,isFrame,im)
                                                %elseif sigRec.TID == "trigger"
                                                    %assign tID      = -1
                                                    %assign sTimeIdx = FcnGetSampTimeIdx(tID,isFrame,im)
                                                %else
                                                    %<SLibReportErrorWithId("RTW:tlc:TIDType")>
                                                %endif
                                                %% get the system number
                                                %assign sysNum = sigRec.SysNum
                                            %else
                                                %assign tID      = -2
                                                %assign sTimeIdx = FcnGetSampTimeIdx(tID,isFrame,im)
                                                %% get the system number
                                                %assign sysNum = ::CompiledModel.NumSystems-1
                                            %endif
                                            %% Write data directly to BlockIOSignal structure
                                            %if FcnDynamicAPI()
                                                %assign needsAddressMapIndexVar = TLC_TRUE
                                                %assign entryIndex = 0
                                                %assign dynamicInit = dynamicInit + ppIf + "\n" + tBlockSignals + ...
                                                    "[" + numSignals + "].addrMapIndex = " + addrMapIndex + ...
                                                    ";\n" + numSignalsPP + ";\n" + addrMapIndexPP + ";\n" + ...
                                                    ppFi + "\n"
                                            %else
                                                %assign entryIndex = addrMapIdx
                                            %endif
                                            %<ppIf>
                                            {%<entryIndex>, %<sysNum>, TARGET_STRING("%<blkPath>"),
                                            TARGET_STRING("%<sigLabel>"), %<OutputPortIdx>, %<dataTypeMapIdx>, \
                                            %<dimMapIdx>, %<fxpMapIdx>, %<sTimeIdx>},
                                            %<ppFi>
                                            %% Construct the loggingInfo to be dumped later
                                            %if IsModelReferenceSimTarget()
                                                %assign loggingInfoStartIdx  = ...
                                                    loggingInfoStartIdx + regionOffset
                                                %assign loggingInfoBlockPath = ...
                                                    loggingInfoBlockPath + ...
                                                    STRING(grPath)
                                                %assign loggingInfoPortIndex = loggingInfoPortIndex + %<hnIdx>
                                                %% Figure out the system number
                                                %assign loggingInfoSysNum = ...
                                                    loggingInfoSysNum + %<BlockHierarchyMap.Subsystem[sysIdx].SLContextSysNum>
                                            %endif
                                            %% Keep track of number of signals logged in the
                                            %% CAPI Signals structure.
                                            %% Among other things, this info will be used for
                                            %% deciding whether "BlockIO" or "rtU" needs to be
                                            %% passed as an argument to CAPI function -
                                            %% model_InitializeDataMapInfo
                                            %%
                                            %if !ISEMPTY(sigRec)
                                                %if ISFIELD(sigRec, "VarGroupIdx") && ...
                                                    LibGetVarGroupCategory(sigRec.VarGroupIdx[0]) == "HierarchicalCoderData"
                                                    %assign groupIdx = ::CompiledModel.VarGroups.VarGroup[sigRec.VarGroupIdx[0]].CoderDataGroupIndex
                                                    %assign InCAPI.NumDataGroupElements[groupIdx] = InCAPI.NumDataGroupElements[groupIdx] + 1
                                                    %assign InCAPI.NumBIOSignals = InCAPI.NumBIOSignals + 1
                                                %elseif (sigRec.RecordType == "ExternalInput")
                                                    %% Increment virtual root input port signals
                                                    %assign InCAPI.NumExtInputs = InCAPI.NumExtInputs + 1
                                                    %if IsMultiInstanceERTOrModelReference()
                                                        %<SLibAccessThisSysFcnArgHelper(sigRec, "Registration", "", "", TLC_TRUE)>
                                                    %endif
                                                %else
                                                    %% Increment  Block Outputs. Non-virtual root input
                                                    %% port signals are also put in block outputs.
                                                    %assign InCAPI.NumBIOSignals = InCAPI.NumBIOSignals + 1
                                                %endif
                                                %if SLibGetArgIsVarDims(sigRec)
                                                    %assign InCAPI.NumVarDimsSignals = InCAPI.NumVarDimsSignals + 1
                                                %endif
                                            %endif %% !ISEMPTY(sigRec)
                                            %if regionIsGround
                                                %% Increment num ground signals
                                                %assign InCAPI.NumGrndSignals = InCAPI.NumGrndSignals + 1
                                            %endif
                                        %endwith  %% HierarchyNode[hnIdx]
                                    %endforeach  %% hnIdx = NumHierarchyNodes
                                %endwith %% SignalHierarchyDescriptor[shdIdx]
                            %endforeach %% shdIdx = NumSignalHierarchyDescriptors
                        %endif %% if busHier
                        %foreach subsysIdx = NumSubsystems
                            %with Subsystem[subsysIdx]
                                %assign isRootSys = (Subsystem[subsysIdx].Type == "root") ? 1 : 0
                                %% Step 2: Process the blocks
                                %foreach blkIdx = NumBlocks
                                    %with Block[blkIdx]
                                        %% Loop through Data Output Ports & write signal data to
                                        %% BlockIOSignals structure
                                        %assign virtBlock = (Block[blkIdx].Virtual > 0)
                                        %assign isInport  = (Block[blkIdx].Type == "Inport")
                                        %assign rootInport= (isRootSys && isInport)
                                        %assign rootOutport = (isRootSys && Block[blkIdx].Type == "Outport")
                                        %assign isTestPointedForEachParitionedInport = ISFIELD(Block[blkIdx], "IsTestPointedForEachPartitionedInport") && ...
                                            (Block[blkIdx].IsTestPointedForEachPartitionedInport > 0)
                                        %%--SLRTSPECIALCASE-------------
                                        %assign isSubsystem  = (Block[blkIdx].Type == "SubSystem")
                                        %if (skipSubSystem && isSubsystem)
                                            %continue
                                        %endif
                                        %assign isBusCreator = (Block[blkIdx].Type == "BusCreator")
                                        %if (skipBusCreator && isBusCreator )
                                            %continue
                                        %endif
                                        %if (skipIsProtected)
                                            %continue
                                        %endif

                                        %assign visitInportOfRootOutport = rootOutport && ...
                                            ISFIELD(Block[blkIdx].DataInputPort[0],"RootOutportDrivenBySynthesizedBlock")&& ...
                                            Block[blkIdx].DataInputPort[0].RootOutportDrivenBySynthesizedBlock
                                        %%--SLRTSPECIALCASE-------------
                                        %%0:nonvirt 1:virt 2:post comp virt
                                        %if ((!virtBlock) || (IsModelReferenceTarget()) ...
                                            || rootInport || (virtBlock && isSubsystem) || isTestPointedForEachParitionedInport)
                                            %if (visitInportOfRootOutport)
                                                %assign portsToVisit = 1
                                            %else
                                                %assign portsToVisit = NumDataOutputPorts
                                            %endif
                                            %foreach portIdx = portsToVisit

                                                %if (visitInportOfRootOutport)
                                                    %assign port =  DataInputPort[0]
                                                %else
                                                    %assign port =  DataOutputPort[portIdx]
                                                %endif
                                                %with port
                                                    %assign ppIf = ""
                                                    %assign ppFi = ""

                                                    %if IsModelReferenceSimTarget() && TestPoint == 1 && MdlRefSimLoggableTestPoint == 0
                                                        %continue
                                                    %endif
                                                    %% If this DataOutputPort has more than one region, do not
                                                    %% process it here - it has already been processed in the
                                                    %% SHD loop above. Note that it is only done when the SHD bus
                                                    %% hierarchy is being written out (currently, only for ModelRef
                                                    %% sim target).
                                                    %if busHier && NumRegions > 1
                                                        %continue
                                                    %endif
                                                    %foreach regIdx = NumRegions
                                                        %%
                                                        %% Skip non-testpointed virtual sigs.
                                                        %%
                                                        %if (virtBlock && (TestPoint == 0) && !isTestPointedForEachParitionedInport)
                                                            %continue
                                                        %endif
                                                        %assign portObj.SignalSrc = Region[regIdx]._Source
                                                        %if ISFIELD(Region[regIdx],"BusSelElIdx")
                                                            %% All regions of a vector within a NVB source must have the same BusSelElIdx
                                                            %assign portObj.BusSelElIdx = Region[regIdx].BusSelElIdx[0]
                                                            %assign portObj.BusSelElCGTypeId = Region[regIdx].BusSelElCGTypeId[0]
                                                        %endif
                                                        %assign regionOffset      = Region[regIdx].Offset
                                                        %assign regionDimensions  = Region[regIdx].Dimensions
                                                        %assign sigRec = SLibGetSourceRecord(portObj, 0)
                                                        %assign regionIsGround = TLC_FALSE
                                                        %assign constString = ""
                                                        %% CAPI don't need to work on root outport.
                                                        %%
                                                        %% also, Skip function-call outputs.
                                                        %if !(ISEMPTY(sigRec))
                                                            %if sigRec.RecordType == "ExternalOutput" || ...
                                                                sigRec.RecordType == "ContState"
                                                                %continue
                                                            %endif
                                                            %if (RTWCAPITestPtSignals == 1) && ...
                                                                (sigRec.TestPoint !="yes")
                                                                %continue
                                                            %endif
                                                            %if (ISFIELD(sigRec, "Invariant") && sigRec.Invariant == "yes") && ...
                                                                !IsMultiInstanceERTOrModelReference()
                                                                %assign constString = "(void *) "
                                                            %endif
                                                            %if TYPE(sigRec.TID) != "Number" && ...
                                                                TYPE(sigRec.TID) == "String"
                                                                %% Check for non-sampled signals
                                                                %if sigRec.TID != "constant" && ...
                                                                    sigRec.TID != "trigger"
                                                                    %% Skip signals other than constant and triggered
                                                                    %continue
                                                                %endif
                                                            %endif

                                                            %if SLibIsCoderGroupUseAccessFcnForDataRecord(sigRec)
                                                                %continue
                                                            %endif

                                                            %if sigRec.MemoryMapIdx[2] == -1
                                                                %% Skip  Local or reuse data
                                                                %continue
                                                            %else
                                                                %assign structIdx  = sigRec.MemoryMapIdx[0]
                                                                %assign secIdx     = sigRec.MemoryMapIdx[1]
                                                                %assign dataIdx    = sigRec.MemoryMapIdx[2]
                                                                %if secIdx == -1
                                                                    %% Unstructured data
                                                                    %assign data = UnstructuredData.Data[dataIdx]
                                                                    %assign isComplex   = data.IsComplex
                                                                    %assign dataTypeIdx = data.DataTypeIdx
                                                                    %assign isPointer   = (data.Access == "indirect") ? 1 : 0
                                                                    %if sigRec.StorageTypeQualifier=="volatile"
                                                                        %assign constString = "(void *) "
                                                                    %endif
                                                                %elseif structIdx == -1
                                                                    %% Custom data
                                                                    %assign data =  CustomData[secIdx].Data[dataIdx]
                                                                    %if !FcnCSCSupportsCAPI(data)
                                                                        %continue
                                                                    %endif
                                                                    %assign isComplex   = data.IsComplex
                                                                    %assign dataTypeIdx = data.DataTypeIdx
                                                                    %assign isPointer   = (data.Access == "indirect") ? 1 : 0
                                                                    %assign constString = "(void *) "
                                                                %else
                                                                    %% Structured data
                                                                    %assign section     = ...
                                                                        StructuredData[structIdx].Section[secIdx]
                                                                    %assign data        = section.Data[dataIdx]
                                                                    %assign dataTypeIdx = section.DataTypeIdx
                                                                    %assign isComplex   = section.IsComplex
                                                                    %% data access is "direct"
                                                                    %assign isPointer   = TLC_FALSE
                                                                %endif
                                                                %% data.PPIf already has conditions. No special handling needed for IV. Refer globalmaplib
                                                                %% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-codegen/CAPI/tInlineVariantsWithCAPI.m
                                                                %assign ppIf = data.PPIf
                                                                %assign ppFi = data.PPEndIf
                                                                %assign getAddrMapIdxVarCond = SLibGetVariantConditionCombineByOR(getAddrMapIdxVarCond, data.VarCond)
                                                                %%------------SLRTSPECIALCASE---------------
                                                                %if (skipComplex && isComplex)
                                                                    %continue
                                                                %endif
                                                                %%------------SLRTSPECIALCASE---------------
                                                            %endif %% Non-Local Data
                                                            %if !FcnDataSupportsCAPI(data)
                                                                %continue
                                                            %endif
                                                            %assign dataAddress = data.BaseAddr
                                                            %assign dataIsFixPt = data.IsFixedPoint
                                                            %assign dataIsStruct = data.IsStruct
                                                            %%------------SLRTSPECIALCASE---------------
                                                            %if (skipStruct && dataIsStruct)
                                                                %continue
                                                            %endif
                                                            %%------------SLRTSPECIALCASE---------------
                                                        %elseif ISFIELD(Region[regIdx], "GroundDataTypeIdx")
                                                            %assign regionIsGround = TLC_TRUE
                                                            %assign dataTypeIdx = Region[regIdx].GroundDataTypeIdx
                                                            %assign isComplex   = Region[regIdx].GroundIsComplex
                                                            %assign isPointer   = TLC_FALSE
                                                            %assign dataAddress  = ...
                                                                FcnGetCAPIGroundAddr(im, dataTypeIdx, isComplex, regionDimensions)
                                                            %assign dataIsFixPt = TLC_FALSE %% assume false
                                                            %assign dataIsStruct = TLC_FALSE %% GROUND signals cannot be structures
                                                            %%------------SLRTSPECIALCASE---------------
                                                            %if (skipStruct && dataIsStruct)
                                                                %continue
                                                            %endif
                                                            %%------------SLRTSPECIALCASE---------------
                                                        %else
                                                            %% just skip this record - skip signals with no memory
                                                            %% info. Most likely fcn-call signal or ground signal
                                                            %% with no additional information.
                                                            %continue
                                                        %endif
                                                        %%
                                                        %<FcnOptionallyAddModelRefCanonicalInputNeededByCAPIFlag(sigRec)>
                                                        %%
                                                        %createrecord recordToUseWithFxpMapIdx { }
                                                        %if ISFIELD(Region[regIdx],"BusSelElIdx")
                                                            %assign busSelElIdx = Region[regIdx].BusSelElIdx[0]
                                                            %assert !ISEMPTY(busSelElIdx)
                                                            %assign dataTypeIdx = LibCGTypeToSLType(Region[regIdx].BusSelElCGTypeId[0])
                                                            %assign isComplex   = LibCGTypeIsComplex(Region[regIdx].BusSelElCGTypeId[0])
                                                            %assign dataAddress = REGEXPREP( dataAddress, "\\[\\d+\\]$", "")
                                                            %if busSelElIdx[0] != "." || LibDoesStringContainDotOrArrow(dataAddress)
                                                                %assign dataAddress = REGEXPREP( ...
                                                                    dataAddress, "&(.*)", "&($1" + busSelElIdx + ")")
                                                            %else
                                                                %assign dataAddress = REGEXPREP( ...
                                                                    dataAddress, "&(.*)", "&((*$1)" + busSelElIdx + ")")
                                                            %endif
                                                            %assign dataIsStruct = LibIsStructDataType(dataTypeIdx)
                                                            %assign dataIsFixPt = LibIsDataTypeFixpt(dataTypeIdx)
                                                            %if dataIsFixPt
                                                                %assign fxpIdx = FcnGetUniformFixPtTypeInGMM(DataTypes.DataType[dataTypeIdx])
                                                                %addtorecord recordToUseWithFxpMapIdx \
                                                                FixedPointInfo GlobalMemoryMap.FixedPointMaps.FixPtRecord[fxpIdx]
                                                            %endif
                                                        %endif
                                                        %% Address
                                                        %assign addrMapIdx        = im.NumDataAddr
                                                        %addtorecord Region[regIdx] CAPIAddrMapIdx addrMapIdx
                                                        %% Add the index for later
                                                        %if busHier
                                                            %if !ISEMPTY(sigRec) && !ISFIELD(sigRec, "rtwCAPIAddrMapIdx")
                                                                %with sigRec
                                                                    %addtorecord sigRec rtwCAPIAddrMapIdx addrMapIdx
                                                                %endwith
                                                            %else
                                                                %% This signal has already been mapped.
                                                            %endif
                                                        %endif
                                                        %if isPointer
                                                            %assign sigAddress      = dataAddress
                                                            %assign comments = "%<im.NumDataAddr>: Signal Pointer"
                                                        %elseif (regionOffset > 0)
                                                            %% For virtual Blocks, e.g Demux
                                                            %% compensate for the offset
                                                            %if isComplex
                                                                %assign regionOffset  = regionOffset*2
                                                            %endif
                                                            %assign castString = ""
                                                            %if dataIsStruct
                                                                %assign castString = "(char *)"
                                                            %endif
                                                            %assign sigAddress      = "%<castString> %<dataAddress>"
                                                            %if !WHITE_SPACE(castString)
                                                                %assign sigAddress = FcnReplaceCCastWithStaticCastForCPP(sigAddress)
                                                            %endif
                                                            %assign sigAddress      = constString + ...
                                                                "(%<sigAddress> + %<regionOffset>)"
                                                            %assign comments = "%<im.NumDataAddr>: Signal"
                                                        %else
                                                            %assign sigAddress = constString + dataAddress
                                                            %assign comments = "%<im.NumDataAddr>: Signal"
                                                        %endif
                                                        %% Block Path
                                                        %if !(regionIsGround && Region[regIdx].GroundIsSynthesized)
                                                            %assign grBlkIdx = [%<subsysIdx>, %<blkIdx>]
                                                            %assign blkPath  = SLibMangledGrBlockPath(grBlkIdx)
                                                            %assign blkPath  = FcnReturnCompliantBlockPath(blkPath, "Signal")
                                                        %else
                                                            %assign blkPath = ""
                                                        %endif

                                                        %assign isActiveDuringCodegen = 1

                                                        %if(!ISEMPTY(sigRec) && ISFIELD(sigRec,"isActiveDuringCodegen"))
                                                            %assign isActiveDuringCodegen = sigRec.isActiveDuringCodegen
                                                        %endif

                                                        %% If this block signal's source buffer is a DWork, we count them in InCAPI.NumBlockSignalsMergedByGlobalDwork
                                                        %assign idNum = IDNUM(portObj.SignalSrc[0])
                                                        %if idNum[0] == "D" %% global DWork index
                                                            %assign InCAPI.NumBlockSignalsMergedByGlobalDwork = ...
                                                                InCAPI.NumBlockSignalsMergedByGlobalDwork + 1
                                                        %endif

                                                        %if isRM
                                                            %<FcnSetAddrMapInfoWithLogging(im, sigAddress, "", comments, ppIf, ppFi, isActiveDuringCodegen)>
                                                        %else
                                                            %<FcnSetAddrMapInfo(im, sigAddress, comments, ppIf, ppFi, isActiveDuringCodegen)>
                                                        %endif

                                                        %% Signal Label
                                                        %if NumRegions == 1
                                                            %% use block DataOutputPort's signal label
                                                            %assign sigLabel = STRING(SignalLabel)
                                                        %else
                                                            %if !ISEMPTY(sigRec) && ISFIELD(sigRec, "SigLabel") && sigRec.SigLabel != ""
                                                                %assign sigLabel = STRING(sigRec.SigLabel)
                                                            %elseif ISFIELD(Region[regIdx], "GroundLabel")
                                                                %assign sigLabel = Region[regIdx].GroundLabel
                                                            %else
                                                                %assign sigLabel = ""
                                                            %endif
                                                        %endif
                                                        %% Data Type
                                                        %assign dataTypeMapIdx = ...
                                                            FcnGetDataTypeMapIdx(dataTypeIdx,isComplex,isPointer,im)
                                                        %% Dimension
                                                        %assign virtSigDimensions = regionIsGround || !FcnRegionDimsEqualDataDims(regionDimensions, data)
                                                        %if virtSigDimensions
                                                            %assign dimMapIdx    = ...
                                                                FcnGetVirtSigDimensionMapIdx(regionDimensions,im, ppIf, ppFi)
                                                        %else
                                                            %assign dimMapIdx = FcnGetDimensionMapIdx(data,im, ppIf, ppFi)
                                                        %endif
                                                        %% Fixed Point
                                                        %if dataIsFixPt
                                                            %%------------SLRTSPECIALCASE---------------
                                                            %if (skipwideFxPt)
                                                                %if (data.FixedPointInfo.NumBits > 52)
                                                                    %continue
                                                                %endif
                                                            %endif
                                                            %%------------SLRTSPECIALCASE---------------
                                                            %if !ISEMPTY(recordToUseWithFxpMapIdx)
                                                                %assign fxpMapIdx = FcnGetFxpMapIdx(recordToUseWithFxpMapIdx,im)
                                                            %else
                                                                %assign fxpMapIdx = FcnGetFxpMapIdx(data,im)
                                                            %endif
                                                        %else
                                                            %assign fxpMapIdx = 0
                                                        %endif
                                                        %% sample time index
                                                        %if !ISEMPTY(sigRec) && ISFIELD(sigRec, "FrameData") && (sigRec.FrameData == "yes")
                                                            %assign isFrame =  1
                                                        %else
                                                            %assign isFrame =  0
                                                        %endif
                                                        %if !ISEMPTY(sigRec)
                                                            %if (TYPE(sigRec.TID) == "Vector" && TYPE(sigRec.TID[0]) == "Number")
                                                                %if ::CompiledModel.SampleTime[sigRec.TID[0]].IsUnionTs == "yes"
                                                                    %assign tID      = -1
                                                                %else
                                                                    %assign tID      = sigRec.TID[0]
                                                                %endif
                                                                %assign sTimeIdx = FcnGetSampTimeIdx(tID,isFrame,im)
                                                            %elseif TYPE(sigRec.TID) == "Number"
                                                                %if ::CompiledModel.SampleTime[sigRec.TID].IsUnionTs == "yes"
                                                                    %assign tID      = -1
                                                                %else
                                                                    %assign tID      = sigRec.TID
                                                                %endif
                                                                %assign sTimeIdx = FcnGetSampTimeIdx(tID,isFrame,im)
                                                            %elseif sigRec.TID == "constant"
                                                                %assign tID      = -2
                                                                %assign sTimeIdx = FcnGetSampTimeIdx(tID,isFrame,im)
                                                            %elseif sigRec.TID == "trigger"
                                                                %assign tID      = -1
                                                                %assign sTimeIdx = FcnGetSampTimeIdx(tID,isFrame,im)
                                                            %else
                                                                %<SLibReportErrorWithId("RTW:tlc:TIDType")>
                                                            %endif
                                                            %% get the system number
                                                            %if ISFIELD(sigRec, "SysNum")
                                                                %assign sysNum = sigRec.SysNum
                                                            %else
                                                                %assign sysNum = 0
                                                            %endif
                                                        %else
                                                            %assign tID      = -2
                                                            %assign sTimeIdx = FcnGetSampTimeIdx(tID,isFrame,im)
                                                            %% get the system number
                                                            %assign sysNum = ::CompiledModel.NumSystems-1
                                                        %endif
                                                        %% C-API Hook Processing
                                                        %%
                                                        %% Skip signals that are virtual or variable dimensions
                                                        %if !ISEMPTY(sigRec) && (!virtBlock || rootInport) && (NumRegions == 1) && ...
                                                            !(ISFIELD(data, "IsVarDims") && (data.IsVarDims)) && ...
                                                            !virtSigDimensions
                                                            %% !virtSigDimensions filters out signals with virtual dimensions,
                                                            %% including array expressions, where signals are multiplexed
                                                            %% inside one chunk of storage via region
                                                            %% offset and dimensions.
                                                            %assign blkSID = ""
                                                            %assign portNum = ""
                                                            %% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-codegen/CAPI/tInlineVariantsWithCAPI.m -testspec:test_CAPI_modelref
                                                            %if ISFIELD(Block[blkIdx],"OrigInlineVarBlkSID") && ISFIELD(Block[blkIdx],"OrigInlineVarPortNum")
                                                                %assign blkSID = Block[blkIdx].OrigInlineVarBlkSID
                                                                %assign portNum = Block[blkIdx].OrigInlineVarPortNum - 1
                                                            %else
                                                                %assign blkSID = Block[blkIdx].SID
                                                                %assign portNum = portIdx
                                                            %endif
                                                            %assign capiHookTID = sigRec.TID
                                                            %if (TYPE(sigRec.TID) != "Number") && (TYPE(sigRec.TID) != "Vector") && ...
                                                                sigRec.TID == "trigger"
                                                                %% find the associated container TID
                                                                %assign nonTrigTID = []
                                                                %% lookup the System
                                                                %assign systemAndInstanceIdx = SLibGetSystemAndCallSideIndex(sigRec)
                                                                %assign systemIdx = systemAndInstanceIdx[0]
                                                                %assign instanceIdx = systemAndInstanceIdx[1]

                                                                %with System[systemIdx]
                                                                    %% only need to support systems corresponding to export functions
                                                                    %% entry points
                                                                    %if (Type == "function-call") || (Type == "atomic")
                                                                        %% validate system and instance indices against sysNum, which is
                                                                        %% the instance specific descendent subsystem index.
                                                                        %assert DescSysIdx[instanceIdx] == sysNum
                                                                        %% direct lookup of the non-triggered TID (container sample time).
                                                                        %assign nonTrigTID = DescSysNonTrigTID[instanceIdx]
                                                                    %endif
                                                                %endwith
                                                                %if !ISEMPTY(nonTrigTID) && (nonTrigTID >= 0)
                                                                    %assign capiHookTID = nonTrigTID
                                                                %endif
                                                            %endif

                                                            %if(ISFIELD(sigRec,"isActiveDuringCodegen") && sigRec.isActiveDuringCodegen == 1)

                                                                %<FcnCAPIHookAddSignal(CAPIHooks,    \
                                                                portNum,      \
                                                                im.NumActiveSignalsDuringCodegen,   \
                                                                isPointer,    \
                                                                sigRec.StorageClass, \
                                                                sigRec.CGTypeIdx, \
                                                                sigRec.FrameData, \
                                                                capiHookTID, \
                                                                blkSID, \
                                                                sigLabel)>
                                                            %endif
                                                        %endif
                                                        %% Write data directly to BlockIOSignal structure
                                                        %if FcnDynamicAPI()
                                                            %assign needsAddressMapIndexVar = TLC_TRUE
                                                            %assign entryIndex = 0
                                                            %assign dynamicInit = dynamicInit + ppIf + "\n" + ...
                                                                tBlockSignals + "[" + numSignals + "].addrMapIndex = " + ...
                                                                addrMapIndex + ";\n" + numSignalsPP + ";\n" + ...
                                                                addrMapIndexPP + ";\n" + ppFi + "\n"
                                                        %else
                                                            %assign entryIndex = addrMapIdx
                                                        %endif
                                                        %%------------SLRTSPECIALCASE---------------
                                                        %if EXISTS(slrt)
                                                            %assign blkPath = slrtSignalHook(capiFile, sigRec, blkPath, sigLabel, portIdx, NumDataOutputPorts)
                                                        %endif
                                                        %%------------SLRTSPECIALCASE---------------
                                                        %<ppIf>
                                                        {%<entryIndex>, %<sysNum>, TARGET_STRING("%<blkPath>"),
                                                        TARGET_STRING("%<sigLabel>"), %<portIdx>, %<dataTypeMapIdx>, \
                                                        %<dimMapIdx>, %<fxpMapIdx>, %<sTimeIdx>},
                                                        %<ppFi>
                                                        %% Construct the loggingInfo to be dumped later
                                                        %if (ISEMPTY(sigRec) || ...
                                                            ((sigRec.RecordType == "ExternalInput") && ...
                                                            (!ISFIELD(sigRec, "GrSrc"))) )
                                                            %assign grSrc = [%<subsysIdx>,%<blkIdx>,%<portIdx>]
                                                        %else
                                                            %assign grSrc = sigRec.GrSrc
                                                        %endif
                                                        %if IsModelReferenceSimTarget()
                                                            %assign loggingInfoStartIdx  = ...
                                                                loggingInfoStartIdx + regionOffset
                                                            %assign loggingInfoBlockPath = ...
                                                                loggingInfoBlockPath + ...
                                                                STRING(SLibMangledGrBlockPath(grSrc))
                                                            %assign loggingInfoPortIndex = ...
                                                                loggingInfoPortIndex + grSrc[2]
                                                            %% Figure out the system number
                                                            %assign loggingInfoSysNum = ...
                                                                loggingInfoSysNum + %<SLContextSysNum>
                                                        %endif
                                                        %% Keep track of number of signals logged in the
                                                        %% CAPI Signals structure.
                                                        %% Among other things, this info will be used for
                                                        %% deciding whether "BlockIO" or "rtU" needs to be
                                                        %% passed as an argument to CAPI function -
                                                        %% model_InitializeDataMapInfo
                                                        %%
                                                        %if !ISEMPTY(sigRec)
                                                            %if ISFIELD(sigRec, "VarGroupIdx") && ...
                                                                LibGetVarGroupCategory(sigRec.VarGroupIdx[0]) == "HierarchicalCoderData"
                                                                %assign groupIdx = ::CompiledModel.VarGroups.VarGroup[sigRec.VarGroupIdx[0]].CoderDataGroupIndex
                                                                %assign InCAPI.NumDataGroupElements[groupIdx] = InCAPI.NumDataGroupElements[groupIdx] + 1
                                                                %assign InCAPI.NumBIOSignals = InCAPI.NumBIOSignals + 1
                                                            %elseif (sigRec.RecordType == "ExternalInput")
                                                                %% Increment virtual root input port signals
                                                                %assign InCAPI.NumExtInputs = InCAPI.NumExtInputs + 1
                                                                %if IsMultiInstanceERTOrModelReference()
                                                                    %<SLibAccessThisSysFcnArgHelper(sigRec, "Registration", "","", TLC_TRUE)>
                                                                %endif
                                                            %else
                                                                %% Increment  Block Outputs. Non-virtual root input
                                                                %% port signals are also put in block outputs.
                                                                %assign InCAPI.NumBIOSignals = InCAPI.NumBIOSignals + 1
                                                            %endif
                                                            %if SLibGetArgIsVarDims(sigRec)
                                                                %assign InCAPI.NumVarDimsSignals = InCAPI.NumVarDimsSignals + 1
                                                            %endif
                                                        %endif
                                                        %if regionIsGround
                                                            %% Increment num ground signals
                                                            %assign InCAPI.NumGrndSignals = InCAPI.NumGrndSignals + 1
                                                        %endif
                                                    %endforeach  %% regIdx = NumRegions
                                                %endwith  %% port
                                            %endforeach  %% portIdx = NumDataOutputPorts
                                        %endif  %% Block[blkIdx].Virtual == 0
                                        %if Block[blkIdx].Type == "Stateflow" && ISFIELD(Block[blkIdx],"ChartData")
                                            %foreach dwkIdx = Block[blkIdx].ChartData.NumChartData
                                                %if Block[blkIdx].ChartData.ChartData[dwkIdx].IsTestPoint
                                                    %assign dwRec = ::CompiledModel.DWorks.DWork[Block[blkIdx].DWork[dwkIdx]._idx]
                                                    %assign chartData  = Block[blkIdx].ChartData.ChartData[dwkIdx]
                                                    %assign structIdx  = dwRec.MemoryMapIdx[0]
                                                    %assign secIdx     = dwRec.MemoryMapIdx[1]
                                                    %assign dataIdx    = dwRec.MemoryMapIdx[2]
                                                    %assign loggingFcnPtr = ""
                                                    %if ISFIELD(dwRec, "PreprocessingFcnPtr")
                                                        %assign loggingFcnPtr = dwRec.PreprocessingFcnPtr
                                                    %endif
                                                    %if secIdx == -1
                                                        %% Unstructured data
                                                        %assign data        = UnstructuredData.Data[dataIdx]
                                                        %assign isComplex   = data.IsComplex
                                                        %assign dataTypeIdx = data.DataTypeIdx
                                                        %assign isPointer   = (data.Access == "indirect") ? 1 : 0
                                                    %elseif structIdx == -1
                                                        %% Custom data
                                                        %assign data        =  CustomData[secIdx].Data[dataIdx]
                                                        %if !FcnCSCSupportsCAPI(data)
                                                            %continue
                                                        %endif
                                                        %assign isComplex   = data.IsComplex
                                                        %assign dataTypeIdx = data.DataTypeIdx
                                                        %assign isPointer   = (data.Access == "indirect") ? 1 : 0
                                                    %else
                                                        %% Structured data
                                                        %assign section     = ...
                                                            StructuredData[structIdx].Section[secIdx]
                                                        %assign data        = section.Data[dataIdx]
                                                        %assign dataTypeIdx = section.DataTypeIdx
                                                        %assign isComplex   = section.IsComplex
                                                        %% data access is "direct"
                                                        %assign isPointer   = TLC_FALSE
                                                    %endif
                                                    %% Address
                                                    %assign addrMapIdx     = im.NumDataAddr
                                                    %if isPointer
                                                        %assign sigAddress   = data.BaseAddr
                                                        %assign comments = "%<im.NumDataAddr>: Stateflow Chart Data Pointer"
                                                    %else
                                                        %assign sigAddress   = data.BaseAddr
                                                        %assign comments = "%<im.NumDataAddr>: Stateflow Chart Data"
                                                    %endif
                                                    %assign ppIf = data.PPIf
                                                    %assign ppFi = data.PPEndIf
                                                    %% Block Path
                                                    %assign grBlkIdx = [%<subsysIdx>, %<blkIdx>]
                                                    %assign blkPath  = SLibMangledGrBlockPath(grBlkIdx) + ...
                                                        "/" + chartData.Path
                                                    %%------------SLRTSPECIALCASE---------------
                                                    %if EXISTS(slrt)
                                                        %assign blkPath  = SLibMangledGrBlockPath(grBlkIdx) + ...
                                                            ":" + chartData.Path
                                                    %endif
                                                    %%------------SLRTSPECIALCASE---------------
                                                    %assign blkPath        = FcnReturnCompliantBlockPath(blkPath, "Stateflow data")
                                                    %assign isActiveDuringCodegen = 0
                                                    %if isRM
                                                        %<FcnSetAddrMapInfoWithLogging(im, sigAddress, loggingFcnPtr, comments, ppIf, ppFi, isActiveDuringCodegen)>
                                                    %else
                                                        %<FcnSetAddrMapInfo(im, sigAddress, comments, ppIf, ppFi, isActiveDuringCodegen)>
                                                    %endif
                                                    %% Signal Label
                                                    %assign sigLabel       = chartData.SFName
                                                    %% Data Type
                                                    %assign dataTypeMapIdx = ...
                                                        FcnGetDataTypeMapIdx(dataTypeIdx,isComplex,isPointer,im)
                                                    %% Dimension
                                                    %assign dimMapIdx      = FcnGetDimensionMapIdx(data,im, ppIf, ppFi)
                                                    %% Fixed Point
                                                    %if data.IsFixedPoint
                                                        %%------------SLRTSPECIALCASE---------------
                                                        %if (skipwideFxPt)
                                                            %if (data.FixedPointInfo.NumBits > 52)
                                                                %continue
                                                            %endif
                                                        %endif
                                                        %%------------SLRTSPECIALCASE---------------
                                                        %assign fxpMapIdx    = FcnGetFxpMapIdx(data,im)
                                                    %else
                                                        %assign fxpMapIdx    = 0
                                                    %endif
                                                    %% SampleTime
                                                    %assign tID        = dwRec.TID
                                                    %if TYPE(tID) != "Number" && TYPE(tID) != "Vector"
                                                        %if tID == "triggered"
                                                            %assign tID = -1
                                                        %elseif tID == "constant"
                                                            %assign tID = -2
                                                        %elseif tID == "trigger"
                                                            %assign tID = -1
                                                        %else
                                                            %<SLibReportErrorWithId("RTW:tlc:TIDType")>
                                                        %endif
                                                    %endif
                                                    %assign sTimeIdx = FcnGetSampTimeIdx(tID, 0, im)
                                                    %assign sysNum = 0
                                                    %% Write data directly to BlockIOSignal structure
                                                    %if FcnDynamicAPI()
                                                        %assign needsAddressMapIndexVar = TLC_TRUE
                                                        %assign entryIndex = 0
                                                        %assign dynamicInit = dynamicInit + tBlockSignals + ppIf + "\n" + ...
                                                            "[" + numSignals + "].addrMapIndex = " + addrMapIndex + ";\n" + ...
                                                            numSignalsPP + ";\n" + addrMapIndexPP + ";\n" + ppFi + "\n"
                                                    %else
                                                        %assign entryIndex = addrMapIdx
                                                    %endif
                                                    %%------------SLRTSPECIALCASE---------------
                                                    %if EXISTS(slrt)
                                                        %assign blkPath  = slrtSignalChartDataHook(capiFile,dwRec,blkPath, sigLabel)
                                                    %endif
                                                    %%------------SLRTSPECIALCASE---------------
                                                    %<ppIf>
                                                    {%<entryIndex>, %<sysNum>, TARGET_STRING("%<blkPath>"),
                                                    TARGET_STRING("%<sigLabel>"), 0, %<dataTypeMapIdx>, \
                                                    %<dimMapIdx>, %<fxpMapIdx>, %<sTimeIdx>},
                                                    %<ppFi>
                                                    %assign InCAPI.NumSFLocals = InCAPI.NumSFLocals + 1
                                                    %if IsModelReferenceSimTarget()
                                                        %% Need to pad the loggingInfo to keep the same size
                                                        %assign loggingInfoStartIdx  = loggingInfoStartIdx + 0
                                                        %assign loggingInfoBlockPath = loggingInfoBlockPath + ""
                                                        %assign loggingInfoPortIndex = loggingInfoPortIndex + 0
                                                        %assign loggingInfoSysNum    = loggingInfoSysNum + 0
                                                    %endif
                                                %endif
                                            %endforeach
                                        %endif %% Block[blkIdx].Type == "Stateflow"
                                    %endwith  %% Block[blkIdx]
                                %endforeach  %% blkIdx = NumBlocks
                            %endwith  %% Subsystem[subsysIdx]
                        %endforeach  %%  subsysIdx = NumSubsystems
                        %undef portobj
                        {
                            0, 0, %<nulldef>, %<nulldef>, 0, 0, 0, 0, 0
                        }
                    };
                    %if tempSLfeature==2
                        %closefile filterBlkOutputbuf
                    %endif
                    %if busHier
                        /* Virtual bus elements */
                        %%
                        %% Handle bus blocks
                        %createrecord busInfo { }
                        %assign busOffset = 0
                        %assign NumBusSignals = SIZE(busIndexVector, 0)
                        %foreach busEl = NumBusSignals
                            %assign busIndex = busIndexVector[busEl]
                            %if ISEQUAL(busIndex, [-1, -1])
                                %continue
                            %endif
                            %with SignalHierarchyDescriptor[busIndex[0]]
                                %if busIndex[1] != 0
                                    %<LibBlockReportFatalError([], "More than one HierarchyNode found for an SHD")>
                                %endif
                                %% sysIdx: The subsystem index containing the block that produces this bus signal
                                %assign sysIdx = SubsystemIdx
                                %assign portIdx = OutputPortIdx
                                %with HierarchyNode[0]
                                    %if GrSrc[0] != -1
                                        %assign blkPath  = SLibMangledGrBlockPath(GrSrc)
                                    %else
                                        %assert ISFIELD(SignalHierarchyDescriptor[busIndex[0]], "FullBlockPath") == TLC_TRUE
                                        %assign blkPath = FullBlockPath
                                    %endif
                                    %assign blkPath  = FcnReturnCompliantBlockPath(blkPath, "Signal")
                                    %assign busOffset = %<FcnDumpBusElements(busInfo, busOffset, blkPath, portIdx)>
                                %endwith  %% HierarchyNode
                            %endwith %% SignalHierarchyDescriptor
                        %endforeach %% NumBusElements
                        %% Loop and dump
                        %if ISEMPTY(busInfo)
                            %assign numBusElements = 0
                        %else
                            %assign numBusElements = SIZE(busInfo.busElements, 1)
                        %endif
                        %if numBusElements != 0
                            static %<constKeyword> rtwCAPI_LoggingBusElement rtBusElements[]%<equalSign>{

                                %foreach busElIdx = numBusElements
                                    %assign numSigs = SIZE(busInfo.busElements[busElIdx].indicies.elements, 1)
                                    %foreach sigIdx = numSigs
                                        %assign elIndex = busInfo.busElements[busElIdx].indicies.elements[sigIdx].index
                                        %assign elType  = busInfo.busElements[busElIdx].indicies.elements[sigIdx].type
                                        {%<elIndex>, %<elType>},
                                    %endforeach
                                %endforeach
                                {0, rtwCAPI_signal}
                            };
                        %endif

                        static %<constKeyword> rtwCAPI_LoggingBusSignals rtBusSignals[]%<equalSign>{
                            /*
                            *  Signal label, Block path, Port Index, CAPI index, num elements
                            */
                            %if ISEMPTY(busInfo)
                                %assign numBusElements = 0
                            %else
                                %assign numBusElements = SIZE(busInfo.busElements, 1)
                            %endif
                            %foreach busElIdx = numBusElements
                                %assign busElStr = busInfo.busElements[busElIdx].str
                                %<busElStr>
                            %endforeach
                            {%<nulldef>, %<nulldef>, 0, 0, %<nulldef>}
                        };
                    %endif %% busHier == 1

                    %%for generating C-API in cpp
                %endif  %% %if tempSLfeature==0 || tempSLfeature==2
            %endif  %% RTWCAPISignals == 1

            %%for generating C-API in cpp
            %if tempSLfeature==0 || tempSLfeature==2

                %if RTWCAPIParams == 1

                    %% Internal testing facility
                    %if EXISTS(ParameterTuningTestFile)
                        %include "%<ParameterTuningTestFile>"
                    %endif

                    %switch InlineParameters
                      %case 0
                        /* Tunable block parameters */
                        %break
                      %case 1
                        /* Individual block tuning is not valid when inline parameters is *
                        * selected. An empty map is produced to provide a consistent     *
                        * interface independent  of inlining parameters.                 *
                        */
                        %break
                      %case 2
                        %break
                    %endswitch

                    static %<constKeyword> %<tBlockParamsType> %<tBlockParams>[]%<equalSign>{

                        /* addrMapIndex, blockPath,
                        * paramName, dataTypeIndex, dimIndex, fixPtIdx
                        */

                        %if InlineParameters != 1
                            %% Loop through Parameters and add relevant parameter information
                            %% to BlockParams Structure
                            %foreach subsysIdx = NumSubsystems
                                %with Subsystem[subsysIdx]
                                    %foreach blkIdx = NumBlocks
                                        %with Block[blkIdx]
                                            %foreach paramIdx = NumParameters
                                                %if (skipIsProtected)
                                                    %continue
                                                %endif
                                                %assign mParam  = Parameter[paramIdx]
                                                %if mParam._idx < 0 %% post compile virtual blocks
                                                    %continue
                                                %endif
                                                %if mParam.IsReference == 1
                                                    %continue
                                                %endif
                                                %assign param   = ...
                                                    ::CompiledModel.ModelParameters.Parameter[mParam._idx]
                                                %if (param.MemoryMapIdx[2] == -1) || (param.Tunable == "no")
                                                    %% Inaccessible data or non tunable parameter
                                                    %continue
                                                %elseif (!ISEMPTY(param.WorkspaceVarName))
                                                    %% Parameter represents a workspace variable
                                                    %continue
                                                %else
                                                    %assign structIdx  = param.MemoryMapIdx[0]
                                                    %assign secIdx     = param.MemoryMapIdx[1]
                                                    %assign dataIdx    = param.MemoryMapIdx[2]
                                                    %if (secIdx == -1)
                                                        %assign data = UnstructuredData.Data[dataIdx]
                                                        %assign isComplex   = data.IsComplex
                                                        %assign dataTypeIdx = data.DataTypeIdx
                                                        %%------------SLRTSPECIALCASE---------------
                                                        %if (skipComplex && isComplex)
                                                            %continue
                                                        %endif
                                                        %%------------SLRTSPECIALCASE---------------
                                                    %else
                                                        %if structIdx == -1
                                                            %% Custom data
                                                            %assign data =  CustomData[secIdx].Data[dataIdx]
                                                            %if !FcnCSCSupportsCAPI(data)
                                                                %continue
                                                            %endif
                                                            %assign isComplex   = data.IsComplex
                                                            %assign dataTypeIdx = data.DataTypeIdx
                                                        %else
                                                            %assert(structIdx != -1)
                                                            %assign section=StructuredData[structIdx].Section[secIdx]
                                                            %assign data       = section.Data[dataIdx]
                                                            %assign dataTypeIdx= section.DataTypeIdx
                                                            %assign isComplex  = section.IsComplex
                                                        %endif
                                                        %%------------SLRTSPECIALCASE---------------
                                                        %if (skipComplex && isComplex)
                                                            %continue
                                                        %endif
                                                        %%------------SLRTSPECIALCASE---------------
                                                    %endif
                                                    %assign isReadOnly = data.Permission == "ro"
                                                    %% Skip certain kinds of data - Read only
                                                    %if isReadOnly
                                                        %continue
                                                    %endif
                                                    %if !FcnDataSupportsCAPI(data)
                                                        %continue
                                                    %endif
                                                    %% Address
                                                    %assign addrMapIdx     = im.NumDataAddr
                                                    %assign paramAddr = data.BaseAddr
                                                    %if Type == "SubSystem"
                                                        %assign comments = "%<im.NumDataAddr>: Mask Parameter"
                                                    %else
                                                        %assign comments = "%<im.NumDataAddr>: Block Parameter"
                                                    %endif
                                                    %% Block Path
                                                    %assign grBlkIdx       = [%<subsysIdx>, %<blkIdx>]
                                                    %assign blkPath        = SLibMangledGrBlockPath(grBlkIdx)
                                                    %assign blkPath        = FcnReturnCompliantBlockPath(blkPath, "Parameter")
                                                    %assign ppIf = data.PPIf
                                                    %assign ppFi = data.PPEndIf
                                                    %assign getAddrMapIdxVarCond = SLibGetVariantConditionCombineByOR(getAddrMapIdxVarCond, data.VarCond)
                                                    %assign isActiveDuringCodegen = 0
                                                    %if isRM
                                                        %<FcnSetAddrMapInfoWithLogging(im, paramAddr, "", comments, ppIf, ppFi, isActiveDuringCodegen)>
                                                    %else
                                                        %<FcnSetAddrMapInfo(im, paramAddr, comments, ppIf, ppFi, isActiveDuringCodegen)>
                                                    %endif
                                                    %% Parameter Name
                                                    %assign paramName      = LibBlockParameterName(mParam)
                                                    %% Data Type
                                                    %assign isPointer      = TLC_FALSE
                                                    %assign dataTypeMapIdx = ...
                                                        FcnGetDataTypeMapIdx(dataTypeIdx,isComplex,isPointer,im)
                                                    %% Dimensions
                                                    %assign dimMapIdx = FcnGetDimensionMapIdx(data, im, ppIf, ppFi)
                                                    %% Fixed point
                                                    %if data.IsFixedPoint
                                                        %%------------SLRTSPECIALCASE---------------
                                                        %if (skipwideFxPt)
                                                            %if (data.FixedPointInfo.NumBits > 52)
                                                                %continue
                                                            %endif
                                                        %endif
                                                        %%------------SLRTSPECIALCASE---------------
                                                        %assign fxpMapIdx    = FcnGetFxpMapIdx(data,im)
                                                    %else
                                                        %assign fxpMapIdx    = 0
                                                    %endif
                                                    %% Write data directly to model_capi.c(pp)
                                                    %if FcnDynamicAPI()
                                                        %assign needsAddressMapIndexVar = TLC_TRUE
                                                        %assign entryIndex = 0
                                                        %assign dynamicInit = dynamicInit + ppIf + "\n" + ...
                                                            tBlockParams + "[" +  numBlockParams + "].addrMapIndex = " + ...
                                                            addrMapIndex + ";\n" + numBlockParamsPP + ...
                                                            ";\n" + addrMapIndexPP + ";\n" + ppFi + "\n"
                                                    %else
                                                        %assign entryIndex = addrMapIdx
                                                    %endif
                                                    %%------------SLRTSPECIALCASE---------------
                                                    %if EXISTS(slrt)
                                                        %createrecord paramInfo { ...
                                                            data        data ...
                                                            section     section ...
                                                            blkPath     blkPath  ...
                                                            paramName   paramName ...
                                                            dataTypeIdx dataTypeIdx ...
                                                            isComplex   isComplex ...
                                                        }
                                                        %assign blkPath = slrtParameterHook(capiFile, paramInfo)
                                                    %endif
                                                    %%------------SLRTSPECIALCASE---------------
                                                    %<ppIf>
                                                    {%<entryIndex>, TARGET_STRING("%<blkPath>"),
                                                    TARGET_STRING("%<paramName>"), %<dataTypeMapIdx>, %<dimMapIdx>, %<fxpMapIdx>},
                                                    %<ppFi>
                                                    %if ISFIELD(param, "VarGroupIdx") && ...
                                                        LibGetVarGroupCategory(param.VarGroupIdx[0]) == "HierarchicalCoderData"
                                                        %assign groupIdx = ::CompiledModel.VarGroups.VarGroup[param.VarGroupIdx[0]].CoderDataGroupIndex
                                                        %assign InCAPI.NumDataGroupElements[groupIdx] = InCAPI.NumDataGroupElements[groupIdx] + 1
                                                    %else
                                                        %assign InCAPI.NumBlockParams = InCAPI.NumBlockParams + 1
                                                    %endif
                                                %endif
                                            %endforeach
                                        %endwith  %% Block[blkIdx]
                                    %endforeach  %% blkIdx = NumBlocks
                                %endwith  %% Subsystem[subsysIdx]
                            %endforeach  %%  subsysIdx = NumSubsystems
                        %endif  %% !Inline Parameters
                        {
                            0, %<nulldef>, %<nulldef>, 0, 0, 0
                        }
                    };
                %endif  %% RTWCAPIParams == 1


                %assign stateIdxStr = ""
                %if RTWCAPIStates == 1
                    /* Block states information */

                    %assign commavar = ""
                    %assign cr = "\n"
                    static %<constKeyword> %<tBlockStatesType> %<tBlockStates>[]%<equalSign>{

                        /* addrMapIndex, contStateStartIndex, blockPath,
                        * stateName, pathAlias, dWorkIndex, dataTypeIndex, dimIndex,
                        * fixPtIdx, sTimeIndex, isContinuous, hierInfoIdx, flatElemIdx
                        */

                        %foreach subsysIdx = NumSubsystems
                            %with Subsystem[subsysIdx]
                                %foreach blkIdx = NumBlocks
                                    %assign dwOwner = Block[blkIdx]
                                    %if Block[blkIdx].Type == "ModelReference"
                                        %assert Block[blkIdx].NumDiscStates == 0
                                        %continue
                                    %endif
                                    %if ISFIELD(Block[blkIdx],"ShadowBlock")
                                        %assign dwOwner = Block[blkIdx].ShadowBlock.Block
                                    %endif
                                    %if dwOwner.Virtual != 0
                                        %continue
                                    %endif
                                    %% Block Path
                                    %assign grBlkIdx       = [%<subsysIdx>, %<blkIdx>]
                                    %if SLibIsGeneratingSimTargetForProtectedModel()
                                        %assign blkPath = SLibGetProtectedBlockPath()
                                    %else
                                        %assign blkPath = SLibGrBlockPath(grBlkIdx)
                                        %assign blkPath = FcnReturnCompliantBlockPath(blkPath, "State")
                                    %endif
                                    %with dwOwner
                                        %foreach dStateIdx = NumDiscStates
                                            %assign dWorkIdx = DiscState[dStateIdx]._idx
                                            %if dWorkIdx < 0 %% post compile virtual blocks
                                                %continue
                                            %endif
                                            %assert (dWorkIdx < ::CompiledModel.DWorks.NumDWorks)
                                            %assign dWork    = ::CompiledModel.DWorks.DWork[dWorkIdx]
                                            %if !dWork.DataLoggingOn
                                                %continue
                                            %endif
                                            %assign stateIdxStr = stateIdxStr + "%<commavar>" + cr + cr + "%<dWorkIdx>"
                                            %assign commavar = ","
                                            %assign constString = ""
                                            %if dWork.MemoryMapIdx[2] == -1
                                                %% Skip  Local or reuse data
                                                %continue
                                            %else
                                                %assign structIdx  = dWork.MemoryMapIdx[0]
                                                %assign secIdx     = dWork.MemoryMapIdx[1]
                                                %assign dataIdx    = dWork.MemoryMapIdx[2]
                                                %assign loggingFcnPtr = ""
                                                %if ISFIELD(dwRec, "PreprocessingFcnPtr")
                                                    %assign loggingFcnPtr = dwRec.PreprocessingFcnPtr
                                                %endif
                                                %if secIdx == -1
                                                    %% Unstructured data
                                                    %assign data        = UnstructuredData.Data[dataIdx]
                                                    %assign isComplex   = data.IsComplex
                                                    %assign dataTypeIdx = data.DataTypeIdx
                                                    %assign isPointer   = (data.Access == "indirect") ? 1 : 0
                                                    %if dWork.StorageTypeQualifier=="volatile"
                                                        %assign constString = "(void *) "
                                                    %endif
                                                %elseif structIdx == -1
                                                    %% Custom data
                                                    %assign data       =  CustomData[secIdx].Data[dataIdx]
                                                    %if !FcnCSCSupportsCAPI(data)
                                                        %continue
                                                    %endif
                                                    %assign isComplex   = data.IsComplex
                                                    %assign dataTypeIdx = data.DataTypeIdx
                                                    %assign isPointer   = (data.Access == "indirect") ? 1 : 0
                                                %else
                                                    %% Structured data
                                                    %assign section     = ...
                                                        StructuredData[structIdx].Section[secIdx]
                                                    %assign data        = section.Data[dataIdx]
                                                    %assign dataTypeIdx = section.DataTypeIdx
                                                    %assign isComplex   = section.IsComplex
                                                    %% data access is "direct"
                                                    %assign isPointer   = TLC_FALSE
                                                %endif
                                            %endif
                                            %if !FcnDataSupportsCAPI(data)
                                                %continue
                                            %endif
                                            %% The vss conditions on dworks have been translated to iv conditions as part of unification. Hence, we do not need to separately get the
                                            %% vss conditions.
                                            %% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-codegen/CAPI/tInlineVariantsWithCAPI.m -testspec:test_dwork_vssAndIV
                                            %assign ppIf = data.PPIf
                                            %assign ppFi = data.PPEndIf
                                            %assign getAddrMapIdxVarCond = SLibGetVariantConditionCombineByOR(getAddrMapIdxVarCond, data.VarCond)
                                            %% State Address
                                            %assign addrMapIdx     = im.NumDataAddr
                                            %if isPointer
                                                %assign stateAddress       = data.BaseAddr
                                                %assign comments = "%<im.NumDataAddr>: Discrete State Pointer"
                                            %else
                                                %assign stateAddress       = constString + data.BaseAddr
                                                %assign comments = "%<im.NumDataAddr>: Discrete State"
                                            %endif
                                            %assign isActiveDuringCodegen = 0
                                            %if isRM
                                                %<FcnSetAddrMapInfoWithLogging(im, stateAddress, loggingFcnPtr, comments, ppIf, ppFi, isActiveDuringCodegen)>
                                            %else
                                                %<FcnSetAddrMapInfo(im, stateAddress, comments, ppIf, ppFi, isActiveDuringCodegen)>
                                            %endif
                                            %% State Name
                                            %assign stateName      = dWork.LogStateName
                                            %% Data Type
                                            %assign dataTypeMapIdx = ...
                                                FcnGetDataTypeMapIdx(dataTypeIdx, isComplex, isPointer, im)
                                            %% Dimension
                                            %assign dimMapIdx      = FcnGetDimensionMapIdx(data,im, ppIf, ppFi)
                                            %% Fixed Point
                                            %if data.IsFixedPoint
                                                %assign fxpMapIdx    = FcnGetFxpMapIdx(data,im)
                                            %else
                                                %assign fxpMapIdx    = 0
                                            %endif
                                            %% SampleTime
                                            %if TYPE(dWork.TID) == "Vector"
                                                %assign tID = dWork.TID[0]
                                            %else
                                                %assign tID = dWork.TID
                                            %endif

                                            %if TYPE(tID) == "Number"
                                                %assign sTimeIdx = FcnGetSampTimeIdx(tID,0,im)
                                            %elseif tID == "triggered"
                                                %assign tID      = -1
                                                %assign sTimeIdx = FcnGetSampTimeIdx(tID,0,im)
                                            %elseif tID == "constant"
                                                %assign tID      = -2
                                                %assign sTimeIdx = FcnGetSampTimeIdx(tID, 0 ,im)
                                            %else
                                                %<SLibReportErrorWithIdAndArgs("RTW:tlc:TIDTypeState", "%<dWork.TID>")>
                                            %endif
                                            %% hierInfoIdx and flatElemIdx
                                            %assign hierInfoIdx      = dWork.hierInfoIdx
                                            %assign flatElemIdx      = dWork.flatElemIdx
                                            %% Write data directly to BlockStates structure
                                            %if FcnDynamicAPI()
                                                %assign needsAddressMapIndexVar = TLC_TRUE
                                                %assign entryIndex = 0
                                                %assign dynamicInit = dynamicInit + ppIf + "\n" + ...
                                                    tBlockStates + "[" ...
                                                    + numStates + "].addrMapIndex = " + ...
                                                    addrMapIndex + ";\n" + numStatesPP + ";\n" ...
                                                    + addrMapIndexPP + ";\n" + ppFi + "\n"
                                            %else
                                                %assign entryIndex = addrMapIdx
                                            %endif
                                            %<ppIf>
                                            %assign blkPathStr = FEVAL("coder.internal.getEscapedString", blkPath)
                                            {%<entryIndex>, -1, TARGET_STRING("%<blkPathStr>"),
                                            TARGET_STRING("%<stateName>"), "", 0, %<dataTypeMapIdx>, %<dimMapIdx>, \
                                            %<fxpMapIdx>, %<sTimeIdx>, 0, %<hierInfoIdx>, %<flatElemIdx>},
                                            %<ppFi>
                                            %if ISFIELD(dWork, "VarGroupIdx") && ...
                                                LibGetVarGroupCategory(dWork.VarGroupIdx[0]) == "HierarchicalCoderData"
                                                %assign groupIdx = ::CompiledModel.VarGroups.VarGroup[dWork.VarGroupIdx[0]].CoderDataGroupIndex
                                                %assign InCAPI.NumDataGroupElements[groupIdx] = InCAPI.NumDataGroupElements[groupIdx] + 1
                                            %endif
                                            %assign InCAPI.NumDiscStates = InCAPI.NumDiscStates + 1
                                        %endforeach   %% dStateIdx = NumDiscStates
                                        %%
                                        %% Continuous States
                                        %%
                                        %assert (NumContStates == NumDerivatives)
                                        %foreach cStateIdx = NumContStates
                                            %assign cSIdx = ContState[cStateIdx]._idx
                                            %assert (cSIdx < ::CompiledModel.ContStates.NumContStates)
                                            %assign contState = ::CompiledModel.ContStates.ContState[cSIdx]
                                            %if contState.MemoryMapIdx[2] == -1 || !contState.DataLoggingOn
                                                %% Skip  Local or reuse data or does not have EnableLoggnig flag
                                                %continue
                                            %else
                                                %assign stateIdxStr = stateIdxStr + "%<commavar>" + cr + cr + "%<cSIdx>"
                                                %assign commavar = ","
                                                %assign structIdx  = contState.MemoryMapIdx[0]
                                                %assign secIdx     = contState.MemoryMapIdx[1]
                                                %assign dataIdx    = contState.MemoryMapIdx[2]
                                                %if secIdx == -1
                                                    %% Unstructured data
                                                    %assign data        = UnstructuredData.Data[dataIdx]
                                                    %assign isComplex   = data.IsComplex
                                                    %assign dataTypeIdx = data.DataTypeIdx
                                                %elseif structIdx == -1
                                                    %% Custom data
                                                    %assign data       =  CustomData[secIdx].Data[dataIdx]
                                                    %if !FcnCSCSupportsCAPI(data)
                                                        %continue
                                                    %endif
                                                    %assign isComplex   = data.IsComplex
                                                    %assign dataTypeIdx = data.DataTypeIdx
                                                %else
                                                    %% Structured data
                                                    %assign section     = ...
                                                        StructuredData[structIdx].Section[secIdx]
                                                    %assign data        = section.Data[dataIdx]
                                                    %assign dataTypeIdx = section.DataTypeIdx
                                                    %assign isComplex   = section.IsComplex
                                                %endif
                                            %endif
                                            %% %assign contData = data %%Cache the data record
                                            %%
                                            %%  Continuous state attributes
                                            %%
                                            %assign offset = 0
                                            %assign name = section.Data[dataIdx].Name
                                            %foreach recIdx = contState.Partitions.NumPartitions
                                                %if offset>0
                                                    %assert ( LibGetDataWidth(contState)>1 )
                                                    %assign offsetAddr = "&%<name>[%<offset>]"
                                                %else
                                                    %assign offsetAddr = data.BaseAddr
                                                %endif
                                                %assign ppIf = data.PPIf
                                                %assign ppFi = data.PPEndIf
                                                %assign addrMapIdx     = im.NumDataAddr
                                                %assign comments = "%<im.NumDataAddr>: Continuous State"
                                                %assign isActiveDuringCodegen = 0
                                                %if isRM
                                                    %<FcnSetAddrMapInfoWithLogging(im, offsetAddr, "", comments, ppIf, ppFi, isActiveDuringCodegen)>
                                                %else
                                                    %<FcnSetAddrMapInfo(im, offsetAddr, comments, ppIf, ppFi, isActiveDuringCodegen)>
                                                %endif
                                                %% State Name
                                                %assign stateName      = contState.Partitions.Partition[recIdx].Name
                                                %assign pathAlias      = contState.Partitions.Partition[recIdx].PathAlias
                                                %assign pathAlias      = FcnReturnCompliantBlockPath(pathAlias, "State")
                                                %% Data Type
                                                %assign isPointer      = TLC_FALSE
                                                %assign dataTypeMapIdx = ...
                                                    FcnGetDataTypeMapIdx(dataTypeIdx,isComplex,isPointer,im)
                                                %% Dimension
                                                %assign dataNumRows = data.NumRows
                                                %copyrecord partitionData data
                                                %assign partitionData.NumRows = ...
                                                    contState.Partitions.Partition[recIdx].Width
                                                %assert (dataNumRows == data.NumRows)
                                                %assign dimMapIdx      = FcnGetDimensionMapIdx(partitionData,im, ppIf, ppFi)
                                                %% Fixed Point
                                                %if data.IsFixedPoint
                                                    %assign fxpMapIdx    = FcnGetFxpMapIdx(data,im)
                                                %else
                                                    %assign fxpMapIdx    = 0
                                                %endif
                                                %% SampleTime
                                                %% %if ISFIELD(Block[blkIdx], "TID")
                                                %%   %assign tID = Block[blkIdx].TID
                                                %% %else
                                                %%   %assign bRef   = Block[blkIdx]._blkref
                                                %%   %assign sysBlk = ::CompiledModel.System[bRef[0]].Block[bRef[2]]
                                                %%   %assign tID    = sysBlk.TID
                                                %% %endif
                                                %assign sTimeIdx = FcnGetSampTimeIdx(0, 0, im)
                                                %% Write data directly to BlockStates structure
                                                %if FcnDynamicAPI()
                                                    %assign needsAddressMapIndexVar = TLC_TRUE
                                                    %assign entryIndex = 0
                                                    %assign dynamicInit = dynamicInit + ppIf + "\n" + ...
                                                        tBlockStates + "[" ...
                                                        + numStates + "].addrMapIndex = " + addrMapIndex + ...
                                                        ";\n" + numStatesPP + ";\n" + addrMapIndexPP + ...
                                                        ";\n" + ppFi + "\n"
                                                %else
                                                    %assign entryIndex = addrMapIdx
                                                %endif
                                                %<ppIf>
                                                {%<entryIndex>, ...
                                                    %<offset + contState.StartIndex>, ...
                                                    TARGET_STRING("%<blkPath>"),
                                                TARGET_STRING("%<stateName>"),
                                                TARGET_STRING("%<pathAlias>"),
                                                0, %<dataTypeMapIdx>, %<dimMapIdx>, \
                                                %<fxpMapIdx>, %<sTimeIdx>, 1, -1, 0},
                                                %<ppFi>
                                                %if ISFIELD(contState, "VarGroupIdx") && ...
                                                    LibGetVarGroupCategory(contState.VarGroupIdx[0]) == "HierarchicalCoderData"
                                                    %assign groupIdx = ::CompiledModel.VarGroups.VarGroup[contState.VarGroupIdx[0]].CoderDataGroupIndex
                                                    %assign InCAPI.NumDataGroupElements[groupIdx] = InCAPI.NumDataGroupElements[groupIdx] + 1
                                                %endif
                                                %assign InCAPI.NumContStates = InCAPI.NumContStates + 1
                                                %assign offset = offset+contState.Partitions.Partition[recIdx].Width
                                            %endforeach %% recIdx =
                                        %endforeach %% cStateIdx = NumContStates
                                    %endwith
                                %endforeach   %% blkIdx = NumBlocks
                            %endwith   %% Subsystem[subsysIdx]
                        %endforeach    %% subsysIdx = NumSubsystems
                        {
                            0, -1, %<nulldef>, %<nulldef>, %<nulldef>, 0, 0, 0, 0, 0, 0, -1, 0
                        }
                    };
                %endif  %% RTWCAPIStates = 1

                %if ::isRAccel || IsModelReferenceSimTarget()
                    static %<tStateIdxListType> %<tStateIdxList>[] =\
                    {
                        %if stateIdxStr == ""
                            -1
                        %else
                            %<stateIdxStr>
                        %endif
                    };
                %endif
                %if RTWCAPIRootIO == 1 && !FcnCAPIRootIOSupport() && ...
                    MultiInstanceERTCode && ...
                    !IsModelReferenceTarget() && ...
                    !SLibFcnProtoCtrlActive() && ...
                    !SLibAutosarActive() && ...
                    !GenerateClassInterface
                    %if !UsingMalloc || (::CompiledModel.RootIOFormat ...
                        != "Part of model data structure")
                        %% Warn if user enabled RTWCAPIRootIO for a model generating reusable
                        %% code but without malloc or root-level IO passed as individual or
                        %% structure reference arguments.
                        %% NOTE: We warn only for the above case which is more common. We
                        %% will not warn for cases where FPC is enabled, or model reference
                        %% target, etc.
                        %<SLibReportWarningWithIdAndArgs("RTW:tlc:CAPIRootIOSupport", ::CompiledModel.Name)>
                    %endif
                %endif

                %if RTWCAPIRootIO == 1 && FcnCAPIRootIOSupport()
                    %% Start Root Inputs structure Arrays
                    /* Root Inputs information */
                    static %<constKeyword> %<tBlockSignalsType> %<tRootInputs>[]%<equalSign>{

                        /* addrMapIndex, sysNum, blockPath,
                        * signalName, portNumber, dataTypeIndex, dimIndex, fxpIndex, sTimeIndex
                        */

                        %assign portObj = SLibCreateDummyPortRecord()

                        %assign subsysIdx = 0 %% Root
                        %with Subsystem[subsysIdx]
                            %% Loop through Inport Blocks
                            %foreach inpBlkIdx = NumInportBlocks
                                %assign blkIdx = InportBlocks[inpBlkIdx]
                                %with Block[blkIdx]
                                    %% Loop through Data Output Ports & write root inputs data to
                                    %% RootInputs structure
                                    %foreach portIdx = NumDataOutputPorts
                                        %with DataOutputPort[portIdx]
                                            %assign regIdx = 0
                                            %assign portObj.SignalSrc = Region[regIdx]._Source
                                            %if ISFIELD(Region[regIdx],"BusSelElIdx")
                                                %% All regions of a vector within a NVB must have the same BusSelElIdx
                                                %assign portObj.BusSelElIdx = Region[regIdx].BusSelElIdx[0]
                                                %assign portObj.BusSelElCGTypeId = Region[regIdx].BusSelElCGTypeId[0]
                                            %endif
                                            %assign eiRec = SLibGetSourceRecord(portObj, 0)
                                            %assign constString = ""

                                            %if ISEMPTY(eiRec)
                                                %% Skip inports with no memory info. This probably is an
                                                %% inport outputting a function-call trigger signal.
                                                %continue
                                            %endif

                                            %if SLibIsCoderGroupUseAccessFcnForDataRecord(eiRec)
                                                %continue
                                            %endif

                                            %if ISFIELD(eiRec,"Inactive")
                                                %% Skip always inactive inports.
                                                %% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-codegen/CAPI/tInlineVariantsWithCAPI.m -testspec:test_RootIO_GPCoff
                                                %continue
                                            %endif

                                            %if (NumRegions > 1) || ...
                                                (TYPE(eiRec.TID) != "Number" && TYPE(eiRec.TID) != "Vector") || ...
                                                eiRec.MemoryMapIdx[2] == -1
                                                %assign errTxt = "Unhandled condition for C API Root IO"
                                                %<LibReportError(errTxt)>
                                            %endif

                                            %assign structIdx  = eiRec.MemoryMapIdx[0]
                                            %assign secIdx     = eiRec.MemoryMapIdx[1]
                                            %assign dataIdx    = eiRec.MemoryMapIdx[2]
                                            %if secIdx == -1
                                                %% Unstructured data
                                                %assign data = UnstructuredData.Data[dataIdx]
                                                %assign isComplex   = data.IsComplex
                                                %assign dataTypeIdx = data.DataTypeIdx
                                                %assign isPointer   = (data.Access == "indirect") ? 1 : 0
                                                %if eiRec.StorageTypeQualifier=="volatile"
                                                    %assign constString = "(void *) "
                                                %endif
                                            %elseif structIdx == -1
                                                %% Custom data
                                                %assign data =  CustomData[secIdx].Data[dataIdx]
                                                %if !FcnCSCSupportsCAPI(data)
                                                    %continue
                                                %endif
                                                %assign isComplex   = data.IsComplex
                                                %assign dataTypeIdx = data.DataTypeIdx
                                                %assign isPointer   = (data.Access == "indirect") ? 1 : 0
                                                %assign constString = "(void *) "
                                            %else
                                                %% Structured data
                                                %assign section     = ...
                                                    StructuredData[structIdx].Section[secIdx]
                                                %assign data        = section.Data[dataIdx]
                                                %assign dataTypeIdx = section.DataTypeIdx
                                                %assign isComplex   = section.IsComplex
                                                %% data access is "direct"
                                                %assign isPointer   = TLC_FALSE
                                            %endif
                                            %if !FcnDataSupportsCAPI(data)
                                                %continue
                                            %endif
                                            %%
                                            %<FcnOptionallyAddModelRefCanonicalInputNeededByCAPIFlag(eiRec)>
                                            %%
                                            %assign dataAddress = data.BaseAddr
                                            %assign dataIsFixPt = data.IsFixedPoint

                                            %createrecord recordToUseWithFxpMapIdx { }
                                            %if ISFIELD(Region[regIdx],"BusSelElIdx")
                                                %assign busSelElIdx = Region[regIdx].BusSelElIdx[0]
                                                %assert !ISEMPTY(busSelElIdx)
                                                %assign dataTypeIdx = LibCGTypeToSLType(Region[regIdx].BusSelElCGTypeId[0])
                                                %assign isComplex   = LibCGTypeIsComplex(Region[regIdx].BusSelElCGTypeId[0])
                                                %assign dataAddress = REGEXPREP( dataAddress, "\\[\\d+\\]$", "")
                                                %if busSelElIdx[0] != "." || LibDoesStringContainDotOrArrow(dataAddress)
                                                    %assign dataAddress = REGEXPREP( ...
                                                        dataAddress, "&(.*)", "&($1" + busSelElIdx + ")")
                                                %else
                                                    %assign dataAddress = REGEXPREP( ...
                                                        dataAddress, "&(.*)", "&((*$1)" + busSelElIdx + ")")
                                                %endif
                                                %assign dataIsStruct = LibIsStructDataType(dataTypeIdx)
                                                %assign dataIsFixPt = LibIsDataTypeFixpt(dataTypeIdx)
                                                %if dataIsFixPt
                                                    %assign fxpIdx = FcnGetUniformFixPtTypeInGMM(DataTypes.DataType[dataTypeIdx])
                                                    %addtorecord recordToUseWithFxpMapIdx \
                                                    FixedPointInfo GlobalMemoryMap.FixedPointMaps.FixPtRecord[fxpIdx]
                                                %endif
                                            %endif

                                            %% Address
                                            %assign addrMapIdx        = im.NumDataAddr
                                            %if !ISFIELD(Region[regIdx],"CAPIAddrMapIdx")
                                                %% If field exists, then it got written by signals.
                                                %addtorecord Region[regIdx] CAPIAddrMapIdx addrMapIdx
                                            %endif
                                            %if isPointer
                                                %assign sigAddress      = dataAddress
                                                %assign comments = "%<im.NumDataAddr>: Root Input Pointer"
                                            %else
                                                %assign sigAddress = constString + dataAddress
                                                %assign comments = "%<im.NumDataAddr>: Root Input"
                                            %endif
                                            %assign varCond = eiRec.VariantCondition
                                            %assign getAddrMapIdxVarCond = SLibGetVariantConditionCombineByOR(getAddrMapIdxVarCond, varCond)
                                            %if !ISEMPTY(varCond)
                                                %% ppIf and ppFi are the preprocessor records coming from code variants
                                                %% Hence, external inputs always have an empty ppIf and ppFi value
                                                %assign ppIf = SLibIfVariantConditionForm(varCond)
                                                %assign ppFi = SLibEndIfVariantConditionForm(varCond)
                                            %else
                                                %assign ppIf = data.PPIf
                                                %assign ppFi = data.PPEndIf
                                            %endif
                                            %% Block Path
                                            %assign grBlkIdx = [%<subsysIdx>, %<blkIdx>]
                                            %assign blkPath  = SLibMangledGrBlockPath(grBlkIdx)
                                            %assign blkPath  = FcnReturnCompliantBlockPath(blkPath, "Signal")
                                            %assign isActiveDuringCodegen = 1
                                            %if isRM
                                                %<FcnSetAddrMapInfoWithLogging(im, sigAddress, "", comments, ppIf, ppFi, isActiveDuringCodegen)>
                                            %else
                                                %<FcnSetAddrMapInfo(im, sigAddress, comments, ppIf, ppFi, isActiveDuringCodegen)>
                                            %endif
                                            %% Signal Label
                                            %if eiRec.SigLabel != ""
                                                %assign sigLabel = STRING(eiRec.SigLabel)
                                            %else
                                                %assign sigLabel = ""
                                            %endif
                                            %% Data Type
                                            %assign dataTypeMapIdx = ...
                                                FcnGetDataTypeMapIdx(dataTypeIdx,isComplex,isPointer,im)
                                            %% Dimension
                                            %assign dimMapIdx = FcnGetDimensionMapIdx(data,im, ppIf, ppFi)
                                            %% Fixed Point
                                            %if dataIsFixPt
                                                %if !ISEMPTY(recordToUseWithFxpMapIdx)
                                                    %assign fxpMapIdx = FcnGetFxpMapIdx(recordToUseWithFxpMapIdx,im)
                                                %else
                                                    %assign fxpMapIdx = FcnGetFxpMapIdx(data,im)
                                                %endif
                                            %else
                                                %assign fxpMapIdx = 0
                                            %endif
                                            %% sample time index
                                            %if eiRec.FrameData == "yes"
                                                %assign isFrame =  1
                                            %else
                                                %assign isFrame =  0
                                            %endif
                                            %assign tID      = eiRec.TID
                                            %assign sTimeIdx = FcnGetSampTimeIdx(tID,isFrame,im)
                                            %% get the system number
                                            %assign sysNum = eiRec.SysNum

                                            %% Write data directly to RootInputs structure
                                            %if FcnDynamicAPI()
                                                %assign needsAddressMapIndexVar = TLC_TRUE
                                                %assign entryIndex = 0
                                                %assign dynamicInit = dynamicInit + ppIf + "\n" + tRootInputs + ...
                                                    "[" + numRootInputs + "].addrMapIndex = " + addrMapIndex + ...
                                                    ";\n" + numRootInputsPP + ";\n" + addrMapIndexPP + ";\n" + ...
                                                    ppFi + "\n"
                                            %else
                                                %assign entryIndex = addrMapIdx
                                            %endif
                                            %assign portNum = inpBlkIdx + 1
                                            %<ppIf>
                                            {%<entryIndex>, %<sysNum>, TARGET_STRING("%<blkPath>"),
                                            TARGET_STRING("%<sigLabel>"), %<portNum>, %<dataTypeMapIdx>, \
                                            %<dimMapIdx>, %<fxpMapIdx>, %<sTimeIdx>},
                                            %<ppFi>

                                            %if ISFIELD(eiRec, "VarGroupIdx") && ...
                                                LibGetVarGroupCategory(eiRec.VarGroupIdx[0]) == "HierarchicalCoderData"
                                                %assign groupIdx = ::CompiledModel.VarGroups.VarGroup[eiRec.VarGroupIdx[0]].CoderDataGroupIndex
                                                %assign InCAPI.NumDataGroupElements[groupIdx] = InCAPI.NumDataGroupElements[groupIdx] + 1
                                            %else
                                                %assign InCAPI.NumRootInputs = InCAPI.NumRootInputs + 1
                                            %endif
                                        %endwith %% with DataOutputPort[portIdx]
                                    %endforeach %% foreach portIdx = NumDataOutputPorts

                                %endwith %% with Block[blkIdx]
                            %endforeach %% foreach inpBlkIdx = NumInportBlocks

                        %endwith %% with Subsystem[subsysIdx]

                        {
                            0, 0, %<nulldef>, %<nulldef>, 0, 0, 0, 0, 0
                        }
                    };

                    %% Start Root Outputs structure Arrays
                    /* Root Outputs information */
                    static %<constKeyword> %<tBlockSignalsType> %<tRootOutputs>[]%<equalSign>{

                        /* addrMapIndex, sysNum, blockPath,
                        * signalName, portNumber, dataTypeIndex, dimIndex, fxpIndex, sTimeIndex
                        */

                        %assign subsysIdx = 0 %% Root
                        %with Subsystem[subsysIdx]
                            %% Loop through Outport Blocks
                            %foreach outBlkIdx = NumOutportBlocks
                                %assign blkIdx = OutportBlocks[outBlkIdx]
                                %with Block[blkIdx]
                                    %assign virtBlock = (Block[blkIdx].Virtual > 0)

                                    %% Outport blocks that have a corresponding External Output, have an index to it.
                                    %if ISFIELD(Block[blkIdx],"ExternalOutputIdx")
                                        %assign eoIdx  = Block[blkIdx].ExternalOutputIdx
                                        %assign eoRec = ::CompiledModel.ExternalOutputs.ExternalOutput[eoIdx]
                                        %% Get the table of unique variant conditions.
                                        %if ISFIELD(VariantConditions, "CGVCEList")
                                            %assign cgvceList = VariantConditions.CGVCEList
                                        %else
                                            %assign cgvceList = ""
                                        %endif
                                    %else
                                        %continue
                                    %endif

                                    %if ISFIELD(eoRec,"Inactive")
                                        %% Skip always inactive outports.
                                        %% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-codegen/CAPI/tInlineVariantsWithCAPI.m -testspec:test_RootIO_GPCoff
                                        %continue
                                    %endif

                                    %if SLibIsCoderGroupUseAccessFcnForDataRecord(eoRec)
                                        %continue
                                    %endif

                                    %if virtBlock
                                        %assign errTxt = "Unhandled condition for C API Root IO"
                                        %<LibReportError(errTxt)>
                                    %endif

                                    %assign constString = ""

                                    %assign sysBlk = System[_blkref[0]].Block[_blkref[2]]
                                    %assign tid = sysBlk.TID
                                    %if TYPE(tid) != "Number" && ...
                                        TYPE(tid) == "String"
                                        %% Check for non-sampled signals
                                        %if tid != "constant" && ...
                                            tid != "trigger"
                                            %% Skip signals other than constant and triggered
                                            %continue
                                        %endif
                                    %endif
                                    %if eoRec.MemoryMapIdx[2] == -1
                                        %% If the Outport block does not have ExternalOutputIdx
                                        %% or if it exists and its memory is local, then its external
                                        %% output has been optimized out. Skip.
                                        %% Happens when:
                                        %% (1) gbd_RTWMatFileLogging is false AND
                                        %% (2) getIsRTWSfunction() is false AND
                                        %% (3) BdIsRootReferenceTarget is true
                                        %% Otherwise:
                                        %% (4) UsesRTWFcnProtoCtrl is false AND
                                        %% (5) gcb_NumRuntimeParams is 0 AND
                                        %% (5a) gbd_SaveOutput is false AND
                                        %% (5b) gbd_RTWMatFileLogging is false AND
                                        %% (5c) gcb_IsAnyInputSignalStorageAuto is false
                                        %% SLibExternalOutputIsVirtual(sysBlk)==true in this case
                                        %continue
                                    %else %% eoRec.MemoryMapIdx[2] != -1

                                        %assign structIdx  = eoRec.MemoryMapIdx[0]
                                        %assign secIdx     = eoRec.MemoryMapIdx[1]
                                        %assign dataIdx    = eoRec.MemoryMapIdx[2]
                                        %if secIdx == -1
                                            %% Unstructured data
                                            %assign data = UnstructuredData.Data[dataIdx]
                                            %assign isComplex   = data.IsComplex
                                            %assign dataTypeIdx = data.DataTypeIdx
                                            %assign isPointer   = (data.Access == "indirect") ? 1 : 0
                                        %elseif structIdx == -1
                                            %% Custom data
                                            %assign data =  CustomData[secIdx].Data[dataIdx]
                                            %if !FcnCSCSupportsCAPI(data)
                                                %continue
                                            %endif
                                            %assign isComplex   = data.IsComplex
                                            %assign dataTypeIdx = data.DataTypeIdx
                                            %assign isPointer   = (data.Access == "indirect") ? 1 : 0
                                            %assign constString = "(void *) "
                                        %else
                                            %% Structured data
                                            %assign section     = ...
                                                StructuredData[structIdx].Section[secIdx]
                                            %assign data        = section.Data[dataIdx]
                                            %assign dataTypeIdx = section.DataTypeIdx
                                            %assign isComplex   = section.IsComplex
                                            %% data access is "direct"
                                            %assign isPointer   = TLC_FALSE
                                        %endif
                                        %if !FcnDataSupportsCAPI(data)
                                            %continue
                                        %endif
                                        %assign dataAddress = data.BaseAddr
                                        %assign dataIsFixPt = data.IsFixedPoint

                                        %% Address
                                        %assign addrMapIdx        = im.NumDataAddr
                                        %if isPointer
                                            %assign sigAddress      = dataAddress
                                            %assign comments = "%<im.NumDataAddr>: Root Output Pointer"
                                        %else
                                            %assign sigAddress = constString + dataAddress
                                            %assign comments = "%<im.NumDataAddr>: Root Output"
                                        %endif
                                        %if ISFIELD(eoRec, "LocalCGVCEIdx") && (eoRec.LocalCGVCEIdx != -1)
                                            %assign varCond = cgvceList[eoRec.LocalCGVCEIdx]
                                        %else
                                            %assign varCond = ""
                                        %endif
                                        %assign getAddrMapIdxVarCond = SLibGetVariantConditionCombineByOR(getAddrMapIdxVarCond, varCond)
                                        %if !ISEMPTY(varCond)
                                            %assign ppIf = SLibIfVariantConditionForm(varCond)
                                            %assign ppFi = SLibEndIfVariantConditionForm(varCond)
                                        %else
                                            %assign ppIf = ""
                                            %assign ppFi = ""
                                        %endif
                                        %% Block Path
                                        %assign grBlkIdx = [%<subsysIdx>, %<blkIdx>]
                                        %assign blkPath  = SLibMangledGrBlockPath(grBlkIdx)
                                        %assign blkPath  = FcnReturnCompliantBlockPath(blkPath, "Signal")
                                        %assign isActiveDuringCodegen = 1
                                        %if isRM
                                            %<FcnSetAddrMapInfoWithLogging(im, sigAddress, "", comments, ppIf, ppFi, isActiveDuringCodegen)>
                                        %else
                                            %<FcnSetAddrMapInfo(im, sigAddress, comments, ppIf, ppFi, isActiveDuringCodegen)>
                                        %endif
                                        %% Signal Label
                                        %if eoRec.SigLabel != ""
                                            %assign sigLabel = STRING(eoRec.SigLabel)
                                        %else
                                            %assign sigLabel = ""
                                        %endif
                                        %% Data Type
                                        %assign dataTypeMapIdx = ...
                                            FcnGetDataTypeMapIdx(dataTypeIdx,isComplex,isPointer,im)
                                        %% Dimension
                                        %assign dimMapIdx = FcnGetDimensionMapIdx(data,im, ppIf, ppFi)
                                        %% Fixed Point
                                        %if dataIsFixPt
                                            %assign fxpMapIdx = FcnGetFxpMapIdx(data,im)
                                        %else
                                            %assign fxpMapIdx = 0
                                        %endif
                                        %% sample time index
                                        %if eoRec.FrameData == "yes"
                                            %assign isFrame =  1
                                        %else
                                            %assign isFrame =  0
                                        %endif
                                        %if TYPE(tid) == "Number" || TYPE(tid) == "Vector"
                                            %assign tID      = tid
                                            %assign sTimeIdx = FcnGetSampTimeIdx(tID,isFrame,im)
                                        %elseif tid == "constant"
                                            %assign tID      = -2
                                            %assign sTimeIdx = FcnGetSampTimeIdx(tID,isFrame,im)
                                        %elseif tid == "trigger"
                                            %assign tID      = -1
                                            %assign sTimeIdx = FcnGetSampTimeIdx(tID,isFrame,im)
                                        %else
                                            %<SLibReportErrorWithId("RTW:tlc:TIDType")>
                                        %endif
                                        %% System number always corresponds to Root
                                        %assign sysNum = subsysIdx
                                    %endif %% Non-local data
                                    %% Write data directly to RootOutputs structure
                                    %if FcnDynamicAPI()
                                        %assign needsAddressMapIndexVar = TLC_TRUE
                                        %assign entryIndex = 0
                                        %assign dynamicInit = dynamicInit + ppIf + "\n" + tRootOutputs + ...
                                            "[" + numRootOutputs + "].addrMapIndex = " + addrMapIndex + ...
                                            ";\n" + numRootOutputsPP + ";\n" + addrMapIndexPP + ";\n" + ...
                                            ppFi + "\n"
                                    %else
                                        %assign entryIndex = addrMapIdx
                                    %endif
                                    %assign portIdx = outBlkIdx + 1
                                    %<ppIf>
                                    {%<entryIndex>, %<sysNum>, TARGET_STRING("%<blkPath>"),
                                    TARGET_STRING("%<sigLabel>"), %<portIdx>, %<dataTypeMapIdx>, \
                                    %<dimMapIdx>, %<fxpMapIdx>, %<sTimeIdx>},
                                    %<ppFi>

                                    %if ISFIELD(eoRec, "VarGroupIdx") && ...
                                        LibGetVarGroupCategory(eoRec.VarGroupIdx[0]) == "HierarchicalCoderData"
                                        %assign groupIdx = ::CompiledModel.VarGroups.VarGroup[eoRec.VarGroupIdx[0]].CoderDataGroupIndex
                                        %assign InCAPI.NumDataGroupElements[groupIdx] = InCAPI.NumDataGroupElements[groupIdx] + 1
                                    %else
                                        %assign InCAPI.NumRootOutputs = InCAPI.NumRootOutputs + 1
                                    %endif

                                %endwith %% with Block[blkIdx]
                            %endforeach %% foreach blkIdx = NumOutportBlocks

                        %endwith %% with Subsystem[subsysIdx]
                        {
                            0, 0, %<nulldef>, %<nulldef>, 0, 0, 0, 0, 0
                        }
                    };
                %endif %% if RTWCAPIRootIO == 1 && FcnCAPIRootIOSupport()

                %%for generating C-API in cpp
            %endif  %% %if tempSLfeature==0 || tempSLfeature==2

        %endwith  %% BlockHierarchyMap
        %% end of BlockHierarchyMap loop ===========================================

        %%for generating C-API in cpp
        %if tempSLfeature==0 || tempSLfeature==2

            %if RTWCAPIParams ==1
                %% Tunable Variable Parameters
                %%
                /* Tunable variable parameters */
                static %<constKeyword> %<tModelParamsType> %<tModelParams>[]%<equalSign>{

                    /* addrMapIndex, varName, dataTypeIndex, dimIndex, fixPtIndex */

                    %with ModelParameters
                        %foreach paramIdx = NumModelParameters
                            %assign param = ModelParameter[paramIdx]
                            %foreach instIdx = param.NumInstances
                                %assign constString = ""
                                %assign structIdx = param.Instance[instIdx].MemoryMapIdx[0]
                                %assign secIdx    = param.Instance[instIdx].MemoryMapIdx[1]
                                %assign dataIdx   = param.Instance[instIdx].MemoryMapIdx[2]
                                %if secIdx == -1         %% [-1 -1 dataIdx]
                                    %% Unstructured data
                                    %assign data        = UnstructuredData.Data[dataIdx]
                                    %assign dTypeIdx    = data.DataTypeIdx
                                    %assign isComplex   = data.IsComplex
                                    %assign isPointer   = (data.Access == "indirect") ? 1 : 0
                                    %assign section     = data
                                %elseif structIdx == -1  %% [-1 secIdx dataIdx]
                                    %% Custom data
                                    %assign data        = CustomData[secIdx].Data[dataIdx]
                                    %if !FcnCSCSupportsCAPI(data)
                                        %continue
                                    %endif
                                    %assign dTypeIdx    = data.DataTypeIdx
                                    %assign isComplex   = data.IsComplex
                                    %assign isPointer   = (data.Access == "indirect") ? 1 : 0
                                    %assign constString = "(void *) "
                                    %assign section     = data
                                %else                    %% [structIdx secIdx dataIdx]
                                    %% Structured data
                                    %assign section     = StructuredData[structIdx].Section[secIdx]
                                    %assign data        = section.Data[dataIdx]
                                    %assign dTypeIdx    = section.DataTypeIdx
                                    %assign isComplex   = section.IsComplex
                                    %% data access is "direct"
                                    %assign isPointer   = TLC_FALSE
                                %endif
                                %%------------SLRTSPECIALCASE---------------
                                %if ( (skipComplex && isComplex) || (skipStruct && data.IsStruct) )
                                    %continue
                                %endif
                                %%------------SLRTSPECIALCASE---------------
                                %if !FcnDataSupportsCAPI(data)
                                    %continue
                                %endif
                                %% If parameter is used to specify startup activation, do not include it in the CAPI
                                %if data.IsVariantControlPrmInStartupActivation
                                    %continue
                                %endif
                                %if instIdx == 0
                                    %% Model Parameter Address
                                    %assign addrMapIdx     = im.NumDataAddr
                                    %if isPointer
                                        %assign paramAddress    = data.BaseAddr
                                        %assign comments = "%<im.NumDataAddr>: Model Parameter Pointer"
                                    %else
                                        %assign paramAddress    = constString + data.BaseAddr
                                        %assign comments = "%<im.NumDataAddr>: Model Parameter"
                                    %endif
                                    %assign ppIf = data.PPIf
                                    %assign ppFi = data.PPEndIf
                                    %assign getAddrMapIdxVarCond = SLibGetVariantConditionCombineByOR(getAddrMapIdxVarCond, data.VarCond)
                                    %assign isActiveDuringCodegen = 0
                                    %if isRM
                                        %<FcnSetAddrMapInfoWithLogging(im, paramAddress, "", comments, ppIf, ppFi, isActiveDuringCodegen)>
                                    %else
                                        %<FcnSetAddrMapInfo(im, paramAddress, comments, ppIf, ppFi, isActiveDuringCodegen)>
                                    %endif
                                    %% Variable Name
                                    %assign varName       = param.Name
                                    %% Data Type
                                    %assign dataTypeMapIdx = ...
                                        FcnGetDataTypeMapIdx(dTypeIdx, isComplex, isPointer, im)
                                    %% Dimension
                                    %assign dimMapIdx     = FcnGetDimensionMapIdx(data, im, "", "")
                                    %% Fixed Point
                                    %if data.IsFixedPoint
                                        %%------------SLRTSPECIALCASE---------------
                                        %if (skipwideFxPt)
                                            %if (data.FixedPointInfo.NumBits > 52)
                                                %continue
                                            %endif
                                        %endif
                                        %%------------SLRTSPECIALCASE---------------
                                        %assign fxpMapIdx   = FcnGetFxpMapIdx(data,im)
                                    %else
                                        %assign fxpMapIdx   = 0
                                    %endif
                                    %if ISFIELD(param, "CoderDataGroupIdx")
                                        %assign groupIdx = param.CoderDataGroupIdx
                                        %assign InCAPI.NumDataGroupElements[groupIdx] = InCAPI.NumDataGroupElements[groupIdx] + 1
                                    %endif
                                    %assign InCAPI.NumVariableParams = InCAPI.NumVariableParams + 1

                                    %if FcnDynamicAPI()
                                        %assign needsAddressMapIndexVar = TLC_TRUE
                                        %assign entryIndex = 0
                                        %assign dynamicInit = dynamicInit + ppIf + "\n" + ...
                                            tModelParams + "[" + numModelParams + "].addrMapIndex = " + ...
                                            addrMapIndex + ";\n" + numModelParamsPP + ";\n" + ...
                                            addrMapIndexPP + ";\n" + ppFi + "\n"
                                    %else
                                        %assign entryIndex = addrMapIdx
                                    %endif
                                    %%------------SLRTSPECIALCASE---------------
                                    %if EXISTS(slrt)
                                        %createrecord paramInfo { ...
                                            data        data    ...
                                            section     section ...
                                            blkPath     ""      ...
                                            paramName   varName  ...
                                            dataTypeIdx dTypeIdx ...
                                            isComplex   isComplex ...
                                        }
                                        %<slrtModelParameterHook(capiFile, paramInfo)>
                                    %endif
                                    %%------------SLRTSPECIALCASE---------------
                                    %<ppIf>
                                    {%<entryIndex>, TARGET_STRING("%<varName>"), %<dataTypeMapIdx>, %<dimMapIdx>, %<fxpMapIdx>},
                                    %<ppFi>
                                %endif
                            %endforeach  %% Instance
                        %endforeach  %% Parameter
                    %endwith  %% Model Parameters
                    {0, %<nulldef>, 0, 0, 0 }
                };
            %endif   %% RTWCAPIParams

            %%for generating C-API in cpp
        %endif  %% %if tempSLfeature==0 || tempSLfeature==2

    %endwith %% ::CompiledModel.GlobalMemoryMap

    %%for generating C-API in cpp
    %if tempSLfeature==0 || tempSLfeature==2

        %if EXISTS(slrt)
            %<close_slrt(capiFile)>
        %endif

        %% Keep a count of Data Address. Used to allocate memory in RTModel
        %<LibAddToCompiledModel("NumDataAddrInMap", im.NumDataAddr)>
        %%for generating C-API in cpp
    %endif  %% %if tempSLfeature==0 || tempSLfeature==2

    %%
    %% Ground Addr ========================================================
    %%
    %if im.NumGrounds > 0
        %foreach idx = im.NumGrounds
            %<im.GroundsMap[idx]>;
        %endforeach
    %endif

    %%
    %% AddressMap and Initialize function ====================================
    %%

    %%for generating C-API in cpp
    %if tempSLfeature==1
        %if SIZE(tempRepo)!=[1, 1]
            %assign InCAPI_FromCPP = tempRepo[2]
            %assign InCAPI.NumBIOSignals = InCAPI_FromCPP[0]
            %assign InCAPI.NumBlockParams = InCAPI_FromCPP[1]
            %assign InCAPI.NumDiscStates = InCAPI_FromCPP[4]
            %assign InCAPI.NumRootInputs = InCAPI_FromCPP[7]
            %assign InCAPI.NumRootOutputs = InCAPI_FromCPP[8]
            %assign InCAPI.NumSFLocals = InCAPI_FromCPP[9]
            %assign InCAPI.NumVarDimsSignals = InCAPI_FromCPP[10]
            %assign InCAPI.NumVariableParams = InCAPI_FromCPP[11]
        %endif
    %endif  %% %if tempSLfeature==1

    %assign args = FcnCAPIInitializeFcnArgs(InCAPI)

    %%for generating C-API in cpp
    %if tempSLfeature==1 || tempSLfeature==0
        %assign ::tempRepo2 = FEVAL("genCapiInCpp","","","","","","","","","","","","","","","","",args)
    %endif

    %%for generating C-API in cpp
    %if tempSLfeature==0 || tempSLfeature==2


        %if !UsingMalloc
            %if !IsMultiInstanceERTOrModelReference()
                %if im.NumDataAddr > 0
                    #ifndef HOST_CAPI_BUILD
                    /* Declare Data Addresses statically */
                    static %<tDataAddrType> %<tDataAddrMap>[]%<equalSign>{
                        %assign needsNullGuard = TLC_TRUE
                        %foreach idx = im.NumDataAddr
                            %if needsNullGuard && !WHITE_SPACE(im.AddrMap[idx]) && WHITE_SPACE(im.AddrMapIf[idx])
                                %assign needsNullGuard = TLC_FALSE
                            %endif
                            %<im.AddrMapIf[idx]>
                            %<im.AddrMap[idx]>, \
                            /* %<im.AddrMapComments[idx]> */
                            %<im.AddrMapEndIf[idx]>
                        %endforeach
                        %if needsNullGuard || FcnDynamicAPI()
                            %<SLibGetNullDefinitionFromTfl()>
                        %endif
                    };
                %else  %% if im.NumDataAddr <=0
                    static %<tDataAddrType> *%<tDataAddrMap>%<scalarTokens[0]>%<nulldef>%<scalarTokens[1]>;
                %endif  %% if im.NumDataAddr

                %if im.NumVarDimsAddr > 0
                    /* Declare Data Run-Time Dimension Buffer Addresses statically */
                    static %<tVarDimsAddrMapType> %<tVarDimsAddrMap>[]%<equalSign>{
                        %foreach idx = im.NumVarDimsAddr-1
                            %<im.VarDimsAddrMapIf[idx]>
                            %<im.VarDimsAddrMap[idx]>,
                            %<im.VarDimsAddrMapEndIf[idx]>
                        %endforeach
                        %<im.VarDimsAddrMap[im.NumVarDimsAddr-1]>
                    };
                    #endif
                %else  %% if im.NumVarDimsAddr <=0
                    static %<tVarDimsAddrMapType> *%<tVarDimsAddrMap>%<scalarTokens[0]>%<nulldef>%<scalarTokens[1]>;
                %endif  %% if im.NumDataAddr
            %else   %% if IsMultiInstanceERTorModelReference()
                %assign typePrefix = SLibGetModelTypesNamespacePrefix()
                %if im.NumDataAddr > 0
                    %assign fcnName = "%<prefix>InitializeDataAddr"
                    %assign fcnReturns = "static void"
                    %assign hasSelfParam = TLC_FALSE
                    %assign fcnParams = "%<args.dArg>%<args.rtmArg>%<args.uArg>%<args.bArg>%<args.pArg>%<args.dwArg>%<args.xArg>%<args.ssArg>%<FcnGetCAPIGroupInfo(args, "Arg")>"
                    %if SLibGetDoesSelfHasCoderDataGroup()
                        %if !ISEMPTY(args.rtmArg) && SLibSynthesizedRTM()
                            %assign hasSelfParam = TLC_TRUE
                        %else
                            %assign comma = ISEMPTY(fcnParams) ? "" : ", "
                            %assign fcnParams = "%<typePrefix>%<::tSimStructType> *const %<::tSimStruct>" + "%<comma>" + "%<fcnParams>"
                            %assign hasSelfParam = TLC_TRUE
                        %endif
                    %endif

                    %assign fcnAbstract = "Initialize Data Address"

                    %openfile mallocCode
                    %if !SimstructBasedTarget && !IsModelReferenceTarget() && !GenerateClassInterface ...
                        && UsingMalloc
                        %assign comma = ISEMPTY(fcnParams) ? "" : ", "
                        %if ~hasSelfParam
                            %assign fcnParams = "%<typePrefix>%<::tSimStructType> *const %<::tSimStruct>" + "%<comma>" + "%<fcnParams>"
                        %endif
                        %assign nDataAddr = im.NumDataAddr
                        %assign dAddrType = tDataAddrType

                        %if GenRTModel
                            %assign capiStructId = RTMGet("DataMapInfo")
                        %else
                            %assert isRSim && !IsModelReferenceTarget()
                            %assign capiStructId = "(*%<RSimRTWCAPIVarPtr>)"
                        %endif
                    %endif
                    %closefile mallocCode

                    %createrecord fcnRec {Name fcnName; Returns fcnReturns; Params fcnParams; Abstract fcnAbstract; ...
                        Category "model"; GeneratedBy "capi.tlc"; Type "Initialize"}
                    #ifndef HOST_CAPI_BUILD
                    %<SLibDumpFunctionBanner(fcnRec)>
                    %undef fcnRec
                    %<SLibGetFcnMemSecPragma(fcnName, "MemSecFuncInitTerm", "Pre")>\
                    %<fcnReturns> %<fcnName>(%<fcnParams>) {

                        %<mallocCode>

                        %if FcnDynamicAPI()
                            int dataIdx = 0;
                        %endif
                        %foreach idx = im.NumDataAddr
                            %<im.AddrMapIf[idx]>
                            %assign dataAddress = "(void*) (%<im.AddrMap[idx]>)"
                            %if IsModelRefCanonicalInputNeededByCAPI()
                                %assign baseSysIdx = GetBaseSystemIdx()
                                %with System[baseSysIdx].Interface
                                    %foreach ciIdx = NumCanonicalInputArgDefs
                                        %assign ci = CanonicalInputArgDef[ciIdx]
                                        %assign identi = LibGetRecordIdentifier(ci)
                                        %assign dataAddrStr = "%<im.AddrMap[idx]>"
                                        %if FEVAL("eval", "contains('%<dataAddrStr>', '%<identi>')")
                                            %assign dataAddress = "(void*) (%<im.AddrMap[idx]>)"
                                        %endif
                                    %endforeach
                                %endwith
                            %endif

                            %if FcnDynamicAPI()
                                dataAddr[dataIdx] = %<dataAddress>;
                                dataIdx++;
                            %else
                                dataAddr[%<idx>] = %<dataAddress>;
                            %endif
                            %<im.AddrMapEndIf[idx]>
                        %endforeach
                        %if FcnDynamicAPI()
                            (void)dataIdx;
                        %endif
                    }
                    %<SLibGetFcnMemSecPragma(fcnName, "MemSecFuncInitTerm", "Post")>\
                    #endif
                %endif %% im.NumDataAddr > 0

                %if im.NumDataAddr > 0
                    %assign fcnAbstract = "Initialize Data Run-Time Dimension Buffer Address"
                    %assign fcnName = "%<prefix>InitializeVarDimsAddr"
                    %assign fcnReturns = "static void"

                    %if im.NumVarDimsAddr <= 0 || (im.NumVarDimsAddr==1 && ...
                        ISEQUAL(im.VarDimsAddrMap[0],SLibGetNullDefinitionFromTfl()))
                        %% DWork is not used, so do not pass it as a function argument.
                        %assign dwDecl = ""
                    %else
                        %assign dwDecl = "%<args.dwArg>%<args.ssArg>%<FcnGetCAPIGroupInfo(args, "Arg")>"
                    %endif
                    %assign fcnParams = "%<args.vArg>%<dwDecl>"

                    %assign hasSelfParam = !ISEMPTY(args.rtmArg) && SLibSynthesizedRTM()
                    %if SLibIsSelfStructured() && !IsModelReferenceSimTarget() && !hasSelfParam
                        %assign comma = ISEMPTY(fcnParams) ? "" : ", "
                        %assign fcnParams = "%<typePrefix>%<::tSimStructType> *const %<::tSimStruct>" + "%<comma>" + "%<fcnParams>"
                        %assign hasSelfParam = TLC_TRUE
                    %endif

                    %openfile mallocCode
                    %if !SimstructBasedTarget && !IsModelReferenceTarget() && !GenerateClassInterface && ...
                        UsingMalloc

                        %if ISEMPTY(fcnParams)
                            %assign comma = ""
                        %else
                            %assign comma = ", "
                        %endif
                        %if !hasSelfParam
                            %assign fcnParams = "%<typePrefix>%<::tSimStructType> *const %<::tSimStruct>" + "%<comma>" + "%<fcnParams>"
                        %endif

                        %assign nVarDimsAddr = im.NumVarDimsAddr
                        %assign capiStructId = RTMGet("DataMapInfo")

                    %endif
                    %closefile mallocCode

                    %createrecord fcnRec {Name fcnName; Returns fcnReturns; Params fcnParams; Abstract fcnAbstract; ...
                        Category "model"; GeneratedBy "capi.tlc"; Type "Initialize"}
                    %<SLibDumpFunctionBanner(fcnRec)>
                    %undef fcnRec
                    #ifndef HOST_CAPI_BUILD
                    %<SLibGetFcnMemSecPragma(fcnName, "MemSecFuncInitTerm", "Pre")>\
                    %<fcnReturns> %<fcnName>(%<fcnParams>) {

                        %<mallocCode>

                        %foreach idx = im.NumVarDimsAddr
                            %<im.VarDimsAddrMapIf[idx]>
                            vardimsAddr[%<idx>] = %<im.VarDimsAddrMap[idx]>;
                            %<im.VarDimsAddrMapEndIf[idx]>
                        %endforeach
                    }
                    %<SLibGetFcnMemSecPragma(fcnName, "MemSecFuncInitTerm", "Post")>\
                    #endif
                %endif %% im.NumDataAddr > 0
            %endif %% if IsMultiInstanceERTorModelReference()
        %endif %% !UsingMalloc


        %%
        %% Matfile logging function pointers initialization function ==============
        %%
        %if !UsingMalloc
            %if IsMultiInstanceERTOrModelReference()
                %if im.NumDataAddr > 0
                    %assign fcnAbstract = "Initialize logging function pointers"
                    %assign fcnName = "%<prefix>InitializeLoggingFunctions"
                    %assign fcnReturns = "static void"
                    %assign dwDecl = args.dwDeclCache
                    %assign fcnParams = "RTWLoggingFcnPtr loggingPtrs[]"

                    #ifndef HOST_CAPI_BUILD

                    %createrecord fcnRec {Name fcnName; Returns fcnReturns; Params fcnParams; Abstract fcnAbstract; ...
                        Category "model"; GeneratedBy "capi.tlc"; Type "Initialize"}
                    %<SLibDumpFunctionBanner(fcnRec)>
                    %undef fcnRec
                    %<fcnReturns> %<fcnName>(%<fcnParams>) {
                        %if ISEMPTY(im.LoggingFcns)
                            %foreach idx = im.NumDataAddr
                                loggingPtrs[%<idx>] = %<SLibGetNullDefinitionFromTfl()>;
                            %endforeach
                        %else
                            %foreach idx = im.NumDataAddr
                                %if im.LoggingFcns[idx] == ""
                                    %assign im.LoggingFcns[idx] = SLibGetNullDefinitionFromTfl()
                                %endif
                                loggingPtrs[%<idx>] = %<im.LoggingFcns[idx]>;
                            %endforeach
                        %endif

                    }

                    #endif
                %endif
            %endif
        %endif

        %assign tgtconstKeyword = "TARGET_CONST"
        %%
        %% DataTypeMap ============================================================
        %%
        /* Data Type Map - use dataTypeMapIndex to access this structure */
        static %<tgtconstKeyword> %<tDataTypeMapType> %<tDataTypeMap>[]%<equalSign>{

            /* cName, mwName, numElements, elemMapIndex, dataSize, slDataId, *
            * isComplex, isPointer, enumStorageType */

            %if im.NumDataTypes > 0
                %foreach idx = im.NumDataTypes - 1
                    %<im.DataTypeMap[idx]>,
                %endforeach
                %<im.DataTypeMap[im.NumDataTypes-1]>
            %else
                {
                    "", "", 0, 0, 0, 0, 0, 0, 0
                }
            %endif
        };
        %%------slrtspecialcase------------
        %if EXISTS(slrt)
            %<slrt_dtypeHook(im)>
        %endif
        %%------slrtspecialcase------------

        #ifdef HOST_CAPI_BUILD
        #undef sizeof
        #endif

        %%
        %% Bus Element Map =========================================================
        %%
        /* Structure Element Map - use elemMapIndex to access this structure */
        static %<tgtconstKeyword> %<tElementMapType> %<tElementMap>[]%<equalSign>{

            /* elementName, elementOffset, dataTypeIndex, dimIndex, fxpIndex */

            {%<nulldef>, 0, 0, 0, 0},
            %if im.NumElements > 1
                %foreach idx = im.NumElements - 2
                    %<im.ElemMap[idx]>,
                %endforeach
                %<im.ElemMap[im.NumElements-2]>
            %endif
        };

        %%
        %% DimensionMap ==========================================================
        %%
        /* Dimension Map - use dimensionMapIndex to access elements of ths structure*/
        static %<constKeyword> %<tDimensionMapType> %<tDimensionMap>[]%<equalSign>{

            /* dataOrientation, dimArrayIndex, numDims, vardimsIndex */

            %if im.NumDimensionMaps > 0
                %foreach idx = im.NumDimensionMaps - 1
                    %% DimensionMap is always present and we do not need to guard the dimensionMap
                    %% structure.Moreover, when we generate dynamic CAPIs for codevariants/inlinevariants
                    %% the dimensionIndex is statically determined, unlike the addressMapIndex which is
                    %% done dynamically. Hence, we should not be guarding the dimensionMap
                    %% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-codegen/CAPI/tInlineVariantsWithCAPI.m -testspec: g1499247
                    %<im.DimensionMap[idx]>,
                %endforeach
                %<im.DimensionMap[im.NumDimensionMaps-1]>
            %else
                {
                    rtwCAPI_SCALAR, 0, 0, 0
                }
            %endif
        };

        %%
        %% DimensionArray ========================================================
        %%
        /* Dimension Array- use dimArrayIndex to access elements of this array */
        %if  im.NumDimArray > 0
            static %<constKeyword> %<tDimensionArrayType> %<tDimensionArray>[]%<equalSign>{
                %foreach idx = im.NumDimArray - 1
                    %<im.DimArray[idx]>,\
                    /* %<im.DimArrayComments[idx]> */
                %endforeach
                %<im.DimArray[im.NumDimArray-1]> \
                /* %<im.DimArrayComments[im.NumDimArray-1]> */
            };
        %else
            static %<constKeyword> %<tDimensionArrayType> %<tDimensionArray>[]%<equalSign>{0};
        %endif

        %%
        %% Double Values ========================================================
        %%
        %if im.NumDoubles > 0
            /* C-API stores floating point values in an array. The elements of this  *
            * are unique. This ensures that values which are shared across the model*
            * are stored in the most efficient way. These values are referenced by  *
            *           - %<tFixPtMapType>.fracSlopePtr,                            *
            *           - %<tFixPtMapType>.biasPtr,                                 *
            *           - %<tSampleTimeMapType>.samplePeriodPtr,                    *
            *           - %<tSampleTimeMapType>.sampleOffsetPtr                     */


            static const %<realType> rtcapiStoredFloats[]%<equalSign>{
                %foreach idx = im.NumDoubles - 1
                    %<im.DoublesMap[idx]>,\
                %endforeach
                %<im.DoublesMap[im.NumDoubles-1]>
            };
        %endif
        %%
        %% Fixed Point Map =======================================================
        %%
        /* Fixed Point Map */
        static %<constKeyword> %<tFixPtMapType> %<tFixPtMap>[]%<equalSign>{

            /* fracSlopePtr, biasPtr, scaleType, wordLength, exponent, isSigned */

            {%<nulldef>, %<nulldef>, rtwCAPI_FIX_RESERVED, 0, 0, (%<booleanType>)0 },
            %if im.NumFixPoint > 1
                %foreach idx = im.NumFixPoint - 2
                    %<im.FixPointMap[idx]>,
                %endforeach
                %<im.FixPointMap[im.NumFixPoint-2]>
            %endif
        };

        %%
        %% Sample Time Map =====================================================
        %%
        /* Sample Time Map - use sTimeIndex to access elements of ths structure */
        static %<constKeyword> %<tSampleTimeMapType> %<tSampleTimeMap>[]%<equalSign>{

            /* samplePeriodPtr, sampleOffsetPtr, tid, samplingMode */

            %if im.NumSampleTimes > 0
                %foreach idx = im.NumSampleTimes - 1
                    %<im.SampleTimeMap[idx]>,
                %endforeach
                %<im.SampleTimeMap[im.NumSampleTimes - 1]>
            %else
                {
                    %<nulldef>, %<nulldef>, %<::CompiledModel.SampleTime[0].TID>, 0
                }
            %endif
        };



        %%for generating C-API in cpp
    %endif  %% %if tempSLfeature==0 || tempSLfeature==2




    %if RTWCAPISignals
        %assign tempBIOSig    = tBlockSignals
        %assign tempNumBIOSig = InCAPI.NumBIOSignals + InCAPI.NumExtInputs + ...
            InCAPI.NumSFLocals + InCAPI.NumGrndSignals
    %else
        %assign tempBIOSig    = nulldef
        %assign tempNumBIOSig = 0
    %endif
    %if RTWCAPIParams
        %assign tempBTuning    = tBlockParams
        %assign tempVTuning    = tModelParams
        %assign tempNumBTuning = InCAPI.NumBlockParams
        %assign tempNumVTuning = InCAPI.NumVariableParams
    %else
        %assign tempBTuning    = nulldef
        %assign tempVTuning    = nulldef
        %assign tempNumBTuning = 0
        %assign tempNumVTuning = 0
    %endif
    %if RTWCAPIStates
        %assign tempBStates    = tBlockStates
        %assign tempNumBStates = InCAPI.NumDiscStates + InCAPI.NumContStates
    %else
        %assign tempBStates    = nulldef
        %assign tempNumBStates = 0
    %endif
    %if RTWCAPIRootIO && FcnCAPIRootIOSupport()
        %assign tempRootInputs     = tRootInputs
        %% If we are creating a dynamic C API (in the face of code variants/inline variants), we
        %% will be updating the number of root inports/outports depending on the variant condition being
        %% active/inactive. Hence, initialize them to 0 here.
        %% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-codegen/CAPI/tInlineVariantsWithCAPI.m -testspec:test_RootIO
        %if FcnDynamicAPI()
            %assign tempNumRootInputs  = 0
        %else
            %assign tempNumRootInputs  = InCAPI.NumRootInputs
        %endif
        %assign tempRootOutputs    = tRootOutputs
        %if FcnDynamicAPI()
            %assign tempNumRootOutputs = 0
        %else
            %assign tempNumRootOutputs = InCAPI.NumRootOutputs
        %endif
    %else
        %assign tempRootInputs     = nulldef
        %assign tempNumRootInputs  = 0
        %assign tempRootOutputs    = nulldef
        %assign tempNumRootOutputs = 0
    %endif
    %if IsModelReferenceSimTarget()
        %assign tempStaticInfoLogging = "&mmiStaticInfoLogging"
    %else
        %assign tempStaticInfoLogging = nulldef
    %endif

    %% Define the number of systems
    %assign sysRanDWorkLen  = SIZE(SubsystemRanBC.SysRanDWork, 1)
    %assign tContextSystems = "rtContextSystems"
    %assign loggingInfoLen  = SIZE(loggingInfoStartIdx, 1)


    %%for generating C-API in cpp
    %if tempSLfeature==0 || tempSLfeature==2

        %%
        %% The following are ModelReference logging specific
        %%
        %if IsModelReferenceSimTarget()
            /* The context systems array */
            static %<intType> %<tContextSystems>[%<sysRanDWorkLen>];

            /* Logging Meta info */
            static rtwCAPI_LoggingMetaInfo loggingMetaInfo[]%<equalSign>{
                %if loggingInfoLen > 0
                    %foreach idx=loggingInfoLen-1
                        {%<idx>, %<loggingInfoStartIdx[idx]>, "%<loggingInfoBlockPath[idx]>",...
                            %<loggingInfoPortIndex[idx]>, %<loggingInfoSysNum[idx]>},
                    %endforeach
                    %assign idx = loggingInfoLen-1
                    {%<idx>, %<loggingInfoStartIdx[idx]>, "%<loggingInfoBlockPath[idx]>",...
                        %<loggingInfoPortIndex[idx]>, %<loggingInfoSysNum[idx]>}
                %else
                    {0, 0, "", 0}
                %endif
            };

            /*
            * ModelMapLoggingStaticInfo:
            *   {numSystems, contextSystems}
            */
            static rtwCAPI_ModelMapLoggingStaticInfo mmiStaticInfoLogging%<equalSign>{
                %if useDatasetLoggingHier
                    %<sysRanDWorkLen>, %<tContextSystems>, loggingMetaInfo, 0, %<SLibGetNullDefinitionFromTfl()>, ...
                        {%<numLogHierSigs>, rtSigHierLoggingInfo, rtSigHierLoggingChildIdxs}, ...
                        %<numStateflowLoggedSigs>, %<stateflowLoggedSigsName>
                %elseif busHier
                    %<sysRanDWorkLen>, %<tContextSystems>, loggingMetaInfo, %<numBusElements>, rtBusSignals, {0,%<SLibGetNullDefinitionFromTfl()>,%<SLibGetNullDefinitionFromTfl()>}, ...
                        %<numStateflowLoggedSigs>, %<stateflowLoggedSigsName>
                %else
                    %<sysRanDWorkLen>, %<tContextSystems>, loggingMetaInfo, 0, ...
                        %<SLibGetNullDefinitionFromTfl()>, ...
                        {0,%<SLibGetNullDefinitionFromTfl()>,%<SLibGetNullDefinitionFromTfl()>}, ...
                        %<numStateflowLoggedSigs>, %<stateflowLoggedSigsName>
                %endif
            };
        %endif

        static rtwCAPI_ModelMappingStaticInfo mmiStatic%<equalSign>{

            /* Signals:{signals, numSignals,
            *           rootInputs, numRootInputs,
            *           rootOutputs, numRootOutputs},
            * Params: {blockParameters, numBlockParameters,
            *          modelParameters, numModelParameters},
            * States: {states, numStates},
            * Maps:   {dataTypeMap, dimensionMap, fixPtMap,
            *          elementMap, sampleTimeMap, dimensionArray},
            * TargetType: targetType
            */

            %if FcnDynamicAPI()
                {%<tempBIOSig>, 0,
                %<tempRootInputs>, %<tempNumRootInputs>,
                %<tempRootOutputs>, %<tempNumRootOutputs>},
                {%<tempBTuning>, 0,
                %<tempVTuning>, 0},
                {%<tempBStates>, 0},
            %else
                {%<tempBIOSig>, %<tempNumBIOSig>,
                %<tempRootInputs>, %<tempNumRootInputs>,
                %<tempRootOutputs>, %<tempNumRootOutputs>},
                {%<tempBTuning>, %<tempNumBTuning>,
                %<tempVTuning>, %<tempNumVTuning>},
                {%<tempBStates>, %<tempNumBStates>},
            %endif
            {%<tDataTypeMap>, %<tDimensionMap>, %<tFixPtMap>,
            %<tElementMap>, %<tSampleTimeMap>, %<tDimensionArray>},
            "float",
            {%<ModelChecksum[0]>,
            %<ModelChecksum[1]>,
            %<ModelChecksum[2]>,
            %<ModelChecksum[3]>},
            %<tempStaticInfoLogging>, 0,
            (%<booleanType>)%<::ProtectedModelReferenceTarget>
            %if ::isRAccel || IsModelReferenceSimTarget()
                ,%<tStateIdxList>
            %endif
        };

        %% Include definition in model_capi.c(pp) file
        /* Function to get C API Model Mapping Static Info */
        const rtwCAPI_ModelMappingStaticInfo*
        %<::CompiledModel.Name>_GetCAPIStaticMap(void) {
            return &mmiStatic;
        }

        %%for generating C-API in cpp
    %endif  %% %if tempSLfeature==0 || tempSLfeature==2

    %%for generating C-API in cpp
    %if tempSLfeature==1
        %%if SIZE(tempRepo)!=[1, 1]
        %assign im.AddrMap = tempRepo[0]
        %assign im.NumDataAddr = SIZE(tempRepo[0],1)
        %assign im.VarDimsAddrMap = tempRepo[1]
        %assign im.NumVarDimsAddr = SIZE(tempRepo[1],1)
        %<LibAddToCompiledModel("NumDataAddrInMap", im.NumDataAddr)>
        %%endif
        %%for generating C-API in cpp
    %endif  %% %if tempSLfeature==1

    %% Include declaration in model.h file
    %openfile staticMapBuf
    /* Function to get C API Model Mapping Static Info */
    extern const rtwCAPI_ModelMappingStaticInfo*
    %<::CompiledModel.Name>_GetCAPIStaticMap(void);
    %closefile staticMapBuf
    %<SLibCacheCodeToFile("mdl_fcn_decl", staticMapBuf)>

    %%
    %% System arrays ========================================================
    %%
    %% Consider the following model:
    %%
    %%  /------------------------------------------------------\
    %%  |                                                      |
    %%  |   ___________       ___________       ____________   |
    %%  |   |         |       |         |       |          |   |
    %%  |   | Enable1 |       | Enable2 |       |  Model2  |   |
    %%  |   |_________|       |_________|       |__________|   |
    %%  |                                                      |
    %%  \------------------------------------------------------/
    %%
    %%  Where:
    %%  Enable1 : in ---> gain ---> out
    %%  Enable2 : another model block (Model1) with (in ----> gain -----> out)
    %%  Model2  : contains a copy of Enable1 (call it Enable3)
    %%
    %%  Each Model Reference code (in the MMI) will generate arrays that are
    %%  local to itself.  The root slot is always initialized by the parent
    %%  at run time but all systems slots are generated.
    %%
    %%  Hence, Model1 contains only two systems, root and tempModelReference
    %%  i.e the arrays will look as follows
    %%
    %%   <all tid numbers are arbitrary below>
    %%
    %%    system number    0          1
    %%    sysRanPtr   : [ sysRanPtr  NULL ]  sysRanPtr and rootTid are passed
    %%    sysRanTid   : [ rootTid     2   ]  the initilize function of parent
    %%    contextSys  : [   0         0   ]
    %%
    %%  Model2 contains another system that is the enabled subsystem, Enable3
    %%
    %%    system number    0          1          2
    %%    sysRanPtr   : [ sysRanPtr  NULL     dworkPtr ]
    %%    sysRanTid   : [ rootTid     2          4     ]
    %%    contextSys  : [   0         0          2     ]
    %%
    %%  'dworkPtr' is a pointer to the sysRanBC dwork entry that is generated
    %%  for Model2 and corresponds to the conditiionally executed system
    %%  Enable3.  Note that its contextSys number is itself 2.  If there was
    %%  another atomic system inside Enable3, it would get a unique system
    %%  number but its contextSys number would be 2.
    %%
    %assign sysRanDWork = SubsystemRanBC.SysRanDWork
    %assign baseIdx     = GetBaseSystemIdx()

    %if sysRanDWorkLen > 0 && IsModelReferenceSimTarget()
        #ifndef HOST_CAPI_BUILD
        %assign systemRan = "sysRanDType *systemRan[]"
        %assign systemTid = "%<intType> systemTid[]"

        %assign fcnName = "%<prefix>InitializeSystemRan"
        %assign fcnReturns = "static void"
        %assign fcnParams = ["%<::tSimStructType> *const %<::tSimStruct>, %<systemRan>%<args.dwArg>, ", ...
            "%<systemTid>, void *rootSysRanPtr, int rootTid"]
        %assign fcnAbstract = "Initialize the system ran breadcrumbs"
        %createrecord fcnRec {Name fcnName; Returns fcnReturns; Params fcnParams; Abstract fcnAbstract; ...
            Category "model"; GeneratedBy "capi.tlc"; Type "Initialize"}
        %<SLibDumpFunctionBanner(fcnRec)>
        %undef fcnRec

        %<fcnReturns> %<fcnName>(%<fcnParams[0]>
        %<fcnParams[1]>) {
            UNUSED_PARAMETER(%<RTMGetModelSS()>);
            %if !ISEMPTY(args.dwArg)
                UNUSED_PARAMETER(localDW);
            %endif

            %% systemRan
            %foreach i = sysRanDWorkLen
                %assign  dwIdx = sysRanDWork[i]
                %if (dwIdx > -1)
                    %assign dwRec = ::CompiledModel.DWorks.DWork[dwIdx]
                    %with System[baseIdx]
                        %assign sysDWork = SLibGetSysRanBCDWork(dwIdx)
                    %endwith
                    %assert (dwRec.Name == "SubsysRanBC")
                    %assign  sigAddr = "&"+ sysDWork
                    systemRan[%<i>] = (sysRanDType *)%<sigAddr>;
                %else
                    %if i==0
                        systemRan[%<i>] = (sysRanDType *) rootSysRanPtr;
                    %else
                        systemRan[%<i>] = %<nulldef>;
                    %endif
                %endif
            %endforeach

            %% systemTid
            %foreach i = ::CompiledModel.NumSystems
                %with System[i]
                    %if Type == "root"
                        systemTid[0] = rootTid; %% rootTid is an argument to this fcn
                    %else
                        %assign numDescSys = SIZE(DescSysIdx, 1)
                        %foreach j = numDescSys
                            %assign descIdx = DescSysIdx[j]
                            %assign sysTid  = DescSysNonTrigTID[j]
                            %assert (sysTid != -1) %% tid should never be triggered
                            %if sysTid >= 0
                                %if MdlRefDisallowSampleTimeInheritance() && ...
                                    !MdlRefIsAPERTriggeredBlock()
                                    systemTid[%<descIdx>] = %<FcnGetMdlRefGlobalTIDMap("")>[%<sysTid>];
                                %else
                                    systemTid[%<descIdx>] = rootTid;
                                %endif
                            %else
                                %% Fill in constant for constant_tid
                                %assert ((sysTid == -2)||((sysTid == -5)))
                                systemTid[%<descIdx>] = %<sysTid>;
                            %endif
                        %endforeach
                    %endif
                %endwith
            %endforeach

            %% contextSystem
            %assign contextSysVector = ::CompiledModel.SubsystemRanBC.ContextSysIdx
            %assign sizeVect         = SIZE(contextSysVector, 1)

            %foreach j = sizeVect
                %assign idx = contextSysVector[j]
                %<tContextSystems>[%<j>] = %<idx>;
            %endforeach

            %% sysIdxToRun
            %if ISFIELD(::CompiledModel, "ReusedSubSystemBlockData")
                %assign baseSystem = ::CompiledModel.System[baseIdx]
                %assign numDW = SIZE(::CompiledModel.ReusedSubSystemBlockData.DWorkIndex,1)
                %foreach idx = numDW
                    %assign sysIdx = %<::CompiledModel.ReusedSubSystemBlockData.DWorkValue[idx]>
                    %assign dwIdx = ::CompiledModel.ReusedSubSystemBlockData.DWorkIndex[idx]
                    %assign dwRec = ::CompiledModel.DWorks.DWork[dwIdx]
                    %assert (dwRec.Name == "sysIdxToRun")
                    %assign dwRecName = LibGetRecordIdentifier(dwRec)
                    %assign dwPath = SLibCGIRVarGroupPath(...
                        dwRec.VarGroupIdx[0], baseIdx, baseSystem.CrossNoArgFcnBound)
                    %<dwPath>%<dwRecName> = %<sysIdx>;
                %endforeach
            %endif
        }
        #endif /* HOST_CAPI_BUILD */
    %endif

    %% Cache InitializeDataMapInfo Definition
    %assign curBlockFcn = ::BlockFcn
    %assign ::BlockFcn = "InitializeDataMapInfo"

    %assign fcnAbstract = "Cache pointers into DataMapInfo substructure of RTModel"
    %assign fcnName = "%<::CompiledModel.Name>_InitializeDataMapInfo"
    %assign fcnReturns = "void"

    %assign simstructDecl = ""
    %if (::isRAccel || isRSim) && !IsModelReferenceTarget()
        %% For top models, in rapid accelerator and rsim, _capi.h includes model.h, which externs the root simstruct
        %% Having the simstruct as an argument here will shadow the extern declaration
    %else
        %if MultiInstanceERTCode || IsModelReferenceTarget()
            %assign simstructDecl = "%<SLibGetModelTypesNamespacePrefix()>%<::tSimStructType> *const %<::tSimStruct>"
        %endif
    %endif

    %assign dwDecl = ""
    %if args.isDwArgDeclSame
        %assign dwDecl = args.dwArg
    %endif
    %assign fcnParams = "%<simstructDecl>%<args.uArg>%<args.bArg>%<args.pArg>%<dwDecl>%<args.xArg>%<args.ssArg>%<FcnGetCAPIGroupInfo(args, "Arg")>"
    %if ISEMPTY(fcnParams)
        %assign fcnParams = "void"
    %endif
    %if IsModelReferenceSimTarget()
        %assign fcnParams = "%<fcnParams>, void *sysRanPtr, int contextTid"
    %endif
    %createrecord fcnRec {Name fcnName; Returns fcnReturns; Params fcnParams; Abstract fcnAbstract; ...
        Category "model"; GeneratedBy "capi.tlc"; Type "Initialize"}
    %<SLibGetFcnMemSecPragma(fcnName, "MemSecFuncInitTerm", "Pre")>\
    %<SLibDumpFunctionBanner(fcnRec)>
    %undef fcnRec
    #ifndef HOST_CAPI_BUILD
    %<fcnReturns> %<fcnName>(%<fcnParams>) {

        %assign capiStructId =""
        %%
        %%Top Level RSIM executable is the only known target that
        %%does not set the GenRTModel variable. RTM special access
        %%functions cannot be used. Instead a text replacement is made

        %if GenRTModel
            %assign capiStructId = RTMGet("DataMapInfo")
        %else
            %assert isRSim && !IsModelReferenceTarget()
            %assign capiStructId = "(*%<RSimRTWCAPIVarPtr>)"
        %endif

        %if UsingMalloc || CodeFormat == "S-Function"
            /* run-time setup of addresses */
            %assign nParams   = InCAPI.NumBlockParams + InCAPI.NumVariableParams
            %assign nDataAddr = im.NumDataAddr
            %assign nVarDimsAddr = im.NumVarDimsAddr
            %assign dAddrType = tDataAddrType
            %assign localStr  = CodeFormat == "S-Function" ? "Local" : ""
            %assign reqInsts = LibGetSystemField(rootSystem,"ReqRootPrmHdrDataInsts")
            %% Discrete States (or Block Signals if DWorkAndBlockIOCombined) - DWork
            %if ( (InCAPI.NumDiscStates > 0) || ...
                (InCAPI.NumSFLocals > 0) || ...
                ((InCAPI.NumBIOSignals > 0) && ::CompiledModel.DWorkAndBlockIOCombined) ) ...
                && !LibDWorkInstanceIsEmpty()
                %if ::CompiledModel.HasSimStructVars == 0
                    %<::tDWorkType> *%<LibGetDWorkStruct()>%<scalarTokens[0]>(%<tDWorkType> *) \
                    %<RTMGet("%<localStr>RootDWork")>%<scalarTokens[1]>;
                %elseif !WHITE_SPACE(localStr)
                    %<RTMGet("RootDWork")> = (%<::tDWorkType> *) %<RTMGet("%<localStr>RootDWork")>;
                %endif
            %endif
            %% Continuous States
            %if (InCAPI.NumContStates > 0) && !LibContStatesInstanceIsEmpty()
                %if ::CompiledModel.HasSimStructVars == 0
                    %<::tContStateType> *%<LibGetContinuousStateStruct()>%<scalarTokens[0]>(%<tContStateType> *) \
                    %<RTMGet("%<localStr>ContStates")>%<scalarTokens[1]>;
                %elseif !WHITE_SPACE(localStr)
                    %<RTMGet("ContStates")> = (%<::tContStateType> *) %<RTMGet("%<localStr>ContStates")>;
                %endif
            %endif
            %% Parameters
            %if (nParams) > 0 && !SLibPrmBufferIsEmpty("SimulinkGlobal","Instance") && !FcnParamsAreGlobalStruct()
                %if ::CompiledModel.HasSimStructVars == 0
                    %<::tParametersType> *%<LibGetParametersStruct()>%<scalarTokens[0]>(%<tParametersType> *) \
                    %<RTMGet("%<localStr>DefaultParam")>%<scalarTokens[1]>;
                %elseif !WHITE_SPACE(localStr)
                    %<RTMGet("DefaultParam")> = (%<::tParametersType> *) %<RTMGet("%<localStr>DefaultParam")>;
                %endif
            %endif
            %% BlockIO
            %if (InCAPI.NumBIOSignals > 0) && !LibBlockIOInstanceIsEmpty()
                %if ::CompiledModel.HasSimStructVars == 0
                    %<::tBlockIOType> *%<LibGetBlockIOStruct()>%<scalarTokens[0]>(%<tBlockIOType> *) \
                    %<RTMGet("%<localStr>BlockIO")>%<scalarTokens[1]>;
                %elseif !WHITE_SPACE(localStr)
                    %<RTMGet("BlockIO")> = (%<::tBlockIOType> *) %<RTMGet("%<localStr>BlockIO")>;
                %endif
            %endif
            %% External Inputs
            %if ((InCAPI.NumExtInputs > 0) && !LibExternalInputsStructIsEmpty()) || ...
                ((InCAPI.NumRootInputs > 0) && !LibExternalInputsStructIsEmpty())
                %if ::CompiledModel.HasSimStructVars == 0
                    %<::tInputType> *%<LibGetExternalInputStruct()>%<scalarTokens[0]>(%<::tInputType> *) \
                    %<RTMGet("%<localStr>U")>%<scalarTokens[1]>;
                %elseif !WHITE_SPACE(localStr)
                    %<RTMGet("U")> = (%<::tInputType> *) %<RTMGet("%<localStr>U")>;
                %endif
            %endif
            %% External Outputs
            %if ((InCAPI.NumRootOutputs > 0) && !LibExternalOutputsStructIsEmpty())
                %if ::CompiledModel.HasSimStructVars == 0
                    %<tOutputType> *%<LibGetExternalOutputStruct()>%<scalarTokens[0]>(%<tOutputType> *) \
                    %<RTMGet("%<localStr>Y")>%<scalarTokens[1]>;
                %elseif !WHITE_SPACE(localStr)
                    %<RTMGet("Y")> = (%<tOutputType> *) %<RTMGet("%<localStr>Y")>;
                %endif
            %endif
            %%CoderGroups
            %foreach idx = ::CompiledModel.NumCoderDataGroups
                %assign coderGroup = ::CompiledModel.CoderDataGroup[idx]
                %if !LibCoderDataGroupStructIsEmpty(coderGroup) && !coderGroup.IsSelf && ...
                    coderGroup.IsInstanceSpecific && FcnIncludeGroupTypeInAPI(coderGroup)
                    %assign varGroupIdx = SLibGetRootVarGroupIdxForCoderGroup(coderGroup)
                    %if (varGroupIdx>= 0)
                        %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
                        %assign structTypeName = varGroup.StructureTypeName
                        %assign structureInstanceName = varGroup.StructureInstanceName
                        %assign structureReferenceName = varGroup.StructureReferenceName
                        %assign structureBaseName = ::tSimStruct
                        %if coderGroup.AsStructure == "InParent"
                            %<structTypeName> *%<structureInstanceName>%<scalarTokens[0]>(%<structTypeName> *) \
                            %<structureBaseName>->%<structureReferenceName>%<scalarTokens[1]>;
                        %elseif coderGroup.AsStructure == "InSelf"
                            %<structTypeName> *%<structureInstanceName>%<scalarTokens[0]>(%<structTypeName> *) \
                            &%<structureBaseName>->%<structureReferenceName>%<scalarTokens[1]>;
                        %endif
                    %endif
                %endif
            %endforeach

            %if (nDataAddr > 0)
                %if UsingMalloc
                    %<dAddrType> *%<tDataAddrMap>;
                %else
                    static %<dAddrType> %<tDataAddrMap>[%<nDataAddr>];
                %endif
            %else
                static %<tDataAddrType> *%<tDataAddrMap>%<scalarTokens[0]>%<nulldef>%<scalarTokens[1]>;
            %endif

            %if (nVarDimsAddr > 0)
                %if UsingMalloc
                    %<tVarDimsAddrMapType> *%<tVarDimsAddrMap>;
                %else
                    static %<tVarDimsAddrMapType> %<tVarDimsAddrMap>[%<nVarDimsAddr>];
                %endif
            %else
                static %<tVarDimsAddrMapType> *%<tVarDimsAddrMap>%<scalarTokens[0]>%<nulldef>%<scalarTokens[1]>;
            %endif

            %if (nDataAddr > 0)
                %if UsingMalloc
                    rt_FREE( rtwCAPI_GetDataAddressMap( &(%<capiStructId>.mmi) ) ); \
                    %<tDataAddrMap> = (%<dAddrType>*) \
                    malloc(%<nDataAddr> * sizeof(%<dAddrType>));
                %endif

                if((%<tDataAddrMap>) == %<nulldef>) {
                    %<RTMSetErrStat("RT_MEMORY_ALLOCATION_ERROR")>;
                    return;
                }

                %foreach idx = nDataAddr
                    %<tDataAddrMap>[%<idx>] = (%<dAddrType>)(%<im.AddrMap[idx]>);
                %endforeach
            %endif

            %if (nVarDimsAddr > 0)
                %if UsingMalloc
                    rt_FREE( rtwCAPI_GetVarDimsAddressMap( &(%<capiStructId>.mmi) ) ); \
                    %<tVarDimsAddrMap> = (%<tVarDimsAddrMapType>*) \
                    malloc(%<nVarDimsAddr> * sizeof(%<tVarDimsAddrMapType>));
                %endif

                if((%<tVarDimsAddrMap>) == %<nulldef>) {
                    %<RTMSetErrStat("RT_MEMORY_ALLOCATION_ERROR")>;
                    return;
                }

                %foreach idx = nVarDimsAddr
                    %<tVarDimsAddrMap>[%<idx>] =  (%<tVarDimsAddrMapType>)(%<im.VarDimsAddrMap[idx]>);
                %endforeach
            %endif
        %endif

        %if FcnDynamicAPI()
            /* Initialize dynamic info for code variants */
            %if needsAddressMapIndexVar
                %assign condIf = SLibIfVariantConditionForm(getAddrMapIdxVarCond)
                %assign condFi = SLibEndIfVariantConditionForm(getAddrMapIdxVarCond)
                %<condIf>
                int %<addrMapIndex>%<scalarTokens[0]>0%<scalarTokens[1]>;
                %<condFi>
            %endif

            %<numSignals> = 0;
            %<numStates> = 0;
            %<numBlockParams> = 0;
            %<numModelParams> = 0;
            %<numRootInputs> = %<tempNumRootInputs>;
            %<numRootOutputs> = %<tempNumRootOutputs>;
            %<dynamicInit>
        %endif

        /* Set C-API version */
        rtwCAPI_SetVersion(%<capiStructId>.mmi, 1);

        /* Cache static C-API data into the Real-time Model Data structure */
        rtwCAPI_SetStaticMap(%<capiStructId>.mmi, &mmiStatic);

        /* Cache static C-API logging data into the Real-time Model Data structure */
        rtwCAPI_SetLoggingStaticMap(%<capiStructId>.mmi, %<tempStaticInfoLogging>);

        %if !IsMultiInstanceERTOrModelReference() || GenerateGRTWrapper || ...
            UsingMalloc
            /* Cache C-API Data Addresses into the Real-Time Model Data structure */
            rtwCAPI_SetDataAddressMap(%<capiStructId>.mmi, %<tDataAddrMap>);

            /* Cache C-API Data Run-Time Dimension Buffer Addresses into the Real-Time Model Data structure */
            rtwCAPI_SetVarDimsAddressMap(%<capiStructId>.mmi, %<tVarDimsAddrMap>);
            %%------slrtspecialcase------------
            %if EXISTS(slrt)
                %if (tempNumBTuning > 0) && !LibParametersStructIsEmpty()
                    %assign rtmargName = RTMGetModelSS()
                    /* Cache C-API rtp Address and size  into the Real-Time Model Data structure */
                    %<capiStructId>.mmi.InstanceMap.rtpAddress =  rtmGetDefaultParam(%<rtmargName>);
                    %<capiStructId>.mmi.staticMap->rtpSize =  sizeof(%<::tParametersType>);
                %endif
            %endif
            %%------slrtspecialcase------------
        %else
            %if im.NumDataAddr > 0
                /* Cache C-API Data Addresses into the Real-Time Model Data structure */
                %assign argsdDecl = "%<RTMGet("DataMapInfo")>.dataAddress"
                %assign fcnParams = "%<argsdDecl>%<args.rtmDecl>%<args.uDeclCache>%<args.bDeclCache>%<args.pDeclCache>%<args.dwDeclCache>%<args.xDeclCache>%<args.ssDeclCache>"
                %foreach idx = ::CompiledModel.NumCoderDataGroups
                    %assign fcnParams = fcnParams + args.groupDeclCache[idx]
                %endforeach
                %assign hasSelfParam = !ISEMPTY(args.rtmDecl) && SLibSynthesizedRTM()
                %assign comma = ISEMPTY(fcnParams) ? "" : ", "
                %if SLibGetDoesSelfHasCoderDataGroup() && !hasSelfParam
                    %assign fcnParams = "%<RTMGetModelSS()>" + "%<comma>" + "%<fcnParams>"
                    %assign hasSelfParam = TLC_TRUE
                %endif
                %if !SimstructBasedTarget && !IsModelReferenceTarget() && !GenerateClassInterface && ...
                    UsingMalloc
                    %assign comma = ISEMPTY(fcnParams) ? "" : ", "
                    %if ~hasSelfParam
                        %% RTM needed to free RTM->DataMapInfo.mmi.InstanceMap.dataAddrMap
                        %assign fcnParams = "%<RTMGetModelSS()>" + "%<comma>" + "%<fcnParams>"
                    %endif
                %endif

                %<prefix>InitializeDataAddr(%<fcnParams>);
                rtwCAPI_SetDataAddressMap(%<capiStructId>.mmi, %<capiStructId>.dataAddress);

                /* Cache C-API Data Run-Time Dimension Buffer Addresses into the Real-Time Model Data structure */
                %if im.NumVarDimsAddr <= 0 || (im.NumVarDimsAddr==1 && ...
                    ISEQUAL(im.VarDimsAddrMap[0],SLibGetNullDefinitionFromTfl()))
                    %% DWork is not used, so do not pass it as a function argument.
                    %assign dwDecl = ""
                %else
                    %assign dwDecl = "%<args.dwDeclCache>%<args.ssDeclCache>%<FcnGetCAPIGroupInfo(args, "DeclCache")>"
                %endif
                %assign argsvDecl = "%<RTMGet("DataMapInfo")>.vardimsAddress"
                %assign fcnParams = "%<argsvDecl>%<dwDecl>"

                %assign hasSelfParam = !ISEMPTY(args.rtmDecl) && SLibSynthesizedRTM()
                %assign comma = ISEMPTY(fcnParams) ? "" : ", "
                %if SLibIsSelfStructured() && !IsModelReferenceSimTarget() && !hasSelfParam
                    %assign fcnParams = "%<RTMGetModelSS()>" + "%<comma>" + "%<fcnParams>"
                    %assign hasSelfParam = TLC_TRUE
                %endif

                %if !SimstructBasedTarget && !IsModelReferenceTarget() && !GenerateClassInterface && ...
                    UsingMalloc
                    %if ISEMPTY(fcnParams)
                        %assign comma = ""
                    %else
                        %assign comma = ", "
                    %endif
                    %% RTM needed to free RTM->DataMapInfo.mmi.InstanceMap.vardimsAddrMap
                    %if !hasSelfParam
                        %assign fcnParams = "%<RTMGetModelSS()>" + "%<comma>" + "%<fcnParams>"
                    %endif
                %endif
                %<prefix>InitializeVarDimsAddr(%<fcnParams>);
                rtwCAPI_SetVarDimsAddressMap(%<capiStructId>.mmi, %<capiStructId>.vardimsAddress);
                %%------slrtspecialcase------------
                %if EXISTS(slrt)
                    %if !ISEMPTY(args.pArg) && !LibParametersStructIsEmpty()
                        %<capiStructId>.mmi.InstanceMap.rtpAddress = %<LibGetParametersStruct()>;
                        %<capiStructId>.mmi.staticMap->rtpSize = sizeof(%<::tParametersType>);
                    %endif
                %endif
                %%------slrtspecialcase------------
            %endif

            /* Set Instance specific path */
            rtwCAPI_SetPath(%<capiStructId>.mmi, %<nulldef>);
            rtwCAPI_SetFullPath(%<capiStructId>.mmi, %<nulldef>);
        %endif

        %if IsMultiInstanceERTOrModelReference() && im.NumDataAddr > 0 && !UsingMalloc
            %assign loggingPtrsArray = "%<RTMGet("DataMapInfo")>.loggingPtrs"
            /* Cache C-API logging function pointers into the Real-Time Model Data structure */
            %<prefix>InitializeLoggingFunctions(%<loggingPtrsArray>);
            rtwCAPI_SetLoggingPtrs(%<capiStructId>.mmi, %<loggingPtrsArray>);
        %endif

        /* Cache the instance C-API logging pointer */
        %if IsModelReferenceSimTarget()
            rtwCAPI_SetInstanceLoggingInfo(%<capiStructId>.mmi, &%<capiStructId>.mmiLogInstanceInfo);
        %else
            rtwCAPI_SetInstanceLoggingInfo(%<capiStructId>.mmi, %<nulldef>);
        %endif

        /* Set reference to submodels */
        %if ::NumModelBlocksWithCAPI > 0
            rtwCAPI_SetChildMMIArray(%<capiStructId>.mmi, %<capiStructId>.childMMI);
            rtwCAPI_SetChildMMIArrayLen(%<capiStructId>.mmi, %<::NumModelBlocksWithCAPI>);
        %else
            rtwCAPI_SetChildMMIArray(%<capiStructId>.mmi, %<nulldef>);
            rtwCAPI_SetChildMMIArrayLen(%<capiStructId>.mmi, 0);
        %endif

        %if sysRanDWorkLen > 0 && IsModelReferenceSimTarget()
            %<prefix>InitializeSystemRan(%<RTMGetModelSS()>,%<capiStructId>.systemRan%<args.dwDecl>,
            %<capiStructId>.systemTid, sysRanPtr, contextTid);
            rtwCAPI_SetSystemRan(%<capiStructId>.mmi,%<capiStructId>.systemRan);
            rtwCAPI_SetSystemTid(%<capiStructId>.mmi,%<capiStructId>.systemTid);
        %endif

        %% The ModelReference target uses the global timing engine
        %if IsModelReferenceSimTarget()
            rtwCAPI_SetGlobalTIDMap(%<capiStructId>.mmi, &%<FcnGetMdlRefGlobalTIDMap("")>[0]);
        %endif

    }
    %assign ::BlockFcn = curBlockFcn
    #else /* HOST_CAPI_BUILD */
    %%Host DataMapInfo
    %assign capiStructHostId = "dataMap"
    %assign fcnNameHost   = "%<::CompiledModel.Name>_host_InitializeDataMapInfo"
    %assign fcnParamsHost = "%<::CompiledModel.Name>_host_DataMapInfo_T *dataMap, const char *path"

    #ifdef __cplusplus
    extern "C" {
        #endif

        %<fcnReturns> %<fcnNameHost>(%<fcnParamsHost>) {

            /* Set C-API version */
            rtwCAPI_SetVersion(%<capiStructHostId>->mmi, 1);

            /* Cache static C-API data into the Real-time Model Data structure */
            rtwCAPI_SetStaticMap(%<capiStructHostId>->mmi, &mmiStatic);

            /* host data address map is NULL */
            rtwCAPI_SetDataAddressMap(%<capiStructHostId>->mmi, %<SLibGetNullDefinitionFromTfl()>);

            /* host vardims address map is NULL */
            rtwCAPI_SetVarDimsAddressMap(%<capiStructHostId>->mmi, %<SLibGetNullDefinitionFromTfl()>);

            /* Set Instance specific path */
            rtwCAPI_SetPath(%<capiStructHostId>->mmi, path);

            rtwCAPI_SetFullPath(%<capiStructHostId>->mmi, %<SLibGetNullDefinitionFromTfl()>);

            /* Set reference to submodels */

            %if ::NumModelBlocksWithCAPI > 0
                %assign mdlRefBlks    = ::CompiledModel.ModelReferenceBlocks
                %assign nMdlRefBlks   = SIZE(mdlRefBlks,0)
                %assign mdlBlkIdx = 0
                %foreach rowIdx = nMdlRefBlks
                    %assign mdlRefInfo = mdlRefBlks[rowIdx]
                    %assign mSysIdx = mdlRefInfo[0]
                    %assign bIdx    = mdlRefInfo[1]
                    %assign instIdx = mdlRefInfo[2]
                    %with System[mSysIdx].Block[bIdx]
                        %assign blk = System[mSysIdx].Block[bIdx]

                        %if !blk.ParamSettings.SupportsCAPI
                            %continue
                        %endif

                        %assign blockInterface = GetModelrefInterface(blk)
                        %assign tmpVec = [%<mdlRefInfo[3]>, %<mdlRefInfo[4]>]

                        %% For protected SIM targets, don't add the path
                        %if SLibIsGeneratingSimTargetForProtectedModel()
                            %assign bpath = SLibGetProtectedBlockPath()
                        %else
                            %assign bpath  = STRING(SLibMangledGrBlockPath(tmpVec))
                        %endif
                        %assign mdlRefName = STRING(blockInterface.Name)
                        %if ISFIELD(blockInterface, "RegistrationFcn")
                            dataMap->childMMI[%<mdlBlkIdx>] = &(dataMap->child%<mdlBlkIdx>.mmi);
                            %<mdlRefName>_host_InitializeDataMapInfo(&(dataMap->child%<mdlBlkIdx>), "%<bpath>");
                        %endif
                        %assign mdlBlkIdx = mdlBlkIdx + 1
                    %endwith%%System[mSysIdx].Block[bIdx]
                %endforeach

                rtwCAPI_SetChildMMIArray(%<capiStructHostId>->mmi, %<capiStructHostId>->childMMI);
                rtwCAPI_SetChildMMIArrayLen(%<capiStructHostId>->mmi, %<::NumModelBlocksWithCAPI>);
            %else
                rtwCAPI_SetChildMMIArray(%<capiStructHostId>->mmi, %<nulldef>);
                rtwCAPI_SetChildMMIArrayLen(%<capiStructHostId>->mmi, 0);
            %endif

        }

        #ifdef __cplusplus
    }
    #endif

    #endif /* HOST_CAPI_BUILD */

    %<SLibGetFcnMemSecPragma(fcnName, "MemSecFuncInitTerm", "Post")>\
    %% call C-API Hooks
    %<FcnCAPIHookExecute(CAPIHooks)>
%endfunction %% FcnWriteCAPIStructures

%% Function FcnAddArgForGroup ===============================================
%% Abstract:
%%   Should we add an argument to the C API functions for a coder data group?
%%
%function FcnAddArgForGroup(group, inCAPI)
    %% No need if the group is empty
    %if LibCoderDataGroupStructIsEmpty(group)
        %return TLC_FALSE
        %% No need if the group is self
    %elseif group.IsSelf
        %return TLC_FALSE
        %% No need if the group is not declared to be instance specific
    %elseif !group.IsInstanceSpecific
        %return TLC_FALSE
        %% Even if declared instance-specific, no need if the model is
        %% single instance.  This can happen for InstP and
        %% standalone multiinstance
    %elseif !SLibMultiInstance()
        %return TLC_FALSE
        %% No need if the C API settings indicate there is no reason to even
        %% consider doing so
    %elseif !FcnIncludeGroupTypeInAPI(group)
        %return TLC_FALSE
        %% No need if no tracking, except for mdlref sim.
    %elseif ((inCAPI.NumDataGroupElements[group.GroupIndex] == 0) && !IsModelReferenceSimTarget())
        %return TLC_FALSE
    %else
        %return TLC_TRUE
    %endif
%endfunction

%% Function FcnCAPIInitializeArgs ===========================================
%% Abstract:
%%   Function arguments for the following functions
%%      o _InitializeDataMapInfo
%%      o _InitializeDataAddressMap
%%
%%   During run-time, _InitializeDataAddressMap() initializes the C-API
%%   addresses with the global address of the signal/parameter/state/DWork.
%%
%%   For normal GRT/ERT build, the initialize function accesses these global
%%   addresses directly. The function arguments will be empty in this case.
%%   For MultiInstanceERTCode or model ref target builds, the globals are
%%   passed as arguments to the model_ initialize function. Hence, the id
%%   corresponding to the argument will be used to initialize the C-API addr.
%%   The following table shows arguments corresponding to various targets.
%%
%%    ----------------------------------------------------------------------
%%   | Target Type          | CAPI Init Func Prototype     | Function Call  |
%%   |----------------------------------------------------------------------
%%   | Normal ERT/GRT       | void f(void)                 |  f()           |
%%   |                      | Args Empty, Global Access    |                |
%%   |----------------------------------------------------------------------|
%%   | GRT Malloc/S-function| void f()                     |  f()           |
%%   |                      | Access data stored in rtM    |                |
%%   |                      | (rtM->ModelData.inputs)      |                |
%%   |                      | (rtM->ModelData.Parameters)  |                |
%%   |----------------------------------------------------------------------|
%%   | MultiInstanceERTCode | void f(void*        addr[],  |f(rtM->dataAddr,|
%%   | (RootIO Structures)  |        ExternalInputs* rtU,  |   rtU,rtB, rtP,|
%%   |                      |        BlockIO*        rtB,  |   rtDWork, rtX)|
%%   |                      |        Parameters*     rtP,  |                |
%%   |                      |        D_Work*       rtDwork,|                |
%%   |                      |        ContinuousStates* rtX,|                |
%%   |                      |                            ) |                |
%%   |----------------------------------------------------------------------|
%%   | MultiInstanceERTCode | void f(void*        addr[],  |f(rtM->dataAddr,|
%%   | (RootIO Individual)  |        DType1*       rtU_In1,|   rtU_In1, ...,|
%%   |                      |        DType2*       rtU_In2,|   ..., rtU_InN,|
%%   |                      |        ...               ...,|   rtB, rtP,    |
%%   |                      |        DTypeN*       rtU_InN,|   rtDWork, rtX)|
%%   |                      |        BlockIO*          rtB,|                |
%%   |                      |        Parameters*       rtP,|                |
%%   |                      |        D_Work*       rtDwork,|                |
%%   |                      |        ContinuousStates* rtX,|                |
%%   |                      |                            ) |                |
%%   |----------------------------------------------------------------------|
%%   | Model Ref Target     | void f(void*          addr[],|f(rtM->dataAddr,|
%%   | (RootIO Always       |        DType1*         rtu_1,|   rtu_1,   ...,|
%%   |   Individual)        |        DType2*         rtu_2,|   ..., rtu_N,  |
%%   |                      |        ...               ...,|   localB, rtP, |
%%   |                      |        DTypeN*         rtu_N,|   localDW,     |
%%   |                      |        rtB_Sys*       localB,|   localX)      |
%%   |                      |        Parameters*       rtP,|                |
%%   |                      |        rtDW_Sys*     localDW,|                |
%%   |                      |        rtX_Sys*       localX,|                |
%%   |                      |                            ) |                |
%%   |----------------------------------------------------------------------|
%%
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants3.m
%function FcnCAPIInitializeFcnArgs(inCAPI) void
    %assign int32Type = LibGetDataTypeNameFromId(::CompiledModel.tSS_INT32)

    %createrecord       \
    CAPI_FunctionArgs { \
        uArg        ""; \
        uDecl       ""; \
        uDeclCache  ""; \
        dArg        ""; \
        dDecl       ""; \
        dDeclCache  ""; \
        vArg        ""; \
        vDecl       ""; \
        vDeclCache  ""; \
        pArg        ""; \
        pDecl       ""; \
        pDeclCache  ""; \
        bArg        ""; \
        bDecl       ""; \
        bDeclCache  ""; \
        dwArg       ""; \
        dwDecl      ""; \
        dwDeclCache ""; \
        xArg        ""; \
        xDecl       ""; \
        xDeclCache  ""; \
        ssArg       ""; \
        ssDecl      ""; \
        ssDeclCache "";  \
        isDwArgDeclSame 0 \
        rtmArg      ""; \
        rtmDecl     ""; \
        rtmDeclCache  "" \
    }
    %assign args = CAPI_FunctionArgs
    %assign emptyString = ""
    %addtorecord args groupArg ...
        Vector(%<::CompiledModel.NumCoderDataGroups>) [""@%<::CompiledModel.NumCoderDataGroups>]
    %addtorecord args groupDecl ...
        Vector(%<::CompiledModel.NumCoderDataGroups>) [""@%<::CompiledModel.NumCoderDataGroups>]
    %addtorecord args groupDeclCache ...
        Vector(%<::CompiledModel.NumCoderDataGroups>) [""@%<::CompiledModel.NumCoderDataGroups>]

    %assign addressPrefix = ""
    %if GenerateClassInterface
        %assign addressPrefix = "&"
    %endif

    %if !UsingMalloc
        %assign rootSystem     = System[NumSystems-1]
        %assign reqInsts = LibGetSystemField(rootSystem,"ReqRootPrmHdrDataInsts")

        %assign typePrefix = SLibGetModelTypesNamespacePrefix()

        %if IsMultiInstanceERTOrModelReference()
            %assign args.dArg    = "void* dataAddr[]"
            %assign args.dDecl   = "%<RTMGet("DataMapInfo")>.dataAddress"
            %assign args.dDeclCache = args.dDecl

            %assign args.vArg = "%<int32Type>* vardimsAddr[]"
            %assign args.vDecl   = "%<RTMGet("DataMapInfo")>.vardimsAddress"
            %assign args.vDeclCache = args.vDecl

            %if RTWCAPIParams == 1
                %if (!reqInsts.ParamsInst || GenerateClassInterface)  && ...
                    (!IsModelRefScalableBuild() || GenerateClassInterface) && ...
                    !SLibPrmBufferIsEmpty("SimulinkGlobal","Instance") && ...
                    ((inCAPI.NumBlockParams + inCAPI.NumVariableParams) > 0)
                    %assign args.pArg = ", %<typePrefix>%<::tParametersType> *%<LibGetParametersStruct()>"
                    %if SLibUseBackwardCompatibleReusableInterface() || ...
                        GenerateClassInterface || IsModelReferenceTarget()
                        %assign args.pDecl = ", %<addressPrefix>%<LibGetParametersStruct()>"
                        %assign args.pDeclCache = ", %<LibGetParametersStruct()>"
                    %else
                        %assign args.pDecl = ", %<addressPrefix>%<SLibGetParamPointerFromRTM(0)>"
                        %assign args.pDeclCache = ", %<SLibGetParamPointerFromRTM(0)>"
                    %endif
                %endif

                %if SLibHasGroupedModelArgFromChildModel()
                    %assign args.rtmArg = ", %<typePrefix>%<::tSimStructType> *const %<::tSimStruct>"
                    %assign args.rtmDecl = GenerateClassInterface ? ...
                        ", %<::tSimStruct>" : ", %<addressPrefix>%<RTMGetModelSS()>"
                    %assign args.rtmDeclCache = ", %<RTMGetModelSS()>"
                %endif

            %endif %% Parameters

            %if RTWCAPISignals == 1
                %assign selfAccess = SLibGetUseRTMcgType() && !GenerateClassInterface
                %assign boRequired = !reqInsts.BlockIOInst && (inCAPI.NumBIOSignals > 0)
                %if boRequired && !LibBlockIOInstanceIsEmpty() && !selfAccess ...
                    && (!IsModelRefScalableBuild() || GenerateClassInterface)

                    %% Add blockIO as input argument
                    %if IsModelReferenceTarget() && !GenerateClassInterface
                        %assign baseSysIdx = GetBaseSystemIdx()
                        %assign dataType = FcnSysVarGroupType(System[baseSysIdx],"BlockIO")
                        %assign args.bArg = ", " + dataType + " *localB"
                        %assign args.bDecl = ", localB"
                        %assign args.bDeclCache = args.bDecl
                        %assign curBlockFcn = ::BlockFcn
                        %assign ::BlockFcn = "InitializeDataMapInfo"
                        %<SLibAccessArgHelper(System[baseSysIdx].Interface.BlockIOArgDef,"","")>
                        %assign ::BlockFcn = curBlockFcn
                    %else
                        %assign args.bArg = ", %<typePrefix>%<::tBlockIOType> *%<LibGetBlockIOStruct()>"
                        %if SLibUseBackwardCompatibleReusableInterface() || GenerateClassInterface
                            %assign args.bDecl = ", %<addressPrefix>%<LibGetBlockIOStruct()>"
                            %assign args.bDeclCache = ", %<LibGetBlockIOStruct()>"
                        %else
                            %assign args.bDecl = ", %<addressPrefix>%<SLibGetBlockIOPointerFromRTM(0)>"
                            %assign args.bDeclCache = ", %<SLibGetBlockIOPointerFromRTM(0)>"
                        %endif
                    %endif
                %endif %% BlockIO
                %assign selfAccess = SLibGetUseRTMcgType() && !GenerateClassInterface
                %assign dwRequired = !reqInsts.DworkInst && ...
                    ((inCAPI.NumVarDimsSignals > 0) || IsModelReferenceSimTarget())
                %if !LibDWorkInstanceIsEmpty() && !selfAccess && ...
                    (!IsModelRefScalableBuild() || GenerateClassInterface) && ...
                    (dwRequired || (boRequired && ...
                    (::CompiledModel.DWorkAndBlockIOCombined || inCAPI.NumBlockSignalsMergedByGlobalDwork > 0)))
                    %% Add dwork as input argument
                    %if IsModelReferenceTarget() && !GenerateClassInterface
                        %assign baseSysIdx  = GetBaseSystemIdx()
                        %assign dataType    = FcnSysVarGroupType(System[baseSysIdx],"DWork")
                        %assign args.dwArg  = ", %<dataType> *localDW"
                        %assign args.dwDecl = ", localDW"
                        %assign args.dwDeclCache = args.dwDecl
                        %assign args.isDwArgDeclSame = TLC_TRUE
                        %assign curBlockFcn = ::BlockFcn
                        %assign ::BlockFcn = "InitializeDataMapInfo"
                        %<SLibAccessArgHelper(System[baseSysIdx].Interface.DWorkArgDef,"","")>
                        %assign ::BlockFcn = curBlockFcn
                        %% If data store references are the only thing in dwork the registration function
                        %% won't track localDW elsewhere so we need to do it here
                        %assign ::BlockFcn = "Registration"
                        %<SLibAccessArgHelper(System[baseSysIdx].Interface.DWorkArgDef,"","")>
                        %assign ::BlockFcn = curBlockFcn
                    %else
                        %assign args.dwArg  = ", %<typePrefix>%<::tDWorkType> *%<LibGetDWorkStruct()>"
                        %if SLibUseBackwardCompatibleReusableInterface() || GenerateClassInterface
                            %assign args.dwDecl = ", %<addressPrefix>%<LibGetDWorkStruct()>"
                            %assign args.dwDeclCache = ", %<LibGetDWorkStruct()>"
                            %assign args.isDwArgDeclSame = TLC_TRUE
                        %else
                            %assign args.dwDecl = ", %<addressPrefix>%<SLibGetDWorkPointerFromRTM(0)>"
                            %assign args.dwDeclCache = ", %<SLibGetDWorkPointerFromRTM(0)>"
                            %assign args.isDwArgDeclSame = TLC_FALSE
                        %endif
                    %endif
                %endif %% Var-Dims Address
                %if !reqInsts.ExtInpsInst && ...
                    !LibExternalInputsStructIsEmpty() && (inCAPI.NumExtInputs > 0)
                    %% Add External inputs as function arguments
                    %assign isPeriodicRateGrouping = ...
                        SLibSystemFcnPeriodicRateGrouping(rootSystem, ::BlockFcn)

                    %if IsModelReferenceTarget()
                        %assign baseSysIdx   = GetBaseSystemIdx()
                        %% Canonical Inputs
                        %with System[baseSysIdx].Interface
                            %foreach argIdx = NumCanonicalInputArgDefs
                                %assign ci    = CanonicalInputArgDef[argIdx]
                                %if FcnArgNeeded(ci, rootSystem.CurrentTID, isPeriodicRateGrouping)
                                    %assign identi     = LibGetRecordIdentifier(ci)
                                    %assign dataType   = SLibGetRecordDataTypeName(ci, "")
                                    %assign optStar    = (LibGetRecordWidth(ci) == 1 && ...
                                        !(IsModelReferenceRTWTarget() && !FcnPassCanonicalInputByPtr(ci))) ...
                                        ? " *" : " "
                                    %assign optWidth   = LibOptionalVectorWidth(LibGetRecordWidth(ci))
                                    %assign dataType   = "const %<dataType>"
                                    %assign argDef     = dataType + optStar + identi + optWidth
                                    %assign args.uArg  = args.uArg + ", " +  argDef
                                    %assign args.uDecl = args.uDecl + ", " + identi
                                    %assign args.uDeclCache = args.uDecl
                                %endif
                                %if SLibGetCanIOIsVarDims(ci)
                                    %assign cdwIdx   = SLibGetCanDimSizeDWIdxForArg(ci)
                                    %assign canDWork = CanonicalDWorkArgDef[cdwIdx]
                                    %if FcnArgNeeded(ci, rootSystem.CurrentTID, isPeriodicRateGrouping)
                                        %assign identi     = LibGetRecordIdentifier(canDWork)
                                        %assign dwIdx      = canDWork.FirstSignalSrc %% global idx
                                        %assign dwRec      = ::CompiledModel.DWorks.DWork[dwIdx]
                                        %assign dwWidth    = SLibDWorkWidth(dwRec)
                                        %assign dataType   = "const int "
                                        %assign argDef     = dataType + identi + "[%<dwWidth>]"
                                        %assign args.uArg  = args.uArg + ", " +  argDef
                                        %assign args.uDecl = args.uDecl + ", " + identi
                                        %assign args.uDeclCache = args.uDecl
                                    %endif
                                %endif
                            %endforeach %% Canonical inputs
                        %endwith

                    %elseif (MultiInstanceERTCode && (RootIOStructures || SLibHasGlobalExternalInputsWithFPC()))
                        %% MultiInstance code with inputs passed as structure Arg
                        %assign args.uArg  = args.uArg + ", " + "%<typePrefix>%<::tInputType> *%<LibGetExternalInputStruct()>"
                        %if SLibUseBackwardCompatibleReusableInterface() || ...
                            GenerateClassInterface || ...
                            ::CompiledModel.RootIOFormat != "Part of model data structure"
                            %assign args.uDecl = args.uDecl + ", " + "%<addressPrefix>%<LibGetExternalInputStruct()>"
                            %assign args.uDeclCache = args.uDeclCache + ", " + "%<LibGetExternalInputStruct()>"
                        %else
                            %assign args.uDecl = args.uDecl + ", " + "%<addressPrefix>%<RTMGet("U")>"
                            %assign args.uDeclCache = args.uDeclCache + ", " + "%<RTMGet("U")>"
                        %endif

                    %else
                        %foreach idx = ExternalInputs.NumExternalInputs
                            %assign extInp = ExternalInputs.ExternalInput[idx]
                            %with extInp
                                %if extInp.StorageClass != "Auto" || ...
                                    !FcnArgNeeded(extInp,rootSystem.CurrentTID,isPeriodicRateGrouping)
                                    %continue
                                %endif
                                %assign id = LibGetRecordIdentifier(extInp)
                                %assign passByRef = PassExtInpByRef(extInp)
                                %assign args.uDecl = args.uDecl + ", " + ...
                                    "%<LibGetExternalInputStruct()>%<UQualifier>%<id>"
                                %assign args.uDeclCache = args.uDecl
                                %assign optStar = passByRef ? "*" : ""
                                %assign dataType  = SLibGetRecordDataTypeName(extInp, "")
                                %if LibGetRecordWidth(extInp) > 1
                                    %assign args.uArg = args.uArg + ", " + ...
                                        "%<dataType> %<LibGetExternalInputStruct()>%<UQualifier>%<id>[%< LibGetRecordWidth(extInp)>]"
                                %else
                                    %assign args.uArg = args.uArg + ", " + ...
                                        "%<dataType> %<optStar>%<LibGetExternalInputStruct()>%<UQualifier>%<id>"
                                %endif
                            %endwith
                        %endforeach
                    %endif  %% External Inputs
                %endif %% External inputs

                %% We need this for Stateflow data
                %assign selfAccess = SLibGetUseRTMcgType() && !GenerateClassInterface
                %if !reqInsts.DworkInst && !LibDWorkInstanceIsEmpty() && !selfAccess && ...
                    (!IsModelRefScalableBuild() || GenerateClassInterface) && ...
                    ((inCAPI.NumSFLocals > 0) || IsModelReferenceSimTarget())
                    %if IsModelReferenceTarget() && !GenerateClassInterface
                        %assign baseSysIdx  = GetBaseSystemIdx()
                        %assign dataType    = FcnSysVarGroupType(System[baseSysIdx],"DWork")
                        %assign args.dwArg = ", %<dataType> *localDW"
                        %assign args.dwDecl = ", localDW"
                        %assign args.dwDeclCache = args.dwDecl
                        %assign args.isDwArgDeclSame = TLC_TRUE
                        %assign curBlockFcn = ::BlockFcn
                        %assign ::BlockFcn = "InitializeDataMapInfo"
                        %<SLibAccessArgHelper(System[baseSysIdx].Interface.DWorkArgDef,"","")>
                        %assign ::BlockFcn = curBlockFcn
                    %else
                        %assign args.dwArg = ", %<typePrefix>%<::tDWorkType> *%<LibGetDWorkStruct()>"
                        %if SLibUseBackwardCompatibleReusableInterface() || GenerateClassInterface
                            %assign args.dwDecl = ", %<addressPrefix>%<LibGetDWorkStruct()>"
                            %assign args.dwDeclCache = ", %<LibGetDWorkStruct()>"
                            %assign args.isDwArgDeclSame = TLC_TRUE
                        %else
                            %assign args.dwDecl = ", %<addressPrefix>%<SLibGetDWorkPointerFromRTM(0)>"
                            %assign args.dwDeclCache = ", %<SLibGetDWorkPointerFromRTM(0)>"
                            %assign args.isDwArgDeclSame = TLC_FALSE
                        %endif
                    %endif
                %endif %% DWork
            %endif

            %if RTWCAPIStates == 1
                %assign selfAccess = SLibGetUseRTMcgType() && !GenerateClassInterface
                %if !reqInsts.DworkInst && !LibDWorkInstanceIsEmpty() && !selfAccess && ...
                    (!IsModelRefScalableBuild() || GenerateClassInterface) && ...
                    ((inCAPI.NumDiscStates > 0) || IsModelReferenceSimTarget())
                    %if IsModelReferenceTarget() && !GenerateClassInterface
                        %assign baseSysIdx  = GetBaseSystemIdx()
                        %assign dataType    = FcnSysVarGroupType(System[baseSysIdx],"DWork")
                        %assign args.dwArg  = ", %<dataType> *localDW"
                        %assign args.dwDecl = ", localDW"
                        %assign args.dwDeclCache = args.dwDecl
                        %assign args.isDwArgDeclSame = TLC_TRUE
                        %assign curBlockFcn = ::BlockFcn
                        %assign ::BlockFcn = "InitializeDataMapInfo"
                        %<SLibAccessArgHelper(System[baseSysIdx].Interface.DWorkArgDef,"","")>
                        %assign ::BlockFcn = curBlockFcn
                    %else
                        %assign args.dwArg  = ", %<typePrefix>%<::tDWorkType> *%<LibGetDWorkStruct()>"
                        %if SLibUseBackwardCompatibleReusableInterface() || GenerateClassInterface
                            %assign args.dwDecl = ", %<addressPrefix>%<LibGetDWorkStruct()>"
                            %assign args.dwDeclCache = ", %<LibGetDWorkStruct()>"
                            %assign args.isDwArgDeclSame = TLC_TRUE
                        %else
                            %assign args.dwDecl = ", %<addressPrefix>%<SLibGetDWorkPointerFromRTM(0)>"
                            %assign args.dwDeclCache = ", %<SLibGetDWorkPointerFromRTM(0)>"
                            %assign args.isDwArgDeclSame = TLC_FALSE
                        %endif
                    %endif
                %endif %% Discrete States
                %if !reqInsts.ContStatesInst && !LibContStatesInstanceIsEmpty() && ...
                    (inCAPI.NumContStates > 0)
                    %if IsModelReferenceTarget()
                        %% Skip CState arg if local solver is used. There is a coder data group
                        %% that handles it.
                        %if !RTMMdlRefHasLocalSolver()
                            %assign baseSysIdx = GetBaseSystemIdx()
                            %assign dataType   = "%<FcnSysVarGroupType(System[baseSysIdx],"ContStates")> "
                            %assign args.xArg  = ", %<dataType> *localX"
                            %assign args.xDecl = ", localX"
                            %assign args.xDeclCache = args.xDecl
                            %assign curBlockFcn = ::BlockFcn
                            %assign ::BlockFcn = "InitializeDataMapInfo"
                            %<SLibAccessArgHelper(System[baseSysIdx].Interface.ContStatesArgDef,"","")>
                            %assign ::BlockFcn = curBlockFcn
                        %endif
                    %else
                        %assign args.xArg  = ", %<typePrefix>%<::tContStateType> *%<LibGetContinuousStateStruct()>"
                        %if SLibUseBackwardCompatibleReusableInterface() || GenerateClassInterface
                            %assign args.xDecl = ", %<addressPrefix>%<LibGetContinuousStateStruct()>"
                            %assign args.xDeclCache = ", %<LibGetContinuousStateStruct()>"
                        %else
                            %assign args.xDecl = ", (%<typePrefix>%<::tContStateType> *)%<addressPrefix>%<SLibGetContStatesPointerFromRTM(0)>"
                            %assign args.xDeclCache = ", (%<typePrefix>%<::tContStateType> *)%<SLibGetContStatesPointerFromRTM(0)>"
                        %endif
                    %endif
                %endif
            %endif  %% Continuous States
        %endif %% if IsMultiInstanceERTorModelReference()

        %assign mdlRef = IsModelReferenceTarget()
        %assign multiOrMdlref = MultiInstanceERTCode || mdlRef
        %% Coder groups for submodel or reusable top
        %if multiOrMdlref
            %assign groupTypePrefix = ""
            %if GenerateClassInterface && SLibIsSystemTypesModelClassNamespace(rootSystem)
                %assign groupTypePrefix = typePrefix
            %endif
            %foreach idx = ::CompiledModel.NumCoderDataGroups
                %assign group = ::CompiledModel.CoderDataGroup[idx]
                %if FcnAddArgForGroup(group, inCAPI)
                    %if IsModelReferenceTarget() && !GenerateClassInterface
                        %assign baseSysIdx  = GetBaseSystemIdx()
                        %assign dataType    = groupTypePrefix + SLibCoderDataGroupType(group)
                        %assign groupToken = "CoderDataGroup" + group.Name
                        %assign varGroupIdx = FcnSysVarGroupIndex(System[baseSysIdx], groupToken, 0)
                        %if varGroupIdx < 0
                            %continue
                        %endif
                        %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
                        %assign varName = varGroup.LocalName

                        %assign args.groupArg[idx]  = ", %<dataType> *%<varName>"
                        %if SLibAccessGroupThroughSelf(group)
                            %assign args.groupDecl[idx] = ", %<addressPrefix>%<SLibGetCoderDataGroupPointerFromRTM(group, 0)>"
                            %assign args.groupDeclCache[idx] = ", %<SLibGetCoderDataGroupPointerFromRTM(group, 0)>"
                        %else
                            %assign args.groupDecl[idx] = ", %<addressPrefix>%<SLibCoderDataGroupInstance(group)>"
                            %assign args.groupDeclCache[idx] = ", &%<SLibCoderDataGroupInstance(group)>"
                        %endif
                        %assign argDef = groupToken + "ArgDef"
                        %assign curBlockFcn = ::BlockFcn
                        %assign ::BlockFcn = "InitializeDataMapInfo"
                        %assign accessHelper = SLibAccessArgHelper(System[baseSysIdx].Interface.%<argDef>,"","")
                        %assign ::BlockFcn = curBlockFcn
                        %<accessHelper>
                    %else
                        %assign args.groupArg[idx]  = ", %<groupTypePrefix>%<SLibCoderDataGroupType(group)>* %<LibGetCoderDataGroupStruct(group)>"
                        %if GenerateClassInterface
                            %if group.AsStructure == "InSelf"
                                %assign args.groupDecl[idx] = ", &%<SLibCoderDataGroupInstance(group)>"
                                %assign args.groupDeclCache[idx] = ", %<SLibCoderDataGroupInstance(group)>"
                            %else
                                %assign args.groupArg[idx]  = ", %<groupTypePrefix>%<SLibCoderDataGroupType(group)>* %<SLibCoderDataGroupReference(group)>"
                                %assign args.groupDecl[idx] = ", %<SLibCoderDataGroupReference(group)>"
                                %assign args.groupDeclCache[idx] = ", %<SLibCoderDataGroupReference(group)>"
                            %endif
                        %elseif SLibAccessGroupThroughSelf(group)
                            %if SLibStandaloneMultiInstanceInTopModel(group)
                                %% For coder group that has no reference/instance in RTM (currently only AUTOSAR CTypedPIM)
                                %assign args.groupDecl[idx] = ", %<addressPrefix>%<SLibCoderDataGroupInstance(group)>"
                                %assign args.groupDeclCache[idx] = ", %<SLibCoderDataGroupInstance(group)>"
                            %else
                                %assign args.groupDecl[idx] = ", %<addressPrefix>%<SLibGetCoderDataGroupPointerFromRTM(group, 0)>"
                                %assign args.groupDeclCache[idx] = ", %<SLibGetCoderDataGroupPointerFromRTM(group, 0)>"
                            %endif
                        %else
                            %assign args.groupDecl[idx] = ", %<addressPrefix>%<SLibCoderDataGroupInstance(group)>"
                            %assign args.groupDeclCache[idx] = ", &%<SLibCoderDataGroupInstance(group)>"
                        %endif
                    %endif
                %endif
            %endforeach
        %endif

        %if GenerateClassInterface && SLibGetDoesSelfExist()
            %assign selfVG = ::CompiledModel.VarGroups.VarGroup[SLibGetSelfVarGroupIndex()]
            %assign selfGroupIdx = SLibGetSelfCoderDataGroupIndex()
            %assign ssargs = ""
            %assign ssdecls = ""
            %foreach elemIdx = selfVG.NumVarGroupElements
                %assign elem = IDNUM(selfVG.VarGroupElements[elemIdx])
                %if elem[0] == "VG"
                    %assign elemVG = ::CompiledModel.VarGroups.VarGroup[elem[1]]
                    %if elemVG.CoderDataGroupIndex == selfGroupIdx
                        %assign typename = SLibGetTypeNameFromCGType(elemVG.CGTypeIdx)
                        %assign symbolicDims = LibCGTypeSymbolicVectorDims(elemVG.CGTypeIdx)
                        %assign refOp = ISEMPTY(symbolicDims) ? "& " : " "
                        %assign ssargs = ssargs + ", " + "%<typePrefix>%<typename>" + "%<refOp>" + elemVG.Name + symbolicDims
                        %assign ssdecls = ssdecls + ", " + elemVG.Name
                    %endif
                %endif
            %endforeach
            %assign args.ssArg = ssargs
            %assign args.ssDecl = ssdecls
            %assign args.ssDeclCache = ssdecls
        %endif
    %endif %% !UsingMalloc
    %<LibAddToCompiledModel("CAPIFunctionArgs", args)>
    %return args
%endfunction

%% Function FcnIncludeGroupTypeInAPI ===================================================
%% Abstract:
%%   Decide whether or not to include (i.e. not ignore) a group based on
%%   Settings and its type (e.g. InstP vs. !InstP)
%function FcnIncludeGroupTypeInAPI(group) void
    %if group.ContainsInstanceSpecificParameter
        %return RTWCAPIParams
    %else
        %return RTWCAPISignals || RTWCAPIStates || RTWCAPIRootIO
    %endif
%endfunction

%% Function FcnReturnCompliantBlockPath ======================================
%% Abstract:
%%   Checks if the blkPath string is less than maximum allowed string length.
%%   If length is less, returns the blkPath, otherwise generate warnings.
%%   We choose the a value of 509 (ANSI standard) for maximum allowed length.
%%   The maximum allowed string length can be overwritten via a TLC option
%%   "RTWMaxStringLength = ###". The max allowed is 509 according to ANSI.
%%   However, MSVC allows upto 2000 chars.
%%
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants3.m
%function FcnReturnCompliantBlockPath(blkPath, type) void
    %assign blkPath = STRING(blkPath)
    %assign strLen  = SIZE(blkPath, 1)
    %if (strLen > %<RTWMaxStringLength>)
        %assign warnStr= "C-API %<type> BlockPath length of '%<strLen>' " + ...
            "is greater than the length '509' ISO C89 compilers are required " + ...
            "to support. An empty BlockPath will be placed in the C-API structure.\n" + ...
            "BlockPath: " + blkPath
        %<LibReportWarning(warnStr)>
        %assign blkPath = ""
    %endif
    %return blkPath
%endfunction

%% Function: FcnDataSupportsCAPI ===================================================================
%% Abstract:
%%   Can we describe this data in C-API file?
%%
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants3.m
%function FcnDataSupportsCAPI(data) void
    %if (TYPE(data) == "Scope")
        %assign rtwRecord = LibRTWRecord(data)
        %if !ISEMPTY(rtwRecord) && (rtwRecord.StorageClass == "Custom" || ...
            SLibIsLegacyStorageClassForDataRecord(rtwRecord))
            %assign cscDefn = SLibGetCSCDefForData(rtwRecord)
            %if (cscDefn.Name == "CalPrm" || cscDefn.Name == "InternalCalPrm" || ...
                cscDefn.Name == "PerInstanceMemory")
                %return TLC_FALSE
            %endif
        %endif
        %return !SLibIsGlobalMapDataWithNoExternalLinkage(data)
    %else
        %return TLC_FALSE
    %endif
%endfunction

%function FcnCSCSupportsCAPI(data) void
    %assign rtwRecord = LibRTWRecord(data)
    %if !ISEMPTY(rtwRecord)
        %assign cscDefn = SLibGetCSCDefForData(rtwRecord)
        %switch cscDefn.CSCType
          %case "AccessFunction"
            %return TLC_FALSE
          %default
            %break
        %endswitch
    %endif
    %return TLC_TRUE
%endfunction

%% Function FcnWriteDatasetLoggingHier =======================================
%% Abstract:
%%   This function writes out bus hierarchy information required for dataset
%%   logging.
%%
%% TopTester: test/toolbox/simulink/variants/var-bus-general/tVariantBusGecks.m
%function FcnWriteDatasetLoggingHier() Output
    %assign uintType = LibGetDataTypeNameFromId(::CompiledModel.tSS_UINTEGER)

    %assign totalChildIdx = 0
    %assign equalSign = LibGetDataInitEqualSign()

    %% Write hierarchy structures
    static const rtwCAPI_SignalHierLoggingInfo rtSigHierLoggingInfo[]%<equalSign>{
        %foreach shIdx = NumSignalHierLoggingInfo
            %% Signal name and number of children
            %assign sigName  = SignalHierLoggingInfo[shIdx].SignalName
            %assign numChild = SignalHierLoggingInfo[shIdx].NumChildren

            %% Start index of children in vector
            %if numChild > 0
                %assign childStartIdx = totalChildIdx
            %else
                %assign childStartIdx = -1
            %endif

            %% Initialization string
            %assign dynInit  =  "{ \"%<sigName>\", %<numChild>, %<childStartIdx> }"
            %if shIdx < NumSignalHierLoggingInfo - 1
                %assign dynInit = dynInit + ","
            %endif

            %<dynInit>

            %% Increment total children
            %assign totalChildIdx = totalChildIdx + numChild
        %endforeach
    };

    %% Write child index vector
    %assign curChildCount = 0
    static const %<uintType>  rtSigHierLoggingChildIdxs[]%<equalSign>{
        %foreach shIdx = NumSignalHierLoggingInfo
            %foreach cIdx = SignalHierLoggingInfo[shIdx].NumChildren
                %assign curChildIdx = SignalHierLoggingInfo[shIdx].Children[cIdx]
                %assign dynInit = "%<curChildIdx>"
                %if curChildCount < totalChildIdx - 1
                    %assign dynInit = dynInit + ","
                %endif

                %<dynInit>

                %assign curChildCount = curChildCount + 1
            %endforeach
        %endforeach
    };

%endfunction

%% Function FcnWriteDatasetLoggingSFSignals ==================================
%% Abstract:
%%   This function writes out logging information for all logged Stateflow
%%   signals in this model for Dataset format logging
%%
%function FcnWriteDatasetLoggingSFSignals() Output

    %% Write Stateflow chart signal logging info
    static const rtwCAPI_StateflowSignalLoggingInfo rtStateflowChartLoggingInfo[]%<LibGetDataInitEqualSign()>{
        %foreach sigIdx = NumStateflowSigLogInfo

            %% Extract settings from record
            %assign signalName = STRING(StateflowSigLogInfo[sigIdx].SignalName)
            %assign bpath = STRING(StateflowSigLogInfo[sigIdx].BlockPath)
            %assign loggingName = STRING(StateflowSigLogInfo[sigIdx].LoggingName)
            %assign maxPoints = StateflowSigLogInfo[sigIdx].MaxPoints
            %assign decimation = StateflowSigLogInfo[sigIdx].Decimation
            %if StateflowSigLogInfo[sigIdx].UseCustomName
                %assign useCustomName = TLC_TRUE
            %else
                %assign useCustomName = TLC_FALSE
            %endif

            %% Initialization string
            %assign dynInit  =  "{ \"%<signalName>\", \"%<bpath>\", \"%<loggingName>\", %<maxPoints>, %<decimation>, %<useCustomName> }"
            %if sigIdx < NumStateflowSigLogInfo - 1
                %assign dynInit = dynInit + ","
            %endif

            %<dynInit>

        %endforeach
    };


%endfunction

%% Function FcnWriteCAPIHeadersandDefines ======================================
%% Abstract:
%%
%%TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants3.m
%function FcnWriteCAPIHeadersandDefines(baseName) Output
    %assign uint16Type = LibGetDataTypeNameFromId(::CompiledModel.tSS_UINT16)

    %assign HostHeaderFile = LibGetMdlCapiHostHdrBaseName()
    %assign HeaderFile = LibGetMdlCapiHdrBaseName()
    #include "rtw_capi.h"

    #ifdef HOST_CAPI_BUILD
    #include "%<HostHeaderFile>.h"

    #define sizeof(s) ((size_t)(0xFFFF))
    #undef rt_offsetof
    #define rt_offsetof(s,el) ((%<uint16Type>)(0xFFFF))

    #define TARGET_CONST
    #define TARGET_STRING(s) (s)

    %<LibDumpFixptOddSizeTypedefs()>

    #else /* HOST_CAPI_BUILD */

    #include "%<SLibCoderBuiltinTypeidTypesFilename()>"
    #include "%<baseName>.h"
    #include "%<HeaderFile>.h"

    %% imported signals are declared in model_private.h
    %% if RemoveHideChild is on, include private file in capi.h instead of capi.c
    %if !RemoveNonEmptyHideChildSymbol()
        %<SLibIncludePrivateHeader()>
    %endif

    %if EXISTS(::LightWeightRTWCAPINeeded)
        #define LIGHT_WEIGHT_CAPI
    %endif

    #ifdef LIGHT_WEIGHT_CAPI
    #define TARGET_CONST
    #define TARGET_STRING(s)               (%<SLibGetNullDefinitionFromTfl()>)
    #else
    #define TARGET_CONST                   const
    #define TARGET_STRING(s)               (s)
    #endif

    #endif /* HOST_CAPI_BUILD */

%endfunction

%% Function FcnWriteHostHeader =================================================
%% Abstract:
%%
%%TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants3.m
%function FcnWriteHostHeader() Output

    %%Create Host header file
    %assign ModelHeaderFile = LibGetMdlPubHdrBaseName()
    %assign HostHeaderFile = LibGetMdlCapiHostHdrBaseName()
    %assign FileNameHost = "%<HostHeaderFile>.h"
    %assign FileTagHost  = "%<ModelHeaderFile>_cap_host_h_"

    %openfile outputFileHost = FileNameHost

    %assign includeGuard = SLibGenerateIncludeGuardMacro(FileTagHost)
    #ifndef %<includeGuard>
    #define %<includeGuard>

    #ifdef HOST_CAPI_BUILD

    #include "rtw_capi.h"
    %if ::isRAccel || IsModelReferenceSimTarget()
        #include "rtw_modelmap_simtarget.h"
    %else
        #include "rtw_modelmap.h"
    %endif

    %if ::NumModelBlocksWithCAPI > 0
        %assign mdlRefBlks    = ::CompiledModel.ModelReferenceBlocks
        %assign nMdlRefBlks   = SIZE(mdlRefBlks,0)
        %foreach rowIdx = nMdlRefBlks
            %assign mdlRefInfo = mdlRefBlks[rowIdx]
            %assign mSysIdx = mdlRefInfo[0]
            %assign bIdx    = mdlRefInfo[1]
            %assign instIdx = mdlRefInfo[2]
            %with System[mSysIdx].Block[bIdx]
                %assign blk = System[mSysIdx].Block[bIdx]

                %if !blk.ParamSettings.SupportsCAPI
                    %continue
                %endif

                %assign blockInterface = GetModelrefInterface(blk)
                %assign tmpVec = [%<mdlRefInfo[3]>, %<mdlRefInfo[4]>]
                %assign mdlRefName = STRING(blockInterface.Name)
                %if ISFIELD(blockInterface, "RegistrationFcn")

                    #include "%<mdlRefName>_capi_host.h"

                %endif
            %endwith%%System[mSysIdx].Block[bIdx]
        %endforeach
    %endif

    %assign structTag = "%<Name>_host_DataMapInfo_T"
    %<SLibGetStructDefHeaderForHeaderFiles("", structTag, "")>
    rtwCAPI_ModelMappingInfo mmi;
    %if ::NumModelBlocksWithCAPI > 0
        %assign mdlRefBlks    = ::CompiledModel.ModelReferenceBlocks
        %assign nMdlRefBlks   = SIZE(mdlRefBlks,0)

        rtwCAPI_ModelMappingInfo *childMMI[%<nMdlRefBlks>];

        %assign mdlBlkIdx = 0
        %foreach rowIdx = nMdlRefBlks
            %assign mdlRefInfo = mdlRefBlks[rowIdx]
            %assign mSysIdx = mdlRefInfo[0]
            %assign bIdx    = mdlRefInfo[1]
            %assign instIdx = mdlRefInfo[2]
            %with System[mSysIdx].Block[bIdx]
                %assign blk = System[mSysIdx].Block[bIdx]

                %if !blk.ParamSettings.SupportsCAPI
                    %continue
                %endif

                %assign blockInterface = GetModelrefInterface(blk)
                %assign tmpVec = [%<mdlRefInfo[3]>, %<mdlRefInfo[4]>]
                %assign mdlRefName = STRING(blockInterface.Name)
                %if ISFIELD(blockInterface, "RegistrationFcn")
                    %<mdlRefName>_host_DataMapInfo_T child%<mdlBlkIdx>;
                %endif
                %assign mdlBlkIdx = mdlBlkIdx + 1
            %endwith%%System[mSysIdx].Block[bIdx]
        %endforeach
    %endif
    %<SLibGetStructDefTailForHeaderFiles(structTag, "")>

    #ifdef __cplusplus
    extern "C" {
        #endif

        void %<::CompiledModel.Name>_host_InitializeDataMapInfo(%<CompiledModel.Name>_host_DataMapInfo_T *dataMap, const char *path);

        #ifdef __cplusplus
    }
    #endif

    #endif /* HOST_CAPI_BUILD */

    #endif /* %<includeGuard> */

    /* EOF: %<FileNameHost> */
    %closefile outputFileHost
%endfunction

%function FcnGetModelInitializeDataMapInfoName() void
    %return ::CompiledModel.Name + "_InitializeDataMapInfo"
%endfunction

%%
%endif   %% _CAPI_

%% EOF capi.tlc ===============================================================
