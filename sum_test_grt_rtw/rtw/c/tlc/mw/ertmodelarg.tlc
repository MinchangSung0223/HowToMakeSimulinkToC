%% ============================================================================
%% File : ertmodelarg.tlc
%%
%% Abstract:
%%   This is the system library file for code generation's Embedded-C code format.
%%
%%
%% Copyright 1994-2023 The MathWorks, Inc.

%selectfile NULL_FILE

%if EXISTS(_ERT_MODEL_ARG_) == 0
%assign _ERT_MODEL_ARG_ = 1

%% Function: SLibModelStepFcnName
%% Abstrack:
%%   Generate model step fcn name
%%
%function SLibModelStepFcnName(tid) void
    %assert CombineOutputUpdateFcns
    %if SLibFcnProtoCtrlActive()
        %assign fcnData = FcnGetFunctionPrototypeRecord()
        %return fcnData.FunctionName
    %elseif SLibAutosarActive()
        %if SLibSingleTasking()
            %assign fcnData = FcnGetAutosarRecord()
            %% Use symbol rather than short name be the function name
            %return fcnData.PeriodicRunnableSymbol
        %else
            %return ::CompiledModel.RTWAutosar.AutosarRunnables.Runnable[tid].Symbol
        %endif
    %elseif ( GenerateClassInterface && ...
        !(ISEMPTY(tid) && SLibNeedWrapperStepFcn()!=0) )  %% NOT generating wrapper for static main
        %assign classConfObj = FcnGetRTWCPPStepPrototypeRecord()
        %assign tidPostfix = ""
        %if !SLibSingleTasking()
            %%MR/MT, must be void-void case
            %if CGMODEL_ACCESS("CGModel.isCPPMappingEnabled")
                %assign fcnCall = CGMODEL_ACCESS("CGModel.getModelEntryFunctionName", "Step", "%<tid>")
            %else
                %assign tidPostfix = "%<tid>"
                %assign fcnCall = "%<classConfObj.FunctionName>"
                %assign fcnCall = fcnCall+"%<tidPostfix>"
            %endif
        %elseif !ISEMPTY(tid)
            %if tid > 0
                %assign fcnCall = SampleTime[tid].EntryFcnName
            %else
                %return ""
            %endif
        %else
            %if CGMODEL_ACCESS("CGModel.isCPPMappingEnabled")
                %assign fcnCall = CGMODEL_ACCESS("CGModel.getModelEntryFunctionName", "Step", "")
            %else
                %assign fcnCall = "%<classConfObj.FunctionName>"
            %endif
        %endif

        %if ::CPPObjectName == "this"
            %return "this->"+fcnCall
        %else
            %return "%<::CPPObjectName>."+fcnCall
        %endif
    %else
        %assign fcnName = ""
        %if CGMODEL_ACCESS("CGModel.isModelEntryFunctionPresent","Step")
            %if CGMODEL_ACCESS("CGModel.isIndividualFunctionMappingEnabled")
                %assign fcnName = CGMODEL_ACCESS("CGModel.getModelEntryFunctionName","Step", "%<tid>")
            %else
                %% Append TID to base name (Needed for Bosch feature flag)
                %assign fcnName = CGMODEL_ACCESS("CGModel.getModelEntryFunctionName","Step", "%<tid>")+"%<tid>"
            %endif
        %else
            %assign fcnName = "%<Name>_step%<tid>"
        %endif

        %return fcnName
    %endif
%endfunction

%%%
%%% Initialize Function related functions.
%%%

%function GenerateModelInitFcnHeader(fcnName) void
    %assign fcnReturns = "void"
    %if SLibIsERTFunctionStatic()
        %assign fcnReturns = "static %<fcnReturns>"
    %endif
    %assign fcnParams  = SLibModelFcnArgs("Initialize",TLC_FALSE,"")
    %if SLibAutosarCompilerAbstractionRequired()
        %assign memsecUUID = SLibGetFcnMemSecUUIDForFunction("Initialize", "")
        %assign retVal = SLibAutosarCompilerAbstractionForFcnDeclRtnType(fcnReturns, "FuncCalledByRTE", memsecUUID) + " " + fcnName + "(" + fcnParams + ")"
    %else
        %assign retVal = fcnReturns + " " + fcnName + "(" + fcnParams + ")"
    %endif
    %return retVal
%endfunction

%function GenerateModelInitFcnBody(rootSystem, fcnName, fcnReturns, fcnParams)
    %% Cannot be used when using malloc to generate initialize function.
    %assert !::UsingMalloc
    %assign fcns = ["ModelInitialize", "Registration"]
    %openfile initFcnBody
    %openfile localVariables
    %if MultiInstanceERTCode && !GenerateClassInterface
        %<SLibDumpLocalVariablesForBlockFcn(rootSystem, fcns)>
    %endif
    %closefile localVariables

    %if !WHITE_SPACE(localVariables)
        %<localVariables>
    %endif

    %if SLibAutosarActive()
        %with ::CompiledModel.RTWAutosar.E2EFunctions
            %if ((NumE2EReads + NumE2EWrites) > 0) && !CGMODEL_ACCESS("CGModel.isE2ETransformerSupported")
                %assign self = ""
                %if ::CompiledModel.MultiInstanceERTCode
                    %assign self = RTWAutosar.InstanceHandleName
                %endif
                /* End-to-End (E2E) Protection Wrapper initialization */
                %foreach e2eFcnIdx = NumE2EReads
                    %if E2ERead[e2eFcnIdx].VariantCondition == ""
                        E2EPW_ReadInit_%<E2ERead[e2eFcnIdx].PortElement>(%<self>);
                    %else
                        %<SLibIfVariantConditionForm(E2ERead[e2eFcnIdx].VariantCondition)>
                        E2EPW_ReadInit_%<E2ERead[e2eFcnIdx].PortElement>(%<self>);
                        %<SLibEndIfVariantConditionForm(E2ERead[e2eFcnIdx].VariantCondition)>
                    %endif
                %endforeach
                %foreach e2eFcnIdx = NumE2EWrites
                    %if E2EWrite[e2eFcnIdx].VariantCondition == ""
                        E2EPW_WriteInit_%<E2EWrite[e2eFcnIdx].PortElement>(%<self>);
                    %else
                        %<SLibIfVariantConditionForm(E2EWrite[e2eFcnIdx].VariantCondition)>
                        E2EPW_WriteInit_%<E2EWrite[e2eFcnIdx].PortElement>(%<self>);
                        %<SLibEndIfVariantConditionForm(E2EWrite[e2eFcnIdx].VariantCondition)>
                    %endif
                %endforeach
            %endif
        %endwith %% CompiledModel.RTWAutosar.E2EInitFunctions
    %endif

    %<ModelInitializeBodyBuffer>

    %if SLibAutosarActive()
        %<SLibDumpUnusedParameterForInstanceHandle(fcns)>
    %else
        %openfile UnusedParamBuffer
        %<SLibDumpUnusedParameterForRTM(fcns)>
        %closefile UnusedParamBuffer
        %<UnusedParamBuffer>
        %<UpdateUnusedParamSymbolForModelEntryPointFunctionFile(UnusedParamBuffer, "InitFcn", 0)>\
    %endif
    %closefile initFcnBody
    %return initFcnBody
%endfunction

%function GenerateModelInitFcnName() void
    %if SLibFcnProtoCtrlActive()
        %assign fcnData = FcnGetFunctionPrototypeRecord()
        %return fcnData.InitFunctionName
    %elseif SLibAutosarActive()
        %assign fcnData = FcnGetAutosarRecord()
        %% Use symbol rather than short name be the function name
        %return fcnData.InitRunnableSymbol
    %elseif SLibIsExportFcnDiagram() && ISFIELD(::CompiledModel, "ExportFcnCustomInitFcnName")
        %return ::CompiledModel.ExportFcnCustomInitFcnName
    %elseif SLibIsExportFcnDiagram()
        %foreach tid = NumSampleTimes
            %if ISFIELD(SampleTime[tid], "EventSourceType") && ...
                SampleTime[tid].EventSourceType == "PowerUpEvent"
                %if ISFIELD(SampleTime[tid] ,"EntryFcnName")
                    %return SampleTime[tid].EntryFcnName
                %endif
            %endif
        %endforeach
        %if CGMODEL_ACCESS("CGModel.isModelEntryFunctionPresent","Initialize")
            %return CGMODEL_ACCESS("CGModel.getModelEntryFunctionName","Initialize", "")
        %else
            %return ::CompiledModel.Name + "_initialize"
        %endif
    %else
        %if CGMODEL_ACCESS("CGModel.isModelEntryFunctionPresent","Initialize")
            %return CGMODEL_ACCESS("CGModel.getModelEntryFunctionName","Initialize", "")
        %else
            %return ::CompiledModel.Name + "_initialize"
        %endif
    %endif
%endfunction

%%%
%%% Terminate Function related functions.
%%%

%function GenerateModelTermFcnHeader(fcnName) void
    %assign fcnReturns = "void"
    %if SLibIsERTFunctionStatic()
        %assign fcnReturns = "static %<fcnReturns>"
    %endif
    %assign fcnParams  = SLibModelFcnArgs("Terminate",TLC_FALSE,"")
    %% AUTOSAR Compiler Abstraction not needed for terminate function
    %if SLibAutosarCompilerAbstractionRequired()
        %assign memsecUUID = SLibGetFcnMemSecUUIDForFunction("Terminate", "")
        %assign retVal = SLibAutosarCompilerAbstractionForFcnDeclRtnType(fcnReturns, "FuncCalledByRTE", memsecUUID) + " " + fcnName + "(" + fcnParams + ")"
    %else
        %assign retVal = fcnReturns + " " + fcnName + "(" + fcnParams + ")"
    %endif
    %return retVal
%endfunction

%function GenerateModelTermFcnBody(rootSystem, fcnName)
    %% Cannot be used when using malloc to generate terminate function.

    %openfile termFcnBody

    %assign GenerateTmFcnWarning = TLC_FALSE
    %assign hdrBuf  = ""
    %assign bodyBuf = ""

    %if IncludeMdlTerminateFcn
        %openfile hdrBuf
        %assign fcnAbstract = "Model terminate function"

        %assign fcnReturns = "void"
        %if SLibIsERTFunctionStatic()
            %assign fcnReturns = "static %<fcnReturns>"
        %endif
        %assign fcnParams = SLibModelFcnArgs("Terminate",TLC_FALSE,"")
        %createrecord fcnRec {Name fcnName; Returns fcnReturns; Params fcnParams; Abstract fcnAbstract; ...
            Category "model"; GeneratedBy "ertreg.tlc"; Type "Terminate"}
        %<SLibDumpFunctionBanner(fcnRec)>
        %undef fcnRec
        %if CGMODEL_ACCESS("CGModel.isIndividualFunctionMappingEnabled") || SLibAutosarActive()
            %<SLibGetFcnMemSecPragmaForFunction(fcnName, "Terminate", "", "Pre")>\
        %else
            %<SLibGetFcnMemSecPragma(fcnName, "MemSecFuncInitTerm", "Pre")>\
        %endif
        %<GenerateModelTermFcnHeader(fcnName)>
        %closefile hdrBuf

        %openfile bodyBuf
    %endif

    %if LibSystemFcnIsEmpty(rootSystem,"Terminate")
        %if IncludeMdlTerminateFcn
            /* (no terminate code required) */
        %endif
    %else
        %openfile TerminateFcnBody
        %<LibDumpSystemProfileCode(rootSystem, "Terminate", "End")>\
        %<LibDumpSystemSSVars(rootSystem, "Terminate")>\
        %<LibGetSystemLocalVars(rootSystem, "Terminate","")>\
        %<SLibGetFcnLocalVars(rootSystem, "Terminate","")>\
        %<LibDumpSystemUserCode(rootSystem,"Terminate","Header")>\
        %<LibDumpSystemUserCode(rootSystem,"Terminate","Body")>\
        %<LibDumpSystemFcn(rootSystem,"Terminate")>\
        %closefile TerminateFcnBody

        %if IncludeMdlTerminateFcn
            %openfile localVariables
            %if MultiInstanceERTCode && !GenerateClassInterface
                %<SLibDumpLocalVariablesForBlockFcn(rootSystem,"Terminate")>
            %endif
            %closefile localVariables

            %if !WHITE_SPACE(localVariables)
                %<localVariables>
            %endif
            %<TerminateFcnBody>
        %else
            %assign GenerateTmFcnWarning = GenerateTmFcnWarning || !WHITE_SPACE(TerminateFcnBody)
        %endif
        %openfile TerminateFcnBody1
        %<LibDumpSystemUserCode(rootSystem,"Terminate","Trailer")>
        %closefile TerminateFcnBody1
        %if IncludeMdlTerminateFcn
            %<TerminateFcnBody1>\
        %else
            %assign GenerateTmFcnWarning = GenerateTmFcnWarning || !WHITE_SPACE(TerminateFcnBody1)
        %endif

    %endif

    %if haveModelRefTermCode
        %if IncludeMdlTerminateFcn
            %<modelrefTermBuffer>\
        %else
            %assign GenerateTmFcnWarning = GenerateTmFcnWarning || !WHITE_SPACE(modelrefTermBuffer)
        %endif
    %endif

    %if IncludeMdlTerminateFcn
        %closefile bodyBuf
    %endif

    %if UsingMalloc
        %openfile termFreeCode
        %<SLibGenRootTermMemFreeCode()>
        %closefile termFreeCode

        %if !IncludeMdlTerminateFcn
            %assign GenerateTmFcnWarning = GenerateTmFcnWarning || !WHITE_SPACE(termFreeCode)
        %endif
    %endif

    %if IncludeMdlTerminateFcn
        %<hdrBuf>
        {
            %<bodyBuf>
            %if UsingMalloc
                %<termFreeCode>\
            %else
                %openfile UnusedParamBuffer
                %<SLibDumpUnusedParameterForRTM("Terminate")>
                %closefile UnusedParamBuffer
                %<UnusedParamBuffer>
                %<UpdateUnusedParamSymbolForModelEntryPointFunctionFile(UnusedParamBuffer, "TermFcn", 0)>\
            %endif
        }
        %if CGMODEL_ACCESS("CGModel.isIndividualFunctionMappingEnabled") || SLibAutosarActive()
            %<SLibGetFcnMemSecPragmaForFunction(fcnName, "Terminate", "", "Post")>\
        %else
            %<SLibGetFcnMemSecPragma(fcnName, "MemSecFuncInitTerm", "Post")>\
        %endif
    %endif

    %if !IncludeMdlTerminateFcn && GenerateTmFcnWarning
        %<FcnThrowTerminateFcnWarning()>
    %endif

    %closefile termFcnBody
    %return termFcnBody
%endfunction

%function GenerateNonClassicInterfaceModelTermFcnName() void
    %if SLibAutosarActive() && IncludeMdlTerminateFcn
        %assign terminateRunnables = ::CompiledModel.RTWAutosar.TerminateRunnables.Runnable
        %assert(SIZE(terminateRunnables, 1) == 1)
        %return ::CompiledModel.RTWAutosar.TerminateRunnables.Runnable[0].Symbol
    %endif

    %if CGMODEL_ACCESS("CGModel.isModelEntryFunctionPresent","Terminate")
        %return CGMODEL_ACCESS("CGModel.getModelEntryFunctionName","Terminate", "")
    %else
        %return ::CompiledModel.Name + "_terminate"
    %endif
%endfunction

%% Function: SLibModelStepFcnReturn
%% Abstract:
%%   Generate model step fcn return
%%
%function SLibModelStepFcnReturn(mode) void
    %assert CombineOutputUpdateFcns
    %if SLibFcnProtoCtrlActive()
        %assign fcnData = FcnGetFunctionPrototypeRecord()
        %return FcnModelStepFcnReturnCode(fcnData, mode)
    %elseif GenerateClassInterface
        %assign classConfObj = FcnGetRTWCPPStepPrototypeRecord()
        %return FcnModelStepFcnReturnCode(classConfObj, mode)
    %else
        %if mode == "ReturnType"
            %return "void"
        %else
            %return ""
        %endif
    %endif
%endfunction

%% Function: SLibExtIOStructArgNeeded
%% Abstract:
%%   Return true if any element in extOut/extIn is accessed.
%%
%% type  = 'Input', check external inports
%%         'Output', check external outports
%%
%function SLibExtIOStructArgNeeded(type, tid, isPeriodicRateGrouping)
    %assert type == "Input" || type == "Output"
    %assign retVal = TLC_FALSE

    %if RootIOStructures
        %assign numIOs = External%<type>s.NumExternal%<type>s
        %foreach idx = numIOs
            %assign extIO = External%<type>s.External%<type>[idx]

            %if !FcnArgNeeded(extIO,tid,isPeriodicRateGrouping)
                %continue
            %endif

            %if type == "Input"
                %if (extIO.StorageClass != "Auto")
                    %continue
                %endif
            %else
                %% Output
                %assign extOut       = ExternalOutputs.ExternalOutput[idx]
                %assign sysIdx       = extOut.Block[0]
                %assign blkIdx       = extOut.Block[1]
                %assign outportBlock = System[sysIdx].Block[blkIdx]
                %if SLibExternalOutputIsVirtual(outportBlock)
                    %continue
                %endif
            %endif

            %assign retVal = TLC_TRUE
            %break
        %endforeach
    %endif

    %return retVal
%endfunction

%% Function: SLibModelFcnArgs
%% Abstract:
%%   Generate model fcn arg list.
%%
%% isCallSite = 1, is call site and called from ertmain
%%            = 2, is call site, not called from ertmain
%%
%function SLibModelFcnArgs(type,isCallSite,tid) void
    %assign tmpBlockFcn = ::BlockFcn
    %assign recArgs = []
    %assign rootSystem        = System[NumSystems-1]
    %assign isRateGrouping    = ...
        SLibSystemFcnPeriodicRateGrouping(rootSystem, type) || ...
        SLibIsExplicitTaskingExportFcnRateGrouping(type, tid)
    %assign calledFromERTMain =  (isCallSite == 2) ? 0 : 1

    %if MultiInstanceERTCode && SLibAutosarActive()
        %return FcnGetMultiInstanceRunnableArgs(isCallSite)
    %endif

    %assign tmpHasSimStructVars = ::CompiledModel.HasSimStructVars
    %if MultiInstanceERTCode && ...
        ::CompiledModel.RootIOFormat == "Part of model data structure"
        %% If UsingMalloc is true, all data is passed in with SimStruct at callsite
        %assign ::CompiledModel.HasSimStructVars = isCallSite
    %endif
    %if type == "ODEUpdateContinuousStates"
        %assign type = "UpdateContStates"
        %assign needsTID = TLC_FALSE
    %else
        %% NeedsTID is true if rootsystem is multirate
        %% and need tid

        %if LibIsDeploymentDiagram()
            %assign needsTID = TLC_TRUE
        %else
            %assign needsTID = LibSystemFcnNeedsTID(rootSystem,type)
        %endif

    %endif

    %if GenerateClassInterface && GenerateSampleERTMain && !SLibGenerateNativeThreads()
        %assert (needsTID == TLC_FALSE)
    %endif

    %assign reqInsts = LibGetSystemField(rootSystem, "ReqRootPrmHdrDataInsts")

    %if !SLibUseBackwardCompatibleReusableInterface()
        %if MultiInstanceERTCode && !(::SeparateRegistrationFcn && ...
            type == "Registration") && !GenerateClassInterface
            %if isCallSite
                %assign recArgs = recArgs + "%<::tSimStruct>"
            %else
                %if type=="Terminate" && UsingMalloc
                    %assign recArgs = recArgs + "%<::tSimStructType> * %<::tSimStruct>"
                %else
                    %assign recArgs = recArgs + "%<::tSimStructType> *const %<::tSimStruct>"
                %endif
            %endif
        %endif
    %endif

    %if type == "Initialize" && ::SeparateRegistrationFcn
        %assign type = "ModelInitialize"
    %endif

    %switch type
      %case "Initialize"
      %case "Registration"
        %assign ::BlockFcn = "Registration"
        %break
      %case "Start"
        %assign ::BlockFcn = "Start"
        %if needsTID
            %if isCallSite
                %assign recArgs = recArgs + "%<tid>"
            %else
                %assign recArgs = recArgs + "%<::tTIDType> %<::tTID>"
            %endif
        %endif
        %break
      %case "Output"
        %assign ::BlockFcn = "Output"
        %if needsTID
            %if isCallSite
                %assign recArgs = recArgs + "%<tid>"
            %else
                %assign recArgs = recArgs + "%<::tTIDType> %<::tTID>"
            %endif
        %endif
        %break
      %case "OutputUpdate"
        %assign ::BlockFcn = "OutputUpdate"
        %if SLibFcnProtoCtrlActive()
            %assign fcnData = FcnGetFunctionPrototypeRecord()
            %if isCallSite
                %assign recArgs = recArgs + FcnModelStepFcnArgs(fcnData,"WrapperCall")
            %else
                %assign recArgs = recArgs + FcnModelStepFcnArgs(fcnData,"WrapperDec")
            %endif
        %elseif GenerateClassInterface
            %assign classConfObj = FcnGetRTWCPPStepPrototypeRecord()
            %if isCallSite
                %assign recArgs = recArgs + FcnModelStepFcnArgs(classConfObj,"WrapperCall")
            %else
                %if ISEMPTY(tid) && needsTID && SLibNeedWrapperStepFcn()!=0
                    %% Switchyard wrapper function args for static main
                    %assign classname = CGMODEL_ACCESS("CGModel.getClassName")
                    %assign recArgs = recArgs + "%<classname> & %<::CPPObjectName>" + "%<::tTIDType> %<::tTID>"
                %else
                    %assign recArgs = recArgs + FcnModelStepFcnArgs(classConfObj,"WrapperDec")
                %endif
            %endif
        %else
            %if needsTID
                %if isCallSite
                    %assign recArgs = recArgs + "%<tid>"
                %else
                    %assign recArgs = recArgs + "%<::tTIDType> %<::tTID>"
                %endif
            %endif
        %endif
        %break
      %case "RootUpdate"
        %assign ::BlockFcn = "RootUpdate"
        %if needsTID
            %if isCallSite
                %assign recArgs = recArgs + "%<tid>"
            %else
                %assign recArgs = recArgs + "%<::tTIDType> %<::tTID>"
            %endif
        %endif
        %if ISEQUAL(rootSystem.CurrentTID, 1) && (NumContStates > 0)
            %<SLibAddTIDtoAccessTIDList(rootSystem.Interface.RTMArgDef, ...
                "RootUpdate", "",[0,1])>
        %endif
        %break
      %case "Update"
        %assign ::BlockFcn = "Update"
        %if needsTID
            %if isCallSite
                %assign recArgs = recArgs + "%<tid>"
            %else
                %assign recArgs = recArgs + "%<::tTIDType> %<::tTID>"
            %endif
        %endif
        %if ISEQUAL(rootSystem.CurrentTID, 1) && (NumContStates > 0)
            %<SLibAddTIDtoAccessTIDList(rootSystem.Interface.RTMArgDef, ...
                "Update", "",[0,1])>
        %endif
        %break
      %case "UpdateContStates"
        %assign ::BlockFcn = "UpdateContStates"
        %if SLibFcnProtoCtrlActive()
            %assign fcnData = FcnGetFunctionPrototypeRecord()
            %if isCallSite
                %assign recArgs = recArgs + FcnModelStepFcnArgs(fcnData,"CalledInStep")
            %else
                %assign recArgs = recArgs + FcnModelStepFcnArgs(fcnData,"WrapperDec")
            %endif
        %elseif GenerateClassInterface
            %assign classConfObj = FcnGetRTWCPPStepPrototypeRecord()
            %if isCallSite
                %assign recArgs = recArgs + FcnModelStepFcnArgs(classConfObj,"CalledInStep")
            %else
                %if ISEMPTY(tid) && needsTID && SLibNeedWrapperStepFcn()!=0
                    %% Switchyard wrapper function args for static main
                    %assign classname = CGMODEL_ACCESS("CGModel.getClassName")
                    %assign recArgs = recArgs + "%<classname> & %<::CPPObjectName>" + "%<::tTIDType> %<::tTID>"
                %else
                    %assign recArgs = recArgs + FcnModelStepFcnArgs(classConfObj,"WrapperDec")
                %endif
            %endif
        %else
            %if needsTID
                %if isCallSite
                    %assign recArgs = recArgs + "%<tid>"
                %else
                    %assign recArgs = recArgs + "%<::tTIDType> %<::tTID>"
                %endif
            %endif
        %endif
        %break
      %case "ZeroCrossing"
      %case "Derivative"
      %case "ForcingFunction"
      %case "MassMatrix"
      %case "Projection"
        %assign ::BlockFcn = type
        %if GenerateClassInterface
            %assign classConfObj = FcnGetRTWCPPStepPrototypeRecord()
            %if isCallSite
                %assign recArgs = recArgs + FcnModelStepFcnArgs(classConfObj,"CalledInStep")
            %else
                %assign recArgs = recArgs + FcnModelStepFcnArgs(classConfObj,"WrapperDec")
            %endif
        %elseif SLibFcnProtoCtrlActive()
            %assign fcnData = FcnGetFunctionPrototypeRecord()
            %if isCallSite
                %assign recArgs = recArgs + FcnModelStepFcnArgs(fcnData,"CalledInStep")
            %else
                %assign recArgs = recArgs + FcnModelStepFcnArgs(fcnData,"WrapperDec")
            %endif
        %endif
        %if UsingMalloc && (type == "Derivative" ||  type == "Projection")
            %assign ::BlockFcn = type
            %<SLibAccessArgHelper(rootSystem.Interface.RTMArgDef,"","")>
        %endif
        %break
      %case "Disable"
      %case "Enable"
      %case "ModelInitialize"
      %case "Terminate"
        %assign ::BlockFcn = type
        %break
      %default
        %assign errTxt = "Unknown type: %<type>"
        %<LibReportFatalError(errTxt)>
    %endswitch

    %with rootSystem.Interface
        %assign deref = calledFromERTMain && !(UsingMalloc && ...
            (::CompiledModel.RootIOFormat == "Part of model data structure")) ? "&" : ""
        %assign addTypeCast = WHITE_SPACE(deref)
        %if SLibUseBackwardCompatibleReusableInterface()
            %if !reqInsts.SimStructInst && FcnArgNeeded(RTMArgDef,...
                rootSystem.CurrentTID,isRateGrouping) && !GenerateClassInterface
                %if isCallSite
                    %assign recArgs = recArgs + "%<::tSimStruct>"
                %else
                    %assign recArgs = recArgs + "%<::tSimStructType> *const %<::tSimStruct>"
                %endif
            %endif
            %if !reqInsts.ParamsInst && FcnArgNeeded(ParameterArgDef,...
                rootSystem.CurrentTID,isRateGrouping) && !GenerateClassInterface
                %if isCallSite
                    %assign recArgs = recArgs + "%<deref>%<SLibGetParametersStruct(addTypeCast)>"
                %else
                    %assign recArgs = recArgs + "%<::tParametersType> *%<SLibGetParametersStruct(0)>"
                %endif
            %endif
            %if !reqInsts.BlockIOInst && FcnArgNeeded(BlockIOArgDef,...
                rootSystem.CurrentTID,isRateGrouping) && !GenerateClassInterface
                %if isCallSite
                    %assign recArgs = recArgs + "%<deref>%<SLibGetBlockIOStruct(addTypeCast)>"
                %else
                    %assign recArgs = recArgs + "%<::tBlockIOType> *%<SLibGetBlockIOStruct(0)>"
                %endif
            %endif
            %if !reqInsts.DworkInst && FcnArgNeeded(DWorkArgDef,...
                rootSystem.CurrentTID,isRateGrouping) && !GenerateClassInterface
                %if isCallSite
                    %assign recArgs = recArgs + "%<deref>%<SLibGetDWorkStruct(addTypeCast)>"
                %else
                    %assign recArgs = recArgs + "%<::tDWorkType> *%<SLibGetDWorkStruct(0)>"
                %endif
            %endif
            %if !reqInsts.ContStatesInst && FcnArgNeeded(ContStatesArgDef,...
                rootSystem.CurrentTID,isRateGrouping) && !GenerateClassInterface
                %if isCallSite
                    %assign recArgs = recArgs + "%<deref>%<SLibGetContinuousStateStruct(addTypeCast)>"
                %else
                    %assign recArgs = recArgs + "%<::tContStateType> *%<SLibGetContinuousStateStruct(0)>"
                %endif
            %endif
            %if !reqInsts.PrevZCStatesInst && FcnArgNeeded(ZCEventArgDef,...
                rootSystem.CurrentTID,isRateGrouping) && !GenerateClassInterface
                %if isCallSite
                    %assign recArgs = recArgs + "%<deref>%<SLibGetPreviousZCStruct(addTypeCast)>"
                %else
                    %assign recArgs = recArgs + "%<::tPrevZCStateType> *%<SLibGetPreviousZCStruct(0)>"
                %endif
            %endif
        %endif
        %if !reqInsts.ExtInpsInst && !LibExternalInputsStructIsEmpty() && ...
            !GenerateClassInterface && !SLibFcnProtoCtrlActive()
            %if ::CompiledModel.RootIOFormat == "Structure reference"
                %if SLibExtIOStructArgNeeded("Input",rootSystem.CurrentTID,isRateGrouping)
                    %if isCallSite
                        %assign recArgs = recArgs + "%<deref>%<SLibGetExternalInputStruct(addTypeCast,isCallSite,TLC_FALSE)>"
                    %else
                        %assign recArgs = recArgs + "%<::tInputType> *%<SLibGetExternalInputStruct(0,isCallSite,TLC_FALSE)>"
                    %endif
                %endif
            %elseif ::CompiledModel.RootIOFormat == "Individual arguments"
                %foreach idx = ExternalInputs.NumExternalInputs
                    %assign extInp = ExternalInputs.ExternalInput[idx]
                    %assign id = LibGetRecordIdentifier(extInp)
                    %with extInp
                        %if extInp.StorageClass != "Auto" || ...
                            !FcnArgNeeded(extInp,rootSystem.CurrentTID,isRateGrouping)
                            %continue
                        %endif
                        %assign passByRef = PassExtInpByRef(extInp)
                        %if isCallSite
                            %assign addressOf = passByRef ? deref : ""
                            %assign needTypecast = WHITE_SPACE(addressOf) &&  WHITE_SPACE(UQualifier) &&  WHITE_SPACE(id)
                            %assign recArgs = recArgs + "%<addressOf>%<SLibGetExternalInputStruct(needTypecast,isCallSite,TLC_FALSE)>%<UQualifier>%<id>"
                        %else
                            %assign optStar = passByRef ? "*" : ""
                            %assign dataType  = SLibGetRecordDataTypeName(extInp, "")
                            %if !ISEMPTY(dataType) && SLibGetEnableFileControlForEntryPointFcns()
                                %assign stepFcnHeaderFile = GetEntryPointFcnMappedFile("OutputFcn", "Header", tid)
                                %<SLibUpdateLocalSymbolTableForFile(stepFcnHeaderFile, dataType)>\
                            %endif
                            %if LibGetRecordSymbolicWidth(extInp) != "1"
                                %assign recArgs = recArgs + "%<dataType> %<SLibGetExternalInputStruct(0,isCallSite,TLC_FALSE)>%<UQualifier>%<id>[%<LibGetRecordSymbolicWidth(extInp)>]"
                            %else
                                %assign recArgs = recArgs + "%<dataType> %<optStar>%<SLibGetExternalInputStruct(0,isCallSite,TLC_FALSE)>%<UQualifier>%<id>"
                            %endif
                        %endif
                    %endwith
                %endforeach
            %endif
        %endif
        %if !reqInsts.ExtOutputsInst && !LibExternalOutputsStructIsEmpty() && ...
            !GenerateClassInterface && !SLibFcnProtoCtrlActive()
            %if ::CompiledModel.RootIOFormat == "Structure reference"
                %if SLibExtIOStructArgNeeded("Output",rootSystem.CurrentTID,isRateGrouping)
                    %if isCallSite
                        %assign recArgs = recArgs + "%<deref>%<SLibGetExternalOutputStruct(addTypeCast,isCallSite,TLC_FALSE)>"
                    %else
                        %assign recArgs = recArgs + "%<::tOutputType> *%<SLibGetExternalOutputStruct(0,isCallSite,TLC_FALSE)>"
                    %endif
                %endif
            %elseif ::CompiledModel.RootIOFormat == "Individual arguments"
                %foreach idx = ExternalOutputs.NumExternalOutputs
                    %assign extOut       = ExternalOutputs.ExternalOutput[idx]
                    %assign sysIdx       = extOut.Block[0]
                    %assign blkIdx       = extOut.Block[1]
                    %assign outportBlock = System[sysIdx].Block[blkIdx]
                    %if SLibExternalOutputIsVirtual(outportBlock) || ...
                        !FcnArgNeeded(extOut,rootSystem.CurrentTID,isRateGrouping)
                        %continue
                    %endif
                    %assign portWidth = LibGetRecordSymbolicWidth(extOut)
                    %assign dataType  = SLibGetRecordDataTypeName(extOut, "")
                    %assign id = LibGetRecordIdentifier(extOut)
                    %assign pointerOrReference = "*"
                    %if LibCGTypeIsCoderArray(extOut.CGTypeIdx)
                        %assign pointerOrReference = "&"
                        %assign deref = ""
                    %endif
                    %if isCallSite
                        %if portWidth != "1"
                            %assign recArgs = recArgs + "%<SLibGetExternalOutputStruct(0,isCallSite,TLC_FALSE)>%<YQualifier>%<id>"
                        %else
                            %assign recArgs = recArgs + "%<deref>%<SLibGetExternalOutputStruct(addTypeCast,isCallSite,TLC_FALSE)>%<YQualifier>%<id>"
                        %endif
                    %else
                        %if portWidth != "1"
                            %assign recArgs = recArgs + "%<dataType> %<SLibGetExternalOutputStruct(0,isCallSite,TLC_FALSE)>%<YQualifier>%<id>[%<portWidth>]"
                        %else
                            %assign recArgs = recArgs + "%<dataType> %<pointerOrReference>%<SLibGetExternalOutputStruct(0,isCallSite,TLC_FALSE)>%<YQualifier>%<id>"
                        %endif
                    %endif
                %endforeach
            %endif
        %endif

    %endwith

    %assign ::BlockFcn = tmpBlockFcn
    %assign  ::CompiledModel.HasSimStructVars = tmpHasSimStructVars

    %if ISEMPTY(recArgs)
        %if isCallSite
            %return ""
        %else
            %if !GenerateClassInterface
                %return "void"
            %else
                %return ""
            %endif
        %endif
    %endif

    %foreach idx = SIZE(recArgs,1)
        %if idx == 0
            %assign fcnArgs = recArgs[idx]
        %else
            %if !ISEMPTY(recArgs[idx])
                %assign fcnArgs = fcnArgs + ", %<recArgs[idx]>"
            %endif
        %endif
    %endforeach
    %return fcnArgs
%endfunction

%function FcnGetStdVectorResizeBufferHelper(cgTypeIdx, varName, nIter) void
    %if !LibCGTypeContainsStdContainer(cgTypeIdx)
        %return ""
    %endif

    %assign buffer = ""
    %openfile buffer

    %if LibCGTypeIsMatrix(cgTypeIdx)
        %assign baseCGTIdx = LibCGTypeBaseIndex(cgTypeIdx)
        %if LibCGTypeContainsStdContainer(baseCGTIdx)
            %assign iter = "Iter_%<nIter>"
            for (size_t %<iter> = 0; %<iter> < %<LibCGTypeSymbolicWidth(cgTypeIdx)>; %<iter>++)
            {
                %<FcnGetStdVectorResizeBufferHelper(baseCGTIdx, "%<varName>[%<iter>]", nIter + 1)>
            }
        %endif
    %elseif SLibCGTypeIsStructStrict(cgTypeIdx)
        %foreach idx = LibCGTypeNumMembers(cgTypeIdx)
            %assign mCGTIdx = LibCGTypeMemberCGTypeIdx(cgTypeIdx, idx)
            %assign accessName = varName + "." + LibCGTypeMemberName(cgTypeIdx, idx)
            %if LibCGTypeIsStdContainer(mCGTIdx)
                %assign width = LibCGTypeSymbolicWidth(mCGTIdx)
                %<accessName>.resize(%<width>);
                %<FcnGetStdVectorResizeBufferHelper(mCGTIdx, "%<accessName>", nIter)>
            %elseif SLibCGTypeIsStructStrict(mCGTIdx)
                %<FcnGetStdVectorResizeBufferHelper(mCGTIdx, "%<accessName>", nIter)>
            %endif
        %endforeach
    %endif

    %closefile buffer
    %return buffer
%endfunction

%function FcnCacheStdVectorResizeBuffer(cgTypeIdx, argName) void
    %if !GenerateClassInterface || SLibIsMatrixUsingStdArray()
        %return
    %endif

    %assign buffer = FcnGetStdVectorResizeBufferHelper(cgTypeIdx, argName, 1)

    %if ISEMPTY(buffer) || WHITE_SPACE(buffer)
        %return
    %endif

    %if !ISFIELD(::CompiledModel, "CachedFPCVarsStdVectorResizeBuffer")
        %<LibAddToCompiledModel("CachedFPCVarsStdVectorResizeBuffer", "")>
    %endif

    %assign ::CompiledModel.CachedFPCVarsStdVectorResizeBuffer = ...
        ::CompiledModel.CachedFPCVarsStdVectorResizeBuffer + buffer
%endfunction

%function SLibDeclareFcnProtoCtlVariables() void
    %openfile tmpFcnBuf
    %if SLibFcnProtoCtrlActive()
        %%customized function prototype generated. Need global variables.
        /* Global variables used by function prototype control */
        %assign fcnData = FcnGetFunctionPrototypeRecord()
        %with fcnData
            %foreach idx = NumArgSpecData
                %assign spec = ArgSpecData[idx]

                %if spec.Category == "None" || spec.SLObjectType == "Outport"
                    %continue
                %endif

                %assign staticFlag = "static "
                %assign extInp    = ExternalInputs.ExternalInput[spec.PortNum]
                %assign dTypeId   = LibGetRecordDataTypeId(extInp)
                %assign dataType  = LibGetRecordOptStdDataTypeName(extInp, "", TLC_TRUE)
                %assign ground = "%<LibGetGroundInitFromId(dTypeId)>"

                %%define ground if necessary (e.g., init returns the ground name, but it is not)
                %%yet defined
                %if (::CompiledModel.DataTypes.DataType[dTypeId].GroundName == ground && !ISFIELD(::definedGroundNames, ground))
                    %<LibDumpGroundDeclarations(1)>
                %endif

                %if LibGetRecordIsComplex(extInp)
                    %assign ground = "{" + ground + ", " + ground + "}"
                %endif
                %assign portWidth = LibGetRecordSymbolicWidth(extInp)
                %assign argName = spec.ArgName

                %assign cgTypeIdx = SLibGetRecordContainerCGTypeIdx(extInp)
                %assign hasInit = TLC_TRUE

                %if portWidth != "1"
                    %assign isStdContainer = LibGetRecordIsStdContainer(extInp)
                    %if LibGetRecordWidth(extInp) > 1
                        %% we generate initializer for external inports with static known size
                        %assign initializer = " = {"
                        %% add an additional {} around std container, this is required when the base type is struct or complex type
                        %if isStdContainer
                            %assign initializer = initializer + " {"
                        %endif
                        %foreach idx = LibGetRecordWidth(extInp) - 1
                            %assign initializer = initializer + ground + ", "
                        %endforeach
                        %assign initializer = initializer + ground + "}"
                        %if isStdContainer
                            %assign initializer = initializer + " }"
                        %endif
                    %else
                        %% we don't generate initializer if exports inport has symbolic size
                        %assign initializer = ""
                        %if isStdContainer && !SLibIsMatrixUsingStdArray()
                            %% pass size to std::vector constructor
                            %assign initializer = "(" + LibCGTypeSymbolicWidth(cgTypeIdx) + ")"
                        %endif
                        %assign hasInit = TLC_FALSE
                    %endif
                    %if SLibAutosarCompilerAbstractionRequired()
                        %if isStdContainer
                            %assign definition = ...
                                "%<staticFlag>%<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, dataType, TLC_FALSE, TLC_FALSE, "%<argName>", "DataGlobal")>%<initializer>;"
                        %else
                            %assign definition = ...
                                "%<staticFlag>%<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, dataType, TLC_FALSE, TLC_FALSE, "%<argName>[%<portWidth>]", "DataGlobal")>%<initializer>;"
                        %endif
                    %else
                        %if isStdContainer
                            %assign definition = ...
                                "%<staticFlag>%<dataType> %<argName>%<initializer>;"
                        %else
                            %assign definition = ...
                                "%<staticFlag>%<dataType> %<argName>[%<portWidth>]%<initializer>;"
                        %endif
                    %endif
                    %assign definition = LibGetCppBracedInitStr(definition)
                    %<DeclareFcnProtoCtrlInportVariableComments(fcnData, idx)>
                    %<SLibApplyMemSecToDataDefn(definition, ...
                        "MemSecDataInputs", "%<LibGetExternalInputStruct()>")> \
                %else
                    %if NumContStates > 0 && spec.Category == "Pointer"
                        %if SLibAutosarCompilerAbstractionRequired()
                            %assign definition = ...
                                "%<staticFlag>%<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, dataType, TLC_FALSE, TLC_FALSE, "local_%<argName>", "DataGlobal")> = %<ground>;"
                        %else
                            %assign definition = ...
                                "%<staticFlag>%<dataType> local_%<argName> = %<ground>;"
                        %endif
                        %assign definition = LibGetCppBracedInitStr(definition)
                        %<DeclareFcnProtoCtrlInportVariableComments(fcnData, idx)>
                        %<SLibApplyMemSecToDataDefn(definition, ...
                            "MemSecDataInputs", "%<LibGetExternalInputStruct()>")> \

                        %if SLibAutosarCompilerAbstractionRequired()
                            %assign definition = ...
                                "%<staticFlag>%<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, dataType, TLC_TRUE, TLC_FALSE, argName, "DataGlobal")> = &local_%<argName>;"
                        %else
                            %assign definition = ...
                                "%<staticFlag>%<dataType> * %<argName> = &local_%<argName>;"
                        %endif
                        %assign definition = LibGetCppBracedInitStr(definition)
                        %<SLibApplyMemSecToDataDefn(definition, ...
                            "MemSecDataInputs", "%<LibGetExternalInputStruct()>")> \
                    %else
                        %if SLibAutosarCompilerAbstractionRequired()
                            %assign definition = ...
                                "%<staticFlag>%<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, dataType, TLC_FALSE, TLC_FALSE, argName, "DataGlobal")> = %<ground>;"
                        %else
                            %assign definition = ...
                                "%<staticFlag>%<dataType> %<argName> = %<ground>;"
                        %endif
                        %assign definition = LibGetCppBracedInitStr(definition)
                        %<DeclareFcnProtoCtrlInportVariableComments(fcnData, idx)>
                        %<SLibApplyMemSecToDataDefn(definition, ...
                            "MemSecDataInputs", "%<LibGetExternalInputStruct()>")> \
                    %endif
                %endif

                %% special handling for std::vector memory allocaiton
                %if !hasInit
                    %<FcnCacheStdVectorResizeBuffer(cgTypeIdx, "%<argName>")>
                %endif
            %endforeach %% NumArgSpecData
        %endwith %%fcnData

        %with fcnData
            %foreach idx = NumArgSpecData
                %assign spec = ArgSpecData[idx]

                %if spec.Category == "None" || spec.SLObjectType == "Inport" || ...
                    GetTheOtherReusableArgInFPC(fcnData, idx) >= 0
                    %continue
                %endif

                %assign staticFlag = "static "
                %assign extOut       = ExternalOutputs.ExternalOutput[spec.PortNum]
                %assign portWidth    = LibGetRecordSymbolicWidth(extOut)
                %assign dataType     = LibGetRecordOptStdDataTypeName(extOut, "", TLC_TRUE)
                %assign sysIdx       = extOut.Block[0]
                %assign blkIdx       = extOut.Block[1]
                %assign outportBlock = System[sysIdx].Block[blkIdx]
                %assign argName = spec.ArgName

                %assign cgTypeIdx = SLibGetRecordContainerCGTypeIdx(extOut)

                %if portWidth != "1"
                    %assign isStdContainer = LibGetRecordIsStdContainer(extOut)
                    %assign constrStr = ""
                    %if isStdContainer && !SLibIsMatrixUsingStdArray()
                        %% pass size to std::vector constructor
                        %assign constrStr = "(" + LibCGTypeSymbolicWidth(cgTypeIdx) + ")"
                    %endif
                    %if SLibAutosarCompilerAbstractionRequired()
                        %if isStdContainer
                            %assign definition = "%<staticFlag>%<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, dataType, TLC_FALSE, TLC_FALSE, "%<argName>%<constrStr>", "DataGlobal")>;"
                        %else
                            %assign definition = "%<staticFlag>%<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, dataType, TLC_FALSE, TLC_FALSE, "%<argName>[%<portWidth>]", "DataGlobal")>;"
                        %endif
                        /* '%<outportBlock.Name>' */
                    %else
                        %if isStdContainer
                            %assign definition = "%<staticFlag>%<dataType> " ...
                                "%<argName>%<constrStr>;"
                        %else
                            %assign definition = "%<staticFlag>%<dataType> " ...
                                "%<argName>[%<portWidth>];"
                        %endif
                        /* '%<outportBlock.Name>' */
                    %endif
                    %<SLibApplyMemSecToDataDefn(definition, "MemSecDataOutputs", ...
                        "%<LibGetExternalOutputStruct()>")> \
                %else
                    %if NumContStates > 0 && spec.Category == "Pointer"
                        %if SLibAutosarCompilerAbstractionRequired()
                            %assign definition = "%<staticFlag>%<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, dataType, TLC_FALSE, TLC_FALSE, "local_%<argName>", "DataGlobal")>;"
                            /* '%<outportBlock.Name>' */
                        %else
                            %assign definition = "%<staticFlag>%<dataType> local_%<argName>;"
                            /* '%<outportBlock.Name>' */
                        %endif
                        %<SLibApplyMemSecToDataDefn(definition, "MemSecDataOutputs", ...
                            "%<LibGetExternalOutputStruct()>")> \
                        %if SLibAutosarCompilerAbstractionRequired()
                            %assign definition = "%<staticFlag>%<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, dataType, TLC_TRUE, TLC_FALSE, argName, "DataGlobal")> = &local_%<argName>;"
                        %else
                            %assign definition = "%<staticFlag>%<dataType> * %<argName> = &local_%<argName>;"
                        %endif
                        %<SLibApplyMemSecToDataDefn(definition, "MemSecDataOutputs", ...
                            "%<LibGetExternalOutputStruct()>")> \
                    %else
                        %if SLibAutosarCompilerAbstractionRequired()
                            %assign definition = "%<staticFlag>%<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, dataType, TLC_FALSE, TLC_FALSE, argName, "DataGlobal")>;"
                            /* '%<outportBlock.Name>' */
                        %else
                            %assign definition = "%<staticFlag>%<dataType> %<argName>;"
                            /* '%<outportBlock.Name>' */
                        %endif
                        %<SLibApplyMemSecToDataDefn(definition, "MemSecDataOutputs", ...
                            "%<LibGetExternalOutputStruct()>")> \
                    %endif
                %endif

                %% special handling for std::vector memory allocation
                %<FcnCacheStdVectorResizeBuffer(cgTypeIdx, "%<argName>")>
            %endforeach %%NumArgSpecData
        %endwith %%fcnData
    %endif
    %closefile tmpFcnBuf

    %return tmpFcnBuf
%endfunction

%% Keep this function for backward compatibility. Since the variable declared is not always global,
%% The function is renamed to SLibDeclareFcnProtoCtlVariables(). However, since the function is
%% used by down stream target teams, the old function continues to work to maintain backward compatibility.
%function SLibDeclareFcnProtoCtlGlobalVariables() void
    %return SLibDeclareFcnProtoCtlVariables()
%endfunction


%function SLibDeclareGlobalVariablesForCPPClass() void
    %if GenerateClassInterface
        %assign classConfObj = FcnGetRTWCPPStepPrototypeRecord()
        %assign namespaceStr = ""
        %assign serviceVarsStr = ""
        %if ::NamespaceName != ""
            %assign namespaceStr = "%<NamespaceName>::"
        %endif

        %assign rootSystem = System[GetBaseSystemIdx()]
        %assign rootModule = ::CompiledModel.RTWCGModules.RTWCGModule[rootSystem.CGIRModuleIdx]
        %assign fcnIdx = ISFIELD(rootModule,"SystemFunctionTypes") && ISFIELD(rootModule.SystemFunctionTypes,"ModelConstructor") ...
            ? GETFIELD(rootModule.SystemFunctionTypes,"ModelConstructor") : -1
        %assign ctorArgs = ""
        %if fcnIdx > -1
            %assign fcnParams = ""
            %assign constrFcn = rootModule.Function[fcnIdx]
            %assign comma = ""
            %foreach argIdx = constrFcn.NumArgs
                %if 0 == constrFcn.ArgAccessed[argIdx]
                    %continue
                %endif
                %assign argName = constrFcn.ArgNames[argIdx]
                %assign addrBuf = " &"

                %assign argType = constrFcn.ArgTypes[argIdx]
                %if argType >= 0
                    %assign argTypeName = SLibGetTypeNameFromCGType(argType)
                    %assign lenArgTypeName = SIZE(argTypeName)[1]
                    %assign argTypeNameLastChar = argTypeName[lenArgTypeName-1]
                    %if argTypeNameLastChar == "&"
                        %assign addrBuf = " "
                    %endif
                %endif
                %assign idnum = IDNUM(constrFcn.ArgSource[argIdx])
                %assign fcnParams = fcnParams + comma + addrBuf + argName
                %assign comma = ","
                %assign tmpServiceBuf = SLibDeclareServicePortGlobalVarForCPPClass(constrFcn, argIdx)
                %if !WHITE_SPACE(tmpServiceBuf)
                    %assign serviceVarsStr = serviceVarsStr + tmpServiceBuf
                %endif
            %endforeach
            %if !WHITE_SPACE(fcnParams)
                %if LibGetUsesCppBracedInit()
                    %assign ctorArgs = "{" + fcnParams + "}"
                %else
                    %assign ctorArgs = "(" + fcnParams + ")"
                %endif
            %endif
        %endif

        %if classConfObj.noArgOnList
            %% GlobalAccess' case requires no
            %% Global variable other than the object, since they
            %% will be class scope fields.

            %openfile tmpFcnBuf
            %if !WHITE_SPACE(serviceVarsStr)
                %<serviceVarsStr>
            %endif

            %if ExtMode && ExtModeXCP
                %% In XCP-based External Mode, in order to be able to access
                %% the model's parameters and signals, the model object needs
                %% to be declared as public
                %assign qualifier = ""
            %else
                %assign qualifier = "static "
            %endif
            %<qualifier>%<namespaceStr>%<CPPClassName> %<CPPObjectName>%<ctorArgs>;  /* Instance of model class */

            %closefile tmpFcnBuf

            %return tmpFcnBuf
        %endif

        %openfile tmpFcnBuf
        %if !WHITE_SPACE(serviceVarsStr)
            %<serviceVarsStr>
        %endif

        %if ExtMode && ExtModeXCP
            %% In XCP-based External Mode, in order to be able to access
            %% the model's parameters and signals, the model object needs
            %% to be declared as public
            %assign qualifier = ""
        %else
            %assign qualifier = "static "
        %endif
        %<qualifier>%<namespaceStr>%<CPPClassName> %<CPPObjectName>%<ctorArgs>;  /* Instance of model class */

        %with classConfObj
            %foreach idx = NumArgSpecData
                %assign spec = ArgSpecData[idx]

                %if spec.Category == "None" || spec.SLObjectType == "Outport"
                    %continue
                %endif

                %assign staticFlag = "static "
                %assign extInp    = ExternalInputs.ExternalInput[spec.PortNum]
                %assign dataType  = LibGetRecordOptStdDataTypeName(extInp, "", TLC_TRUE)
                %assign portWidth = LibGetRecordSymbolicWidth(extInp)
                %assign dTypeId   = LibGetRecordDataTypeId(extInp)
                %assign ground = "%<LibGetGroundInitFromId(dTypeId)>"
                %if LibGetRecordIsComplex(extInp)
                    %assign ground = "{" + ground + ", " + ground + "}"
                %endif

                %% define ground if necessary
                %% e.g., init returns the ground name, but it is not yet defined
                %if (::CompiledModel.DataTypes.DataType[dTypeId].GroundName == ground && ...
                    !ISFIELD(::definedGroundNames, ground))
                    %<LibDumpGroundDeclarations(1)>
                %endif
                %assign argName = spec.ArgName

                %assign cgTypeIdx = SLibGetRecordContainerCGTypeIdx(extInp)
                %assign hasInit = TLC_TRUE

                %if portWidth != "1"
                    %assign isStdContainer = LibGetRecordIsStdContainer(extInp)
                    %if LibGetRecordWidth(extInp) > 1
                        %% we generate initializer for external inports with static known size
                        %assign initializer = " = {"
                        %% add an additional {} around std container, this is required
                        %% when the base type is struct or complex type
                        %if isStdContainer
                            %assign initializer = initializer + " {"
                        %endif
                        %foreach idx = LibGetRecordWidth(extInp) - 1
                            %assign initializer = initializer + ground + ", "
                        %endforeach
                        %assign initializer = initializer + ground + "}"
                        %if isStdContainer
                            %assign initializer = initializer + " }"
                        %endif
                    %else
                        %% we don't generate initializer for external inports with symbolic size
                        %assign initializer = ""
                        %if isStdContainer && !SLibIsMatrixUsingStdArray()
                            %% pass size to std::vector constructor
                            %assign initializer = "(" + LibCGTypeSymbolicWidth(cgTypeIdx) + ")"
                        %endif
                        %assign hasInit = TLC_FALSE
                    %endif
                    %if isStdContainer
                        %assign definition = ...
                            "%<staticFlag>%<dataType> %<argName>%<initializer>;"
                    %else
                        %assign definition = ...
                            "%<staticFlag>%<dataType> %<argName>[%<portWidth>]%<initializer>;"
                    %endif
                    %assign definition = LibGetCppBracedInitStr(definition)
                    %<DeclareFcnProtoCtrlInportVariableComments(classConfObj, idx)>
                    %<SLibApplyMemSecToDataDefn(definition, ...
                        "MemSecDataInputs", "%<LibGetExternalInputStruct()>")> \
                %else
                    %if NumContStates > 0 && spec.Category == "Pointer"
                        %assign definition = ...
                            "%<staticFlag>%<dataType> local_%<argName> = %<ground>;"
                        %assign definition = LibGetCppBracedInitStr(definition)

                        %<DeclareFcnProtoCtrlInportVariableComments(classConfObj, idx)>
                        %<SLibApplyMemSecToDataDefn(definition, ...
                            "MemSecDataInputs", "%<LibGetExternalInputStruct()>")> \

                        %assign definition = ...
                            "%<staticFlag>%<dataType> * %<argName> = &local_%<argName>;"
                        %assign definition = LibGetCppBracedInitStr(definition)

                        %<SLibApplyMemSecToDataDefn(definition, ...
                            "MemSecDataInputs", "%<LibGetExternalInputStruct()>")> \
                    %else
                        %if LibIsStdStringDataType(dTypeId)
                            %assign definition = ...
                                "%<staticFlag>%<dataType> %<argName>;"
                        %else
                            %assign definition = ...
                                "%<staticFlag>%<dataType> %<argName> = %<ground>;"
                        %endif

                        %assign definition = LibGetCppBracedInitStr(definition)
                        %<DeclareFcnProtoCtrlInportVariableComments(classConfObj, idx)>
                        %<SLibApplyMemSecToDataDefn(definition, ...
                            "MemSecDataInputs", "%<LibGetExternalInputStruct()>")> \
                    %endif
                %endif

                %% special handling for std::vector memory allocation
                %if !hasInit
                    %<FcnCacheStdVectorResizeBuffer(cgTypeIdx, "%<argName>")>
                %endif
            %endforeach %% NumArgSpecData
        %endwith %%classConfObj

        %with classConfObj
            %foreach idx = NumArgSpecData
                %assign spec = ArgSpecData[idx]

                %if spec.Category == "None" || spec.SLObjectType == "Inport" || ...
                    GetTheOtherReusableArgInFPC(classConfObj, idx) >= 0
                    %continue
                %endif

                %assign staticFlag = "static "
                %assign extOut       = ExternalOutputs.ExternalOutput[spec.PortNum]
                %assign portWidth    = LibGetRecordSymbolicWidth(extOut)
                %assign dataType     = LibGetRecordOptStdDataTypeName(extOut, "", TLC_TRUE)
                %assign sysIdx       = extOut.Block[0]
                %assign blkIdx       = extOut.Block[1]
                %assign outportBlock = System[sysIdx].Block[blkIdx]
                %assign argName = spec.ArgName
                %assign cgTypeIdx    = SLibGetRecordContainerCGTypeIdx(extOut)

                %if portWidth != "1"
                    %if LibGetRecordIsStdContainer(extOut)
                        %assign constrStr = ""
                        %if !SLibIsMatrixUsingStdArray()
                            %% pass size to std::vector constructor
                            %assign constrStr = "(" + LibCGTypeSymbolicWidth(cgTypeIdx) + ")"
                        %endif
                        %assign definition = "%<staticFlag>%<dataType> " ...
                            "%<argName>%<constrStr>;"
                    %else
                        %assign definition = "%<staticFlag>%<dataType> " ...
                            "%<argName>[%<portWidth>];"
                    %endif

                    /* '%<outportBlock.Name>' */
                    %<SLibApplyMemSecToDataDefn(definition, "MemSecDataOutputs", ...
                        "%<LibGetExternalOutputStruct()>")> \
                %else
                    %if NumContStates > 0 && spec.Category == "Pointer"
                        %assign definition = "%<staticFlag>%<dataType> local_%<argName>;"

                        /* '%<outportBlock.Name>' */
                        %<SLibApplyMemSecToDataDefn(definition, "MemSecDataOutputs", ...
                            "%<LibGetExternalOutputStruct()>")> \
                        %assign definition = "%<staticFlag>%<dataType> * %<argName> = &local_%<argName>;"
                        %assign definition = LibGetCppBracedInitStr(definition)

                        %<SLibApplyMemSecToDataDefn(definition, "MemSecDataOutputs", ...
                            "%<LibGetExternalOutputStruct()>")> \
                    %else
                        %assign definition = "%<staticFlag>%<dataType> %<argName>;"

                        /* '%<outportBlock.Name>' */
                        %<SLibApplyMemSecToDataDefn(definition, "MemSecDataOutputs", ...
                            "%<LibGetExternalOutputStruct()>")> \
                    %endif
                %endif

                %% special handling for std::vector memory allocation
                %<FcnCacheStdVectorResizeBuffer(cgTypeIdx, "%<argName>")>
            %endforeach %%NumArgSpecData
        %endwith %%classConfObj

        %closefile tmpFcnBuf

        %return tmpFcnBuf

    %else
        %return ""
    %endif %%%%%% GenerateClassInterface

%endfunction

%function FcnManageModelArgMemory(dataTypeId, portWidth, mem, action) void
    %openfile buffer
    %% g3039282: dynamic matrix relies on default constructor / destructor
    %if LibDoesDataTypeNeed%<action>or(dataTypeId) && ...
        !LibDataTypeIsDynamicMatrix(dataTypeId)
        %if portWidth != "1"
            for (int idx = 0; idx < %<portWidth>; idx++) {
                %assign mem = mem + "[idx]"
        %endif
        %assign function = "SLibDataType" + action
        %assign result = %<function>("&("+mem+")", dataTypeId)
        %<result>;
        %if portWidth != "1"
        }
        %endif
    %endif
    %closefile buffer
    %return buffer
%endfunction

%function FcnConstructModelArg(dataTypeId, portWidth, mem) void
    %assign buffer = FcnManageModelArgMemory(dataTypeId, portWidth, mem, "Construct")
    %assign ::CompiledModel.ConstructErtModelArgs = ...
        ::CompiledModel.ConstructErtModelArgs + buffer
%endfunction

%function FcnDestructModelArg(dataTypeId, portWidth, mem) void
    %assign buffer = FcnManageModelArgMemory(dataTypeId, portWidth, mem, "Destruct")
    %assign ::CompiledModel.DestructErtModelArgs = ...
        ::CompiledModel.DestructErtModelArgs + buffer
%endfunction

%function SLibDeclareModelFcnArgs(useStatic) void

    %if !MultiInstanceERTCode || (UsingMalloc && ...
        ::CompiledModel.RootIOFormat == "Part of model data structure")
        %return ""
    %endif

    %assign rootSystem = System[NumSystems-1]

    %assign reqInsts = LibGetSystemField(rootSystem, "ReqRootPrmHdrDataInsts")

    %assign static = useStatic ? "static" : ""

    %openfile tmpFcnBuf

    %if !UsingMalloc
        %assign simStructDeclared = TLC_FALSE
        %if !reqInsts.SimStructInst && (!EmptyRealTimeObject || SLibIsSelfUserDefinedAndStructured()) && ...
            !GenerateClassInterface

            %assign definition = ...
                "%<static> %<::tSimStructType> %<::tSimStruct>_;"
            %% SLibAutosarCompilerAbstraction not needed as MultiInstance not supported
            %<SLibApplyMemSecToDataDefn(definition, ...
                "MemSecDataInternal", "%<::tSimStruct>_")>\
            %if MultiInstanceERTCode && !UsingMalloc && !SLibIsExportFcnDiagram() ...
                && !GenerateErtSFunction
                %assign definition = ...
                    "%<static> %<::tSimStructType> *const %<::tSimStructPtr> = " ...
                    "&%<::tSimStruct>_; /* Real-time model */"
            %else
                %assign definition = ...
                    "%<static> %<::tSimStructType> *const %<::tSimStruct> = " ...
                    "&%<::tSimStruct>_; /* Real-time model */"
            %endif
            %assign definition = LibGetCppBracedInitStr(definition)
            %% SLibAutosarCompilerAbstraction not needed as MultiInstance not supported
            %<SLibApplyMemSecToDataDefn(definition, ...
                "MemSecDataConstants", "%<::tSimStruct>")>\
            %assign simStructDeclared = TLC_TRUE
        %endif
        %if !reqInsts.ParamsInst && ...
            !SLibPrmBufferIsEmpty("SimulinkGlobal", "Instance") && ...
            !GenerateClassInterface
            %assign tmpHasSimStructVars = ::CompiledModel.HasSimStructVars
            %assign ::CompiledModel.HasSimStructVars = 0
            %assign equalSign = LibGetDataInitEqualSign()
            %openfile definition
            %<static> %<::tParametersType> %<LibGetParametersStruct()>%<equalSign>{
                %<SLibGetPrmBuffer("SimulinkGlobal", "Instance")>
            }; /* Modifiable parameters */\
            %closefile definition
            %% SLibAutosarCompilerAbstraction not needed as MultiInstance not supported
            %<SLibApplyMemSecToDataDefn(definition, ...
                "MemSecDataParameters", "%<LibGetParametersStruct()>")>\
            %assign ::CompiledModel.HasSimStructVars = tmpHasSimStructVars
        %endif
        %if !reqInsts.BlockIOInst && !LibBlockIOInstanceIsEmpty() && ...
            !GenerateClassInterface && !SLibGetUseRTMcgType()
            %assign definition = ...
                "%<static> %<::tBlockIOType> %<LibGetBlockIOStruct()>; /* Observable signals */"
            %% SLibAutosarCompilerAbstraction not needed as MultiInstance not supported
            %<SLibApplyMemSecToDataDefn(definition, ...
                "MemSecDataInternal", "%<LibGetBlockIOStruct()>")>\
        %endif
        %if !reqInsts.DworkInst && !LibDWorkInstanceIsEmpty() && !GenerateClassInterface && !SLibGetUseRTMcgType()
            %assign definition = ...
                "%<static> %<::tDWorkType> %<LibGetDWorkStruct()>; /* Observable states */"
            %% SLibAutosarCompilerAbstraction not needed as MultiInstance not supported
            %<SLibApplyMemSecToDataDefn(definition, ...
                "MemSecDataInternal", "%<LibGetDWorkStruct()>")>\
        %endif
        %if ::CompiledModel.NumCoderDataGroups > 0
            %%if !GenerateClassInterface
            %% Emit definitions for all exported coder data groups except standalone
            %% Because they are always defined in model.c
            %assign mdlData = simStructDeclared || GenerateClassInterface
            %createrecord groupFilter { \
                Static TLC_TRUE \
                Dynamic TLC_TRUE \
                NoneInit TLC_FALSE \
                AccessStandalone TLC_FALSE \
                AccessInSelf TLC_FALSE \
                AccessInParent TLC_TRUE \
                Exported TLC_TRUE \
                Imported TLC_FALSE \
                SkipModelData mdlData \
                EmitToTestBuffer TLC_FALSE \
            }
            %<SLibDeclareCoderDataGroupInstances(::CompiledModel.System[GetBaseSystemIdx()],static,groupFilter)>\
            %%endif
        %endif
        %if !reqInsts.ContStatesInst && !LibContStatesInstanceIsEmpty() && ...
            !GenerateClassInterface
            %assign definition = ...
                "%<static> %<::tContStateType> %<LibGetContinuousStateStruct()>; " ...
                "/* Observable continuous states */"
            %% SLibAutosarCompilerAbstraction not needed as MultiInstance not supported
            %<SLibApplyMemSecToDataDefn(definition, ...
                "MemSecDataInternal", "%<LibGetContinuousStateStruct()>")>\
        %endif
        %if !reqInsts.ContStatesDisabledInst && !LibContStatesDisabledInstanceIsEmpty() && ...
            !GenerateClassInterface
            %assign definition = ...
                "%<static> %<::tXdisType> %<LibGetContinuousStateDisabledStruct()>; " ...
                "/* Continuous states Disabled */"
            %% SLibAutosarCompilerAbstraction not needed as MultiInstance not supported
            %<SLibApplyMemSecToDataDefn(definition, ...
                "MemSecDataInternal", "%<LibGetContinuousStateDisabledStruct()>")>\
        %endif
        %if !reqInsts.PeriodicContStatesInst && !LibPeriodicContStatesInstanceIsEmpty() && ...
            !GenerateClassInterface
            %assign pstatesInd =  LibGetPeriodicContStateIndices()
            %assign pstatesRng =  LibGetPeriodicContStateRanges()
            %assign defind = "%<static> %<tPeriodicStateIndType> %<pstatesInd>; "
            %assign defrng = "%<static> %<tPeriodicStateRngType> %<pstatesRng>; "
            /* Observable periodic continuous states */
            %% SLibAutosarCompilerAbstraction not needed as MultiInstance not supported
            %<SLibApplyMemSecToDataDefn(defind, "MemSecDataInternal", "%<pstatesInd>")>\
            %<SLibApplyMemSecToDataDefn(defrng, "MemSecDataInternal", "%<pstatesRng>")>\
        %endif
        %if !reqInsts.PrevZCStatesInst && !LibPrevZCStatesInstanceIsEmpty() && ...
            !GenerateClassInterface && !SLibGetUseRTMcgType()
            %assign definition = ...
                "%<static> %<::tPrevZCStateType> %<LibGetPreviousZCStruct()>; " ...
                "/* Triggered events */"
            %% SLibAutosarCompilerAbstraction not needed as MultiInstance not supported
            %<SLibApplyMemSecToDataDefn(definition, ...
                "MemSecDataInternal", "%<LibGetPreviousZCStruct()>")>\
        %endif
    %endif %%!UsingMalloc
    %if !reqInsts.ExtInpsInst && !LibExternalInputsInstanceIsEmpty() &&...
        !GenerateClassInterface
        %if RootIOStructures
            %assign definition = ...
                "%<static> %<::tInputType> %<LibGetExternalInputStruct()>; /* External inputs */"
            %% SLibAutosarCompilerAbstraction not needed as MultiInstance not supported
            %<SLibApplyMemSecToDataDefn(definition, ...
                "MemSecDataInputs", "%<LibGetExternalInputStruct()>")>\
        %elseif SLibHasGlobalExternalInputsWithFPC()
            %% Do nothing
        %else
            %foreach idx = ExternalInputs.NumExternalInputs
                %assign extInp = ExternalInputs.ExternalInput[idx]
                %with extInp
                    %if extInp.StorageClass != "Auto"
                        %continue
                    %endif
                    %assign id = LibGetRecordIdentifier(extInp)
                    %assign qfd_id = "%<LibGetExternalInputStruct()>%<UQualifier>%<id>"
                    %assign portWidth = LibGetRecordSymbolicWidth(extInp)
                    %assign dataType  = SLibGetRecordDataTypeName(extInp, "")
                    %if dataType == "fcn_call"
                        %continue
                    %endif
                    %assign cgType = ::CompiledModel.CGTypes.CGType[extInp.CGTypeIdx]
                    %assign align=""
                    %if !LibCGTypeIsStruct(extInp.CGTypeIdx) && extInp.Alignment > 0
                        %assign align = SLibGetAlignmentSyntax(::CompiledModel.Name, qfd_id, dataType, ...
                            extInp.Alignment, "DATA_ALIGNMENT_GLOBAL_VAR")
                    %endif
                    /* '%<extInp.BlockName>' */
                    %if LibGetRecordSymbolicWidth(extInp) != "1"
                        %assign plainDef = "%<static> %<dataType> %<qfd_id>[%<LibGetRecordSymbolicWidth(extInp)>];"
                    %else
                        %assign plainDef = "%<static> %<align> %<dataType> %<qfd_id>;"
                    %endif
                    %if !ISEMPTY(align)
                        %assign definition = LibGlobalDefinitionWithAlignment(plainDef, "", align)
                    %else
                        %assign definition = plainDef
                    %endif
                    %<SLibApplyMemSecToDataDefn(definition, ...
                        "MemSecDataInputs", "%<LibGetExternalInputStruct()>")> \
                    %% Allocate
                    %assign dataTypeId = LibGetRecordDataTypeId(extInp)
                    %<FcnConstructModelArg(dataTypeId, portWidth, qfd_id)>
                    %<FcnDestructModelArg(dataTypeId, portWidth, qfd_id)>
                %endwith
            %endforeach
        %endif
    %endif
    %if !reqInsts.ExtOutputsInst && !LibExternalOutputsInstanceIsEmpty() && ...
        !GenerateClassInterface
        %if RootIOStructures
            %assign definition = ...
                "%<static> %<::tOutputType> %<LibGetExternalOutputStruct()>; /* External outputs */"
            %% SLibAutosarCompilerAbstraction not needed as MultiInstance not supported
            %<SLibApplyMemSecToDataDefn(definition, ...
                "MemSecDataOutputs", "%<LibGetExternalOutputStruct()>")>\
        %elseif SLibHasGlobalExternalOutputsWithFPC()
            %% Do nothing
        %else
            %foreach idx = ExternalOutputs.NumExternalOutputs
                %assign extOut       = ExternalOutputs.ExternalOutput[idx]
                %assign sysIdx       = extOut.Block[0]
                %assign blkIdx       = extOut.Block[1]
                %assign outportBlock = System[sysIdx].Block[blkIdx]
                %if SLibExternalOutputIsVirtual(outportBlock)
                    %continue
                %endif
                %assign portWidth = LibGetRecordSymbolicWidth(extOut)
                %assign dataType = SLibGetRecordDataTypeName(extOut, "")
                %if dataType == "fcn_call"
                    %continue
                %endif
                %assign id = LibGetRecordIdentifier(extOut)
                %assign qfd_id = "%<LibGetExternalOutputStruct()>%<YQualifier>%<id>"
                %assign cgType = ::CompiledModel.CGTypes.CGType[extOut.CGTypeIdx]
                %assign align=""
                %if !LibCGTypeIsStruct(extOut.CGTypeIdx) && extOut.Alignment > 0
                    %assign align = SLibGetAlignmentSyntax(::CompiledModel.Name, qfd_id, dataType, ...
                        extOut.Alignment, "DATA_ALIGNMENT_GLOBAL_VAR")
                %endif
                /* '%<outportBlock.Name>' */
                %if portWidth != "1"
                    %assign plainDef = "%<static> %<dataType> %<qfd_id>[%<portWidth>];"
                %else
                    %assign plainDef = "%<static> %<align> %<dataType> %<qfd_id>;"
                %endif
                %if !ISEMPTY(align)
                    %assign definition = LibGlobalDefinitionWithAlignment(plainDef, "", align)
                %else
                    %assign definition = plainDef
                %endif
                %<SLibApplyMemSecToDataDefn(definition, ...
                    "MemSecDataOutputs", "%<LibGetExternalOutputStruct()>")> \
                %% Allocate
                %assign dataTypeId = LibGetRecordDataTypeId(extOut)
                %<FcnConstructModelArg(dataTypeId, portWidth, qfd_id)>
                %<FcnDestructModelArg(dataTypeId, portWidth, qfd_id)>
            %endforeach
        %endif
    %endif
    %closefile tmpFcnBuf

    %return tmpFcnBuf

%endfunction %% SLibDeclareModelFcnArgs(useStatic) void

%endif %% _ERT_MODEL_ARG_
