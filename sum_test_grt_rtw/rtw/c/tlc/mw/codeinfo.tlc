%% ============================================================================
%%
%%
%%
%%
%% Abstract:
%%   This file creates the codeInfo MATLAB object and saves it in a MAT file.
%%   The process of creation here means emitting out an MATLAB file which
%%   contains appropriate syntax to create codeInfo object.
%%
%% Copyright 2007-2023 The MathWorks, Inc.
%%

%if EXISTS(::_CIINFO_) == 0
%assign ::_CIINFO_ = 1

%assign rightClickBuildFeature = CGMODEL_ACCESS("CGModel.RightClickBuild")

%include "%<::CompiledModel.Name>_codeIRInfo.tlc"
%include "codeinfolib.tlc"
%% reset state of codeinfolib.tlc which is also used by C API processing
%<SLibResetCodeInfoLib()>
%include "codeinfodatalib.tlc"
%include "codeinfofcnlib.tlc"
%include "codeinfomdlreflib.tlc"
%include "autosarsup.tlc"

%selectfile NULL_FILE
%realformat "CONCISE"

%% Name of the .m function which creates the codeInfo object and saves in .mat
%assign fcnName = "writeCodeInfoFcn"
%assign timingSubfcnName = "getIndexFromTimingInternalId"
%assign iDataSubfcnName = "getInternalDataByName"
%assign iDataSubfcnVariableName = "getInternalDataByVariableName"
%assign nameChkfcnName = "checkDataGraphicalNames"
%assign uniquifyDataInterfaces = "uniquifyDataAccess"

%selectfile NULL_FILE

%%with ::CompiledModel
%% Open file on disk and start writing to it
%openfile ModelCI = "%<fcnName>.m"
%assign comment = "% Autogenerated file: %<::CompiledModel.GeneratedOn>"
%<comment>
function %<fcnName>

%assign componentObj = "codeInfo"
%assign expInportsObj = "expInports"

%assign comment = "% Load a ComponentInterface object from IR"
%<comment>
%<FcnLoadCodeIRInfo()>
%<FcnGetModelArgParamIdxFromIRInfo()>

%if SLibAutosarActive()
    %assign map = FcnGetAutosarDataMap()
    %<componentObj>.Name          = '%<map.ComponentName>';
    %<SLibCreateStaticMemory()>
    %<SLibAddAutosarVarInfo()>
%endif
%%

%% create a data interface writer to code descriptor
%assign buildDir = FEVAL("rtwprivate", "rtwattic", "getBuildDir")

wr = coder.internal.writeDataInterfacesToCodeDescriptor("%<::CompiledModel.Name>",pwd) ;
wr.writeName(%<componentObj>.Name);
%if SLibAutosarCompliant()
    wr.setIsAutosar(true);
%endif
%if IsModelReferenceSimTarget()
    wr.setIsModelRefSimTarget(true);
%endif
%if CGMODEL_ACCESS("CGModel.isCodeGenContextBuild")
    wr.setIsLibraryCodegen(true);
%endif

%<SLibCreateInportInterfaces()>
%%
%<SLibCreateOutportInterfaces()>
%%
skippedParameters = [];
%<SLibCreateParameterInterfaces()>
%%
%<SLibCreateDataStoreInterfaces()>

%<SLibCreateBlockOutputInterfaces()>
%<SLibCreateDWorkInterfaces()>



%%
%if !GenerateClassInterface
    %if !IsModelReferenceTarget()
        %% Create Initialize function interface
        %<SLibCreateModelFunctionInterface(componentObj, "Initialize", "")>
        %%
        %if UsingMalloc
            %% Create Allocation function interface
            %<SLibCreateModelFunctionInterface(componentObj, "Registration", "")>
        %endif
        %%
        %% Create OutputUpdate function interface
        %% case 1: LibIsDeploymentDiagram
        %% case 2: !SLibIsAsyncTaskOnlyModel() || SLibIsExportFcnDiagram()
        %% case 3: AsyncTaskOnly && !SLibIsExportFcnDiagram   ===  negation of case2, i.e. !(!SLibIsAsyncTaskOnlyModel() || SLibIsExportFcnDiagram())
        %%
        %if LibIsDeploymentDiagram() %% case 1: LibIsDeploymentDiagram
            %<SLibDeploymentGenerateCodeInfo(componentObj)>
        %elseif (!SLibIsAsyncTaskOnlyModel() || SLibIsExportFcnDiagram())  %% case 2: !SLibIsAsyncTaskOnlyModel() || SLibIsExportFcnDiagram()
            %if (SLibIsExportFcnDiagram() && SLibAutosarActive())
                %<SLibCreateRunnables(componentObj)>
            %else
                %assign isAsyncExportFcn = SLibIsExportFcnDiagram() && SLibIsAsyncTaskOnlyModel()
                %assign isPeriodicExportFcn = SLibIsExportFcnDiagram() && !SLibIsAsyncTaskOnlyModel()
                %assign isPeriodicRateGrouping = SLibIsMultiRateAndPeriodicRateGrouping(System[NumSystems-1])
                %%
                %assign updateCState  = (NumContStates > 0)
                %if isPeriodicRateGrouping || isAsyncExportFcn %% Rate grouped
                    %%
                    %% Create rate grouped function interfaces
                    %assign maxSampleTime = NumRuntimeExportedRates
                    %if SLibIsExportFcnDiagram()
                        %assign maxSampleTime = NumSampleTimes
                    %endif
                    %foreach tid = maxSampleTime
                        %assign tidIdx = tid
                        %if SLibIsExportFcnDiagram()
                            %% Loop over TIDs backwards for export function diagrams to match
                            %% module generation order in opaquelib.tlc : FcnGenerateCodeFromModule
                            %% Needed to keep fcn index consistent with OutputFunctions array
                            %assign tidIdx = maxSampleTime - tid - 1
                        %endif

                        %if (tidIdx==1) && FixedStepOpts.TID01EQ
                            %continue
                        %endif
                        %if SLibIsExportFcnDiagram()
                            %assign expFcnName = SLibGenExporFunctionName(tidIdx)
                            %if WHITE_SPACE(expFcnName)
                                %% Skip empty function names for export functions
                                %continue
                            %else
                                %assign rootSystem = System[NumSystems-1]
                                %assign thisModule = ::CompiledModel.RTWCGModules.RTWCGModule[rootSystem.CGIRModuleIdx]
                                %if ISFIELD(thisModule, "SystemFunctions") && ...
                                    ISFIELD(thisModule.SystemFunctions, expFcnName)
                                    %assign fcnIndex = GETFIELD(thisModule.SystemFunctions, expFcnName)
                                    %assign thisFcn  = thisModule.Function[fcnIndex]
                                    %if ISFIELD(thisFcn,"IsRateGroupedSLFcn") && thisFcn.IsRateGroupedSLFcn == TLC_TRUE
                                        %% Skip rate grouped Simulink functions. They are handled as model entry
                                        %% point functions elsewhere. Without skipping here, we end up with duplicate
                                        %% functions in PIL.
                                        %continue
                                    %endif
                                %endif
                            %endif
                        %endif
                        %% Skip synchronous sample times for async export function
                        %if isAsyncExportFcn && ...
                            (tidIdx < NumRuntimeExportedRates)
                            %continue
                        %endif
                        %assign tid = tidIdx
                        %if !CombineOutputUpdateFcns && !SLibIsExportFcnDiagram() %% Export function is always treated as combined
                            %assign outString = "Output"
                            %if updateCState
                                %assign updateString = "UpdateContStates"
                            %else
                                %assign updateString = "RootUpdate"
                            %endif
                            %<SLibCreateModelFunctionInterface(componentObj, outString, tid)>
                            %<SLibCreateModelFunctionInterface(componentObj, updateString, tid)>
                        %else
                            %if updateCState
                                %assign outString = "UpdateContStates"
                            %else
                                %assign outString = "OutputUpdate"
                            %endif
                            %<SLibCreateModelFunctionInterface(componentObj, outString, tid)>
                        %endif
                        %assign updateCState = TLC_FALSE
                    %endforeach
                    %if !SLibIsExportFcnDiagram() && !SLibIsAsyncTaskOnlyModel() && !SLibAutosarActive()
                        %foreach tid = NumSampleTimes
                            %if SLibResetOrResetWithInitEventTID(tid)
                                %<SLibCreateModelFunctionInterface(componentObj, "OutputUpdate", tid)>
                            %endif
                        %endforeach
                    %endif
                %elseif !SLibIsExportFcnDiagram() %% Non-rate grouped
                    %%
                    %% Create non-rate grouped function interfaces
                    %%
                    %% Please note that export function models will
                    %% not have a step function generated through this
                    %% branch. They may have one generated by the
                    %% Simulink Function path
                    %if !CombineOutputUpdateFcns
                        %assign outString = "Output"
                        %if updateCState
                            %assign updateString = "UpdateContStates"
                        %else
                            %assign updateString = "RootUpdate"
                        %endif
                        %<SLibCreateModelFunctionInterface(componentObj, outString, "")>
                        %<SLibCreateModelFunctionInterface(componentObj, updateString, "")>
                    %else
                        %if updateCState
                            %assign outString = "UpdateContStates"
                        %else
                            %assign outString = "OutputUpdate"
                        %endif
                        %<SLibCreateModelFunctionInterface(componentObj, outString, "")>
                    %endif
                    %if !SLibAutosarActive()
                        %% Add reset functions to list of output functions vector in
                        %% CodeInfo for the "Non-rate grouped" case. Note that in the
                        %% "Rate grouped" case all TID's are iterated over, which includes
                        %% the reset functions.
                        %foreach tid = NumSampleTimes
                            %if SLibResetOrResetWithInitEventTID(tid)
                                %<SLibCreateModelFunctionInterface(componentObj, "OutputUpdate", tid)>
                            %endif
                        %endforeach
                    %endif
                %endif
            %endif
            %if !SLibAutosarActive()
                %if !SLibIsExportFcnDiagram() %% Export function's info should be handled in the rate grouping code
                    %<AddFunctionCallInputInformation(componentObj)>
                %endif
                %<AddExternalInportMappingInfo(expInportsObj)>
            %else
                %if !SLibIsExportFcnDiagram() && (NumAsynchronousSampleTimes > 0)
                    %<SLibCreateRunnables(componentObj)>
                %endif
            %endif
        %elseif SLibIsAsyncTaskOnlyModel()  && !SLibIsExportFcnDiagram()     %% case 3: AsyncTaskOnly && !SLibIsExportFcnDiagram
            %if SLibAutosarActive()
                %<SLibCreateModelFunctionInterface(componentObj, "OutputUpdate", "")>
                %<SLibCreateRunnables(componentObj)>
            %else
                %<AddFunctionCallInputInformation(componentObj)>
                %<AddExternalInportMappingInfo(expInportsObj)>
            %endif
        %else
            %% Your code should not be here.
            %<LibReportFatalError("Function interface error in codeInfo.")>
        %endif

        %% derivative function
        %if EXISTS(IncludeMdlDerivativeFcn) && IncludeMdlDerivativeFcn == TLC_TRUE
            %<SLibCreateModelFunctionInterface(componentObj, "Derivative", "")>
        %endif

        %if IncludeMdlTerminateFcn
            %<SLibCreateModelFunctionInterface(componentObj, "Terminate", "")>
        %endif
    %else
        %<SLibCreateModelReferenceFunctionInterfaces(componentObj)>
        %<AddExternalInportMappingInfo(expInportsObj)>
    %endif
%else %% GenerateClassInterface
    %if LibIsDeploymentDiagram()
        %<SLibDeploymentGenerateCodeInfo(componentObj)>
    %else
        %if (SLibIsAsyncTaskOnlyModel() && ...
            SLibIsERTTarget() && ...
            !IsModelReferenceRTWTarget())
            %% step functions were removed in TLC so we must remove it from code info as well
            codeInfo.OutputFunctions = [];
        %endif
        %if !IsModelReferenceRTWTarget() && SLibIsExportFcnDiagram()
            %% %<SLibCreateModelFunctionInterface(componentObj, "Initialize", "")>
            %% %if UsingMalloc
            %%   %% Create Allocation function interface
            %%  %<SLibCreateModelFunctionInterface(componentObj, "Registration", "")>
            %% %endif
            tmpArgs         = [];
            tmpActualArgs   = [];
            tmpRet          = coder.types.Argument.empty;
            tmpActualReturn = RTW.DataInterface.empty;
            %<AddFunctionCallInputInformation(componentObj)>
            %<AddExternalInportMappingInfo(expInportsObj)>
        %endif
        %if IsModelReferenceRTWTarget()
            %<SLibCreateModelReferenceFunctionInterfaces(componentObj)>
            %<AddExternalInportMappingInfo(expInportsObj)>
            for i=1 : length(codeInfo.OutputFunctions)
            codeInfo.OutputFunctions(i).Owner = codeInfo.InternalData(1).Implementation;
            end
        %elseif NumRuntimeExportedRates > 1 && SLibIsPeriodicRateGrouping() && !SLibIsExportFcnDiagram() %% multi rate
            fcnVec = [];
            updateFcnVec = [];
            %foreach tid = NumRuntimeExportedRates
                %if (tid==1) && FixedStepOpts.TID01EQ
                    %continue
                %endif
                %%
                %if CombineOutputUpdateFcns
                    %assign outString = "Step"
                %else
                    %assign outString = "Output"
                %endif
                %%
                %assign timeObj = SLibGetRTWTimingObject(tid)
                fcnTemp = codeInfo.OutputFunctions(1);
                tmpImpl = coder.types.Prototype;
                %if CGMODEL_ACCESS("CGModel.isCPPMappingEnabled")
                    %assign stepName = CGMODEL_ACCESS("CGModel.getModelEntryFunctionName", outString, "%<tid>")
                    tmpImpl.Name = "%<stepName>";
                %else
                    tmpImpl.Name = [fcnTemp.Prototype.Name,'%<tid>'];
                %endif

                tmpImpl.HeaderFile = fcnTemp.Prototype.HeaderFile;
                tmpImpl.SourceFile = fcnTemp.Prototype.SourceFile;
                tmpFcn = RTW.FunctionInterface;
                tmpFcn.Prototype = tmpImpl;
                tmpFcn.Timing = %<timeObj>;
                tmpFcn.Owner = fcnTemp.Owner;
                fcnVec = [fcnVec, tmpFcn];

                %if !CombineOutputUpdateFcns
                    tmpUpdateImpl = coder.types.Prototype;
                    %if CGMODEL_ACCESS("CGModel.isCPPMappingEnabled")
                        %assign updateName = CGMODEL_ACCESS("CGModel.getModelEntryFunctionName", "Update", "%<tid>")
                        tmpUpdateImpl.Name = "%<updateName>";
                    %else
                        tmpUpdateImpl.Name = ['update', '%<tid>'];
                    %endif

                    tmpUpdateImpl.HeaderFile = fcnTemp.Prototype.HeaderFile;
                    tmpUpdateImpl.SourceFile = fcnTemp.Prototype.SourceFile;
                    tmpUpdateFcn = RTW.FunctionInterface;
                    tmpUpdateFcn.Prototype = tmpUpdateImpl;
                    tmpUpdateFcn.Timing = %<timeObj>;
                    tmpUpdateFcn.Owner = fcnTemp.Owner;
                    updateFcnVec = [updateFcnVec, tmpUpdateFcn];
                %endif
            %endforeach
            %% depending on the fix of g758487, the wrapper step function may or may not present
            codeInfo.OutputFunctions = fcnVec;
            %if !CombineOutputUpdateFcns
                codeInfo.UpdateFunctions = updateFcnVec;
            %endif
            %<AddFunctionCallInputInformation(componentObj)>
        %elseif !SLibIsExportFcnDiagram() && !CombineOutputUpdateFcns %% SingleTasking update
            tmpUpdateImpl = coder.types.Prototype;
            %if CGMODEL_ACCESS("CGModel.isCPPMappingEnabled")
                %assign updateName = CGMODEL_ACCESS("CGModel.getModelEntryFunctionName", "Update", "")
                tmpUpdateImpl.Name = "%<updateName>";
            %else
                tmpUpdateImpl.Name = 'update';
            %endif
            %assign timeObj = SLibGetRTWTimingObject(0)
            fcnTemp = codeInfo.OutputFunctions(1);
            tmpUpdateImpl.HeaderFile = fcnTemp.Prototype.HeaderFile;
            tmpUpdateImpl.SourceFile = fcnTemp.Prototype.SourceFile;
            tmpUpdateFcn = RTW.FunctionInterface;
            tmpUpdateFcn.Prototype = tmpUpdateImpl;
            tmpUpdateFcn.Timing = %<timeObj>;
            tmpUpdateFcn.Owner = fcnTemp.Owner;
            codeInfo.UpdateFunctions = tmpUpdateFcn;
            %<AddFunctionCallInputInformation(componentObj)>
        %elseif (NumRuntimeExportedRates == 1) && !SLibIsExportFcnDiagram()
            %<AddFunctionCallInputInformation(componentObj)>
        %else
            %%do nothing here
        %endif
        %if !SLibAutosarActive()
            %% Add reset function into output functions vector for non-AUTOSAR
            %% targets, for the GenerateClassInterface case.
            %foreach tid = NumSampleTimes
                %if SLibResetOrResetWithInitEventTID(tid)
                    %<SLibCreateModelFunctionInterface(componentObj, "OutputUpdate", tid)>
                %endif
            %endforeach
        %endif
    %endif
    %<FcnAddRTMFunctionsIfNeeded()>
%endif

%% Add Simulink functions info. For AUTOSAR, the Simulink functions are
%% treated as runnables and added in SLibCreateRunnables.
%if !(IsModelReferenceSimTarget())
    %<AddSimulinkFunctionInfo(componentObj)>
%endif

%% Updates output function interface codeInfo for reused IO arguments
%% in terms of function prototype control
%if GenerateClassInterface || SLibFcnProtoCtrlActive()
    %<UpdateReusableArgsCodeInfoByFPC(componentObj)>
%endif

%assign rtmDI = FcnGetRTMOrSelfDataInterace()
%if !ISEMPTY(rtmDI)
    %% Used below by CoderGroup code
    %assign rtmVarObj = "%<rtmDI>.Implementation"
%endif

%% if the root system has any CoderDataGroups, and the code is reusable
%% then add the required DataGroup info to the InternalData
%if !LibCoderDataGroupStructsAreEmpty() && SLibMultiInstance()


    %% Add CoderDataGroups to CodeInfo InternalData
    %foreach idx = ::CompiledModel.NumCoderDataGroups
        %assign group = ::CompiledModel.CoderDataGroup[idx]
        %assign neededForAutosarPIP = SLibIsAutosarPIPGroupNeededInCodeInfoInternalData(group)

        %assign groupNeeded = neededForAutosarPIP || ...
            SLibIsGroupNeededInCodeInfoInternalData(group)
        %% does the root system have a non-empty VarGroup matching the current group?
        %% is it referenced by rtM/self? is it rtM/self?
        %if groupNeeded
            %assert EXISTS(rtmVarObj) || GenerateClassInterface || FcnHasRTMOrSelf() || ...
                (SLibStandaloneMultiInstanceInTopModel(group) && !SLibStructTypeDefScopeIsImported(group))
            %assign typeObjName = group.Name + "Type"
            %assign typeName = SLibCoderDataGroupType(group)
            %if GenerateClassInterface && SLibIsModelTypesModelClassNamespace() && (group.AsStructure == "InParent" || group.AsStructure == "InSelf")
                %assign typeName = ::CPPClassName + "::" + typeName
            %endif
            %assign groupType = FcnGetInternalTypeObj(typeObjName, typeName, "")
            %assign groupVarId = "rt_" + group.Name
            %assign groupVar = SLibGetCoderDataGroupVariable(group)
            %assign desc = "Storage class " + group.Name
            %if (!SLibAutosarActive() || neededForAutosarPIP) && !GenerateClassInterface && FcnHasRTMOrSelf()
                %% create a RTW.PointerExpression for the group
                %assign groupExpr = ""
                %if group.AsStructure == "InSelf"
                    %assign groupExpr = ...
                        FcnCreateStructRTMMemberObject(groupVarId, SLibCoderDataGroupRTMFieldName(group), ...
                        groupType, rtmVarObj)
                %else
                    %assign groupPtrType = FcnGetPointerTypeObj(groupType, 0, 0)
                    %assign groupExpr = ...
                        FcnCreateRTMMemberObject(groupVarId, SLibCoderDataGroupRTMFieldName(group), ...
                        groupPtrType, rtmVarObj, groupVar)
                %endif
                %assign groupDataObj = ...
                    FcnGetInternalDataObject(groupVarId, "", desc, groupExpr, [])

            %else
                %assign groupdDataObj =  ...
                    FcnGetInternalDataObject(groupVarId, "", desc, groupVar, [])
            %endif
        %endif
    %endforeach
%endif

%% Create DataImplementations for Instance-Specific parameters
%% We do this late because we need to have already populated the
%% CodeInfoMap
%<SLibCreateInstanceSpecificParameterInterfaces()>

%if GenerateClassInterface
    %<SLibCreateModelConstructorActualArgs()>
%endif

%<FcnAddModelRefDWork()>
%<FcnUpdateSubsystemInterfaces()>

if ~isempty(skippedParameters)
wr.removeSkippedParameters(codeInfo.Parameters(skippedParameters));
codeInfo.Parameters(skippedParameters) = [];
end

%% Writing out internal data
%assign internalData = FIELDNAMES(CodeInfoMap.InternalDataMap)
%foreach idx = SIZE(internalData,1)
    %if (idx == 0)
        %<componentObj>.InternalData = [%<componentObj>.InternalData, %<internalData[idx]>];
    %else
        %<componentObj>.InternalData(end+1) = %<internalData[idx]>;
    %endif
    wr.addInternalData(%<internalData[idx]>);
%endforeach

%assign comment = "% Handling Right-Click Builds"
%<comment>
ss = rtwprivate('getSourceSubsystemHandle',codeInfo.GraphicalPath);
%assign comment = "% Check if Rt-Click build, then re-map SIDs"
%<comment>
if ~isempty(ss) && rtwprivate('rtwattic','hasSIDMap')
codeInfo = modifyCodeInfoForSubsystemBuild(ss, codeInfo, wr);
end

wr.writeFunctionInterfaces(%<componentObj>);
wr.writeServerCallPoints(%<componentObj>);

%if GenerateClassInterface
    wr.ConstructorArgumentFixup;
    %<FcnAddModelBlockInstanceVariableName()>
%endif

%if ISFIELD(::CompiledModel, "CodeDescriptorAsyncFunctions")
    %assign fieldNames = FIELDNAMES(::CompiledModel.CodeDescriptorAsyncFunctions)
    %foreach idx = SIZE(fieldNames, 1)
        %assign cur = GETFIELD(::CompiledModel.CodeDescriptorAsyncFunctions,fieldNames[idx])
        wr.addAsyncFunctionInterfaces("%<cur.functionName>", %<cur.taskIndex>, %<cur.priority>);
    %endforeach
%endif

wr.closeRepo();
%if !IsModelReferenceTarget()
    if exist('%<expInportsObj>', 'var')
    save codeInfo.mat %<componentObj> %<expInportsObj>;
    else
    save codeInfo.mat %<componentObj>;
    end
%else
    %assert IsModelReferenceRTWTarget() || (IsModelReferenceSimTarget())
    if exist('%<expInportsObj>', 'var')
    save %<::CompiledModel.Name>_mr_codeInfo.mat %<componentObj> %<expInportsObj>;
    else
    save %<::CompiledModel.Name>_mr_codeInfo.mat %<componentObj>;
    end
%endif
returnVal = 1;

%assign comment = "% End Function"
%<comment>: %<fcnName>

function data = %<uniquifyDataInterfaces>(list)
data = RTW.DataInterface.empty;
for idx=1:numel(list)
if ~isPresentDI(data, list(idx))
data(end+1) = list(idx); %#ok<AGROW>
end
end
%<comment>: %<uniquifyDataInterfaces>

function isPresent = isPresentDI(list, di)
isPresent = false;
for idx = 1:numel(list)
if isequal(list(idx), di)
isPresent = true;
break
end
end

function idx = %<timingSubfcnName>(internalIdVec, internalId)
idx = find(internalIdVec == internalId);
if (isempty(idx) || (length(idx) > 1))
ciMsg = 'Time object cannot be empty';
ciExc = MException('RTW:buildProcess:CodeInfoInternalError',ciMsg);
throw(ciExc);
end
%<comment>: %<timingSubfcnName>

function %<nameChkfcnName>(ciName, rtwName)
if (startsWith(ciName, 'BlockParam:'))
tokens = split(ciName, ':');
ciName = tokens{2};
end
if (strcmp(ciName, rtwName) ~= 1)
ciMsg = ['Name mismatch: ', ciName, ' and ', rtwName];
ciExc = MException('RTW:buildProcess:CodeInfoInternalError',ciMsg);
throw(ciExc);
end
%<comment>: %<nameChkfcnName>

function iData = %<iDataSubfcnName>(iDataVec, iDataName)
iData = RTW.DataInterface.empty;
for idxData = 1:numel(iDataVec)
if strcmp(iDataName, iDataVec(idxData).GraphicalName)
iData(end+1) = iDataVec(idxData);
break
end
end
if (isempty(iData) || (length(iData) > 1))
ciMsg = 'Internal Data object cannot be empty';
ciExc = MException('RTW:buildProcess:CodeInfoInternalError',ciMsg);
throw(ciExc);
end
%<comment>: %<iDataSubfcnName>

function iData = %<iDataSubfcnVariableName>(iDataVec, iDataVariableName)
iData = RTW.DataInterface.empty;
for idxData = 1:numel(iDataVec)
if strcmp(iDataVariableName, iDataVec(idxData).Implementation.VariableName)
iData = iDataVec(idxData);
break
end
end
if isempty(iData)
ciMsg = 'Internal Data object cannot be empty';
ciExc = MException('RTW:buildProcess:CodeInfoInternalError',ciMsg);
throw(ciExc);
end
%<comment>: %<iDataSubfcnVariableName>

function codeInfo = modifyCodeInfoForSubsystemBuild(ss, codeInfo, wr)
%if rightClickBuildFeature==0
    %assign comment = "% Extract Subsystem Build Map from AtticData"
    %<comment>
    Subsystem_Build_Mapping = rtwprivate('rtwattic','getSIDMap');

    %assign comment = "% Parameters"
    %<comment>
    for i = 1:length(codeInfo.Parameters)
    sid = codeInfo.Parameters(i).SID;

    sid = Simulink.ID.getSubsystemBuildSID(sid,ss, Subsystem_Build_Mapping);
    wr.updateSIDForSubsystemBuild("Parameter", i, sid, codeInfo.Parameters(i));
    codeInfo.Parameters(i).SID = sid;
    end

    %assign comment = "% Data Stores"
    %<comment>
    for i = 1:length(codeInfo.DataStores)
    sid = codeInfo.DataStores(i).SID;

    sid = Simulink.ID.getSubsystemBuildSID(sid,ss, Subsystem_Build_Mapping);
    codeInfo.DataStores(i).SID = sid;
    wr.updateSIDForSubsystemBuild("DataStore", i, sid);

    end

    %assign comment = "% Inports"
    %<comment>
    for i = 1:length(codeInfo.Inports)
    sid = codeInfo.Inports(i).SID;

    sid = Simulink.ID.getSubsystemBuildSID(sid,ss, Subsystem_Build_Mapping);
    codeInfo.Inports(i).SID = sid;
    wr.updateSIDForSubsystemBuild("Inport", i, sid);

    end

    %assign comment = "% Outports"
    %<comment>
    for i = 1:length(codeInfo.Outports)
    sid = codeInfo.Outports(i).SID;

    sid = Simulink.ID.getSubsystemBuildSID(sid,ss, Subsystem_Build_Mapping);
    codeInfo.Outports(i).SID = sid;
    wr.updateSIDForSubsystemBuild("Outport", i, sid);

    end
%endif

%closefile ModelCI

%endif  %% _CIINFO_

%% [EOF] codeinfo.tlc
