%% ============================================================================
%%
%%
%%
%%
%%
%% Abstract:
%%      Library of functions for generating codeInfo object and its components.
%%
%% Copyright 1994-2023 The MathWorks, Inc.
%%

%if EXISTS(_CIINFOFCNLIB_) == 0
%assign _CIINFOFCNLIB_ = 1

%include "codeinfolib.tlc"

%selectfile NULL_FILE

%% Function SLibAutosarAddDirectReadWrite
%% Abstract
%%   Generates direct read write information from a runnable.
%%
%function SLibAutosarWriteDirectReadWrite(runnable, outputFcnName) Output
    tmpDirectReads  = [];
    tmpDirectWrites = [];
    %if ISFIELD(runnable, "IOFunction")
        %assign numReadWrites = SIZE(runnable.IOFunction)[1]
        %foreach rwIdx = numReadWrites
            %assign rwRec = runnable.IOFunction[rwIdx]
            %switch (rwRec.Class)
              %case "ImplicitRead"
              %case "ExplicitRead"
              %case "QueuedExplicitRead"
              %case "ImplicitReadErrorStatus"
              %case "ExplicitReadErrorStatus"
              %case "QueuedExplicitReadErrorStatus"
              %case "ExplicitReadIsUpdated"
              %case "BasicSoftwareRead"
              %case "ModeRead"
                temp_inp = %<componentObj>.Inports(%<FcnGetCIIdxFromEIIdx(rwRec.ModelPortIndex)>);
                tmpDirectReads = [tmpDirectReads, temp_inp];
                %break
              %case "ImplicitWrite"
              %case "ImplicitWriteRef"
              %case "ExplicitWrite"
              %case "BasicSoftwareWrite"
              %case "ModeWrite"
                temp_out = %<componentObj>.Outports(%<rwRec.ModelPortIndex>+1);
                tmpDirectWrites = [tmpDirectWrites, temp_out];
                %break
              %case "ImplicitInterrunnableRead"
              %case "ExplicitInterrunnableRead"
                %assign temp_ir = FcnGetInternalDataByVariableName(rwRec.ExtraStr)
                tmpDirectReads = [tmpDirectReads, %<temp_ir>];
                %break
              %case "ImplicitInterrunnableWrite"
              %case "ExplicitInterrunnableWrite"
                %assign temp_ir = FcnGetInternalDataByVariableName(rwRec.ExtraStr)
                tmpDirectWrites = [tmpDirectWrites, %<temp_ir>];
                %break
              %default
                %<LibReportFatalError("CodeInfo internal error: Writing Runnables")>
                %break
            %endswitch
        %endforeach
    %endif
    %assign fcnName = runnable.Symbol
    %assign calibParams = SLibMapCalPrmToRunnables(componentObj, fcnName)
    %assign dsmAccess =  SLibMapDSMToRunnables(componentObj, fcnName)

    tmpDirectReads = [tmpDirectReads, %<calibParams>, %<dsmAccess>];
    tmpDirectWrites = [tmpDirectWrites, %<dsmAccess>];

    %<outputFcnName>.DirectReads  = uniquifyDataAccess(tmpDirectReads);
    %<outputFcnName>.DirectWrites = uniquifyDataAccess(tmpDirectWrites);
%endfunction

%function GetModelFunctionFileInfo(fcnType, tid)
    %switch fcnType
      %case "Initialize"
        %createrecord fileInfo { ...
            fcnType "InitFcn" ...
            fileIndex 0 }
        %break
      %case "Terminate"
        %createrecord fileInfo { ...
            fcnType "TermFcn" ...
            fileIndex 0 }
        %break
      %case "Output"
      %case "OutputUpdate"
        %createrecord fileInfo { ...
            fcnType "OutputFcn" ...
            fileIndex tid }
        %break
      %case "Update"
      %case "RootUpdate"
        %createrecord fileInfo { ...
            fcnType "UpdateFcn" ...
            fileIndex tid }
        %break
      %default
        %createrecord fileInfo { ...
            fcnType "UnknownFcn" ...
            fileIndex 0 }
    %endswitch
    %return fileInfo
%endfunction

%function SLibGetModelFunctionFileByTID(fcnType, tid)
    %if SLibGetEnableFileControlForEntryPointFcns()
        %assign fileInfo = GetModelFunctionFileInfo(fcnType, tid)
        %assign fcnHdrFile = GetEntryPointFcnMappedFile(fileInfo.fcnType, "Header", fileInfo.fileIndex)
        %assign fcnSrcFile = GetEntryPointFcnMappedFile(fileInfo.fcnType, "Source", fileInfo.fileIndex)
    %else
        %assign fcnHdrFile = LibGetMdlPubHdrBaseName() + ".h"
        %assign fcnSrcFile = LibGetMdlSrcBaseName() + "." + ::LangFileExt
    %endif
    %assert !ISEMPTY(fcnHdrFile) && !ISEMPTY(fcnSrcFile)
    %createrecord fcnMappedFile { ...
        hdrFile fcnHdrFile ...
        srcFile fcnSrcFile }
    %return fcnMappedFile
%endfunction

%function SLibGetModelFunctionFileByFcnName(fcnName)
    %if SLibGetEnableFileControlForEntryPointFcns()
        %assign fcnHdrFile = CGMODEL_ACCESS("FileRepository.getHeaderFileForFunctionName", fcnName)
        %assign fcnSrcFile = CGMODEL_ACCESS("FileRepository.getSourceFileForFunctionName", fcnName)
    %else
        %assign fcnHdrFile = LibGetMdlPubHdrBaseName() + ".h"
        %assign fcnSrcFile = LibGetMdlSrcBaseName() + "." + ::LangFileExt
    %endif
    %assert !ISEMPTY(fcnHdrFile) && !ISEMPTY(fcnSrcFile)
    %createrecord fcnMappedFile { ...
        hdrFile fcnHdrFile ...
        srcFile fcnSrcFile }
    %return fcnMappedFile
%endfunction

%% Function SLibCreateModelFunctionInterface =================================
%% Abstract
%%   Create a RTW.FunctionInterface object for a given "tid" and "fcntype"
%%   The process of creation here means emitting out the M-syntax which can
%%   create a M-object in MATLAB.
%%   The M-syntax is
%%      fcnObj = RTW.FunctionInterface
%%
%%   The M-syntax for setting the properties is
%%        fcnObj.Prototype    = prototypeObj
%%        fcnObj.Timing       = timingObj
%%        fcnObj.ActualArgs   = [actArgsVector]
%%        fcnObj.ActualReturn = actReturnObj
%%
%%   Note, all of the properties themselves point to objects.
%%   Some of these objects need to be created (if required) by this function.
%%   For e.g.
%%     - timingObj is created by using the "tid"  argument
%%     - prototypeObj is created using "fcntype" and "tid" arguments
%%     - actualArgsVector/actReturnObj could points to I/O Data. In that case,
%%       the objects would have been created by fcns in codeinfodatalib.tlc
%%     - actualArgsVector/actReturnObj could point to internal data
%%       (BlockI/O, DWork, RTM). These objects will be created by this fcn
%%
%function SLibCreateModelFunctionInterface(component, fcnType, tid) Output
    %%
    %% Initialize vars
    tmpArgs         = [];
    tmpActualArgs   = [];
    tmpRet          = coder.types.Argument.empty;
    tmpActualReturn = RTW.DataInterface.empty;
    %% skip service task tid which is
    %% used for service infrastructure only
    %if !ISEMPTY(tid) && SLibIsServiceTaskTID(tid)
        %return
    %endif
    %%
    %% switch on function type
    %if fcnType == "Registration"
        %assign fcnName = "func_" + "%<::CompiledModel.Name>"
    %elseif SLibResetOrResetWithInitEventTID(tid)
        %assign fcnName = "func_" + "Reset%<tid>"
    %else
        %assign fcnName = "func_" + "%<fcnType>%<tid>"
    %endif
    %switch fcnType
      %case "Registration"
        %break
      %case "Initialize"
        %break
      %case "Output"
      %case "OutputUpdate"
      %case "Update"
      %case "RootUpdate"
      %case "UpdateContStates"
      %case "Derivative"
        %assign tmpBlockFcn = ::BlockFcn
        %assign ::BlockFcn = fcnType

        %assign System[NumSystems-1].CurrentTID = tid

        %if (SLibUseBackwardCompatibleReusableInterface() || !MultiInstanceERTCode) && !SLibResetOrResetWithInitEventTID(tid)
            %% For reusable code with old call interface, the TID argument
            %% is the first argument.
            %% NOTE: For simplified call interface, the TID argument is the second
            %% argument (after RTM argument). This gets generated below in
            %% FcnAddReusableCodeArgs function.
            %<SLibDumpTIDArgument(fcnType, tid, "tmpArgs","tmpActualArgs")>
        %endif
        %assign ::BlockFcn = tmpBlockFcn
        %break
      %case "Terminate"
        %break
      %default
        %assign errTxt = "Unknown fcnType: %<fcnName>"
        %<LibReportFatalError(errTxt)>
    %endswitch

    %if MultiInstanceERTCode && !SLibFcnProtoCtrlActive()
        %<FcnAddReusableCodeArgs(component,fcnType,tid,"tmpArgs","tmpActualArgs")>
        %<FcnAddAllocationReturn(component,fcnType,"tmpRet","tmpActualReturn")>
    %elseif SLibFcnProtoCtrlActive()
        %if MultiInstanceERTCode
            %assert SLibIsSelfStructured()
            %assign rtmObjVar = FcnAddModelDataArg(fcnType, "tmpArgs", "tmpActualArgs")
        %endif

        %% FPC arguments are not carried over to reset functions
        %if ((fcnType == "OutputUpdate") || (fcnType == "UpdateContStates")) && !SLibResetOrResetWithInitEventTID(tid)
            %<FcnAddFPCArgs(component, fcnType,"tmpArgs","tmpActualArgs","tmpRet","tmpActualReturn" )>
        %endif

        %<FcnAddAllocationReturn(component,fcnType,"tmpRet","tmpActualReturn")>
    %else
        %% do nothing
    %endif

    %%
    %% Create a function Prototype with the above arguments
    %<fcnName>_Prototype = coder.types.Prototype;
    %<fcnName>_Prototype.Arguments  = tmpArgs;
    %<fcnName>_Prototype.Return     = tmpRet;

    %% this code here mirrors C++ code in FcnMappedFileRetriever.cpp
    %% for exported output and reset functions, retrieve the file using FcnName because they are not registered using TID
    %% for periodic functions, retrieve the file using TID because they are registered using TID
    %if SLibIsExplicitTaskingExportFcnRateGrouping("OutputUpdate", tid) || SLibResetOrResetWithInitEventTID(tid)
        %assign fcnMappedFile = SLibGetModelFunctionFileByFcnName(SLibGenExporFunctionName(tid))
    %else
        %assign fcnMappedFile = SLibGetModelFunctionFileByTID(fcnType, tid)
    %endif
    %if !SLibAutosarActive()
        %<fcnName>_Prototype.HeaderFile = '%<fcnMappedFile.hdrFile>';
    %endif
    %<fcnName>_Prototype.SourceFile = '%<fcnMappedFile.srcFile>';

    %%
    %% Create a function interface with the above actual arguments
    %<fcnName>_Interface = RTW.FunctionInterface;
    %<fcnName>_Interface.Prototype    = %<fcnName>_Prototype;
    %<fcnName>_Interface.ActualArgs   = tmpActualArgs;
    %<fcnName>_Interface.ActualReturn = tmpActualReturn;
    %if(SLibResetOrResetWithInitEventTID(tid) && ...
        GenerateClassInterface)
        %<fcnName>_Interface.Owner  = %<componentObj>.InternalData(1).Implementation;
    %endif

    %%
    %% Add Name and Timing information
    %assign tidSuffix = "%<System[NumSystems-1].CurrentTID>"
    %assign taskID    = (TYPE(tid) == "Number") ? tid : 0
    %switch fcnType
      %case "Registration"
        %<fcnName>_Prototype.Name = '%<::CompiledModel.Name>';
        %assign timeObj = SLibGetRTWTimingObject("constant")
        %<fcnName>_Interface.Timing = %<timeObj>;
        %<component>.AllocationFunction =  [%<component>.AllocationFunction, %<fcnName>_Interface'];
        %break
      %case "Initialize"
        %<fcnName>_Prototype.Name = '%<GenerateModelInitFcnName()>';
        %assign timeObj = SLibGetRTWTimingObject("constant")
        %<fcnName>_Interface.Timing = %<timeObj>;
        %if SLibAutosarActive()
            %with ::CompiledModel.RTWAutosar.InitRunnables
                %assign tmpOutputFcnName = "%<fcnName>_Interface"
                %assign tmpRunnable = Runnable[0]
                %<SLibAutosarWriteDirectReadWrite(tmpRunnable, tmpOutputFcnName)>
            %endwith
        %endif
        %<component>.InitializeFunctions =  [%<component>.InitializeFunctions, %<fcnName>_Interface'];
        %<fcnName>_Interface.IsInitializeFunction = true;
        %break
      %case "OutputUpdate"
        %if SLibResetOrResetWithInitEventTID(tid)
            %<fcnName>_Prototype.Name = '%<SLibGenExporFunctionName(tid)>';
        %elseif (SLibIsExportFcnDiagram())
            %assign tidSuffix = System[NumSystems-1].CurrentTID
            %assign exportFunctionName = SLibGenExporFunctionName(tidSuffix)
            %if !WHITE_SPACE(exportFunctionName)
                %<fcnName>_Prototype.Name = '%<exportFunctionName>';
                %assign rootSystem = System[NumSystems-1]
                %assign thisModule = ::CompiledModel.RTWCGModules.RTWCGModule[rootSystem.CGIRModuleIdx]
                %assign result = ["", "", "", 1]
                %% For export functions, we need to pass the inline variant condition for that exported entry point
                %% functions for SIL simulations to CodeInfo.
                %% Populate the export Functions FcnTID variant condition from the prototype record.
                %% TopTester: test/toolbox/simulink/variants/var-export-fcns/tExportFcnsWithInlineVariants.m
                %% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tmStateRW_exptFcn_wVarInput_Harness_VC1.m
                %if ISFIELD(thisModule, "SystemFunctions") && ...
                    ISFIELD(thisModule.SystemFunctions, exportFunctionName)
                    %assign fcnIndex = GETFIELD(thisModule.SystemFunctions, exportFunctionName)
                    %assign thisFcn  = thisModule.Function[fcnIndex]
                    %if ISFIELD(thisFcn, "TIDVariantInfo")

                        %assign result[0] = thisFcn.TIDVariantInfo.NetCGVCEPoundIf
                        %assign result[1] = thisFcn.TIDVariantInfo.NetCGVCE
                        %assign result[2] = thisFcn.TIDVariantInfo.EMVCE
                        %assign result[3] = thisFcn.TIDVariantInfo.NetSVCE

                    %endif
                    %if !ISEMPTY(result[0])
                        vInfoObj = RTW.VariantInfo;
                        vInfoObj.NetCGVCEPoundIf = '%<result[0]>';
                        vInfoObj.NetCGVCE = '%<result[1]>';
                        vInfoObj.EMVCE = '%<result[2]>';
                        vInfoObj.NetSVCE = %<result[3]>;
                        %<fcnName>_Interface.VariantInfo = vInfoObj;
                    %endif
                %endif

                %% Add DirectReadWrite info
                %assign baseSystem = ::CompiledModel.System[GetBaseSystemIdx()]

                %foreach fcncallPortGroupIdx = ExternalPortGroups.NumFcnCallPortGroups
                    %assign info = ExternalPortGroups.FcnCallPortGroup[fcncallPortGroupIdx]
                    %assign portGroupTID = info.Tid
                    %if (!WHITE_SPACE(tidSuffix) && portGroupTID == tidSuffix)
                        %assign fcnCallPortGroup = ExternalPortGroups.FcnCallPortGroup[fcncallPortGroupIdx]
                        %<AddFunctionCallDirectReadWriteInfo(baseSystem.Interface, fcnCallPortGroup, component, fcnName, "")>
                        %foreach i = SIZE(info.CallerNames,1)
                            %assign calledFcnName = info.CallerNames[i]
                            %addtorecord CodeInfoMap.ExportFunctionMap %<calledFcnName> { FunctionInterfaceName "%<fcnName>_Interface"}
                        %endforeach
                    %endif
                %endforeach
            %endif
        %else
            %<fcnName>_Prototype.Name = '%<SLibModelStepFcnName(tidSuffix)>';
        %endif
        %assign timeObj = SLibGetRTWTimingObject(taskID)
        %<fcnName>_Interface.Timing = %<timeObj>;

        %if ( SLibAutosarActive() )
            %assign dws = SLibMapDSMToRunnables(component,  SLibModelStepFcnName(tidSuffix))
            %assign calibParams = ...
                SLibMapCalPrmToRunnables(component, SLibModelStepFcnName(tidSuffix))

            %with ::CompiledModel.RTWAutosar.AutosarRunnables
                tmpDirectReads  = [];
                tmpDirectWrites = [];
                %if ISFIELD(Runnable[taskID], "IOFunction")
                    %assign numReadWrites = SIZE(Runnable[taskID].IOFunction)[1]
                    %foreach rwIdx = numReadWrites
                        %assign rwRec = Runnable[taskID].IOFunction[rwIdx]
                        %switch (rwRec.Class)
                          %case "ImplicitRead"
                          %case "ExplicitRead"
                          %case "QueuedExplicitRead"
                          %case "ImplicitReadErrorStatus"
                          %case "ExplicitReadErrorStatus"
                          %case "QueuedExplicitReadErrorStatus"
                          %case "ExplicitReadIsUpdated"
                          %case "BasicSoftwareRead"
                          %case "ModeRead"
                          %case "EndToEndQueuedReceive"
                            temp_inp = %<componentObj>.Inports(%<FcnGetCIIdxFromEIIdx(rwRec.ModelPortIndex)>);
                            tmpDirectReads = [tmpDirectReads, temp_inp];
                            %break
                          %case "ImplicitWrite"
                          %case "ImplicitWriteRef"
                          %case "ExplicitWrite"
                          %case "BasicSoftwareWrite"
                          %case "ModeWrite"
                          %case "EndToEndQueuedSend"
                            temp_out = %<componentObj>.Outports(%<rwRec.ModelPortIndex>+1);
                            tmpDirectWrites = [tmpDirectWrites, temp_out];
                            %break
                          %case "ImplicitInterrunnableRead"
                          %case "ExplicitInterrunnableRead"
                            %assign temp_ir = FcnGetInternalDataByVariableName(rwRec.ExtraStr)
                            tmpDirectReads = [tmpDirectReads, %<temp_ir>];
                            %break
                          %case "ImplicitInterrunnableWrite"
                          %case "ExplicitInterrunnableWrite"
                            %assign temp_ir = FcnGetInternalDataByVariableName(rwRec.ExtraStr)
                            tmpDirectWrites = [tmpDirectWrites, %<temp_ir>];
                            %break
                          %default
                            %<LibReportFatalError("CodeInfo internal error: Writing Runnables")>
                            %break
                        %endswitch
                    %endforeach
                %endif
            %endwith
            tmpDirectReads  = [tmpDirectReads, %<calibParams>, %<dws>];
            tmpDirectWrites = [tmpDirectWrites, %<dws>];
            %<fcnName>_Interface.DirectReads  = tmpDirectReads;
            %<fcnName>_Interface.DirectWrites = tmpDirectWrites;
        %endif
        %<component>.OutputFunctions =  [%<component>.OutputFunctions, %<fcnName>_Interface'];
        %break
      %case "Output"
        %assign timeObj = SLibGetRTWTimingObject(taskID)
        %<fcnName>_Interface.Timing = %<timeObj>;
        %if CGMODEL_ACCESS("CGModel.isModelEntryFunctionPresent","Output")
            %if CGMODEL_ACCESS("CGModel.isIndividualFunctionMappingEnabled")
                %<fcnName>_Prototype.Name = ['%<CGMODEL_ACCESS("CGModel.getModelEntryFunctionName","Output", "%<tidSuffix>")>'];
            %else
                %% Append TID to base name (Needed for Bosch feature flag)
                %<fcnName>_Prototype.Name = ['%<CGMODEL_ACCESS("CGModel.getModelEntryFunctionName","Output", "%<tidSuffix>")>', '%<tidSuffix>'];
            %endif
        %else
            %<fcnName>_Prototype.Name = [%<component>.Name, '_output', '%<tidSuffix>'];
        %endif
        %<component>.OutputFunctions =  [%<component>.OutputFunctions, %<fcnName>_Interface'];
        %break
      %case "Update"
      %case "RootUpdate"
        %assign timeObj = SLibGetRTWTimingObject(taskID)
        %<fcnName>_Interface.Timing = %<timeObj>;
        %if CGMODEL_ACCESS("CGModel.isModelEntryFunctionPresent","Update")
            %if CGMODEL_ACCESS("CGModel.isIndividualFunctionMappingEnabled")
                %<fcnName>_Prototype.Name = ['%<CGMODEL_ACCESS("CGModel.getModelEntryFunctionName","Update", "%<tidSuffix>")>'];
            %else
                %% Append TID to base name (Needed for Bosch feature flag)
                %<fcnName>_Prototype.Name = ['%<CGMODEL_ACCESS("CGModel.getModelEntryFunctionName","Update", "%<tidSuffix>")>', '%<tidSuffix>'];
            %endif
        %else
            %<fcnName>_Prototype.Name = [%<component>.Name, '_update', '%<tidSuffix>'];
        %endif
        %<component>.UpdateFunctions =  [%<component>.UpdateFunctions, %<fcnName>_Interface'];
        %break
      %case "UpdateContStates"
        %assign timeObj = SLibGetRTWTimingObject(taskID)
        %<fcnName>_Interface.Timing = %<timeObj>;
        %if CombineOutputUpdateFcns
            %<fcnName>_Prototype.Name = '%<SLibModelStepFcnName(tidSuffix)>';
            %<component>.OutputFunctions =  [%<component>.OutputFunctions, %<fcnName>_Interface'];
        %else
            %if CGMODEL_ACCESS("CGModel.isModelEntryFunctionPresent","Update")
                %if CGMODEL_ACCESS("CGModel.isIndividualFunctionMappingEnabled")
                    %<fcnName>_Prototype.Name = ['%<CGMODEL_ACCESS("CGModel.getModelEntryFunctionName","Update", "%<tidSuffix>")>'];
                %else
                    %% Append TID to base name (Needed for Bosch feature flag)
                    %<fcnName>_Prototype.Name = ['%<CGMODEL_ACCESS("CGModel.getModelEntryFunctionName","Update", "%<tidSuffix>")>', '%<tidSuffix>'];
                %endif
            %else
                %<fcnName>_Prototype.Name = [%<component>.Name, '_update', '%<tidSuffix>'];
            %endif
            %<component>.UpdateFunctions =  [%<component>.UpdateFunctions, %<fcnName>_Interface'];
        %endif
        %break
      %case "Derivative"
        %assign timeObj = SLibGetRTWTimingObject(taskID)
        %<fcnName>_Interface.Timing = %<timeObj>;
        %<fcnName>_Prototype.Name = [%<component>.Name, '_derivatives', '%<tidSuffix>'];
        %<component>.DerivativeFunction =  [%<fcnName>_Interface'];
        %break
      %case "Terminate"
        %assign timeObj = SLibGetRTWTimingObject("constant")
        %<fcnName>_Interface.Timing = %<timeObj>;
        %if SLibAutosarActive()
            %with ::CompiledModel.RTWAutosar
                %assert(ISFIELD(TerminateRunnables, "Runnable"))
                %assign terminateRunnable = TerminateRunnables.Runnable
                %assert(SIZE(terminateRunnable, 1) == 1)
                %<fcnName>_Prototype.Name = '%<terminateRunnable.Symbol>';
                %assign tmpTermFcnName = "%<fcnName>_Interface"
                %<SLibAutosarWriteDirectReadWrite(terminateRunnable, tmpTermFcnName)>
            %endwith
        %else
            %if CGMODEL_ACCESS("CGModel.isModelEntryFunctionPresent","Terminate")
                %<fcnName>_Prototype.Name = ['%<CGMODEL_ACCESS("CGModel.getModelEntryFunctionName","Terminate", "")>'];
            %else
                %<fcnName>_Prototype.Name = [%<component>.Name, '_terminate'];
            %endif
        %endif
        %<component>.TerminateFunctions =  [%<component>.TerminateFunctions, %<fcnName>_Interface'];
        %break
      %default
        %assign errTxt = "CodeInfo Error: Unknown fcnType: %<fcnType>"
        %<LibReportFatalError(errTxt)>
    %endswitch
%endfunction

%%
%% Function SLibDumpTIDArgument =======================================
%% Abstract
%%   Generate formal parameter and actual argument for TID.
%%   CodeInfo will get updated with this information.
%%
%function SLibDumpTIDArgument(fcnType, tid, tmpArgs, tmpActArgs) Output

    %if (fcnType!="Output" && fcnType!="OutputUpdate" && ...
        fcnType!="Update" && fcnType!="RootUpdate" && fcnType!="UpdateContStates")
        %return
    %endif

    %if LibSystemFcnNeedsTID(System[NumSystems-1], fcnType)
        %% If TID is needed, add it to Arguments
        %assign typeObj = FcnGetIntegerTypeObj(0, 0)
        %assign timeObj = SLibGetRTWTimingObject(0)
        %assign tidName = ::CompiledModel.GlobalScope.tTID
        %% Create a coder.types.Argument object
        %assign tidArg = "TIDArg"
        %<tidArg> = coder.types.Argument;
        %<tidArg>.Type = %<typeObj>;
        %<tidArg>.Name = '%<tidName>';
        %%
        %% Create a RTW.DataInterface object and add it to InternalData
        %if (TYPE(tid) == "Number")
            %assign tidVar = SLibGetRTWLiteralObject(typeObj, tid)
            %assign tidKey = "TID%<tid>"
        %else
            %assign tidVar = SLibGetRTWLiteralObject(typeObj, 0)
            %assign tidKey = "TID"
        %endif
        %assign tidDataObj = FcnGetInternalConstant(tidKey, tidVar)

        %<tmpArgs> = [%<tmpArgs>, %<tidArg>];
        %<tmpActArgs> = [%<tmpActArgs>, %<tidDataObj>];
    %endif

%endfunction

%function FcnAddRTMFunctionsIfNeeded()
    %openfile buffer
    %if NeedRTMInModelClass()
        %assign rtMPtrType = FcnCreateRTMPointerType()
        wr.addGetRTMToModelClass("%<FcnGetGetRTMMethodName()>", %<rtMPtrType>);
        wr.addSetRTMToModelClass("%<FcnGetSetRTMMethodName()>", %<rtMPtrType>);
        wr.addRTMTypeToModelClassElements(%<rtMPtrType>.BaseType, "%<::tSimStruct>");
    %endif
    %closefile buffer
    %return buffer
%endfunction

%function SLibHasAnyAsyncRate(NumSampleTimes)
    %% Only create runnable if there are true Asynchronous rates,
    %% and not just I, R or T rates
    %% This is because NumAsynchronousSampleTimes includes Model Wide Events.
    %assign anyAsyncRates = TLC_FALSE
    %assign maxSampleTime = NumSampleTimes
    %foreach tid = maxSampleTime
        %assign tidIdx = tid
        %if !SLibSynchronousTID(tidIdx) && !SLibModelWideEventTID(tidIdx)
            %% Rate is Asynchronus and Not I, R or T
            %return TLC_TRUE
        %endif
    %endforeach
    %return TLC_FALSE
%endfunction

%%
%% Function SLibCreateRunnables =======================================
%% Abstract
%%   Loop through autosar records and identify runnables and identify.
%%   Create a function record for each runnable.
%%
%function SLibCreateRunnables(component) Output
    %if SLibHasAnyAsyncRate(NumSampleTimes) || SLibIsExportFcnDiagram()
        %% Populate Inports Map for data inports
        %<FcnCreateExportedInports("expInports")>
    %endif

    %with ::CompiledModel.RTWAutosar.AutosarRunnables
        %assign numRunnables = SIZE(Runnable)[1]
        %createrecord RunExpIDMap { }
        %%createrecord RunnableOptimizedMap { }

        %assign maxRootInportIdx = 0
        %foreach runIdx = numRunnables
            %assign mapKey = "runIdx_" + STRING(%<runIdx>)
            %if Runnable[runIdx].IsService == "yes"
                %continue
            %endif
            %assign portIdx = Runnable[runIdx].RootInportIdx
            %if portIdx == -1 && ISEQUAL(Runnable[runIdx].IsReset, "no")
                %continue
            %endif
            %% Use symbol to generate the name of the function in AUTOSAR
            %assign fcnName = Runnable[runIdx].Symbol
            %assign fcnNameMVar  = "Runnable%<runIdx>"
            %<fcnNameMVar>_Prototype = coder.types.Prototype;
            %<fcnNameMVar>_Prototype.Name = '%<fcnName>';
            %assign ModelHeaderFile = LibGetMdlPubHdrBaseName()
            %assign ModelSourceFile = LibGetMdlSrcBaseName()
            %if !SLibAutosarActive()
                %<fcnNameMVar>_Prototype.HeaderFile = ['%<ModelHeaderFile>', '.h'];
            %endif
            %<fcnNameMVar>_Prototype.SourceFile = ['%<ModelSourceFile>', '.%<::LangFileExt>'];

            %%
            %% Create a function interface with the above actual arguments
            %<fcnNameMVar>_Interface = RTW.FunctionInterface;
            %<fcnNameMVar>_Interface.Prototype    = %<fcnNameMVar>_Prototype;

            %% Write direct read and direct writes
            %assign tmpOutputFcnName = "%<fcnNameMVar>_Interface"
            %assign tmpRunnable = Runnable[runIdx]
            %<SLibAutosarWriteDirectReadWrite(tmpRunnable, tmpOutputFcnName)>

            %%
            %if (Runnable[runIdx].TID >= 0)
                %assign timeObj = SLibGetRTWTimingObject(Runnable[runIdx].TID)
                %if %<Runnable[runIdx].SampleTime> == rtInf
                    %<timeObj>.SamplePeriod = Inf;
                %endif
            %else
                %assign timeObj = ...
                    SLibGetRTWTimingObjectFromPeriod(Runnable[runIdx].SampleTime)
            %endif
            %<fcnNameMVar>_Interface.Timing = %<timeObj>;

            %% Write VariantInfo
            %if !ISEMPTY(Runnable[runIdx].NetCGVCE) || !ISEMPTY(Runnable[runIdx].NetSTVCECExpr)
                %<fcnNameMVar>_vInfoObj = RTW.VariantInfo;
                %<fcnNameMVar>_vInfoObj.NetCGVCE = '%<Runnable[runIdx].NetCGVCE>';
                %<fcnNameMVar>_vInfoObj.NetCGVCEPoundIf = '%<Runnable[runIdx].NetCGVCEPoundIf>';
                %<fcnNameMVar>_vInfoObj.NetSVCE = %<Runnable[runIdx].NetSVCE>;
                %<fcnNameMVar>_vInfoObj.EMVCE = '%<Runnable[runIdx].EMVCE>';
                %<fcnNameMVar>_vInfoObj.NetSTVCECExpr = '%<Runnable[runIdx].NetSTVCECExpr>';
                %<fcnNameMVar>_Interface.VariantInfo = %<fcnNameMVar>_vInfoObj;
            %endif

            %<component>.OutputFunctions =  [%<component>.OutputFunctions, %<fcnNameMVar>_Interface'];
            %if portIdx != -1
                fcnIdx = length(%<component>.OutputFunctions);
                %<WriteCurrentExternalInport(portIdx, "fcn_call", "fcnIdx", "", "")>
            %endif
            tmpArgs         = [];
            tmpActArgs   = [];
            %<FcnAddRTEInstanceToAUTOSARRunnable(fcnName, "tmpArgs", "tmpActArgs")>
            %<fcnNameMVar>_Prototype.Arguments = tmpArgs;
            %<fcnNameMVar>_Interface.ActualArgs = tmpActArgs;
        %endforeach
    %endwith
%endfunction

%%
%% Function FcnCreateExportedInports =======================================
%% Abstract
%%   For each external input (corresponding to a data inport), find its port
%%   number and whether it is latched or not. Populate the structure array
%%   with this information.
%%
%function FcnCreateExportedInports(expInportsObj) Output
    %assign comment = "% Initialize Inports Vector for Export Functions"
    %<comment>
    %<expInportsObj> = [];
    %assign comment = "% Populate Inports Map for data inports"
    %<comment>

    %with ::CompiledModel.ExternalInputs
        %assign extDataIdx  = 0
        %assign fcnCallCounter = 0

        %if !SLibAutosarActive()
            %assign isTopMdl = SLibIsExportFcnDiagram()

            %foreach idx = NumExternalInputs
                %assign portIdx = idx + 1
                %assign inport = ExternalInput[idx]
                %if isTopMdl
                    %if (ExternalInput[idx].FunctionCallInitiator == "no")
                        %assign extDataIdx  = extDataIdx + 1
                        %assign portType = "input"
                        %assign counter = extDataIdx
                    %else
                        %assign fcnCallCounter = fcnCallCounter + 1
                        %assign portType = "fcn_call"
                        %% For the top model build, function calls are sorted using port indexes. Therefore, it
                        %% is OK to assign fcnCallCounter's value to the Index field.
                        %assign counter = fcnCallCounter
                    %endif
                    %<WriteCurrentExternalInport(portIdx, portType, counter, "", "")>
                %else
                    %assign extDataIdx  = extDataIdx + 1
                    %assign portIdx = ExternalInput[idx].ExportedId
                    %<WriteCurrentExternalInport(portIdx, "input", extDataIdx, "", "")>
                    %<expInportsObj>(%<portIdx>).IsLatched = true; %% Assume
                    %assign rootSystem = System[NumSystems-1]
                    %foreach id = rootSystem.NumChildSystems
                        %assign sysId = rootSystem.ChildSystems[id][0]
                        %assign system = System[sysId]
                        %if system.Type == "function-call" && system.Exported == "yes" && ...
                            ISFIELD(system, "NonLatchedInputs")
                            %% If external input is a non-latched input, set IsLatched to be false
                            if any(%<idx> == %<system.NonLatchedInputs>)
                            %<expInportsObj>(%<portIdx>).IsLatched = false;
                            end
                        %endif
                    %endforeach
                %endif
                %%
            %endforeach
        %else
            %foreach idx = NumExternalInputs
                %assign portIdx = idx + 1
                %assign inport = ExternalInput[idx]

                %if (ExternalInput[idx].FunctionCallInitiator == "no")
                    %assign extDataIdx  = extDataIdx + 1
                    %assign portType = "input"
                    %assign counter = extDataIdx
                %else
                    %assign fcnCallCounter = fcnCallCounter + 1
                    %assign portType = "fcn_call"
                    %% For the top model build, function calls are sorted using port indexes. Therefore, it
                    %% is OK to assign fcnCallCounter's value to the Index field.
                    %assign counter = fcnCallCounter
                %endif
                %<WriteCurrentExternalInport(portIdx, portType, counter, "", "")>

            %endforeach
        %endif
        %%
    %endwith

%endfunction

%% =====================================================
%% LOCAL HELPER FUNCTIONS BELOW THIS LINE
%% =====================================================
%%
%function FcnAddRTEInstanceToAUTOSARRunnable(fcnName, tmpArgs, tmpActArgs) Output
    %if SLibAutosarActive() && MultiInstanceERTCode
        %% Add Rte_Instance as argument to AUTOSAR runnables
        %assign rteTypeName = "Rte_Instance"
        %assign rteName = FcnGetInstanceHandleName()
        %assign rteType = FcnGetOpaqueTypeObj(rteTypeName, 0, 0)
        %assign rteVarObj  = ...
            SLibGetRTWVariableObject(rteTypeName, rteType, rteName, "", "", "")
        %assign rteDataObj = ...
            FcnGetInternalDataObject(rteTypeName, "", "", rteVarObj, [])

        %%
        %% Create a coder.types.Argument object
        %assign rteArg = "%<fcnName>_RTEArg"
        %<rteArg> = coder.types.Argument;
        %<rteArg>.Type   = %<rteType>;
        %<rteArg>.Name   = '%<rteName>';
        %<rteArg>.IOType = 'INPUT';

        %<tmpArgs>    = [%<tmpArgs>, %<rteArg>];
        %<tmpActArgs> = [%<tmpActArgs>, %<rteDataObj>];
    %endif
%endfunction

%function FcnAddModelDataArg(fcnType, tmpArgs, tmpActArgs) Output
    %assign rtMType    = FcnGetInternalTypeObj(FcnGetRTModelGraphicalName(), ::tSimStructType, "")
    %assign rtMPtrType = 0
    %if UsingMalloc && fcnType == "Terminate"
        %assign rtMPtrType = FcnGetPointerTypeObj(rtMType, 0, 0)
    %else
        %assign rtMPtrType = FcnGetPointerTypeObj(rtMType, 1, 0)
    %endif
    %if SLibAutosarActive()
        %<rtMType>.Name = '%<::CompiledModel.GlobalScope.tSimStructTypeTag>';
    %endif
    %% Create a RTW.DataInterface object and add it to InternalData
    %assign rtmTgtVarObj  = ...
        SLibGetRTWVariableObject(FcnGetRTModelGraphicalName(), rtMType,"%<::tSimStruct>_", "", "", "")
    %assign rtmVarObj  = ...
        SLibGetRTWPointerVariableObject(FcnGetRTModelGraphicalName(), rtMPtrType,"%<::tSimStruct>", rtmTgtVarObj)
    %assign rtmDataObj = ...
        FcnGetInternalDataObject(FcnGetRTModelGraphicalName(), "", FcnGetRTModelGraphicalName(), rtmVarObj, [])
    %% Allocation function never takes RTM as an input argument
    %if !(::SeparateRegistrationFcn && fcnType == "Registration")
        %if !SLibAutosarActive()
            %% AUTOSAR runnables only take Rte_Instance as argument
            %%
            %% Create a coder.types.Argument object
            %assign rtMArg = "%<fcnName>_RTArg"
            %<rtMArg> = coder.types.Argument;
            %<rtMArg>.Type   = %<rtMPtrType>;
            %<rtMArg>.Name   = '%<::tSimStruct>';
            %<rtMArg>.IOType = 'INPUT_OUTPUT';

            %<tmpArgs>    = [%<tmpArgs>, %<rtMArg>];
            %<tmpActArgs> = [%<tmpActArgs>, %<rtmDataObj>];
        %endif
    %endif
    %return rtmVarObj
%endfunction

%function FcnAddReusableCodeArgs(component, fcnType, tid, ...
    tmpArgs, tmpActArgs) Output
    %%
    %% Change ::BlockFcn global variable
    %if ::CompiledModel.SLCI == "on"
        %assign ModelData = "ModelData."
    %else
        %assign ModelData = ""
    %endif
    %assign fcnName = "%<fcnType>%<tid>"
    %if fcnType == "Initialize" && ::SeparateRegistrationFcn
        %assign fcnType = "ModelInitialize"
    %endif
    %switch fcnType
      %case "Registration"
      %case "Initialize"
        %assign ::BlockFcn = "Registration"
        %break
      %case "ModelInitialize"
      %case "Output"
      %case "OutputUpdate"
      %case "RootUpdate"
      %case "Update"
      %case "UpdateContStates"
      %case "Derivative"
      %case "Terminate"
        %assign ::BlockFcn = fcnType
        %break
      %default
        %assign errTxt = "Unknown type: %<type>"
        %<LibReportFatalError(errTxt)>
        %break
    %endswitch
    %%
    %%
    %% Get root system record
    %assign rootSystem  = System[NumSystems-1]
    %%
    %% Get the ReqRootPrmHdrData Instance
    %assign reqInsts = LibGetSystemField(rootSystem, "ReqRootPrmHdrDataInsts")
    %%
    %% Figure out RateGrouping
    %assign isRateGrp = SLibSystemFcnPeriodicRateGrouping(rootSystem, fcnType)
    %%
    %% CurrentTID
    %assign currentTID = rootSystem.CurrentTID
    %%
    %% Figure out other Arguments
    %with rootSystem.Interface

        %if (((SLibUseBackwardCompatibleReusableInterface() || GenerateClassInterface) ...
            && !reqInsts.SimStructInst && ...
            FcnArgNeeded(RTMArgDef, currentTID, isRateGrp)) || ...
            (!SLibUseBackwardCompatibleReusableInterface() && MultiInstanceERTCode)) &&...
            !(GenerateClassInterface && SLibResetOrResetWithInitEventTID(tid))
            %% If RTM is needed, add it to argument
            %assign rtmVarObj = FcnAddModelDataArg(fcnType, tmpArgs, tmpActArgs)

            %if (!SLibUseBackwardCompatibleReusableInterface() && MultiInstanceERTCode ...
                && !GenerateSampleERTMain)
                %% For reusable code with simplified call interface, the TID argument
                %% is the second argument (after RTM argument)
                %<SLibDumpTIDArgument(fcnType, tid, tmpArgs, tmpActArgs)>
            %endif
        %endif
        %if !reqInsts.ParamsInst && FcnArgNeeded(ParameterArgDef, currentTID, isRateGrp) && ...
            !GenerateClassInterface
            %%
            %% Get InternalData from codeIRInfo.mat
            %assign parDataObj = FcnGetInternalDataByName("Parameter")
            %% This is temp solution to handle parameter. Since CGIR write out
            %% SLibGetParamStructPtr as parameter identifier. CodeInfo can't treat
            %% this TLC function call as a var name. The following code overwrite
            %% it by the name of parameter struction (not struct pointer) so that
            %% codeInfo can handle it. Ideally, CGIR should be able to write out
            %% this information correctly.
            if ~isa(%<parDataObj>.Implementation,'RTW.PointerExpression')
            %<parDataObj>.Implementation.Identifier = '%<LibGetParametersStruct()>';
            end
            %%
            %% If RTP is needed, add it to argument
            %assign rtPType    = FcnGetDataInterfaceType(parDataObj)
            %assign rtPPtrType = FcnGetPointerTypeObj(rtPType, 0, 0)
            %%
            %if SLibUseBackwardCompatibleReusableInterface()
                %if !SLibAutosarActive()
                    %% AUTOSAR runnables only take Rte_Instance as argument
                    %%
                    %% Create a coder.types.Argument object
                    %assign rtPArg =  "%<fcnName>_ParArg"
                    %<rtPArg> = coder.types.Argument;
                    %<rtPArg>.Type = %<rtPPtrType>;
                    %<rtPArg>.Name = '%<LibGetParametersStruct()>';
                    %<tmpArgs>    = [%<tmpArgs>, %<rtPArg>];
                    %<tmpActArgs> = [%<tmpActArgs>,; %<parDataObj>];
                %endif
            %else

                if ~isa(%<parDataObj>.Implementation,'RTW.PointerExpression')

                %% Create RTW.PointerExpression corresponding to defaultParam
                %assert EXISTS(rtmVarObj)
                %assign paramPtrExpr = ...
                    FcnCreateRTMMemberObject("rt_Parameter", ModelData + "defaultParam", ...
                    rtPPtrType, rtmVarObj, "%<parDataObj>.Implementation")

                %<parDataObj>.Implementation = %<paramPtrExpr>;
                end

            %endif
        %endif
        %if !reqInsts.BlockIOInst && FcnArgNeeded(BlockIOArgDef,currentTID,isRateGrp) && !SLibIsSelfStructured()
            %% If RTBlockIO is needed, add it to argument
            %assign rtBIOType    = FcnGetInternalTypeObj("BlockIO", ::tBlockIOType, "")
            %if SLibAutosarActive()
                %<rtBIOType>.Name = '%<::CompiledModel.GlobalScope.tBlockIOTypeTag>';
            %endif
            %assign rtBIOPtrType = FcnGetPointerTypeObj(rtBIOType, 0, 0)
            %%
            %% Create a RTW.DataInterface object and add it to InternalData
            %assign bioVar     = ...
                SLibGetRTWVariableObject("rt_BlockIO", rtBIOType, ::tBlockIO, "","","")

            %if SLibUseBackwardCompatibleReusableInterface() || GenerateClassInterface
                %assign bioDataObj =  ...
                    FcnGetInternalDataObject("rt_BlockIO", "", "Block signals", bioVar, [])

                %if !SLibAutosarActive()
                    %% AUTOSAR runnables only take Rte_Instance as argument
                    %%
                    %% Create a coder.types.Argument object
                    %assign rtBArg = "%<fcnName>_BIOArg"
                    %<rtBArg> = coder.types.Argument;
                    %<rtBArg>.Type   = %<rtBIOPtrType>;
                    %<rtBArg>.Name   = '%<LibGetBlockIOStruct()>';
                    %<rtBArg>.IOType = 'INPUT_OUTPUT';
                    %%
                    %<tmpArgs> = [%<tmpArgs>, %<rtBArg>];
                    %<tmpActArgs> = [%<tmpActArgs>, %<bioDataObj>];
                %endif
            %else
                %% Create RTW.PointerExpression corresponding to blockIO
                %assert EXISTS(rtmVarObj)
                %assign blockIOPtrExpr = ...
                    FcnCreateRTMMemberObject("rt_BlockIO", ModelData + "blockIO", ...
                    rtBIOPtrType, rtmVarObj, bioVar)

                %assign bioDataObj =  ...
                    FcnGetInternalDataObject("rt_BlockIO", "", "Block signals", blockIOPtrExpr, [])
            %endif
        %endif
        %if !reqInsts.DworkInst && FcnArgNeeded(DWorkArgDef, currentTID, isRateGrp) && !SLibIsSelfStructured()
            %% If RTDWork is needed, add it to argument
            %assign rtDWType    = FcnGetInternalTypeObj("DWork", ::tDWorkType, "")
            %if SLibAutosarActive()
                %<rtDWType>.Name = '%<::CompiledModel.GlobalScope.tDWorkTypeTag>';
            %endif
            %assign rtDWPtrType = FcnGetPointerTypeObj(rtDWType, 0, 0)
            %%
            %% Create a RTW.DataInterface object and add it to InternalData
            %assign dwVar     = ...
                SLibGetRTWVariableObject("rt_DWork", rtDWType, ::tDWork, "","","")

            %if SLibUseBackwardCompatibleReusableInterface() || GenerateClassInterface
                %assign dwDataObj = ...
                    FcnGetInternalDataObject("rt_DWork", "", "Block states", dwVar, [])

                %if !SLibAutosarActive()
                    %% AUTOSAR runnables only take Rte_Instance as argument
                    %%
                    %% Create a coder.types.Argument object
                    %assign rtDWArg = "%<fcnName>_DWArg"
                    %<rtDWArg> = coder.types.Argument;
                    %<rtDWArg>.Type   = %<rtDWPtrType>;
                    %<rtDWArg>.Name   = '%<LibGetDWorkStruct()>';
                    %<rtDWArg>.IOType = 'INPUT_OUTPUT';
                    %%
                    %<tmpArgs>    = [%<tmpArgs>, %<rtDWArg>];
                    %<tmpActArgs> = [%<tmpActArgs>, %<dwDataObj>];
                %endif
            %else
                %% Create RTW.PointerExpression corresponding to dwork
                %assert EXISTS(rtmVarObj)
                %assign dworkPtrExpr = ...
                    FcnCreateRTMMemberObject("rt_DWork", ModelData + "dwork", ...
                    rtDWPtrType, rtmVarObj, dwVar)

                %assign dwDataObj =  ...
                    FcnGetInternalDataObject("rt_DWork", "", "Block states", dworkPtrExpr, [])
            %endif
        %endif
        %if !reqInsts.ContStatesInst && FcnArgNeeded(ContStatesArgDef,currentTID,isRateGrp)
            %% If Continuous state is needed, add it to argument
            %assign rtCSType    = FcnGetInternalTypeObj("CState", ::tContStateType, "")
            %assign rtCSPtrType = FcnGetPointerTypeObj(rtCSType, 0, 0)
            %%
            %% Create a RTW.DataInterface object and add it to InternalData
            %assign csVar = ...
                SLibGetRTWVariableObject("rt_CState", rtCSType, ::tContState, "", "", "")

            %if SLibUseBackwardCompatibleReusableInterface() || GenerateClassInterface
                %assign csDataObj = ...
                    FcnGetInternalDataObject("rt_CState", "", "Continuous states", csVar, [])
                %if !SLibAutosarActive()
                    %% AUTOSAR runnables only take Rte_Instance as argument
                    %%
                    %% Create a coder.types.Argument object
                    %assign rtCSArg = "%<fcnName>_CSArg"
                    %<rtCSArg> = coder.types.Argument;
                    %<rtCSArg>.Type   = %<rtCSPtrType>;
                    %<rtCSArg>.Name   = '%<LibGetContinuousStateStruct()>';
                    %<rtCSArg>.IOType = 'INPUT_OUTPUT';
                    %%
                    %<tmpArgs>    = [%<tmpArgs>, %<rtCSArg>];
                    %<tmpActArgs> = [%<tmpActArgs>, %<csDataObj>];
                %endif
            %else
                %% Create RTW.PointerExpression corresponding to contStates
                %assert EXISTS(rtmVarObj)
                %assign contStatesPtrExpr = ...
                    FcnCreateRTMMemberObject("rt_CState", ModelData + "contStates", ...
                    rtCSPtrType, rtmVarObj, csVar)

                %assign csDataObj =  ...
                    FcnGetInternalDataObject("rt_CState", "", "Continuous states", contStatesPtrExpr, [])
            %endif
        %endif
        %if !reqInsts.PrevZCStatesInst && FcnArgNeeded(ZCEventArgDef, currentTID,isRateGrp)  && !SLibIsSelfStructured()
            %% If Zero crossing state is needed, add it to argument
            %assign rtPrevZCStateType = FcnGetInternalTypeObj("rt_ZC", ::tPrevZCStateType, "")
            %if SLibAutosarActive()
                %<rtPrevZCStateType>.Name = '%<::CompiledModel.GlobalScope.tPrevZCStateTypeTag>';
            %endif
            %assign rtZCPtrType = FcnGetPointerTypeObj(rtPrevZCStateType, 0, 0)
            %%
            %% Create a RTW.DataInterface object and add it to InternalData
            %assign zcVar = ...
                SLibGetRTWVariableObject("rt_ZC", rtPrevZCStateType, ::tPrevZCState, "","","")

            %if SLibUseBackwardCompatibleReusableInterface() || GenerateClassInterface
                %assign zcDataObj = ...
                    FcnGetInternalDataObject("rt_ZC", "", "Zero crossing states", zcVar, [])
                %if !SLibAutosarActive()
                    %% AUTOSAR runnables only take Rte_Instance as argument
                    %%
                    %% Create a coder.types.Argument object
                    %assign rtZCArg = "%<fcnName>_ZCArg"
                    %<rtZCArg> = coder.types.Argument;
                    %<rtZCArg>.Type   = %<rtZCPtrType>;
                    %<rtZCArg>.Name   = '%<LibGetPreviousZCStruct()>';
                    %<rtZCArg>.IOType = 'INPUT_OUTPUT';
                    %%
                    %<tmpArgs>    = [%<tmpArgs>, %<rtZCArg>];
                    %<tmpActArgs> = [%<tmpActArgs>, %<zcDataObj>];
                %endif
            %else
                %% Create RTW.PointerExpression corresponding to prevZCSigState
                %assert EXISTS(rtmVarObj)
                %assign prevZCSigStatePtrExpr = ...
                    FcnCreateRTMMemberObject("rt_ZC", ModelData + "prevZCSigState", ...
                    rtZCPtrType, rtmVarObj, zcVar)

                %assign zcDataObj = ...
                    FcnGetInternalDataObject("rt_ZC", "", "Zero crossing states", prevZCSigStatePtrExpr, [])
            %endif
        %endif
        %if !reqInsts.ExtInpsInst && !LibExternalInputsStructIsEmpty() && !GenerateClassInterface
            %if ::CompiledModel.RootIOFormat == "Structure reference" || ...
                (::CompiledModel.RootIOFormat == "Part of model data structure")
                %if SLibExtIOStructArgNeeded("Input",currentTID,isRateGrp)
                    %%
                    %% Get InternalData from codeIRInfo.mat
                    %assign eiDataObj = FcnGetInternalDataByName("ExternalInput")
                    %%
                    %% If ExternalInput is needed, add it to argument
                    %assign rtEIType    = FcnGetDataInterfaceType(eiDataObj)
                    %assign rtEIPtrType = FcnGetPointerTypeObj(rtEIType, 0, 0)
                    %%
                    %if ::CompiledModel.RootIOFormat == "Structure reference"
                        %% Create a coder.types.Argument object
                        %assign rtUArg = "%<fcnName>_EIArg"
                        %<rtUArg> = coder.types.Argument;
                        %<rtUArg>.Type = %<rtEIPtrType>;
                        %<rtUArg>.Name = '%<LibGetExternalInputStruct()>';
                        %%
                        %<tmpArgs>    = [%<tmpArgs>, %<rtUArg>];
                        %<tmpActArgs> = [%<tmpActArgs>, %<eiDataObj>];
                    %elseif ::CompiledModel.RootIOFormat == "Part of model data structure"

                        if ~isa(%<eiDataObj>.Implementation,'RTW.PointerExpression')

                        %% Create RTW.PointerExpression corresponding to inputs
                        %assert EXISTS(rtmVarObj)
                        %assign eiPtrExpr = ...
                            FcnCreateRTMMemberObject("rt_ExternalInput", ModelData + "inputs", ...
                            rtEIPtrType, rtmVarObj, "%<eiDataObj>.Implementation")

                        %<eiDataObj>.Implementation = %<eiPtrExpr>;
                        wr.updateInternalData(%<eiPtrExpr>, 'ExternalInput');
                        end

                    %endif
                %endif
            %elseif ::CompiledModel.RootIOFormat == "Individual arguments"
                %% Function call inports are not written to codeIRInfo.mat, but included in ExternalInputs.
                %% Thus need to track the indexing separately.
                %assign idx = -1
                %foreach eiIdx = ExternalInputs.NumExternalInputs
                    %assign ei = ExternalInputs.ExternalInput[eiIdx]
                    %assign idx = idx + 1
                    %with ei
                        %if (ei.StorageClass != "Auto") || ...
                            !FcnArgNeeded(ei,currentTID,isRateGrp)
                            %if SLibGetRecordDataTypeName(ei, "") == "fcn_call"
                                %assign idx = idx - 1
                            %endif
                            %continue
                        %endif
                        %assign id = LibGetRecordIdentifier(ei)
                        %% If this input is needed, add it to argument
                        %assign cgTypeIdx = SLibGetRecordContainerOptStdCGTypeIdx(ei, TLC_TRUE)
                        %assign typeObj = SLibGetCoderCodeTypeObject(cgTypeIdx, 0, 0)
                        %if PassExtInpByRef(ei)
                            %assign typeObj = FcnGetPointerTypeObj(typeObj, 0, 0)
                        %endif
                        %%
                        %% Create a coder.types.Argument object
                        %<fcnName>_EI%<idx>Arg = coder.types.Argument;
                        %<fcnName>_EI%<idx>Arg.Type = %<typeObj>;
                        %<fcnName>_EI%<idx>Arg.Name = '%<LibGetExternalInputStruct()>%<UQualifier>%<id>';
                        %<component>.Inports(%<idx>+1).Implementation.Identifier = '%<LibGetExternalInputStruct()>%<UQualifier>%<id>';
                        %<tmpArgs>    = [%<tmpArgs>, %<fcnName>_EI%<idx>Arg];
                        %<tmpActArgs> = [%<tmpActArgs>, %<component>.Inports(%<idx>+1)];
                        wr.updateInportArg(%<component>.Inports(%<idx>+1), %<idx>+1);
                    %endwith
                %endforeach
            %endif
        %endif
        %if !reqInsts.ExtOutputsInst && !LibExternalOutputsStructIsEmpty() && !GenerateClassInterface
            %if (::CompiledModel.RootIOFormat == "Structure reference" || ...
                ::CompiledModel.RootIOFormat == "Part of model data structure")
                %if SLibExtIOStructArgNeeded("Output",currentTID,isRateGrp)
                    %%
                    %% Get InternalData from codeIRInfo.mat
                    %assign eoDataObj = FcnGetInternalDataByName("ExternalOutput")
                    %%
                    %% If ExternalOutput is needed, add it to argument
                    %%
                    %assign rtEOType    = FcnGetDataInterfaceType(eoDataObj)
                    %assign rtEOPtrType = FcnGetPointerTypeObj(rtEOType, 0, 0)
                    %%
                    %if ::CompiledModel.RootIOFormat == "Structure reference"
                        %% Create a coder.types.Argument object
                        %assign rtYArg = "rtYArg"
                        %<rtYArg> = coder.types.Argument;
                        %<rtYArg>.Type = %<rtEOPtrType>;
                        %<rtYArg>.Name = '%<LibGetExternalOutputStruct()>';
                        %<rtYArg>.IOType = 'OUTPUT';

                        %<tmpArgs>    = [%<tmpArgs>, %<rtYArg>];
                        %<tmpActArgs> = [%<tmpActArgs>, %<eoDataObj>];
                    %elseif ::CompiledModel.RootIOFormat == "Part of model data structure"

                        if ~isa(%<eoDataObj>.Implementation,'RTW.PointerExpression')

                        %% Create RTW.PointerExpression corresponding to outputs
                        %assert EXISTS(rtmVarObj)
                        %assign eoPtrExpr = ...
                            FcnCreateRTMMemberObject("rt_ExternalOutput", ModelData + "outputs", ...
                            rtEOPtrType, rtmVarObj, "%<eoDataObj>.Implementation")

                        %<eoDataObj>.Implementation = %<eoPtrExpr>;
                        wr.updateInternalData(%<eoPtrExpr>, 'ExternalOutput');
                        end

                    %endif
                %endif
            %elseif ::CompiledModel.RootIOFormat == "Individual arguments"
                %foreach idx = ExternalOutputs.NumExternalOutputs
                    %assign eo    = ExternalOutputs.ExternalOutput[idx]
                    %assign eoBlk = ::CompiledModel.System[eo.Block[0]].Block[eo.Block[1]]
                    %if SLibExternalOutputIsVirtual(eoBlk) || ...
                        !FcnArgNeeded(eo,currentTID,isRateGrp)
                        %continue
                    %endif
                    %% If this output is needed, add it to argument
                    %assign cgTypeIdx = SLibGetRecordContainerOptStdCGTypeIdx(eo, TLC_TRUE)
                    %assign typeObj = SLibGetCoderCodeTypeObject(cgTypeIdx, 0, 0)
                    %if PassExtOutpByRef(eo)
                        %assign typeObj = FcnGetPointerTypeObj(typeObj, 0, 0)
                    %endif
                    %%
                    %% Create a coder.types.Argument object
                    %<fcnName>_EO%<idx>Arg = coder.types.Argument;
                    %<fcnName>_EO%<idx>Arg.Type = %<typeObj>;
                    %<fcnName>_EO%<idx>Arg.Name = '%<LibGetExternalOutputStruct()>%<YQualifier>%<LibGetRecordIdentifier(eoBlk)>';
                    %<fcnName>_EO%<idx>Arg.IOType = 'OUTPUT';
                    %<component>.Outports(%<idx>+1).Implementation.Identifier = '%<LibGetExternalOutputStruct()>%<YQualifier>%<LibGetRecordIdentifier(eoBlk)>';

                    %<tmpArgs>    = [%<tmpArgs>, %<fcnName>_EO%<idx>Arg];
                    %<tmpActArgs> = [%<tmpActArgs>, %<component>.Outports(%<idx>+1)];
                    wr.updateOutportArg(%<component>.Outports(%<idx>+1), %<idx>+1);
                %endforeach
            %endif
        %endif
        %<FcnAddRTEInstanceToAUTOSARRunnable(fcnName, tmpArgs, tmpActArgs)>

    %endwith
    %assign ::BlockFcn = "Unknown"
%endfunction

%function FcnAddAllocationReturn(component, fcnType, ...
    tmpRet, tmpActualRet) Output
    %%
    %if !UsingMalloc || (fcnType != "Registration")
        %return
    %endif
    %%
    %assign rtMType    = FcnGetInternalTypeObj(FcnGetRTModelGraphicalName(), ::tSimStructType, "")
    %assign rtMPtrType = FcnGetPointerTypeObj(rtMType, 0, 0)
    %%
    %% Create a coder.types.Argument object
    %assign rtMArg = "%<fcnType>_RTArg"
    %<rtMArg> = coder.types.Argument;
    %<rtMArg>.Type   = %<rtMPtrType>;
    %<rtMArg>.Name   = '%<::tSimStruct>';
    %<rtMArg>.IOType = 'OUTPUT';
    %%
    %% Create a RTW.DataInterface object and add it to InternalData
    %assign rtmTgtVarObj  = ...
        SLibGetRTWVariableObject(FcnGetRTModelGraphicalName(), rtMType,"%<::tSimStruct>_", "", "", "")
    %assign rtmVarObj  = ...
        SLibGetRTWPointerVariableObject(FcnGetRTModelGraphicalName(), rtMPtrType,"%<::tSimStruct>", rtmTgtVarObj)
    %assign rtmDataObj = ...
        FcnGetInternalDataObject(FcnGetRTModelGraphicalName(), "", FcnGetRTModelGraphicalName(), rtmVarObj, [])
    %<tmpRet>    = [%<tmpRet>, %<rtMArg>];
    %<tmpActualRet> = [%<tmpActualRet>, %<rtmDataObj>];

%endfunction


%function FcnAddFPCArgs(component, fcnType, ...
    tmpArgs, tmpActualArgs, tmpRet, tmpActualRet) Output
    %%
    %% Get the FcnClass record
    %assign fcnData = FcnGetFunctionPrototypeRecord()
    %%
    %assign fcnType = "fpcStep"
    %%
    %% Loop over each argument specification
    %with fcnData
        %foreach idx = NumArgSpecData
            %assign spec = ArgSpecData[idx]
            %%
            %assert (spec.Category != "None")
            %%
            %assign isRef   = (spec.Category == "Pointer")
            %assign argName = spec.ArgName
            %assign qualifier = spec.Qualifier
            %%
            %% Figure out "const" qualifier and indirection level
            %if qualifier != "none"
                %if qualifier == "const"
                    %assign arg_const    = 1
                    %assign argPtr_const = 0
                    %assign needPointer  = 0
                %elseif qualifier == "const *"
                    %assign arg_const    = 1
                    %assign argPtr_const = 0
                    %assign needPointer  = 1
                %elseif qualifier == "const * const"
                    %assign arg_const    = 1
                    %assign argPtr_const = 1
                    %assign needPointer  = 1
                %else
                    %<LibReportError("CodeInfo: Fcn Argument Qualifier not supported")>
                %endif
            %else
                %assign arg_const    = 0
                %assign argPtr_const = 0
                %assign needPointer  = isRef
            %endif
            %%
            %% Create either a argument for either inport or outport
            %if spec.SLObjectType == "Inport"
                %assign ei      = ExternalInputs.ExternalInput[spec.PortNum]
                %if (LibCGTypeIsMatrix(ei.CGTypeIdx)) && ...
                    (LibCGTypeWidth(ei.CGTypeIdx)==1)
                    %% This could happen for the case of root inports with a bus object
                    %% data type and port dimensions [1 1]
                    %assign typeObj = SLibGetCoderTypeObject(LibCGTypeBaseIndex(ei.CGTypeIdx), arg_const, 0)
                %else
                    %assign typeObj = SLibGetCoderTypeObject(ei.CGTypeIdx, arg_const, 0)
                %endif
                %if (LibGetRecordWidth(ei) == 1) && needPointer
                    %assign typeObj = FcnGetPointerTypeObj(typeObj, argPtr_const, 0)
                %endif
                %%
                %% Create a coder.types.Argument object
                %<fcnType>_EI%<idx>Arg = coder.types.Argument;
                %<fcnType>_EI%<idx>Arg.Type = %<typeObj>;
                %<fcnType>_EI%<idx>Arg.Name = '%<argName>';

                %<tmpArgs>       = [%<tmpArgs>, %<fcnType>_EI%<idx>Arg];
                %<tmpActualArgs> = [%<tmpActualArgs>, %<component>.Inports(%<spec.PortNum>+1)];
                wr.updateInportArg(%<component>.Inports(%<spec.PortNum>+1),%<spec.PortNum>+1);
                %%
            %elseif spec.SLObjectType == "Outport"
                %% If this output is needed, add it to argument
                %assign eo      = ExternalOutputs.ExternalOutput[spec.PortNum]
                %assign typeObj = SLibGetCoderTypeObject(eo.CGTypeIdx, 0, 0)
                %if (spec.Category != "Value") && (LibCGTypeWidth(eo.CGTypeIdx) == 1)
                    %assign typeObj = FcnGetPointerTypeObj(typeObj, 0, 0)
                %endif
                %%
                %% Create a coder.types.Argument object
                %<fcnType>_EO%<idx>Arg = coder.types.Argument;
                %<fcnType>_EO%<idx>Arg.Type = %<typeObj>;
                %<fcnType>_EO%<idx>Arg.Name = '%<argName>';
                %<fcnType>_EO%<idx>Arg.IOType = 'OUTPUT';
                %if (spec.Category == "Value")

                    %<tmpRet>       = %<fcnType>_EO%<idx>Arg;
                    %<tmpActualRet> = %<component>.Outports(%<spec.PortNum>+1);
                %else

                    %<tmpArgs>       = [%<tmpArgs>, %<fcnType>_EO%<idx>Arg];
                    %<tmpActualArgs> = [%<tmpActualArgs>, %<component>.Outports(%<spec.PortNum>+1)];
                    wr.updateOutportArg(%<component>.Outports(%<spec.PortNum>+1),%<spec.PortNum>+1);
                %endif
                %%
            %else
                %<LibReportFatalError("Should not be here.")>
            %endif
        %endforeach %% NumArgSpecData
    %endwith %%fcnData
%endfunction

%% Function FcnCreateExportFcnInterface =================================
%% Abstract
%%   Create a RTW.FunctionInterface object for a given "systemId" and "fcntype"
%%   The process of creation here means emitting out the M-syntax which can
%%   create a M-object in MATLAB.
%%   The M-syntax is
%%      fcnObj = RTW.FunctionInterface
%%
%%   The M-syntax for setting the properties is
%%        fcnObj.Prototype    = prototypeObj
%%        fcnObj.Timing       = timingObj
%%        fcnObj.ActualArgs   = [actArgsVector]
%%        fcnObj.ActualReturn = actReturnObj
%%
%%   Note, all of the properties themselves point to objects.
%%   Some of these objects need to be created (if required) by this function.
%%   For e.g.
%%     - timingObj is created by using the "systemId"  argument
%%     - prototypeObj is created using "fcntype" and "tid" arguments
%%     - actualArgsVector/actReturnObj could points to I/O Data. In that case,
%%       the objects would have been created by fcns in codeinfodatalib.tlc
%%     - actualArgsVector/actReturnObj could point to internal data
%%       (BlockI/O, DWork, RTM). These objects will be created by this fcn
%%
%function FcnCreateExportFcnInterface(component, fcnType, systemId) Output
    %%
    %% Initialize vars
    tmpArgs         = [];
    tmpActualArgs   = [];
    tmpRet          = coder.types.Argument.empty;
    tmpActualReturn = RTW.DataInterface.empty;
    %% switch on function type
    %switch fcnType
      %case "OutputUpdate"
        %assign fcnName = System[systemId].OutputUpdateFcn
        %break
      %default
        %assign errTxt = "Unknown fcnType: %<fcnType>"
        %<LibReportFatalError(errTxt)>
    %endswitch

    %%
    %% Create a function Prototype with the above arguments
    %<fcnName>_Prototype = coder.types.Prototype;
    %<fcnName>_Prototype.Name = '%<fcnName>';
    %<fcnName>_Prototype.Arguments  = tmpArgs;
    %<fcnName>_Prototype.Return     = tmpRet;
    %assign sysHeaderFile = CGMODEL_ACCESS("CGModel.System.HeaderFileName", systemId)
    %assign sysSrcFile = CGMODEL_ACCESS("CGModel.System.SourceFileName", systemId)
    %if !SLibAutosarActive()
        %<fcnName>_Prototype.HeaderFile = ['%<sysHeaderFile>', '.h'];
    %endif
    %<fcnName>_Prototype.SourceFile = ['%<sysSrcFile>', '.%<::LangFileExt>'];

    %%
    %% Create a function interface with the above actual arguments
    %<fcnName>_Interface = RTW.FunctionInterface;
    %<fcnName>_Interface.Prototype    = %<fcnName>_Prototype;
    %<fcnName>_Interface.ActualArgs   = tmpActualArgs;
    %<fcnName>_Interface.ActualReturn = tmpActualReturn;
    %%
    %% Direct Reads and Direct writes
    %if fcnType == "OutputUpdate"
        %% Child Inports
        %assign system = System[systemId]
        %if ISFIELD(system, "ExternalInputs")
            tmpDirectReads = [];
            %foreach idx = SIZE(system.ExternalInputs, 1)
                %assign eIdx    = system.ExternalInputs[idx] + 1
                temp_inp = %<componentObj>.Inports(%<eIdx>);
                tmpDirectReads = [tmpDirectReads, temp_inp];
            %endforeach
            %<fcnName>_Interface.DirectReads = tmpDirectReads;
        %endif

        %%
        %% ChildOutports
        %if ISFIELD(system, "ExternalOutputs")
            tmpDirectWrites = [];
            %foreach idx = SIZE(system.ExternalOutputs, 1)
                %assign eIdx  = system.ExternalOutputs[idx] + 1
                temp_out = %<componentObj>.Outports(%<eIdx>);
                tmpDirectWrites = [tmpDirectWrites, temp_out];
            %endforeach
            %<fcnName>_Interface.DirectWrites = tmpDirectWrites;
        %endif
    %endif

    %%
    %% Add Name Timing information
    %switch fcnType
      %case "OutputUpdate"
        %assign timeObj = SLibGetRTWTimingObject("inherited")
        %<fcnName>_Interface.Timing = %<timeObj>;
        %<component>.OutputFunctions =  [%<component>.OutputFunctions, %<fcnName>_Interface'];

        %% Populate Inports Map for Fcn-Call ports
        %assign portIdx = System[systemId].ExportedId
        fcnIdx = length(%<component>.OutputFunctions);
        %<WriteCurrentExternalInport(portIdx, "fcn_call", "fcnIdx", "", "")>

        %if !LibSystemFcnIsEmpty(System[systemId],"Enable")
            expInports(%<portIdx>).EnableFcn  = '%<System[systemId].EnableFcn>';
        %endif
        %if !LibSystemFcnIsEmpty(System[systemId],"Disable")
            expInports(%<portIdx>).DisableFcn  = '%<System[systemId].DisableFcn>';
        %endif
        %break
      %case "Enable"
        %assign timeObj = SLibGetRTWTimingObject("constant")
        %<fcnName>_Interface.Timing  = %<timeObj>;
        %<component>.EnableFunction = %<fcnName>_Interface;
        %break
      %case "Disable"
        %assign timeObj = SLibGetRTWTimingObject("constant")
        %<fcnName>_Interface.Timing  = %<timeObj>;
        %<component>.DisableFunction = %<fcnName>_Interface;
        %break
      %default
        %assign errTxt = "CodeInfo Error: Unknown fcnType: %<fcnType>"
        %<LibReportFatalError(errTxt)>
    %endswitch

%endfunction

/%
In terms of FPC, generates two maps named o2IMap and i2OMap
o2IMap maps a reusable inport to its reusable outport
i2OMap maps a reusable outport to its reusable inport
The generated MATLAB code is like this:
fpcInports = {};
fpcReusableOutports = {};
fpcOutports = {};
fpcReusableInports = {};
...
% for each reusable port pair (n, m)
fpcOutports{end+1} = n;
fpcReusableInports{end+1} = m;
fpcInports{end+1} = m;
fpcReusableOutports{end+1} = n;
...
if length(fpcInports) ~= 0
i2OMap = containers.Map(fpcInports,fpcReusableOutports);
else
i2OMap = containers.Map();
end
if length(fpcOutports) ~= 0
o2IMap = containers.Map(fpcOutports,fpcReusableInports);
else
o2IMap = containers.Map();
end
%/
%function CreateReusableFPCIOMap(fpcData, o2IMap, i2OMap) Output
    %assign comment = "% Creates maps between FPC reusable inport/outports%"
    %<comment>
    fpcInports = {};
    fpcReusableOutports = {};
    fpcOutports = {};
    fpcReusableInports = {};
    %assign numArgs = SIZE(fpcData.ArgSpecData, 1)
    %with fpcData
        %foreach argIdx = numArgs
            %assign spec = ArgSpecData[argIdx]
            %if spec.SLObjectType == "Outport" && spec.Category == "Value"
                %continue
            %endif
            %assign reusableIdx = GetTheOtherReusableArgInFPC(fpcData, argIdx)
            %if reusableIdx < 0
                %continue
            %endif
            %assign reusableSpec = ArgSpecData[reusableIdx]
            %if spec.SLObjectType == "Outport"
                fpcOutports{end+1} = %<spec.PortNum>+1;
                fpcReusableInports{end+1} = %<reusableSpec.PortNum>+1;
            %else
                fpcInports{end+1} = %<spec.PortNum>+1;
                fpcReusableOutports{end+1} = %<reusableSpec.PortNum>+1;
            %endif
        %endforeach
    %endwith
    if length(fpcInports) ~= 0
    %<i2OMap> = containers.Map(fpcInports,fpcReusableOutports);
    else
    %<i2OMap> = containers.Map();
    end
    if length(fpcOutports) ~= 0
    %<o2IMap> = containers.Map(fpcOutports,fpcReusableInports);
    else
    %<o2IMap> = containers.Map();
    end
%endfunction

%% Returns the num of arguments in FPC
%function GetNumOfFPCArgs(fpcData)
    %if EXISTS(fpcData.noArgOnList) && fpcData.noArgOnList
        %return 0
    %endif
    %if !EXISTS(fpcData.ArgSpecData)
        %return 0
    %endif
    %return SIZE(fpcData.ArgSpecData, 1)
%endfunction

%% Returns if the FPC has any reusable IO arguments
%function DoesFPCHaveReusableIOs(fpcData)
    %assign numArgs = SIZE(fpcData.ArgSpecData, 1)
    %assign hasReusedIO = TLC_FALSE
    %with fpcData
        %foreach argIdx = numArgs
            %assign spec = ArgSpecData[argIdx]
            %if spec.SLObjectType == "Outport" && spec.Category == "Value"
                %continue
            %endif
            %assign reusableIdx = GetTheOtherReusableArgInFPC(fpcData, argIdx)
            %if reusableIdx < 0
                %continue
            %endif
            %assign hasReusedIO = TLC_TRUE
        %endforeach
    %endwith
    %return hasReusedIO
%endfunction

%% Updates code info by the reusable IO maps between reusable inport/outport
%function UpdateArgsCodeInfoByReusableIOMap(componentObj, o2IMap, i2OMap) Output
    %assign comment = ...
        "% Updates output function interfaces for reused IO arguments%"
    %<comment>
    %%
    %assign comment = "% Loops over each output function%"
    %<comment>
    for ofIdx = 1:length(%<componentObj>.OutputFunctions)
    outputFunction = %<componentObj>.OutputFunctions(ofIdx);
    %% Back-up the old actual and formal arguments
    oldActualArgs = outputFunction.ActualArgs;
    oldArguments = outputFunction.Prototype.Arguments;
    %% * That no actual arguments indicates that this could be a Simulink server
    %%   function. A model step function w/o arguments cannot have FPC. So it is
    %%   fine to ignore the case.
    %% * We assume that a model step function has the same number of actual and
    %%   formal arguments. Do not fix the output function if its actual and
    %%   formal arguments do not match.
    if length(oldActualArgs) == 0 || length(oldActualArgs) ~= length(oldArguments)
    continue;
    end
    %% Initializes the new actual and formal arguments with empty array
    newActualArgs = [];
    newArguments = [];
    %%
    %assign comment = "% Loops over actual arguments%"
    %<comment>
    for argIdx = 1:length(oldActualArgs)
    oldActualArg = oldActualArgs(argIdx);
    oldArgument = oldArguments(argIdx);
    outport = find(oldActualArg == %<componentObj>.Outports);
    if ~isempty(outport)
    if %<o2IMap>.isKey(outport)
    %% Updates the reusable formal output argument with ioType
    %% INPUT_OUTPUT
    newArgument = oldArgument;
    newArgument.IOType ='INPUT_OUTPUT';
    newArguments = [newArguments newArgument];
    %% Copies the reusable actual output argument
    newActualArgs = [newActualArgs oldActualArg];
    %% Makes the reusable input/output part point to the same
    %% implememtation
    reusableInport = %<o2IMap>(outport);
    %<componentObj>.Outports(outport).Implementation = ...
        %<componentObj>.Inports(reusableInport).Implementation;
    wr.updateOutportImplementationForFPC(outport, reusableInport);
    continue;
    end
    end
    inport = find(oldActualArg == %<componentObj>.Inports);
    if ~isempty(inport)
    if %<i2OMap>.isKey(inport)
    %% Ignores reusable input arguments
    continue;
    end
    end
    %% Copies data for other arguments
    newArguments = [newArguments oldArgument];
    newActualArgs = [newActualArgs oldActualArg];
    end %% end of looping actual arguments
    %% Assigns the new actual and formal arguments
    %<componentObj>.OutputFunctions(ofIdx).Prototype.Arguments = newArguments;
    %<componentObj>.OutputFunctions(ofIdx).ActualArgs = newActualArgs;
    end %% end of looping output functions
%endfunction

%% Updates output function interface codeInfo for reused IO arguments
%% in terms of function prototype control
%function UpdateReusableArgsCodeInfoByFPC(componentObj) Output
    %%
    %% Gets the FPC record
    %if !IsModelReferenceTarget()
        %% Gets FPC of reference models
        %if SLibFcnProtoCtrlActive()
            %assign fpcData = FcnGetFunctionPrototypeRecord()
        %elseif GenerateClassInterface
            %assign fpcData = FcnGetRTWCPPStepPrototypeRecord()
        %else
            %% Reaches here if either C or C++ FPC is used
            %return
        %endif
    %elseif GenerateClassInterface || SLibFcnProtoCtrlActive()
        %% Gets FPC of top models
        %assign buildStartDir = FEVAL("rtwprivate","rtwattic","getStartDir")
        %assign mdlInterface = ...
            LoadModelrefInterfaceInMatInfoFile(::CompiledModel.Name, buildStartDir)
        %assign fpcData = mdlInterface.FPC
    %else
        %% Reaches here if a top model has no FPC
        %return
    %endif
    %%
    %% Ignores output functions w/o arguments
    %assign numArgs = GetNumOfFPCArgs(fpcData)
    %if numArgs <= 0
        %return
    %endif
    %%
    %% Do not update code info if the FPC has no reusable IOs
    %if !DoesFPCHaveReusableIOs(fpcData)
        %return
    %endif
    %%
    %% In terms of FPC, generates two maps between reusable inport/outport
    %assign fpcReusableO2IMap = "fpcReusableO2IMap"
    %assign fpcReusableI2OMap = "fpcReusableI2OMap"
    %<CreateReusableFPCIOMap(fpcData, fpcReusableO2IMap, fpcReusableI2OMap)>
    %%
    %% Updates code info by the two maps
    %<UpdateArgsCodeInfoByReusableIOMap(componentObj, ...
        fpcReusableO2IMap, fpcReusableI2OMap)>
%endfunction

%function FcnCheckFunctionForUnusedArugments(subsysBlkSID, moduleIdx, fcn, fcnIndex) Output
    %assign hasSimStruct = TLC_FALSE
    %foreach i = fcn.NumArgs
        %assign isUsed = SLibCG_ArgAccessed(moduleIdx, fcnIndex, i)
        %if !isUsed
            %% Make sure to use M-indexing in the argument index
            wr.removeUnusedArgumentFromSubsystemInterface('%<subsysBlkSID>', '%<fcn.Name>', %<i+1>);
        %elseif fcn.ArgSource[i] == "RTM"
            wr.updateRTMImplementationForSubsystemInterface('%<subsysBlkSID>', '%<fcn.Name>', %<i+1>);
        %endif
    %endforeach
%endfunction

%function FcnRemoveUnusedArgumentsFromSubsystemInterface(system, subsysBlkSID) Output
    %assign module = RTWCGModules.RTWCGModule[system.CGIRModuleIdx]
    %if !ISFIELD(module, "Function") || SIZE(module.Function,1) == 0
        %return
    %endif

    %foreach i = SIZE(module.Function)[1]
        %if !FcnIsSubsystemFunctionUnused(system, module.Function[i])
            %<FcnCheckFunctionForUnusedArugments(subsysBlkSID, system.CGIRModuleIdx, module.Function[i], i)>
        %endif
    %endforeach
%endfunction

%function FcnStripConstVolatileFromTypeName(typeName)
    %assign typeName = REGEXPREP( typeName, "(const | volatile |)", " ")
    %return FEVAL("strtrim",typeName)
%endfunction

%function FcnGetRTMOrSelfTypeName() Output
    %if FcnWillEmitSelf()
        %assign selfIdx = SLibGetSelfCoderDataGroupIndex()
        %assign self = CompiledModel.CoderDataGroup[selfIdx]
        %return SLibCoderDataGroupType(self)
    %else
        %return ::tSimStructType
    %endif
%endfunction

%function FcnCreateRTMPointerType() Output

    %assign rtMType    = FcnGetInternalTypeObj(FcnGetRTModelGraphicalName(), FcnGetRTMOrSelfTypeName(), "")
    %assign rtMPtrType = FcnGetPointerTypeObj(rtMType, 1, 0)
    %if SLibAutosarActive()
        %<rtMType>.Name = '%<::CompiledModel.GlobalScope.tSimStructTypeTag>';
    %endif
    %return rtMPtrType
%endfunction

%function FcnCreateCoderTypeForAddedArgument(typeName, isPointer) Output

    %% The type is just a string, so we need to grep for const and volatile,
    %% and then strip those out and try to find the CGTypeIdx for it
    %assign isConst = FEVAL("contains", typeName, "const ")
    %assign isVolatile = FEVAL("contains", typeName, "volatile ")
    %assign typeName = FcnStripConstVolatileFromTypeName(typeName)

    %if typeName == FcnGetRTMOrSelfTypeName()
        %assert(isPointer)
        %return FcnCreateRTMPointerType()
    %endif

    %% Iterate through the types to find the one with the matching name
    %assign numTypes = ::CompiledModel.CGTypes.NumCGTypes
    %foreach i = numTypes
        %assign curType = ::CompiledModel.CGTypes.CGType[i]
        %if !ISFIELD(curType, "Name")
            %continue
        %endif
        %if curType.SLTypeIdx == -1
            %return FcnCreateOpaqueTypeObj("subsysIntOpaqueType", curType, TLC_FALSE, TLC_FALSE)
        %endif
        %if curType.Name == typeName
            %assign coderTypeObj = SLibGetCoderTypeObject(i, isConst, isVolatile)
            %if isPointer
                %return FcnGetPointerTypeObj(coderTypeObj, TLC_FALSE, TLC_FALSE)
            %else
                %return coderTypeObj
            %endif
        %endif
    %endforeach
    %return []
%endfunction

%function FcnGetSIDOfSubsystemBlockFromSubsystemIndex(sysIdx) Output
    %return System[sysIdx].SID
%endfunction

%function FcnGetRTModelGraphicalName()
    %return "RTModel"
%endfunction

%function FcnGetRTMOrSelfDataInterace() Output
    %assign grName = FcnGetRTModelGraphicalName()
    %assign key = FcnGetInternalDataMapKey(grName)
    %% add RTModel/self if not already part of InternalData
    %if !SLibAutosarActive() && !GenerateClassInterface && FcnHasRTMOrSelf()
        %assign rtMPtrType = FcnCreateRTMPointerType()

        %% Create a RTW.DataInterface object
        %assign rtmOwner = ""
        %assign defnFile = ""
        %assign declFile = ""

        %if FcnIsRTMDefined()
            %assign rtmOwner = LibGetModelName()
            %assign defnFile = SLibGetFullFileNameForCode("mdl_src")
            %assign declFile = SLibGetFullFileNameForCode("mdl_hdr")
        %endif

        %assign rtmTgtVarObj  = ...
            SLibGetRTWVariableObject(grName, "%<rtMPtrType>.BaseType","%<::tSimStruct>_", rtmOwner, defnFile, declFile)
        %assign rtmVarObj  = ...
            SLibGetRTWPointerVariableObject(grName, rtMPtrType,"%<::tSimStruct>", rtmTgtVarObj)
        %<rtmVarObj>.Owner = %<rtmTgtVarObj>.Owner;
        %if FcnIsRTMDefined()
            %<rtmVarObj>.DeclarationFile = %<rtmTgtVarObj>.DeclarationFile;
            %<rtmVarObj>.DefinitionFile = %<rtmTgtVarObj>.DefinitionFile;
        %endif
        %% Add it to InternalData if not already there (e.g. self in th SLfunction case)
        %assign rtmDataObj = ...
            FcnGetInternalDataObject(grName, "", FcnGetRTModelGraphicalName(), rtmVarObj, [])
    %endif
    %assign ret = ""
    %if ISFIELD(CodeInfoMap.InternalDataMap, key)
        %% If we added RTM, return the key name as we do normally
        %assign ret = key
    %endif
    %return ret
%endfunction

%function FcnWriteAddedFunctionParametersToCodeDescriptor() Output
    %assign numAddedParams = CGMODEL_ACCESS("CGModel.GetNumArgumentsAddedInTLC")
    %foreach idx = numAddedParams

        %assign sysIdx = CGMODEL_ACCESS("CGModel.GetSysIdxOfArgumentAddedInTLC", idx)

        %assign sid = FcnGetSIDOfSubsystemBlockFromSubsystemIndex(sysIdx)

        %if ISEMPTY(sid)
            %continue
        %endif

        %assign fcnName = CGMODEL_ACCESS("CGModel.GetFcnNameOfArgumentAddedInTLC", idx)

        %% The argument name might have random whitespace
        %assign argName = FEVAL("strtrim", CGMODEL_ACCESS("CGModel.GetArgNameOfArgumentAddedInTLC", idx))

        %% Unfortunately, if the argument is a pointer, we capture that as part of the argument name
        %% instead of the type name
        %assign isReallyPointer = argName[0] == "*"

        %assign typeName = CGMODEL_ACCESS("CGModel.GetTypeNameOfArgumentAddedInTLC",idx)

        %assign coderType = FcnCreateCoderTypeForAddedArgument(typeName, isReallyPointer)
        %if ISEMPTY(coderType)
            %return
        %endif
        %if isReallyPointer
            %% If it's a pointer, it has a * as the first character, so we need to strip that
            %assign argName = Substring(argName, 1, SIZE(argName, 1))
        %endif
        %assign rtmDI = "''"
        %if typeName == FcnGetRTMOrSelfTypeName()
            %% If the arg is self, make sure to use the existing DataInterface instead of creating a new dummy one
            %assign rtmDI = FcnGetRTMOrSelfDataInterace()
        %endif
        wr.addFunctionParameterToCodeDescriptor('%<sid>', '%<fcnName>', %<coderType>, '%<FcnStripConstVolatileFromTypeName(argName)>', %<CGMODEL_ACCESS("CGModel.GetArgumentAddedInTLCIsAtEndOfArgList", idx)>, %<rtmDI>);
    %endforeach
%endfunction

%function FcnFilterFileIfAddCausedByCodeInfo(fileRec, origNumFiles, newNumFiles) void
    %if newNumFiles > origNumFiles
        %<SLibSetModelFileAttribute(fileRec,"Filter", 1)>
    %endif
%endfunction

%function FcnIsSubsystemFunctionUnused(system, fcn) Output
    %assign fcnType = fcn.FunctionType
    %return !ISEMPTY(fcnType) && LibSystemFcnIsEmptyHelper(system, fcnType, fcn.FcnTID)
%endfunction

%function FcnRemoveEmptyFunctionsFromSubsystemInterface(system, subsysBlkSID) Output

    %% Go over all functions in the system, see if they're empty, and if they are, they won't
    %% be emitted so we need to remove them from SubsystemInterface
    %assign module = RTWCGModules.RTWCGModule[system.CGIRModuleIdx]
    %if !ISFIELD(module, "Function")
        %return
    %endif
    %foreach i = SIZE(module.Function,1)
        %if FcnIsSubsystemFunctionUnused(system, module.Function[i])
            wr.removeEmptyFunctionFromSubsystemInterface('%<subsysBlkSID>', '%<module.Function[i].Name>');
        %endif
    %endforeach
%endfunction

%function FcnUpdateSubsystemInterfaces() Output
    %if !CGMODEL_ACCESS("CGModel.SubsystemInterface")
        %% Only try if we can generate SubsystemInterfaces
        %return
    %endif

    %if RTMShouldOverrideTypeToVoid()
        %% Not supported, void ptr typed used in RTM
        wr.destroyAllSubsystemInterfaces();
        %return
    %endif

    %<FcnWriteAddedFunctionParametersToCodeDescriptor()>

    %assign numSubsys = ::CompiledModel.BlockHierarchyMap.NumSubsystems
    %foreach idx = numSubsys
        %assign subsys = ::CompiledModel.BlockHierarchyMap.Subsystem[idx]

        %if subsys.Type == "root" || subsys.Type == "virtual"
            %% Skip root and virtual subsystems
            %continue
        %endif

        %assign subsysBlockLocation = subsys.SubsystemBlockIndex
        %assign subsysSystemIdx = subsysBlockLocation[0]
        %assign subsysBlockIdxInSystem = subsysBlockLocation[1]

        %assert(subsysSystemIdx != -1 && subsysBlockIdxInSystem != -1)

        %assign subsysBlock = ::CompiledModel.BlockHierarchyMap.Subsystem[subsysSystemIdx].Block[subsysBlockIdxInSystem]

        %if subsysBlock.Type != "SubSystem"
            %% Skip non-graphical subsystems like Stateflow
            %continue
        %endif

        %assign sys = System[subsys.NVOwnerSysIdx]
        %assign sidInMap = LibGetModelName() + ":" + subsysBlock.SID
        %if !CGMODEL_ACCESS("CGModel.HasSubsystemInterface", sidInMap)
            %continue
        %endif

        %<FcnRemoveEmptyFunctionsFromSubsystemInterface(sys, subsysBlock.SID)>
        %<FcnRemoveUnusedArgumentsFromSubsystemInterface(sys, subsysBlock.SID)>

        %assign sys = System[sys.FileNameOwnerIdx]

        %assign numFilesBeforeCall = LibGetNumModelFiles()

        %if SLibGenSubsysFcnAsClassMemFcn(sys)
            %assign declFileName = SLibGetFileNameForCode("mdl_hdr") + ".h"
        %else
            %if LibSystemIsReusedLibraryFcn(sys)
                %% For RLS, the definition is not exported
                %% model code, so use a different category
                %assign category = "sys_fcn_decl"
            %else
                %assign category = "sys_exported_fcn_decl"
            %endif
            %assign fileRecOfDecl = SLibGetFileRecForSystemCode(category, sys, LibSystemIsReusedLibraryFcn(sys),LibIsGlobalServer(sys))
            %assign declFileName = LibGetModelFileAttribute(fileRecOfDecl.Index,"Name")

            %% Unfortunately SLibGetFileRecForSystemCode creates a record if it does not exist,
            %% and we don't want to cause a new file to get generated, so delete a file rec if we caused
            %% it to get created
            %<FcnFilterFileIfAddCausedByCodeInfo(fileRecOfDecl, numFilesBeforeCall, LibGetNumModelFiles())>

        %endif

        %assign numFilesBeforeCall = LibGetNumModelFiles()

        %assign fileRecOfDefn = SLibGetFileRecForSystemCode("sys_fcn_defn", sys, LibSystemIsReusedLibraryFcn(sys),LibIsGlobalServer(sys))
        %assign defnFileName = LibGetModelFileAttribute(fileRecOfDefn.Index,"Name")

        %<FcnFilterFileIfAddCausedByCodeInfo(fileRecOfDefn, numFilesBeforeCall, LibGetNumModelFiles())>

        wr.writeSubsystemFileInformation('%<subsysBlock.SID>', '%<declFileName>', '%<defnFileName>');
    %endforeach
%endfunction

%endif  %% EXISTS(_CIINFOFCNLIB_) == 0

%% [EOF] codeinfofclib.tlc
