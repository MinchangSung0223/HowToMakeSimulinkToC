%% ============================================================================
%%
%%
%% Abstract:
%%   This system file creates the model mapping data.
%%
%% Copyright 1994-2022 The MathWorks, Inc.
%%
%% Pete Szpak
%% March 11, 1998
%%
%selectfile NULL_FILE

%if EXISTS(_COMMONMAPLIB_) == 0
%assign _COMMONMAPLIB_ = 1

%realformat "CONCISE"

%% Function : SLibGetBaseDataTypeIdForFilteredType ===========================
%% Abstract : Check if the datatype is filtered and replaced with its base
%%            datatype
%function SLibGetBaseDataTypeIdForFilteredType(idx) void
    %assign aIdx = idx
    %assign dt = ::CompiledModel.DataTypes.DataType[idx]

    %if (dt.DefinedInLegacyCode == 0) || LibIsModelReferenceSimTarget()
        %assign aIdx = dt.IdAliasedThruTo
    %endif

    %return aIdx
%endfunction

%% Function: SLibDumpDataTypeInfoTable =============================================================
%% Abstract:
%%
%function SLibDumpDataTypeInfoTable() Output
    %with DataTypes
        %if NumDataTypes == 0
            %<LibReportFatalError("NumDataTypes == 0")>
        %else
            %foreach idx = NumDataTypes
                %if idx == NumDataTypes - 1
                    { "%<SLibGetDataTypeName(idx)>", %<DataType[idx].Id>, %<LibGetDataTypeSLSizeFromId(idx)> }
                %else
                    { "%<SLibGetDataTypeName(idx)>", %<DataType[idx].Id>, %<LibGetDataTypeSLSizeFromId(idx)> },
                %endif
            %endforeach
        %endif
    %endwith
%endfunction

%% Function: SLibDumpDataTypeSizeTable =============================================================
%% Abstract:
%%
%function SLibDumpDataTypeSizeTable() Output
    %assign int32Type = LibGetDataTypeNameFromId(::CompiledModel.tSS_INT32)
    %assign uint32Type = LibGetDataTypeNameFromId(::CompiledModel.tSS_UINT32)
    %assign charType = LibGetDataTypeNameFromId(::CompiledModel.tSS_CHAR)
    %with DataTypes
        %if NumDataTypes == 0
            %<LibReportFatalError("NumDataTypes == 0")>
        %else
            %% NumDataTypes > 0
            %foreach idx = NumDataTypes

                %% Get base type of filtered alias type
                %if LibIsAliasDataType(idx)
                    %assign idx = SLibGetBaseDataTypeIdForFilteredType(idx)
                %endif

                %% Skip the handling of data types that are not used in the code.
                %% One specific example is a structure type has a field name clashing
                %% with reserved keywords. In this case, all structure field deferences
                %% are collapsed and the anonymous structure type is not used.
                %if DataTypes.DataType[idx].Skip
                    %% When the data type is skipped, give it a fake size
                    %assign dtSize = "sizeof(%<int32Type>)"
                %elseif idx == tSS_TIMER_UINT32_PAIR
                    %assign dtSize = "2*sizeof(%<uint32Type>)"
                %elseif LibIsStringDataType(idx)
                    %% Use size information from container type if there is one
                    %assign rec = DataTypes.DataType[idx]
                    %if ISFIELD(rec, "ContainerCGTypeIdx")
                        %assign containerTypeIdx = rec.ContainerCGTypeIdx
                        %% Container for string is either a static matrix or a pointer
                        %if LibCGTypeIsMatrix(containerTypeIdx)
                            %% For matrix case - it is always a vector of chars
                            %% OK to take just the first dimension from static matrix of characters
                            %assign dtSize = "%<LibCGTypeDimensions(containerTypeIdx)[0]>"
                        %else
                            %% For pointer case - use %<charType> size
                            %% Data will be transferred as bytes
                            %% Number of bytes will be provided separately, e.g. as data width
                            %assert LibCGTypeIsPointer(containerTypeIdx)
                            %assign dtSize = "sizeof(%<charType>)"
                        %endif
                    %else
                        %% Otherwise, use size information from the data type
                        %assign dtSize = "%<LibGetDataTypeSLSizeFromId(idx)>"
                    %endif
                %else
                    %assign typeName = SLibGetDataTypeName(idx)
                    %assign dtSize = "sizeof(%<typeName>)"
                %endif
                %if UsingMalloc
                    %% run-time assignment
                    DataTypeSizes[%<idx>] = %<dtSize>;
                %else
                    %% static declaration
                    %if (idx == NumDataTypes-1)
                        %<dtSize>
                    %else
                        %<dtSize>,
                    %endif
                %endif
            %endforeach
        %endif
    %endwith
%endfunction


%% Function: SLibDumpDataTypeNameTable =============================================================
%% Abstract:
%%
%function SLibDumpDataTypeNameTable() Output
    %with DataTypes
        %if NumDataTypes == 0
            %<LibReportFatalError("NumDataTypes == 0")>
        %else
            %% NumDataTypes > 0
            %foreach idx = NumDataTypes
                %% Get base type of filtered alias type
                %if LibIsAliasDataType(idx)
                    %assign idx = SLibGetBaseDataTypeIdForFilteredType(idx)
                %endif

                %if UsingMalloc
                    %% run-time assignment
                    DataTypeNames[%<idx>] = "%<SLibGetDataTypeName(idx)>";
                %else
                    %% static declaration
                    %if (idx == NumDataTypes-1)
                        "%<SLibGetDataTypeName(idx)>"
                    %else
                        "%<SLibGetDataTypeName(idx)>",
                    %endif
                %endif
            %endforeach
        %endif
    %endwith
%endfunction

%% Function: SLibDumpDataTypeTransitionTable_helper ================================================
%% Abstract:
%%   Helper for SLibDumpDataTypeTransitionTable, see that function for details.
%function SLibDumpDataTypeTransitionTable_helper(type, dataType, idx, prefix) Output
    %assign charType = LibGetDataTypeNameFromId(::CompiledModel.tSS_CHAR)
    %with ::CompiledModel.GlobalMemoryMap
        %assign comma     = ""
        %assign numSigs   = 0
        %%
        %% dataType is either "signal", "parameter", or "dwork"
        %%
        %if !ISEMPTY(dataType)
            %foreach sectionIdx = dataType.NumSections
                %with dataType.Section[sectionIdx]
                    %assign numSigs = numSigs + 1
                    %if UsingMalloc
                        %% run-time assignment
                        %<prefix>Transitions[%<idx>].baseAddr  = (%<charType> *)(%<BaseAddr>);
                        %<prefix>Transitions[%<idx>].dataType  = %<DataTypeIdx>;
                        %<prefix>Transitions[%<idx>].isComplex = %<IsComplex>;
                        %<prefix>Transitions[%<idx>].nEls      = %<NumElements>;
                        %assign idx = idx + 1
                    %else
                        %% static delaration
                        %<comma>{(%<charType> *)(%<BaseAddr>), %<DataTypeIdx>, %<IsComplex>,\
                        %<NumElements>}\
                        %assign comma = ",\n"
                    %endif
                %endwith
            %endforeach
        %endif
        %%
        %% nonAuto
        %%
        %if ISFIELD(GlobalMemoryMap,"UnstructuredData")
            %assign nData = UnstructuredData.NumData
            %foreach dataIdx = nData
                %with UnstructuredData.Data[dataIdx]
                    %if type == SL_ExtModeType

                        %% Any data record without the SL_LogicalSrc field does not
                        %% correspond to an element of the Simulink BIO or Aggregate
                        %% Parameter tables and can not be included in the data type
                        %% tranistion table or the target data map file.  An example
                        %% is a signal declared as an "exported global".  The function
                        %% SLibGetMapNumDataSections() in globalmaplib.tlc performs
                        %% the same check to return the correct number of data sections.
                        %if ISFIELD(UnstructuredData.Data[dataIdx],"SL_LogicalSrc")
                            %% Calculate the width (number of elements)
                            %if NumDimensions > 2
                                %assign nEls = 1
                                %foreach dimIdx = NumDimensions
                                    %assign nEls = nEls * Dimensions[dimIdx]
                                %endforeach
                            %else
                                %assign nEls = NumCols * NumRows
                            %endif
                            %assign numSigs = numSigs + 1
                            %if UsingMalloc
                                %% run-time assignment
                                %<prefix>Transitions[%<idx>].baseAddr  = (%<charType> *)(%<BaseAddr>);
                                %<prefix>Transitions[%<idx>].dataType  = %<DataTypeIdx>;
                                %<prefix>Transitions[%<idx>].isComplex = %<IsComplex>;
                                %<prefix>Transitions[%<idx>].nEls      = %<nEls>;
                                %assign idx = idx + 1
                            %else
                                %% static delaration
                                %<comma>{(%<charType> *)(%<BaseAddr>), %<DataTypeIdx>, %<IsComplex>,%<nEls>}\
                                %assign comma = ",\n"
                            %endif
                        %endif
                    %endif
                %endwith
            %endforeach
        %endif
        %%
        %% Custom
        %%
        %if ISFIELD(GlobalMemoryMap,"CustomData")
            %assign nDataRecs = NumCustomData

            %foreach dataRecIdx = nDataRecs
                %assign customDataRec = CustomData[dataRecIdx]
                %assign nData         = customDataRec.NumData

                %foreach dataIdx = nData
                    %if nData == 1
                        %assign data = customDataRec.Data
                    %else
                        %assign data = customDataRec.Data[dataIdx]
                    %endif

                    %with data
                        %if type == SL_ExtModeType
                            %% Any data record without the SL_LogicalSrc field does not
                            %% correspond to an element of the Simulink BIO or Aggregate
                            %% Parameter tables and can not be included in the data type
                            %% tranistion table or the target data map file.  An example
                            %% is a signal declared as an "exported global".  The function
                            %% SLibGetMapNumDataSections() in globalmaplib.tlc performs
                            %% the same check to return the correct number of data sections.
                            %if (ISFIELD(data,"SL_LogicalSrc") && data.NumDimensions != -1)
                                %% Calculate the width (number of elements)
                                %if NumDimensions > 2
                                    %assign nEls = 1
                                    %foreach dimIdx = NumDimensions
                                        %assign nEls = nEls * Dimensions[dimIdx]
                                    %endforeach
                                %else
                                    %assign nEls = NumCols * NumRows
                                %endif
                                %assign numSigs = numSigs + 1
                                %if UsingMalloc
                                    %% run-time assignment
                                    %<prefix>Transitions[%<idx>].baseAddr  = (%<charType> *)(%<BaseAddr>);
                                    %<prefix>Transitions[%<idx>].dataType  = %<DataTypeIdx>;
                                    %<prefix>Transitions[%<idx>].isComplex = %<IsComplex>;
                                    %<prefix>Transitions[%<idx>].nEls      = %<nEls>;
                                    %assign idx = idx + 1
                                %else
                                    %% static delaration
                                    %<comma>{(%<charType> *)(%<BaseAddr>), %<DataTypeIdx>, %<IsComplex>,%<nEls>}\
                                    %assign comma = ",\n"
                                %endif
                            %endif
                        %endif
                    %endwith
                %endforeach
            %endforeach
        %endif
    %endwith
%endfunction

%% Function: SLibDumpDataTypeTransitionTable =======================================================
%% Abstract:
%%   This function dumps the Data Type Transition Table for either signals,
%%   dworks, or parameters, depending on the input variable.
%%
%%   o Creates and dumps the table for structured data (bio, dwork, and rtP).
%%   o Creates and dumps the table for unstructured data (global signals,
%%     dwork, and parameters).
%%   o Creates and dumps the table for custom data (custom signals, dwork,
%%     and parameters).
%%
%function SLibDumpDataTypeTransitionTable(type) Output
    %assign isCoderGroupType = (type == "coderGroup")
    %with ::CompiledModel.GlobalMemoryMap
        %if !isCoderGroupType
            %assign dataType  = SLibGetMapStructData(type)
            %switch(type)
              %case "parameter"
                %assign idx    = 0
                %assign prefix = "P"
                %break
              %case "signal"
                %assign idx    = 0
                %assign prefix = "B"
                %break
              %case "dwork"
                %assign idx    = SLibGetMapNumDataSections("signal")
                %assign prefix = "B"
                %break
              %default
                %assert TLC_FALSE
                %break
            %endswitch
            %<SLibDumpDataTypeTransitionTable_helper(type, dataType, idx, prefix)>
        %else %% isCoderGroupType == true
            %assign firstSignalGroup = TLC_TRUE
            %assign firstParamGroup = TLC_TRUE
            %assign comma = ",\n"
            %foreach groupIdx = ::CompiledModel.NumCoderDataGroups
                %assign group = ::CompiledModel.CoderDataGroup[groupIdx]
                %if SLibCoderGroupPackageAsStruct(group) && SLibGetRootVarGroupIdxForCoderGroup(group) >= 0
                    %assign varGroup = SLibVarGroupForCoderGroup(group)
                    %if varGroup.NumVarGroupElements <= 0
                        %continue
                    %endif
                    %foreach structureIdx = NumStructuredData
                        %% tmcphers -- Skip for CState variables since they are not part of the
                        %% data type transition table. Without this invalid code will be
                        %% generated in <model>_dt.h
                        %switch(group.Name)
                          %case "_XLoc"
                          %case "_XDisLoc"
                          %case "_XDotLoc"
                          %case "_AbsTolLoc"
                          %case "_XPerturbMinLoc"
                          %case "_XPerturbMaxLoc"
                            %% Coder group is synthesized for local solver, skip it.
                            %continue
                          %default
                            %% Not a coder group synthesized for local solver -- proceed as normal
                        %endswitch
                        %assign structure = StructuredData[structureIdx]
                        %if structure.Name == varGroup.Name
                            %% Pass prefix "B" for signal coder group, and "P" for parameter coder group.
                            %assign isParamGroup = SLibDataGroupStaticInit(group)
                            %if !isParamGroup
                                %assign idx = SLibGetMapNumDataSections("signal") + SLibGetMapNumDataSections("dwork")
                                %if !firstSignalGroup
                                    %<comma>
                                %endif
                                %assign firstSignalGroup = TLC_FALSE
                                %assign prefix = "B"
                            %else
                                %assign idx = SLibGetMapNumDataSections("parameter")
                                %if !firstParamGroup
                                    %<comma>
                                %endif
                                %assign firstParamGroup = TLC_FALSE
                                %assign prefix = "P"
                            %endif
                            %<SLibDumpDataTypeTransitionTable_helper(type, structure, idx, prefix)>
                        %endif
                    %endforeach
                %endif
            %endforeach
        %endif
    %endwith
%endfunction


%% Function: SLibDumpMapInfo =======================================================================
%% Abstract:
%%   This function dumps the map information for either signals
%%   or parameters, depending on the input variable.
%%
%function SLibDumpMapInfo(type) Output
    %switch(type)
      %case "parameter"
        %assign prefix = "P"
        %assign nTrans = SLibGetParameterMapNumDataSections()
        %break
      %case "signal"
        %assign prefix = "B"
        %assign nTrans = SLibGetBlockIOMapNumDataSections()
        %break
      %default
        %assert TLC_FALSE
        %break
    %endswitch
    %if UsingMalloc
        %% run-time assignment
        %<prefix>TransTable->numTransitions = %<nTrans>U;
        %<prefix>TransTable->transitions = %<prefix>Transitions;
    %else
        %% static declaration
        %<nTrans>U,
        rt%<prefix>Transitions
    %endif
%endfunction


%% Function: SLibDumpBlockIODataTypeTransitionTable ================================================
%% Abstract:
%%   This function is a wrapper and calls SLibDumpDataTypeTransitionTable()
%%   with "signal" and "dwork" to dump the BlockIO data type transition table.
%%   The order of the calls is very important - the BlockIo data type trans
%%   table consists of the signals portion followed by the dwork portion.
%%
%function SLibDumpBlockIODataTypeTransitionTable() Output
    %assign charType = LibGetDataTypeNameFromId(::CompiledModel.tSS_CHAR)
    %assign numSigs   = SLibGetNumDataTypeTransitionTableElements("signal")
    %assign numDWorks = SLibGetNumDataTypeTransitionTableElements("dwork")
    %assign numCoderGroups = SLibGetNumDataTypeTransitionTableElements("coderGroup")

    %%
    %% Dump the signal portion of the DTTT.
    %%
    %<SLibDumpDataTypeTransitionTable("signal")>

    %%
    %% The DTTT always adds signals then dworks.  If there are both signals
    %% and dworks to add to the DTTT, then we must add a comma between the
    %% sections.
    %%
    %if numDWorks && numSigs && !UsingMalloc
        ,
    %endif

    %%
    %% Dump the dwork portion of the DTTT
    %%
    %<SLibDumpDataTypeTransitionTable("dwork")>

    %if numCoderGroups && (numSigs || numDWorks) && !UsingMalloc
        ,
    %endif

    %% Dump coder group portion of the DTTT
    %<SLibDumpDataTypeTransitionTable("coderGroup")>

    %%
    %% It is possible that we initially thought there were available signals
    %% and/or dwork and decided to create the DTTT, then realized those signals
    %% and/or dwork were not available after consulting the Global Memory Map.
    %% We add a dummy entry to the structure to avoid potential compiler errors
    %% if the DTTT is really empty.
    %%
    %if !numDWorks && !numSigs && !numCoderGroups && !UsingMalloc
        {(%<charType> *)%<SLibGetNullDefinitionFromTfl()>, 0, 0, 0}
    %endif

%endfunction


%% Function: SLibGetNumDataTypeTransitionTableElements_helper ======================================
%% Abstract:
%%   Helper for SLibGetNumDataTypeTransitionTableElements, see that function for details.
%function SLibGetNumDataTypeTransitionTableElements_helper(type, dataType) void
    %assign numSigs = 0
    %with ::CompiledModel.GlobalMemoryMap
        %%
        %% dataType is either "signal", "parameter", or "dwork"
        %%
        %if !ISEMPTY(dataType)
            %foreach sectionIdx = dataType.NumSections
                %with dataType.Section[sectionIdx]
                    %assign numSigs = numSigs + 1
                %endwith
            %endforeach
        %endif
        %%
        %% nonAuto
        %%
        %if ISFIELD(GlobalMemoryMap,"UnstructuredData")
            %assign nData = UnstructuredData.NumData
            %foreach dataIdx = nData
                %with UnstructuredData.Data[dataIdx]
                    %if type == SL_ExtModeType

                        %% Any data record without the SL_LogicalSrc field does not
                        %% correspond to an element of the Simulink BIO or Aggregate
                        %% Parameter tables and can not be included in the data type
                        %% tranistion table or the target data map file.  An example
                        %% is a signal declared as an "exported global".  The function
                        %% SLibGetMapNumDataSections() in globalmaplib.tlc performs
                        %% the same check to return the correct number of data sections.
                        %if ISFIELD(UnstructuredData.Data[dataIdx],"SL_LogicalSrc")
                            %% Calculate the width (number of elements)
                            %if NumDimensions > 2
                                %assign nEls = 1
                                %foreach dimIdx = NumDimensions
                                    %assign nEls = nEls * Dimensions[dimIdx]
                                %endforeach
                            %else
                                %assign nEls = NumCols * NumRows
                            %endif
                            %assign numSigs = numSigs + 1
                        %endif
                    %endif
                %endwith
            %endforeach
        %endif
        %%
        %% Custom
        %%
        %if ISFIELD(GlobalMemoryMap,"CustomData")
            %assign nDataRecs = NumCustomData

            %foreach dataRecIdx = nDataRecs
                %assign customDataRec = CustomData[dataRecIdx]
                %assign nData         = customDataRec.NumData
                %assign cscType       = customDataRec.Name

                %foreach dataIdx = nData
                    %if nData == 1
                        %assign data = customDataRec.Data
                    %else
                        %assign data = customDataRec.Data[dataIdx]
                    %endif

                    %with data
                        %if type == SL_ExtModeType
                            %if SLibIsGlobalMapDataWithNoExternalLinkage(data)
                                %assign varName = LibGetRecordVarName(data.RTWRecord)
                                %assign cscDefn = RTWRecord.CSCDefn
                                %assign attribs = LibGetCustomStorageAttributes(data)
                                %if LibGetInstanceSpecificProp(cscDefn, attribs, "IsReusable")
                                    %assign command = "%<varName>.CoderInfo.CustomAttributes.DataScope"
                                    %assign args = ["%<varName>", "%<command>"]
                                    %<SLibReportErrorWithIdAndArgs("RTW:tlc:NonExportedDataUnsupportedInExtModeWithRCSC", args)>
                                %else
                                    %<SLibReportErrorWithIdAndArgs("RTW:tlc:NonExportedDataUnsupportedInExtMode", varName)>
                                %endif
                            %endif
                            %% Any data record without the SL_LogicalSrc field does not
                            %% correspond to an element of the Simulink BIO or Aggregate
                            %% Parameter tables and can not be included in the data type
                            %% transition table or the target data map file.  An example
                            %% is a signal declared as an "exported global".  The function
                            %% SLibGetMapNumDataSections() in globalmaplib.tlc performs
                            %% the same check to return the correct number of data sections.
                            %if ISFIELD(data,"SL_LogicalSrc")
                                %% Calculate the width (number of elements)
                                %if NumDimensions > 2
                                    %assign nEls = 1
                                    %foreach dimIdx = NumDimensions
                                        %assign nEls = nEls * Dimensions[dimIdx]
                                    %endforeach
                                %else
                                    %assign nEls = NumCols * NumRows
                                %endif
                                %assign numSigs = numSigs + 1
                            %endif
                        %endif
                    %endwith
                %endforeach
            %endforeach
        %endif
    %endwith
    %return numSigs
%endfunction

%% Function: SLibGetNumDataTypeTransitionTableElements =============================================
%% Abstract:
%%   This function calculates the actual number of accessible signals, dwork
%%   or parameters for the Data Type Transition Table (DTTT).  The functions
%%   FcnNumUploadableDWorksIsEmpty() and FcnNumAccessibleSignalsIsEmpty() return
%%   whether or not there are accessible dworks or signals, respectively.
%%   However, these functions may be incorrect.  It is possible to have signals
%%   or dworks in the model which are initially thought to be accessible, but
%%   are eliminated once the Global Memory Map (GMM) has been scanned.
%%   Unfortunately, the GMM is not available when SLibDumpModelMappingInfo()
%%   tries to determine if the DTTT is needed.  So we take an educated guess
%%   at that point knowing we may be wrong.  If we create a DTTT and it is
%%   empty (all signals and dworks thought to be accessible were eliminated
%%   after consulting the GMM), we may get a compiler error.  This function
%%   returns the true number of accessible signals or dworks so that we can
%%   detect an empty DTTT and take appropriate action to avoid compiler errors.
%%
%%   The algorithm of this function is a mirror of
%%   SLibDumpDataTypeTransitionTable() and must be kept in sync with it.
%%
%function SLibGetNumDataTypeTransitionTableElements(type) void
    %assign isCoderGroupType = (type == "coderGroup")
    %assign numSigs = 0
    %with ::CompiledModel.GlobalMemoryMap
        %if !isCoderGroupType
            %assign dataType = SLibGetMapStructData(type)
            %assign numSigs = SLibGetNumDataTypeTransitionTableElements_helper(type, dataType)
        %else %% isCoderGroupType == true
            %foreach groupIdx = ::CompiledModel.NumCoderDataGroups
                %assign group = ::CompiledModel.CoderDataGroup[groupIdx]
                %if SLibCoderGroupPackageAsStruct(group) && SLibGetRootVarGroupIdxForCoderGroup(group) >= 0
                    %assign varGroup = SLibVarGroupForCoderGroup(group)
                    %foreach structureIdx = NumStructuredData
                        %assign structure = StructuredData[structureIdx]
                        %if structure.Name == varGroup.Name
                            %assign numSigs = numSigs + SLibGetNumDataTypeTransitionTableElements_helper(type, structure)
                        %endif
                    %endforeach
                %endif
            %endforeach
        %endif
    %endwith
    %return numSigs
%endfunction


%% Function: FcnNumUploadableDWorksIsEmpty =========================================================
%% Abstract:
%%   This function returns whether or not there are any available DWorks.
%%
%function FcnNumUploadableDWorksIsEmpty() void
    %return (::CompiledModel.DWorks.NumDWorks == 0)
%endfunction


%% Function: FcnNumAccessibleSignalsIsEmpty ========================================================
%% Abstract:
%%   This function returns whether or not there are any accessible signals.
%%
%function FcnNumAccessibleSignalsIsEmpty() void
    %return (BlockOutputs.NumAccessibleSignals == 0)
%endfunction


%% Function: SLibBlockIODataTypeTransitionTableIsEmpty =============================================
%% Abstract:
%%   This function is used to check whether we need to create the
%%   DataTypeTransiton table for BlockIO (signals).
%%
%function SLibBlockIODataTypeTransitionTableIsEmpty() void
    %return (FcnNumUploadableDWorksIsEmpty() && FcnNumAccessibleSignalsIsEmpty())
%endfunction


%% Function: SLibDumpBlockIOMapInfo ================================================================
%% Abstract:
%%   This function is a wrapper and calls SLibDumpMapInfo () with "signal".
%%   SLibDumpMapInfo will dump the map info for signals and dwork because they
%%   are both written to the BlockIo data type trans table.
%%
%function SLibDumpBlockIOMapInfo() Output
    %if !SLibBlockIODataTypeTransitionTableIsEmpty()
        %<SLibDumpMapInfo("signal")>
    %endif
%endfunction


%% Function: SLibDumpParametersDataTypeTransitionTable =============================================
%% Abstract:
%%   This function is a wrapper and calls SLibDumpDataTypeTransitionTable()
%%   with "parameter" to dump the Parameter data type transition table.
%%
%function SLibDumpParametersDataTypeTransitionTable() Output
    %<SLibDumpDataTypeTransitionTable("parameter")>
%endfunction

%% Function: SLibNumInaccessiblePrms ===============================================================
%% Abstract:
%%   This function computes the number of parameters that are
%%   inaccessible for External mode.
%function SLibNumInaccessiblePrms() Output
    %assign numInaccessiblePrms = 0
    %with ::CompiledModel.ModelParameters
        %foreach prmIdx = NumParameters
            %assign mParam  = Parameter[prmIdx]
            %assign isInaccessible = TLC_FALSE
            %if ISFIELD(mParam, "UseAccessFunctions") && mParam.UseAccessFunctions == 1
                %assign isInaccessible = TLC_TRUE
            %else
                %assign data = SLibGetGlobalMemoryDataRecord(mParam.MemoryMapIdx)
                %if !ISEMPTY(data) && SLibIsGlobalMapDataWithNoExternalLinkage(data)
                    %assign isInaccessible = TLC_TRUE
                %endif
            %endif
            %if isInaccessible
                %assign numInaccessiblePrms = numInaccessiblePrms + 1
            %endif
        %endforeach
    %endwith
    %return numInaccessiblePrms
%endfunction

%% Function: SLibParametersDataTypeTransitionTableIsEmpty ==========================================
%% Abstract:
%%   This function is used to check whether we need to create the
%%   DataTypeTransiton table for Parameters.
%%
%function SLibParametersDataTypeTransitionTableIsEmpty() void
    %with ::CompiledModel.ModelParameters
        %return (NumParameters - NumConstPrms - NumConstPrmsWithInit - SLibNumInaccessiblePrms()) == 0.0
    %endwith
%endfunction


%% Function: SLibDumpParametersMapInfo =============================================================
%% Abstract:
%%   This function is a wrapper and calls SLibDumpMapInfo() with "parameter" to
%%   dump the Parameters map info.
%%
%function SLibDumpParametersMapInfo() Output
    %if !SLibParametersDataTypeTransitionTableIsEmpty()
        %<SLibDumpMapInfo("parameter")>
    %endif
%endfunction


%% Function: SLibDumpModelMappingInfo ==============================================================
%% Abstract:
%%   Initializes the model mapping info and attach it to the SimStruct.  This
%%   function supports these code formats:
%%   o RealTime
%%   o RealTimeMalloc
%%   o Embedded-C
%%
%function SLibDumpModelMappingInfo() Output
    %assign charType = LibGetDataTypeNameFromId(::CompiledModel.tSS_CHAR)
    %%
    %% Generate the setup code
    %%
    %assign usingStatic = !UsingMalloc
    %assign numDataTypes = LibGetNumDataTypesInModel()
    %if (CreateTransitionTable == 1)  && numDataTypes != -1
        /* data type transition information */
        {
            %if usingStatic
                %%
                %% Static memory allocation (instances are generated in model.dt)
                %%
                static DataTypeTransInfo dtInfo;

                %if ::GenCPP == 0
                    (void) %<LibGenMemFcnCall("memset", "(%<charType> *) &dtInfo", "0", ...
                        "sizeof(dtInfo)")>;
                %elseif SLibIsRTMZeroInitCppEnabled()
                    (void) %<LibGenMemFcnCall("memset", "(void *) &dtInfo", "0", ...
                        "sizeof(dtInfo)")>;
                %endif
                %<RTMSet("ModelMappingInfo", "&dtInfo")>;

                %if xPC==1
                    %<RTMuSet("ReservedForXPC", "(void*) &dtInfo")>;
                %endif
                dtInfo.numDataTypes  = %<numDataTypes>;
                %if numDataTypes > 0
                    dtInfo.dataTypeSizes = &rtDataTypeSizes[0];
                    dtInfo.dataTypeNames = &rtDataTypeNames[0];
                %endif
                %if !SLibBlockIODataTypeTransitionTableIsEmpty()

                    /* Block I/O transition table */
                    dtInfo.BTransTable = &rtBTransTable;
                %endif
                %if !SLibParametersDataTypeTransitionTableIsEmpty()

                    /* Parameters transition table */
                    dtInfo.PTransTable = &rtPTransTable;
                %endif
                %if ::isRAccel && numDataTypes > 0
                    dtInfo.dataTypeInfoTable = rtDataTypeInfoTable;
                %endif
            %else
                #include "%<Name>_reg_dt.h"
            %endif  %% usingStatic == 1
        }
    %endif      %% DataTypeTrans == 1
    %%
    %% Add model_initializeDataMapInfo if C API is selected
    %%
    %if RTWCAPI
        %% Necessary Function arguments are provided by FcnCAPIInitializeFcnArgs
        %% This function definition is provided in capi.tlc
        %% The function arguments are cached globall in ::CompiledModel
        %if ISFIELD(::CompiledModel, "CAPIFunctionArgs")
            %assign args = ::CompiledModel.CAPIFunctionArgs
        %else
            %% If the function arguments were'nt initialized. For e.g S-function
            %% code Format or xPC target
            %assert ((CodeFormat == "S-Function") || (xPC == 1))
            %createrecord       \
            CAPI_FunctionArgs { \
                uArg   ""; \
                uDecl  ""; \
                dArg   ""; \
                dDecl  ""; \
                pArg   ""; \
                pDecl  ""; \
                bArg   ""; \
                bDecl  ""; \
                dwArg  ""; \
                dwDecl ""; \
                xArg   ""; \
                xDecl  ""; \
                ssArg  ""; \
                ssDecl ""  \
            }
            %assign args = CAPI_FunctionArgs
            %addtorecord args groupArg ...
                Vector(%<::CompiledModel.NumCoderDataGroups>) [""@%<::CompiledModel.NumCoderDataGroups>]
            %addtorecord args groupDecl ...
                Vector(%<::CompiledModel.NumCoderDataGroups>) [""@%<::CompiledModel.NumCoderDataGroups>]
            %addtorecord args groupDeclCache ...
                Vector(%<::CompiledModel.NumCoderDataGroups>) [""@%<::CompiledModel.NumCoderDataGroups>]
        %endif
        /* Initialize DataMapInfo substructure containing ModelMap for C API */
        %if IsModelReferenceSimTarget()
            %assign dwDecl = ""
            %if ISFIELD(args,"isDwArgDeclSame") && args.isDwArgDeclSame
                %assign dwDecl = args.dwDecl
            %endif
            %assign genCoderGroupArgsForClassOnly = !RTMMdlRefHasLocalSolver()
            %<::CompiledModel.Name>_InitializeDataMapInfo(%<RTMGetModelSS()>...
                %<args.uDecl>%<args.bDecl>%<args.pDecl>%<dwDecl>%<args.xDecl>%<args.ssDecl>%<FcnGetCAPIGroupInfo(args, "Decl")>, sysRanPtr, contextTid);
        %else
            %% We do not need to generate this temporary rtP structure if we are
            %% generating Encapsulated C++ code, because the model class already
            %% has the rtP structure as its member.
            %if IsModelReferenceInlineOffTarget() && !LibParametersStructIsEmpty() && !GenerateClassInterface
                %assign dataType = ::tParametersType

                %assign baseSystem = ::CompiledModel.System[GetBaseSystemIdx()]
                %assign paramsName = FcnSysVarGroupNonreusedName(baseSystem,"Parameter")
                { \
                    %if !ISEMPTY(paramsName) && !ISEMPTY(args.pDecl)

                        %<dataType> *%<::tParameters> = &%<paramsName>;
                    %endif
            %endif
            %assign simstructDefn = ""
            %if (::isRAccel || isRSim) && !IsModelReferenceTarget()
                %% Rapid accelerator and rsim extern their root simstructs - they're not needed
                %% as arguments to initializedatamapinfo
            %else
                %if MultiInstanceERTCode || IsModelReferenceTarget()
                    %assign simstructDefn = "%<RTMGetModelSS()>"
                %endif
            %endif
            %assign dwDecl = ""
            %if ISFIELD(args,"isDwArgDeclSame") && args.isDwArgDeclSame
                %assign dwDecl = args.dwDecl
            %endif
            %<::CompiledModel.Name>_InitializeDataMapInfo(%<simstructDefn>...
                %<args.uDecl>%<args.bDecl>%<args.pDecl>%<dwDecl>%<args.xDecl>%<args.ssDecl>%<FcnGetCAPIGroupInfo(args, "Decl")>);
            %if IsModelReferenceInlineOffTarget() && !LibParametersStructIsEmpty() && !GenerateClassInterface
            }
            %endif
        %endif
    %endif
%endfunction  %% SLibDumpModelMappingInfo

%endif %% _COMMONMAPLIB_

%% [EOF] commonmaplib.tlc
