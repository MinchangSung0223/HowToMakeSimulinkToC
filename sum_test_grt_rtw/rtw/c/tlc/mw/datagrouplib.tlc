%%
%% Copyright 2015-2023 The MathWorks, Inc.
%%
%% Abstract:
%%   This system TLC library file contains functions that are related to
%%   Simulink.CoderGroups
%%

%if EXISTS(_DATAGROUPLIB_) == 0
%assign _DATAGROUPLIB_ = 1
%<LibAddToCompiledModel("IsCCNMVParamExist", TLC_FALSE)>

%% Function: SLibIsCoderGroupUseAccessFcnForDataRecord =============================================
%% Abstract:
%%  This function check if record is In CoderGroup and if the record is using access function

%function SLibIsCoderGroupUseAccessFcnForDataRecord(record) void
    %%if !SLibIsLegacyStorageClassForDataRecord(record) && ...
    %if SLibDataRecordIsInCoderGroup(record) && ...
        ISFIELD(record,"UseAccessFunctions") && record.UseAccessFunctions == 1
    %return TLC_TRUE
    %endif
    %return TLC_FALSE
%endfunction

%% Function: SLibVargroupElementAutoDataInitConversion =============================================
%% Abstract:
%%  Helper function to convert Auto DataInit to Static or Dynamic
%%
%function SLibVargroupElementAutoDataInitConversion(recType) void
    %if recType == "P"
        %return "Static"
    %else
        %return "Dynamic"
    %endif
%endfunction

%% Function: SLibCoderDataGroupAutoDataInitConversion ==============================================
%% Abstract:
%%   return "Static" if parameters are mapped to "Auto" DataInit CoderDataGroup
%%   return "Static" if  both parameters and signals are mapped to "Auto" DataInit CoderDataGroup
%%   return "Dynamic" if others are mapped to "Auto" DataInit CoderDataGroup
%%
%function SLibCoderDataGroupAutoDataInitConversion(group) void
    %assert(group.DataInit == "Auto")
    %assign autoDataInit = "Auto"
    %if group.GroupContains == "ParameterElementOnly" || group.GroupContains == "ParameterAndSignalElement"
        %assign autoDataInit = "Static"
    %elseif group.GroupContains == "SignalElementOnly"
        %assign autoDataInit = "Dynamic"
    %endif
    %return autoDataInit
%endfunction

%% Function: LibCoderDataGroupStructIsEmpty ========================================================
%% Abstract:
%%   Does the root system have a CoderDataGroup of the given name?
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function LibCoderDataGroupStructIsEmpty(group) void
    %assign baseSysIdx = GetBaseSystemIdx()
    %assign fieldName = "HasCoderDataGroup" + group.Name + "Arg"
    %if SLibIsSynthesizedRTM(group)
        %return !IsModelRefScalableBuild() ? ::CompiledModel.EmptyRealTimeObject : TLC_TRUE
    %elseif group.AsStructure == "None"
        %return TLC_TRUE
    %endif
    %assert (ISFIELD(::CompiledModel.System[baseSysIdx], fieldName))
    %return (::CompiledModel.System[baseSysIdx].%<fieldName> == 0)
%endfunction

%% Function: FcnGetCoderGroupForVarGroup ===========================================================
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function FcnGetCoderGroupForVarGroup(varGroup) void
    %assert varGroup.Category == "HierarchicalCoderData"
    %return ::CompiledModel.CoderDataGroup[varGroup.CoderDataGroupIndex]
%endfunction

%% Function: FcnGetCoderGroupVisibility ============================================================
%%
%function FcnGetCoderGroupVisibility(groupIndex)
    %if GenerateClassInterface
        %assign group = ::CompiledModel.CoderDataGroup[groupIndex]
        %assign groupToken = "CoderDataGroup" + group.Name
        %return CPPGroupVisibility.%<groupToken>
    %else
        %return "Public"
    %endif
%endfunction

%% Function: SLibHaveRootDataGroupVarGroup =========================================================
%% Abstract:
%%   Does the root system have a non-empty CoderDataGroup var group of the given name?
%%
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function SLibHaveRootDataGroupVarGroup(group) void
    %assign rootSystemIndex = GetBaseSystemIdx()
    %foreach varGroupIndex = ::CompiledModel.VarGroups.NumVarGroups
        %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIndex]

        %if varGroup.NumVarGroupElements <= 0
            %continue
        %endif
        %if (varGroup.SysIdx == rootSystemIndex) && ...
            (LibGetVarGroupCategory(varGroupIndex) == "HierarchicalCoderData")
            %assign coderGroupIndex = varGroup.CoderDataGroupIndex
            %assign coderGroup = ::CompiledModel.CoderDataGroup[coderGroupIndex]
            %if coderGroup.Name == group.Name
                %return TLC_TRUE
            %endif
        %endif
    %endforeach

    %return TLC_FALSE

%endfunction

%% Function: LibCoderDataGroupStructsAreEmpty ======================================================
%% Abstract:
%%   Does the root system have any CoderDataGroups?
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function LibCoderDataGroupStructsAreEmpty() void
    %foreach idx = ::CompiledModel.NumCoderDataGroups
        %if !LibCoderDataGroupStructIsEmpty(::CompiledModel.CoderDataGroup[idx])
            %return TLC_FALSE
        %endif
    %endforeach
    %return TLC_TRUE
%endfunction

%% Function: SLibCoderDataGroupIndex ===============================================================
%% Abstract:
%%   Return the group index for the specified name
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function SLibCoderDataGroupIndex(groupName) void
    %foreach idx = ::CompiledModel.NumCoderDataGroups
        %assign group = ::CompiledModel.CoderDataGroup[idx]
        %if group.Name == groupName
            %return group.GroupIndex
        %endif
    %endforeach
    %return -1
%endfunction

%% Function: SLibPolymorphicRootCoderDataGroupIndex ================================================
%% Abstract:
%%   Return the group index for the specified name for a polymorhpic group.
%%   If groupName corresponds to the multi-instance implementation and the model is single instance,
%%   return the single instance group index.
%%
%function SLibPolymorphicRootCoderDataGroupIndex(groupName) void
    %foreach idx = ::CompiledModel.NumCoderDataGroups
        %assign group = ::CompiledModel.CoderDataGroup[idx]
        %if group.Name == groupName
            %assign isModelSingleInstance = !SLibMultiInstance()
            %if isModelSingleInstance && ...
                group.IsPolymorphic && ...
                group.ImplementationType == "MultiInstance"
                %return SLibGetSingleInstanceGroupIdx(group)
            %else
                %return group.GroupIndex
            %endif
        %endif
    %endforeach
    %return -1
%endfunction

%% Function: RTMModelPtrsToCoderDataGroupIsReqFcn ==================================================
%% Abstract:
%%   Does the address of the statically declared CoderDataGroup structures need to be
%%   saved in rtModel. This is conditionally saved for simplified reusable call
%%   interface and always saved for classic call interface.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function RTMModelPtrsToCoderDataGroupIsReqFcn(groupIndex) void
    %assign group = ::CompiledModel.CoderDataGroup[groupIndex]
    %if LibCoderDataGroupStructIsEmpty(group) || SLibGetUseRTMcgType()
        %return TLC_FALSE
    %endif
    %if SLibMultiInstance() && ...
        !GenerateClassInterface && ...
        !SLibUseBackwardCompatibleReusableInterface()
        %return TLC_TRUE
    %endif
    %return RTMModelPtrsToInstanceDataIsReqFcn()

%endfunction %%  RTMModelPtrsToRootDWorkIsReqFcn

%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function FcnGetChildDataGroup(group, sid) void
    %foreach idx = SIZE(::CompiledModel.CoderDataGroups.CoderDataGroup, 1)
        %assign coderDataGroup = ::CompiledModel.CoderDataGroups.CoderDataGroup[idx]
        %if (coderDataGroup.UserProvidedName == group.UserProvidedName) && ...
            coderDataGroup.Depth == 1 && ...
            ISFIELD(coderDataGroup, "CompiledModelBlockIndex") && ...
            (coderDataGroup.CompiledModelBlockIndex == sid)
            %return coderDataGroup
        %endif
    %endforeach

    %assert group.IsSelf
    %foreach idx = SIZE(::CompiledModel.CoderDataGroups.CoderDataGroup, 1)
        %if coderDataGroup.IsSelf && ...
            coderDataGroup.Depth == 1 && ...
            ISFIELD(coderDataGroup, "CompiledModelBlockIndex") && ...
            (coderDataGroup.CompiledModelBlockIndex == sid)
            %return coderDataGroup
        %endif
    %endforeach
    %<LibReportFatalError("Should not get here")>
%endfunction

%% Function: SLibIsSelfVarGroup ====================================================================
%function SLibIsSelfVarGroup(aVarGroup) void
    %return ISFIELD(aVarGroup, "IsModelSelfCoderGroupVarGroup") && ...
        aVarGroup.IsModelSelfCoderGroupVarGroup
%endfunction

%% Function: SLibIsSelfCoderGroupVarGroup ==========================================================
%% Abstract:
%%   Check if a vargroup corresponds to a self coder group.
%%   This includes both the model self vargroup and subsystem self vargroups.
%function SLibIsSelfCoderGroupVarGroup(varGroupIdx) void
    %assign aVarGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
    %if !ISFIELD(aVarGroup, "CoderDataGroupIndex")
        %return TLC_FALSE
    %else
        %assign groupIdx = aVarGroup.CoderDataGroupIndex
        %return (groupIdx > -1) && (groupIdx == SLibGetSelfCoderDataGroupIndex())
    %endif
%endfunction

%% Function: SLibIsSelfCoderGroup
%% Abstract:
%%   Given a system index and a coder group index, returns true iff the coder
%%   group for that system is the self coder group for the model.
%%   This implies that the system must be a base system for this function
%%   to return true.
%function SLibIsSelfCoderGroup(sysIdx, coderGroupIdx) void
    %return GetBaseSystemIdx() == sysIdx && ...
        SLibGetDoesSelfHasCoderDataGroup() && ...
        SLibGetSelfCoderDataGroupIndex() == coderGroupIdx
%endfunction

%% Function: SLibIsDeepLearningCoderGroup
%% Abstract:
%%    Given a coder data group, check whether it is synthesized for deep learning.
%function SLibIsDeepLearningCoderGroup(coderGroup) void
    %return ISFIELD(coderGroup, "SynthesizedNamePrefix") && ...
        !ISEMPTY(coderGroup.SynthesizedNamePrefix) && ...
        (coderGroup.SynthesizedNamePrefix == "_DeepLearning")
%endfunction

%% Function: SLibIsAutosarPIMCoderGroup
%% Abstract:
%%    Given a coder data group, check whether it is synthesized for Autosar
%%    PerInstanceMemory.
%function SLibIsAutosarPIMCoderGroup(coderGroup) void
    %return ISFIELD(coderGroup, "SynthesizedNamePrefix") && ...
        !ISEMPTY(coderGroup.SynthesizedNamePrefix) && ...
        (coderGroup.SynthesizedNamePrefix == "_PIM")
%endfunction

%% Function: SLibIsAutosarStaticMemoryCoderGroup
%% Abstract:
%%    Given a coder data group, check whether it is synthesized for Autosar
%%    Static Memory.
%function SLibIsAutosarStaticMemoryCoderGroup(coderGroup) void
    %return ISFIELD(coderGroup, "SynthesizedNamePrefix") && ...
        !ISEMPTY(coderGroup.SynthesizedNamePrefix) && ...
        (coderGroup.SynthesizedNamePrefix == "_VAR")
%endfunction

%% Function: SLibIsAutosarInstPCoderGroup
%% Abstract:
%%    Given a coder data group, check whether it is synthesized for Autosar
%%    PerInstanceParameter.
%function SLibIsAutosarInstPCoderGroup(coderGroup) void
    %return ISFIELD(coderGroup, "SynthesizedNamePrefix") && ...
        !ISEMPTY(coderGroup.SynthesizedNamePrefix) && ...
        (coderGroup.SynthesizedNamePrefix == "_ARPIP")
%endfunction

%% Function: SLibIsAutosarSharedPCoderGroup
%% Abstract:
%%    Given a coder data group, check whether it is synthesized for Autosar
%%    SharedParameter.
%function SLibIsAutosarSharedPCoderGroup(coderGroup) void
    %return ISFIELD(coderGroup, "SynthesizedNamePrefix") && ...
        !ISEMPTY(coderGroup.SynthesizedNamePrefix) && ...
        (coderGroup.SynthesizedNamePrefix == "_ARSP")
%endfunction

%% Function: SLibIsVariantParamBankVarGroup
%% Abstract:
%%    Given a var group, check whether it is created for variant
%%    parameter banks
%function SLibIsVariantParamBankVarGroup(varGroup) void
    %if ISFIELD(varGroup, "BankSize")
        %return (varGroup.BankSize > 0)
    %endif
    %return TLC_FALSE
%endfunction

%% Function: SLibIsVariantParamBankCoderGroup
%% Abstract:
%%    Given a coder data group, check whether it is created for variant
%%    parameter banks
%function SLibIsVariantParamBankCoderGroup(coderGroup) void
    %assign varGrpIdx = SLibGetRootVarGroupIdxForCoderGroup(coderGroup)
    %if varGrpIdx != -1
        %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGrpIdx]
        %return SLibIsVariantParamBankVarGroup(varGroup)
    %endif
    %return TLC_FALSE
%endfunction

%% Function: SLibGetVarGroupIdxForCoderGroup
%% Abstract:
%%   Given a system index and a coder group index, returns the vargroup id
%%   that corresponds to the given system's coder group.
%function SLibGetVarGroupIdxForCoderGroup(sysIdx, coderDataGroupIdx) void
    %assign group = ::CompiledModel.CoderDataGroup[coderDataGroupIdx]
    %assign groupName = group.Name
    %assign groupToken = "CoderDataGroup" + groupName

    %return FcnSysVarGroupIndex(System[sysIdx], groupToken, 0)
%endfunction

%% Function: SLibGetRTMPointerVariableNameInsideSelfStructure()
%% Abstract:
%%   User-defined and legacy RTM can co-exist, in which case, we may have a pointer
%%   to legacy RTM inside the Self structure. This function returns the name of that
%%   pointer variable, if applicable. Otherwise, it returns an empty string.
%function SLibGetRTMPointerVariableNameInsideSelfStructure() void
    %if SLibIsSelfUserDefinedAndStructured()
        %% todo (sr): register and check for clashes in the Self structure
        %return (::CompiledModel.Name + "_" + "rtm" + "_" + "ref")
    %endif

    %return ""
%endfunction

%% Function: SLibCanInlineRTMIntoSelf()
%% Abstract:
%%   Returns true iff coder group self exists and we can inline
%%   legacy RTM content directly inside this self's typedef.
%%   This can only happen if self's memory section is non const.
%function SLibCanInlineRTMIntoSelf() void
    %return SLibGetDoesSelfHasCoderDataGroup() && SLibIsSelfStructured() && ...
        !SLibHasSelfWithConstantMemorySection() && !GenerateClassInterface
%endfunction

%% Function: FcnGetSeparatorForGroup ===============================================================
%% Abstract:
%%   Returns path separator in vargroup initializer
%function FcnGetSeparatorForGroup(group)
    %if group.IsSelf
        %return ""
    %elseif SLibAccessViaPointerInSelf(group)
        %return "->"
    %else
        %return "."
    %endif
%endfunction


%% Function: FcnGetVargroupInitializers ============================================================
%% Abstract:
%%     Return the static and dynamic initializers for the vargroup
%function FcnGetVargroupInitializers(varGroupIndex, path, dynamicInit, symbolic) void
    %createrecord initializer {}
    %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIndex]
    %assign cgTypeIdx = varGroup.CGTypeIdx

    %% Begin vargroup
    %foreach elemIdx = varGroup.NumVarGroupElements
        %assign element = varGroup.VarGroupElements[elemIdx]
        %assign idnum  = IDNUM(element)
        %assign recType = idnum[0]
        %assign recIdx  = idnum[1]
        %switch recType
          %case "LDW"
          %case "W"
          %case "U"
          %case "Y"
          %case "B"
          %case "ZE"
          %case "L"
            %assign dataRec = SLibGetDataRecForVarGroupMember(recType, recIdx)
            %assign cgTypeIdx = LibGetRecordCGTypeIdx(dataRec)
            %% Exclude things like function-call-event signals
            %if SLibEmitRecordInCoderDataGroupStruct(cgTypeIdx)
                %assign value = FcnGetDynamicDataInitFromCGType(cgTypeIdx)
                %addtorecord initializer Elements { Element value }
            %endif
            %break

          %case "P"
            %assign prm = ::CompiledModel.ModelParameters.Parameter[recIdx]
            %if SLibIsParamUnstructured(prm)
                %assert 0
                %continue
            %endif

            %assign prmNetCond = ISFIELD(prm, "VariantCondition") ? prm.VariantCondition : ""
            %assign hasElement = !ISEMPTY(prmNetCond) ? varGroup.HasElement : ""
            %if (SLibGetWidthOfValueFromParamRec(prm) > 0) && !SLibOmitRecord(prm)
                %if symbolic && (prm.TestpointIndex >= 0)
                    %assign modelElement = []
                    %assign modelElement = modelElement + prm.WorkspaceVarName + ::CompiledModel.Name
                    %addtorecord initializer Elements { Element "TP%<prm.TestpointIndex>" NetVarCondFromChild prmNetCond HasElement hasElement ModelElement modelElement}

                    %assign group = FcnGetCoderGroupForVarGroup(::CompiledModel.VarGroups.VarGroup[varGroupIndex])
                    %assign separator = FcnGetSeparatorForGroup(group)
                    %assign dynamicPath = path + separator + LibGetRecordIdentifier(prm)
                    %addtorecord dynamicInit TP%<prm.TestpointIndex> dynamicPath
                %else
                    %assign value = SLibGetFormattedPrmValue(prm, "")
                    %addtorecord initializer Elements { Element value }
                %endif
            %endif
            %break

          %case "PD"
            %addtorecord initializer Elements { Element element }
            %break

          %case "VG"
            %assign fieldName = LibCGTypeMemberName(cgTypeIdx, elemIdx)
            %assign deeperpath = path + "." + fieldName
            %addtorecord initializer Elements { Element FcnGetVargroupInitializers(recIdx, deeperpath, dynamicInit, symbolic) }
            %break

          %case "RTM"
            %assign elemCGTypeIdx = LibCGTypeMemberCGTypeIdx(cgTypeIdx, recIdx)
            %assign value = FcnGetDynamicDataInitFromCGType(elemCGTypeIdx)
            %addtorecord initializer Elements { Element value }
            %break

          %case "PCDG"
            %assign group = FcnGetCoderGroupForVarGroup(varGroup)
            %assign childDataGroup = FcnGetChildDataGroup(group, recIdx)
            %assert childDataGroup.AsStructure == "InParent"
            %assign prmNetCond = ISFIELD(childDataGroup,"NetVariantCondition") ? childDataGroup.NetVariantCondition : ""
            %assign hasElement = !ISEMPTY(prmNetCond) ? varGroup.HasElement : ""
            %addtorecord initializer Elements { Element childDataGroup.Initializer NetVarCondFromChild prmNetCond HasElement hasElement }
            %break

          %case "RCDG"
            %if symbolic
                %addtorecord initializer Elements { Element element }
            %else
                %assign group = ::CompiledModel.CoderDataGroup[recIdx]
                %openfile value
                &(%<SLibCoderDataGroupInstance(group)>)
                %closefile value
                %addtorecord initializer Elements { Element value }
            %endif
            %break

          %case "RVG"
            %openfile value
            %<SLibGetNullDefinitionFromTfl()>
            %closefile value
            %addtorecord initializer Elements { Element value }
            %break

          %case "X"
          %case "XDI"
          %case "DX"
          %case "XAT"
          %case "XPTMIN"
          %case "XPTMAX"
            %% We should not reach this line because local solver CState
            %% coder groups are configured with DataInit = none.
            %% Other (globally controlled) CStates do not use this function either.
            %<LibReportFatalError("Unexepected CState initialization")>
            %break

          %default
            %<LibReportFatalError("Unhandled vargroup initialization")>
            %break
        %endswitch
    %endforeach
    %return initializer
%endfunction

%% Function: FcnGetVarGroupScopedDSMInitializer ====================================================
%% Abstract:
%%     Return the initializer for the vargroup
%function FcnGetVarGroupScopedDSMInitializer(varGroupIndex, scopedDSMs, selfPath, insideForEach) void
    %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIndex]
    %assign cgTypeIdx = varGroup.CGTypeIdx

    %% Begin vargroup
    %foreach elemIdx = varGroup.NumVarGroupElements
        %assign element = varGroup.VarGroupElements[elemIdx]
        %assign idnum  = IDNUM(element)
        %assign recType = idnum[0]
        %assign recIdx  = idnum[1]
        %switch recType
          %case "W"
            %assign dataRec = SLibGetDataRecForVarGroupMember(recType, recIdx)
            %if dataRec.IsDataStoreReference && !SLibOmitRecord(dataRec)
                %% We do not handle DSM reference inside ForEach
                %assert !insideForEach
                %assign headerFile = ""
                %if IsModelRefScalableBuild()
                    %assign headerFile = ::CompiledModel.Name + ".h"
                %endif
                %if CGMODEL_ACCESS("CGModel.IsVariantSupportForScopedDSMOn") != 0
                    %% add variant condition on ref dsm block in tlc record
                    %%TopTester: test/toolbox/simulink/variants/var-dsm-scoped/tScopedDSMBasic.m -testspec:TestPoint_mTopScopedDSM_TwoLayer
                    %assign vcForRefDSM = dataRec.VariantCondition
                    %addtorecord scopedDSMs ScopedDSMs { Name dataRec.DataStoreMemoryName Path selfPath + LibGetRecordIdentifier(dataRec) VariantCondition vcForRefDSM HeaderFile headerFile}
                %else
                    %addtorecord scopedDSMs ScopedDSMs { Name dataRec.DataStoreMemoryName Path selfPath + LibGetRecordIdentifier(dataRec) HeaderFile headerFile}
                %endif
            %endif
            %break

          %case "VG"
            %% Don't recurse for the self vargroup since we'll start at its children anyway
            %if !SLibVarGroupIsSelfGroup(varGroup)
                %assign deeperPath = selfPath
                %if LibCGTypeIsStruct(cgTypeIdx)
                    %assign fieldName = LibCGTypeMemberName(cgTypeIdx, elemIdx)
                    %assign deeperPath = deeperPath + fieldName + "."
                    %<FcnGetVarGroupScopedDSMInitializer(recIdx, scopedDSMs, deeperPath, insideForEach)>
                    %% ForEach will be a matrix type but we don't allow DSM's inside foreach, so no true
                    %% need to recurse into that case. But we will future-proof and assert ForEach has
                    %% no DSM references inside it
                %elseif LibCGTypeIsMatrix(cgTypeIdx)
                    %<FcnGetVarGroupScopedDSMInitializer(recIdx, scopedDSMs, deeperPath, TLC_TRUE)>
                    %% Unhandled case
                %else
                    %assert TLC_FALSE
                %endif
            %endif
            %break

          %default
            %% Do nothing
            %break
        %endswitch
    %endforeach
%endfunction

%% Function: FcnGetDataGroupInitializer ============================================================
%% Abstract:
%%     Return the initializer for the data group
%%TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function FcnGetDataGroupInitializer(group, path, dynamicInit) void
    %if SLibDataGroupStaticInit(group) || group.ContainsInstanceSpecificParameter
        %assign baseSystem = ::CompiledModel.System[GetBaseSystemIdx()]
        %assign varGroupIndex = FcnSysVarGroupIndex(baseSystem, "CoderDataGroup" + group.Name, 0)
        %if varGroupIndex != -1
            %return FcnGetVargroupInitializers(varGroupIndex, path, dynamicInit, ...
                (group.IsInstanceSpecific || group.ContainsInstanceSpecificParameter) && ...
                IsModelReferenceTarget())
        %else
            %return ""
        %endif
    %else
        %return ""
    %endif
%endfunction

%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function SLibHasSelfWithConstantMemorySection() void
    %assign selfCoderGroupIndex = SLibGetSelfCoderDataGroupIndex()
    %if selfCoderGroupIndex == -1
        %return TLC_FALSE
    %else
        %assign selfCoderGroup = ::CompiledModel.CoderDataGroup[selfCoderGroupIndex]
        %return SLibDataGroupMemorySectionConst(selfCoderGroup)
    %endif
%endfunction

%% Toptetser: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function SLibHasSelfWithStaticInit() void
    %assign selfCoderGroupIndex = SLibGetSelfCoderDataGroupIndex()
    %if selfCoderGroupIndex == -1
        %return TLC_FALSE
    %else
        %assign selfCoderGroup = ::CompiledModel.CoderDataGroup[selfCoderGroupIndex]
        %return SLibDataGroupStaticInit(selfCoderGroup)
    %endif
%endfunction

%% Function: SLibRootCoderGroupVarGroupIdx =========================================================
%% Abstract:
%%   Returns the root level VarGroup index for a given CoderGroup.
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function SLibRootCoderGroupVarGroupIdx(group) void
    %assign rootSystemIndex = GetBaseSystemIdx()
    %foreach varGroupIndex = ::CompiledModel.VarGroups.NumVarGroups
        %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIndex]
        %if (varGroup.SysIdx == rootSystemIndex) && ...
            (LibGetVarGroupCategory(varGroupIndex) == "HierarchicalCoderData")
            %assign coderGroupIndex = varGroup.CoderDataGroupIndex
            %assign coderGroup = ::CompiledModel.CoderDataGroup[coderGroupIndex]
            %if coderGroup.Name == group.Name
                %return varGroupIndex
            %endif
        %endif
    %endforeach
    %return -1
%endfunction

%% Function: SLibGetRootVarGroupIdxForCoderGroup ===================================================
%% Abstract:
%%   Returns the root vargroup index for a given Simulink.CoderGroup.
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function SLibGetRootVarGroupIdxForCoderGroup(aGroup) void
    %assign baseSystem = ::CompiledModel.System[GetBaseSystemIdx()]
    %assign varGroupIdx = ...
        FcnSysVarGroupIndex(baseSystem, "CoderDataGroup" + aGroup.Name, 0)
    %assert SLibRootCoderGroupVarGroupIdx(aGroup) == varGroupIdx
    %return varGroupIdx
%endfunction


%% Function: SLibVarGroupForCoderGroup =============================================================
%% Abstract:
%%   Returns a vargroup for a given Simulink.CoderGroup.
%%
%function SLibVarGroupForCoderGroup(aGroup) void
    %assign varGroupIdx = SLibGetRootVarGroupIdxForCoderGroup(aGroup)
    %if 0 > varGroupIdx
        %return []
    %endif
    %return ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
%endfunction

%% Function: SLibCoderGroupPackageAsStruct =========================================================
%% Abstract:
%%   Returns true if a given coder group is implemented as structure.
%% Toptetser: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function SLibCoderGroupPackageAsStruct(aGroup) void
    %assign rootVarGroupIdx = SLibGetRootVarGroupIdxForCoderGroup(aGroup)
    %if -1 < rootVarGroupIdx
        %return SLibVarGroupIsStruct(rootVarGroupIdx)
    %endif
    %return TLC_TRUE
%endfunction

%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function SLibCoderDataGroupNumElements(aGroup) void
    %assign rootVarGroupIdx = SLibGetRootVarGroupIdxForCoderGroup(aGroup)
    %if -1 < rootVarGroupIdx
        %if !SLibVarGroupIsStruct(rootVarGroupIdx)
            %return SLibVarGroupNumElements(rootVarGroupIdx)
        %elseif SLibVarGroupNumElements(rootVarGroupIdx) > 0 ...
            && !LibCoderDataGroupStructIsEmpty(aGroup)
            %return 1
        %endif
    %endif
    %return 0
%endfunction

%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tmMultiRateSubsystem_VC1.m
%%
%function SLibCrossSystemIdxElement(aGroup, idx) void
    %assign rootVarGroupIdx = SLibGetRootVarGroupIdxForCoderGroup(aGroup)
    %assign retVal = -1
    %if -1 < rootVarGroupIdx
        %assign rootVarGroup = ::CompiledModel.VarGroups.VarGroup[rootVarGroupIdx]
        %assign member = rootVarGroup.VarGroupElements[idx]
        %assign idnum = IDNUM(member)
        %switch idnum[0]
          %case "VG"
            %assign childVG = ::CompiledModel.VarGroups.VarGroup[idnum[1]]
            %assign retVal = childVG.SysIdx
            %break
        %endswitch
    %endif
    %return retVal
%endfunction

%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tmMultiRateSubsystem_VC1.m
%%
%function SLibCrossCoderDataGroupElement(aGroup, idx) void
    %assign rootVarGroupIdx = SLibGetRootVarGroupIdxForCoderGroup(aGroup)
    %assign retVal = []
    %if (-1 < rootVarGroupIdx) && !SLibVarGroupIsStruct(rootVarGroupIdx)
        %assign rootVarGroup = ::CompiledModel.VarGroups.VarGroup[rootVarGroupIdx]
        %assign member = rootVarGroup.VarGroupElements[idx]
        %assign idnum = IDNUM(member)
        %switch idnum[0]
          %case "VG"
            %assign childVG = ::CompiledModel.VarGroups.VarGroup[idnum[1]]
            %assign childCDGIdx = ISFIELD(childVG, "CoderDataGroupIndex") ? childVG.CoderDataGroupIndex : -1
            %assign retVal = childCDGIdx > -1 ? ::CompiledModel.CoderDataGroup[childCDGIdx] : []
            %break
          %case "PCDG"
            %assign retVal = FcnGetChildDataGroup(aGroup, idnum[1])
            %break
          %case "RCDG"
            %assign retVal = ::CompiledModel.CoderDataGroup[idnum[1]]
            %break
        %endswitch
    %endif
    %return retVal
%endfunction

%function FcnVarGroupElementIsNonScalarDsmRef(aVarGroupIdx, aElementIdx) void
    %assert SLibVarGroupNumElements(aVarGroupIdx) > aElementIdx
    %assert -1 < aElementIdx
    %assign source = SLibVarGroupElementSource(aVarGroupIdx,aElementIdx)
    %assign idnum = IDNUM(source)
    %if idnum[0] == "W"
        %assign dwRec = ::CompiledModel.DWorks.DWork[idnum[1]]
        %assign width = LibGetRecordSymbolicWidth(dwRec)
        %assign isScalar = (width == "1")
        %return !isScalar && (dwRec.IsDataStoreReference == 1)
    %else
        %return TLC_FALSE
    %endif
%endfunction

%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function SLibCoderDataGroupElementInstance(aGroup, idx) void
    %assign rootVarGroupIdx = SLibGetRootVarGroupIdxForCoderGroup(aGroup)
    %if -1 < rootVarGroupIdx
        %if !SLibVarGroupIsStruct(rootVarGroupIdx)
            %if FcnVarGroupElementIsNonScalarDsmRef(rootVarGroupIdx, idx)
                %return "*" + SLibVarGroupElementName(rootVarGroupIdx, idx)
                %assign cgTypeIdx = SLibVarGroupElementType(rootVarGroupIdx, idx)
            %else
                %assign instance  = SLibVarGroupElementName(rootVarGroupIdx, idx)
                %assign cgTypeIdx = SLibVarGroupElementType(rootVarGroupIdx, idx)
                %return instance + LibCGTypeSymbolicVectorDims(cgTypeIdx)
            %endif
        %endif
    %endif
    %if IsModelRefScalableBuild() && !GenerateClassInterface
        %assign baseSystem = ::CompiledModel.System[GetBaseSystemIdx()]
        %return FcnSysVarGroupNonreusedName(baseSystem, "CoderDataGroup" + aGroup.Name)
    %else
        %return SLibCoderDataGroupInstance(aGroup)
    %endif
%endfunction

%function SLibCoderDataGroupElementReference(aGroup, idx) void
    %assign rootVarGroupIdx = SLibGetRootVarGroupIdxForCoderGroup(aGroup)
    %if -1 < rootVarGroupIdx
        %if !SLibVarGroupIsStruct(rootVarGroupIdx)
            %assign instance  = SLibVarGroupElementName(rootVarGroupIdx, idx)
            %assign cgTypeIdx = SLibVarGroupElementType(rootVarGroupIdx, idx)
            %return instance + LibCGTypeSymbolicVectorDims(cgTypeIdx)
        %endif
    %endif
    %if IsModelRefScalableBuild() && !GenerateClassInterface
        %assign baseSystem = ::CompiledModel.System[GetBaseSystemIdx()]
        %return FcnSysVarGroupNonreusedName(baseSystem, "CoderDataGroup" + aGroup.Name)
    %else
        %return SLibCoderDataGroupReference(aGroup)
    %endif
%endfunction

%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function SLibCoderDataGroupElementBaseType(aGroup, idx) void
    %assign rootVarGroupIdx = SLibGetRootVarGroupIdxForCoderGroup(aGroup)
    %if -1 < rootVarGroupIdx
        %if !SLibVarGroupIsStruct(rootVarGroupIdx)
            %assign cgTypeIdx = SLibVarGroupElementType(rootVarGroupIdx, idx)
            %assign baseType = SLibGetTypeNameFromCGType(cgTypeIdx)
            %if SLibVarGroupElementIsVolatile(rootVarGroupIdx, idx)
                %assign baseType = "volatile " + baseType
            %endif
            %return baseType
        %endif
    %endif
    %return SLibCoderDataGroupType(aGroup)
%endfunction

%function SLibCoderDataGroupElementTypeFilePackagingInfo(aGroup, idx) void
    %% Set the first element to be the CG type index if it's unstructured,
    %% otherwise set the second element as the struct name.
    %assign res = [ -1, "" ]
    %assign rootVarGroupIdx = SLibGetRootVarGroupIdxForCoderGroup(aGroup)
    %if -1 < rootVarGroupIdx
        %if !SLibVarGroupIsStruct(rootVarGroupIdx)
            %assign res[0] = SLibVarGroupElementType(rootVarGroupIdx, idx)
            %return res
        %endif
    %endif
    %if aGroup.IsSelf && SLibCanInlineRTMIntoSelf()
        %assign res[1] = SLibGetFcnDeclarationRTMSymbolName()
    %else
        %assign res[1] = SLibCoderDataGroupType(aGroup)
    %endif
    %return res
%endfunction

%function SLibCoderDataGroupElementInit(aGroup, instanceInit, idx) void
    %assign rootVarGroupIdx = SLibGetRootVarGroupIdxForCoderGroup(aGroup)
    %if TYPE(instanceInit) == "Vector"
        %return instanceInit[idx]
    %endif
    %openfile init
    {
        %<instanceInit>
    }\
    %closefile init
    %return init
%endfunction

%function SLibCoderDataGroupElementDataRecord(aGroup, aElementIdx) void
    %assign rootVarGroupIdx = SLibGetRootVarGroupIdxForCoderGroup(aGroup)
    %if -1 < rootVarGroupIdx
        %assert aElementIdx >= 0 && aElementIdx < SLibVarGroupNumElements(rootVarGroupIdx)
        %assign source = SLibVarGroupElementSource(rootVarGroupIdx,aElementIdx)
        %assign idnum = IDNUM(source)
        %assign recType = idnum[0]
        %assign recIdx = idnum[1]
        %assign dataRec = SLibGetDataRecForVarGroupMember(recType, recIdx)
        %return dataRec
    %endif
%endfunction

%% Function: SLibCoderDataGroupType ================================================================
%% Abstract:
%%     Return the name of the type of the data group
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function SLibCoderDataGroupType(group) void
    %if group.IsSelf && SLibCanInlineRTMIntoSelf()
        %return tSimStructType
    %elseif IsModelReferenceTarget()
        %assign baseSystem = ::CompiledModel.System[GetBaseSystemIdx()]
        %assign groupToken = "CoderDataGroup" + group.Name
        %return FcnSysVarGroupType(baseSystem, groupToken)
    %else
        %assign token = "::tCoderDataGroup" + group.Name + "Type"
        %return %<token>
    %endif
%endfunction

%% Function: FcnIsCoderDataGroupForInternalDataByFunction ==========================================
%% Abstract
%%   Helper function to determine if group created for GroupInternalDataByFunction
%%
%function FcnIsCoderDataGroupForInternalDataByFunction(group) void
    %assign groupIdentification = group.Identification
    %return ISEQUAL(groupIdentification, "Internal Data Grouped For Same Function")
%endfunction

%% Function: FcnIsFuncWithSeparateDataSystem =======================================================
%% Abstract
%%   Helper function to determine if system is nonreusable subsystem with
%%    function with separate data enabled and InterDataCOderDataGroup is
%%    generated for this subsystem.
%%
%function FcnIsFuncWithSeparateDataSystem(group, system) void
    %assign groupName = group.Name
    %assign grouptoken = "CoderDataGroup" + groupName
    %if ISFIELD(system, "SystemIdx") && ...
        LibSystemIsNonReusedFcn(system) && system.StandaloneSubsystem
        %return (system.Has%<grouptoken>Arg && FcnIsCoderDataGroupForInternalDataByFunction(group)) || ...
            !ISEMPTY(system.MemSecDataInternal) && !ISEQUAL(group.MemorySection,  system.MemSecDataInternal)   %% override required
    %endif
    %return TLC_FALSE
%endfunction
%% Function: FcnGetGroupMemSecInfoForCoderGroup ====================================================
%% Abstract
%%   Helper function will return groupMemSecInfo information from group's
%%    memory section information and will override in case of nonreusable subsystem
%%    FcnIsFuncWithSeparateDataSystem is enabled.
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function FcnGetGroupMemSecInfoForCoderGroup(group, system) void
    %createrecord groupMemSecInfo { \
        memSecName group.MemorySection \
        memSecPkg ""  \
        memSecIsLegacy TLC_TRUE \
    }
    %if ISFIELD(group, "MemorySectionPackage")
        %assign groupMemSecInfo.memSecPkg  = group.MemorySectionPackage
    %endif
    %if ISFIELD(group, "MemorySectionIsLegacy")
        %assign groupMemSecInfo.memSecIsLegacy  = group.MemorySectionIsLegacy
    %endif
    %% override System mem sec information for Function with Separate Data
    %if SLibAreInternalMemorySectionsDefined() && FcnIsFuncWithSeparateDataSystem(group, system)
        %assign groupMemSecInfo.memSecPkg =  FcnGetMemSecPkgForSubsystem(system)
        %if !ISEQUAL(system.MemSecDataInternal, "Default")
            %assign groupMemSecInfo.memSecName =  system.MemSecDataInternal
            %assign groupMemSecInfo.memSecIsLegacy  = TYPE(groupMemSecInfo.memSecName) == "String"
        %else
            %assign groupMemSecInfo.memSecName =  ""
        %endif
    %endif
    %return groupMemSecInfo
%endfunction
%% Function: FcnApplyMemSecToDataDefnForGroup ======================================================
%% Abstract
%%   Helper function
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function FcnApplyMemSecToDataDefnForGroup(definition, group, identifier, system, isModelData, isDecl, isFirstElement, isLastElement, ppIf, ppEndIf) void
    %if IsModelReferenceSimTarget() && group.AsStructure == "None"
        %return ""
    %endif
    %% If the group coming in is an InParent child group, need to get to the corresponding group in this model
    %% for the memsec attributes.  This is OK since we insist on the child and parent groups
    %% using identical memory sections
    %if (group.AsStructure == "InParent") && ISFIELD(group, "Depth")
        %assign group = ::CompiledModel.CoderDataGroup[SLibCoderDataGroupIndex(group.Name)]
    %endif
    %assign applyMemSec = FcnApplyMemSec()
    %openfile buffer
    %if !isModelData
        %<SLibIfSystemVariantCondition(system)>\

    %endif

    %assign groupMemSecInfo = FcnGetGroupMemSecInfoForCoderGroup(group, system)
    %assign msName = groupMemSecInfo.memSecName
    %assign msDefn = FcnGetMemSecDefnInfo(groupMemSecInfo.memSecName, groupMemSecInfo.memSecPkg, groupMemSecInfo.memSecIsLegacy)

    %createrecord qualifierInfo { \
        IsConst group.IsMemorySectionConst \
        IsVolatile group.IsMemorySectionVolatile \
        Qualifier group.MemorySectionQualifier \
    }
    %createrecord msInfo { \
        PragmaPerVar msDefn.PragmaPerVar \
        PrePragma msDefn.PrePragma \
        PostPragma msDefn.PostPragma \
        Comment msDefn.Comment \
    }
    %<SLibCreateDefinitionStatement(definition, msInfo, qualifierInfo, ...
        identifier, TLC_TRUE, isDecl, isFirstElement, isLastElement, ppIf, ppEndIf)>

    %if !isModelData
        %<SLibEndIfSystemVariantCondition(system)>\
    %endif
    %closefile buffer
    %return buffer
%endfunction

%% Function: SLibApplyMemSecToDataDefnForGroup =====================================================
%% Abstract
%%   This function creates a data definition.  Rather than inserting a
%%   definition directly, data should now go through this central mechanism
%%   to add memory section things like pragmas, modifiers, etc.  This
%%   function is similar to SLibApplyMemSecToDataDefnForSystem()
%function SLibApplyMemSecToDataDefnForGroup(definition, group, identifier, system, isModelData) void
    %return FcnApplyMemSecToDataDefnForGroup(definition, group, identifier, system, isModelData, TLC_FALSE, TLC_TRUE, TLC_TRUE,"","")
%endfunction

%% Function: SLibApplyMemSecToDataDeclForGroup =====================================================
%% Abstract
%%   This function creates a data declaration.  Rather than inserting a
%%   definition directly, data should now go through this central mechanism
%%   to add memory section things like pragmas, modifiers, etc.  This
%%   function is similar to SLibApplyMemSecToDataDeclForSystem()
%function SLibApplyMemSecToDataDeclForGroup(definition, group, identifier, system, isModelData) void
    %return FcnApplyMemSecToDataDefnForGroup(definition, group, identifier, system, isModelData, TLC_TRUE, TLC_TRUE, TLC_TRUE,"","")
%endfunction

%% Function: SLibTypeQualifierForGroup =============================================================
%% Abstract
%%   This function returns a type qualifier for a group
%function SLibTypeQualifierForGroup(group) void
    %assign applyMemSec = FcnApplyMemSec()
    %if applyMemSec
        %return SLibGetQualifierString(group.MemorySectionQualifier, ...
            group.IsMemorySectionConst, group.IsMemorySectionVolatile)
    %endif
%endfunction

%% Function: SLibCoderDataGroupIsImported ==========================================================
%% Abstract:
%%     Return whether the data group has imported data scope
%function SLibCoderDataGroupIsImported(group) void
    %return group.DataScope == "Imported"
%endfunction

%% Function: SLibStructTypeDefScopeIsImported ======================================================
%% Abstract:
%%     Return whether the data group has imported struct type definition
%function SLibStructTypeDefScopeIsImported(group) void
    %return group.StructTypeDefScope == "Imported"
%endfunction

%% Function: SLibCoderDataGroupIsOpaque ============================================================
%% Abstract:
%%     Return whether the data group has opaque data scope
%function SLibCoderDataGroupIsOpaque(group) void
    %return group.IsOpaque
%endfunction

%% Function: SLibGetCoderDataGroupHeaderFile =======================================================
%% Abstract:
%%     Return the header file name of the coder data group
%%
%function SLibGetCoderDataGroupHeaderFile(group) void
    %assign baseSystem = ::CompiledModel.System[GetBaseSystemIdx()]
    %assign varGroupIndex = FcnSysVarGroupIndex(baseSystem, "CoderDataGroup" + group.Name, 0)

    %assert varGroupIndex != -1

    %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIndex]
    %assign headerFile = varGroup.CoderDataGroupHeaderFile

    %return headerFile
%endfunction

%% Function: SLibCoderDataGroupIsImportedFromFile ==================================================
%% Abstract:
%%     Return whether the data group has imported data scope with a header
%%     file other than model.h
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function SLibCoderDataGroupIsImportedFromFile(group) void
    %if !SLibCoderDataGroupIsImported(group)
        %return TLC_FALSE
    %endif

    %% Get the base system's vargroup and check the header file. If it's not
    %% model.h, then return
    %assign modelNameHeader = ::CompiledModel.Name+".h"
    %assign headerFile = SLibGetCoderDataGroupHeaderFile(group)

    %if headerFile == modelNameHeader
        %return TLC_FALSE
    %else
        %return TLC_TRUE
    %endif
%endfunction

%% Function: SLibIsCoderDataGroupInitializerEmpty ==================================================
%% Abstract:
%%     Return whether the initializer of coder data group should be empty
%%
%function SLibIsCoderDataGroupInitializerEmpty(isImportedFromFile, group) void
    %return isImportedFromFile && !::CompiledModel.GenerateImportedDataGroupsTypes && ...
        !ISEMPTY(SLibGetCoderDataGroupHeaderFile(group))
%endfunction

%% Function: SLibCoderDataGroupInstance ============================================================
%% Abstract:
%%     Return the name of the instance of the data group
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function SLibCoderDataGroupInstance(group) void
    %assign baseSystem = ::CompiledModel.System[GetBaseSystemIdx()]
    %assign varGroupIndex = FcnSysVarGroupIndex(baseSystem, "CoderDataGroup" + group.Name, 0)
    %if varGroupIndex != -1 && (group.IsSelf != 1 || FcnInitializesCoderDataGroupForCpp(group))
        %return ::CompiledModel.VarGroups.VarGroup[varGroupIndex].StructureInstanceName
    %else
        %assign token = "::tCoderDataGroup" + group.Name
        %return %<token>
    %endif
%endfunction

%% Function: SLibCoderDataGroupArgumentName ========================================================
%% Abstract:
%%     Return the name of the argument name of the data group
%%
%function SLibCoderDataGroupArgumentName(group) void
    %assign baseSystem = ::CompiledModel.System[GetBaseSystemIdx()]
    %assign varGroupIndex = FcnSysVarGroupIndex(baseSystem, "CoderDataGroup" + group.Name, 0)
    %if varGroupIndex != -1 && group.IsSelf != 1
        %return ::CompiledModel.VarGroups.VarGroup[varGroupIndex].StructureArgumentName
    %else
        %assign token = "::tCoderDataGroup" + group.Name
        %return %<token>
    %endif
%endfunction

%% Function: SLibCoderDataGroupReference ===========================================================
%% Abstract:
%%     Return the reference name of the data group
%% This function will be called by SLibGetCoderDataGroupVariable() if the data group
%% is multiinstance and has structure InSelf or InParent
%%
%function SLibCoderDataGroupReference(group) void
    %assign baseSystem = ::CompiledModel.System[GetBaseSystemIdx()]
    %assign varGroupIndex = FcnSysVarGroupIndex(baseSystem, "CoderDataGroup" + group.Name, 0)
    %if varGroupIndex != -1 && group.IsSelf != 1
        %return ::CompiledModel.VarGroups.VarGroup[varGroupIndex].StructureReferenceName
    %else
        %assign token = "::tCoderDataGroup" + group.Name
        %return %<token>
    %endif
%endfunction

%% Function: SLibCoderDataGroupRTMFieldName ========================================================
%% Abstract:
%%     Return the name of the field of the data group in the rtM
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function SLibCoderDataGroupRTMFieldName(group) void
    %if ::CompiledModel.SuppressSelf
        %return ""
    %endif

    %if SLibGetDoesSelfHasCoderDataGroup()
        %if SLibAccessViaPointerInSelf(group)
            %assign eleNameOrIndex = "RCDG" + STRING(group.GroupIndex)
        %elseif group.AsStructure == "InSelf"
            %assign eleNameOrIndex = "VG" + STRING(SLibRootCoderGroupVarGroupIdx(group))
        %else
            %return ""
        %endif
        %assign selfVarGroupIdx = SLibGetSelfVarGroupIndex()
        %assign elIdx = SLibGetElementIdxFromVarGroup(selfVarGroupIdx, eleNameOrIndex)
        %% Undefined
        %if -1 == elIdx
            %return "CoderGroup" + group.Name
        %else
            %return SLibVarGroupElementName(selfVarGroupIdx, elIdx)
        %endif
    %else
        %assign rootVarGroupIndex = SLibGetRootVarGroupIdxForCoderGroup(group)
        %if rootVarGroupIndex > -1
            %assign rootVarGroup = ::CompiledModel.VarGroups.VarGroup[rootVarGroupIndex]
            %assert ISFIELD(rootVarGroup, "StructureReferenceName")
            %return rootVarGroup.StructureReferenceName
        %else
            %% Propagated coder data group case
            %return "CoderGroup" + group.Name
        %endif
    %endif
%endfunction

%% Function: SLibDataRecordIsInCoderGroup() =========================================
%% Abstract:
%%  Check if this record has a varGroupIndex and then check if
%%  that belongs to a coderDataGroupVarGroup. Return true if
%%  that is the case.
%function SLibDataRecordIsInCoderGroup(dataRec) void
    %assign coderGroupId = SLibGetCoderGroupIdForDataRecord(dataRec)
    %return coderGroupId != -1 ? TLC_TRUE : TLC_FALSE
%endfunction

%% Function: SLibIsCoderGroupVarGroup
%% Abstract:
%%   Returns true iff the given vargroup maps to a codergroup
%function SLibIsCoderGroupVarGroup(varGroup) void
    %return ISFIELD(varGroup, "Category") && varGroup.Category == "HierarchicalCoderData"
%endfunction

%% Function: SLibGetCoderGroupIdForDataRecord
%% Abstract:
%%  Given a data record, returns the coder group vargroup index.
%%  If no such index can be found, returns -1.
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tmg1317681_2_VC1.m
%%
%function SLibGetCoderGroupIdForDataRecord(dataRec) void
    %if( ISFIELD(dataRec,"VarGroupIdx") )
        %assign varGroupIdx = dataRec.VarGroupIdx[0]
        %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
        %if LibGetVarGroupCategory(varGroupIdx) == "HierarchicalCoderData"
            %assert ISFIELD(varGroup, "CoderDataGroupIndex")
            %return varGroup.CoderDataGroupIndex
        %endif
    %endif
    %return -1
%endfunction

%% Function: SLibIsLegacyStorageClassForDataRecord()  ================
%% Abstract:
%%  This function returns true if a particular data record
%%  belongs to a "Legacy Storage Class" vargroup. This is needed
%%  to help emit default mapping with Custom Storage classes.
%% Toptetser: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tmMultiRateSubsystem_VC1.m
%%
%function SLibIsLegacyStorageClassForDataRecord(dataRec) void
    %if( ISFIELD(dataRec,"VarGroupIdx") )
        %assign varGroupIdx = dataRec.VarGroupIdx[0]
        %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
        %if varGroup.Category == "HierarchicalCoderData"
            %assign group = FcnGetCoderGroupForVarGroup(varGroup)
            %return group.IsLegacyStorageClass
        %endif
    %endif
    %return TLC_FALSE
%endfunction

%% Function: SLibGetDefaultMappedStorageClassForDataRecord()  ================
%% Abstract:
%%  This function returns the storage class name from coderdatagroup,
%%  if a date recod has a HierarchicalCoderData vargroup
%%  This will return a valid storage class name for a modeling element:
%%  1. default mapped to legacy storage class, or
%%  2. individually or default mapped to new storage class
%% Toptetser: test/toolbox/simulink/udd/tSignalObjectOnOutport.m/matFileLoggingWarnings
%%
%function SLibGetStorageClassNameFromCoderDataGroupForDataRecord(dataRec) void
    %if( ISFIELD(dataRec,"VarGroupIdx") )
        %assign varGroupIdx = dataRec.VarGroupIdx[0]
        %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
        %if varGroup.Category == "HierarchicalCoderData"
            %assign group = FcnGetCoderGroupForVarGroup(varGroup)
            %return group.UserProvidedName
        %endif
    %endif
    %return ""
%endfunction

%% Function: SLibGetCoderDataGroupStructForRecord() =========================================
%% Abstract:
%%  Assuming that the dataRec passed in is in a coder data group,
%%  return that coder data group struct name.
%%  This function should only ever be called after calling
%%  SLibDataRecordIsInCoderGroup() above passes true.
%function SLibGetCoderDataGroupStructForRecord(dataRec) void
    %assert SLibDataRecordIsInCoderGroup(dataRec) == TLC_TRUE
    %assign structName = ""
    %if( ISFIELD(dataRec,"VarGroupIdx") )
        %assign varGroupIdx = dataRec.VarGroupIdx[0]
        %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
        %if (LibGetVarGroupCategory(varGroupIdx) == "HierarchicalCoderData" && (varGroup.PackageAsStruct != 0))
            %assign structName = varGroup.Name
        %endif
    %endif
    %return structName
%endfunction

%% Function: SLibEmitRecordInCoderDataGroupStruct() =========================================
%% Abstract:
%%  Assuming that the CGType passed in has proper type, then
%%  we should group the member associated with this type. Some types
%%  like 'fcn_call' should not be emitted. For now this function only
%%  checks for 'fcn_call' type. It could be expanded in future.
%% Toptetser: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tmMultiRateSubsystem_VC1.m
%%
%function SLibEmitRecordInCoderDataGroupStruct(CGTypeIdx) void
    %assign emitRec = TLC_TRUE
    %assign cgType = ::CompiledModel.CGTypes.CGType[CGTypeIdx]
    %if(ISFIELD(cgType,"Name"))
        %if cgType.Name == "fcn_call"
            %assign emitRec = TLC_FALSE
        %endif
    %endif
    %return emitRec
%endfunction

%% Function: FcnAllocatesCoderDataGroupForGrtMalloc ================================================
%% Abstract:
%%    Return true if GRT malloc needs to create a static structure for default initialization
%%
%function FcnAllocatesCoderDataGroupForGrtMalloc(group) void
    %% Never for child groups
    %% Serdes will ignore storage classes and do the initialization through a wrapper
    %return isGRTMallocOnERT() && ...
        !ISFIELD(group, "Depth") && ...
        (group.AsStructure == "InParent") && ...
        (group.IsInstanceSpecific == TLC_TRUE) && ...
        (group.DataScope == "Exported") && ...
        (group.DataInit == "Static") && ...
        !SLibIsGroupSelfCoderGroup(group) && ...
        !ISEQUAL(::CompiledModel.ConfigSet.HardwareBoard,"IBIS-AMI Model")
%endfunction

%% Function: FcnInitializesCoderDataGroupForCpp ====================================================
%% Abstract:
%%    Return true if C++ needs to create a static structure for default initialization
%%
%function FcnInitializesCoderDataGroupForCpp(group) void
    %% Never for child groups
    %return GenerateClassInterface && ...
        !ISFIELD(group, "Depth") && ...
        (group.AsStructure == "InSelf") && ...
        (group.IsInstanceSpecific == TLC_TRUE) && ...
        (group.DataScope == "Exported") && ...
        !SLibIsGroupSelfCoderGroup(group) && ...
        (group.DataInit == "Static")
%endfunction

%% Function: SLibAllocatesCoderDataGroup ===========================================================
%% Abstract:
%%    Return if this model allocates specific data group
%% TopTester: test/toolbox/rtw/targets/AUTOSAR/Variants/tValueVariants.m
%%
%function SLibAllocatesCoderDataGroup(group) void
    %% InstP is never defined by a sub model
    %if IsModelReferenceTarget()
        %return CGMODEL_ACCESS("CGModel.allocatesCoderDataGroupModelRefTarget", ...
            CAST("Boolean", group.IsInstanceSpecific),...
            CAST("Boolean", group.ContainsInstanceSpecificParameter),...
            group.AsStructure)
    %else
        %if FcnAllocatesCoderDataGroupForGrtMalloc(group) ||...
            FcnInitializesCoderDataGroupForCpp(group)
            %return TLC_TRUE
        %elseif (group.IsInstanceSpecific == TLC_TRUE) && ...
            ((group.AsStructure == "InParent") || (group.AsStructure == "Standalone"))
            %return !SLibMultiInstance()
        %else
            %return TLC_TRUE
        %endif
    %endif
%endfunction

%% Function: SLibAllocatesCoderDataGroups ==========================================================
%% Abstract:
%%    Return if this model allocates data groups in general
%function SLibAllocatesCoderDataGroups() void
    %if IsModelReferenceTarget()
        %return !::CompiledModel.OkToMultiInstanceModelref
    %else
        %return !MultiInstanceERTCode
    %endif
%endfunction

%% Function: FcnIsSingleInstanceAccessFunction(group) void
%% Abstract:
%%    Return true if this group is has an access function that is not for teh
%%    data transfer group
%function FcnIsSingleInstanceAccessFunction(group) void
    %return group.HasAccessMethod && !group.IsDataTransferGroup
%endfunction


%% Function: SLibAccessGroupThroughSelf ============================================================
%% Abstract:
%%    Return true if this group is InParent or InSelf or StandAloneMultiInstance
%%    and the model is multi-instance
%function SLibAccessGroupThroughSelf(group) void
    %if FcnIsSingleInstanceAccessFunction(group)
        %return TLC_FALSE
    %endif
    %if !SLibMultiInstance()
        %return TLC_FALSE
    %endif
    %return (SLibAccessViaPointerInSelf(group) || (group.AsStructure == "InSelf"))
%endfunction

%% Function: SLibDataGroupDynamicInit ==============================================================
%% Abstract:
%%    Return true if this group is dynamically initialized
%function SLibDataGroupDynamicInit(group) void
    %assert !ISEMPTY(group)
    %if group.DataInit == "Auto"
        %return  (SLibCoderDataGroupAutoDataInitConversion(group) == "Dynamic")
    %else
        %return (group.DataInit == "Dynamic")
    %endif
%endfunction

%% Function: SLibDataGroupStaticInit ===============================================================
%% Abstract:
%%    Return true if this group is statically initialized
%function SLibDataGroupStaticInit(group) void
    %assert !ISEMPTY(group)
    %if group.DataInit == "Auto"
        %return  (SLibCoderDataGroupAutoDataInitConversion(group) == "Static")
    %else
        %return (group.DataInit == "Static")
    %endif
%endfunction

%% Function: SLibDataGroupNoneInit =================================================================
%% Abstract:
%%    Return true if this group requires no initialization
%function SLibDataGroupNoneInit(group) void
    %assert !ISEMPTY(group)
    %return (group.DataInit == "None")
%endfunction

%% Function: SLibDataGroupMemorySectionConst =======================================================
%% Abstract:
%%    Return true if this group has a constant memory section
%function SLibDataGroupMemorySectionConst(group) void
    %return group.IsMemorySectionConst
%endfunction

%% Function: SLibSuppressRTMDeclaration ============================================================
%% Abstract:
%%  Return true if the RTM declaration should be suppressed.
%%
%function SLibSuppressRTMDeclaration() void
    %assign varGroupIdx = SLibGetSelfCoderDataGroupVarGroupIndex()
    %if -1 < varGroupIdx && !SLibSynthesizedRTM()
        %return !SLibVarGroupIsStruct(varGroupIdx)
    %endif
    %return TLC_FALSE
%endfunction

%% Function: SLibNeedGroupTypesForTesting ==========================================================
%% Abstract:
%%  Return true the model has Imported groups and the
%%  GenerateImportedDataGroupsTypes feature is on.
%%
%function SLibNeedGroupTypesForTesting()
    %assign hasImportedGroups = TLC_FALSE
    %foreach idx = ::CompiledModel.NumCoderDataGroups
        %assign group = ::CompiledModel.CoderDataGroup[idx]
        %if SLibCoderDataGroupIsImported(group)
            %assign hasImportedGroups = TLC_TRUE
            %break
        %endif
    %endforeach
    %return hasImportedGroups && ::CompiledModel.GenerateImportedDataGroupsTypes
%endfunction

%% Function: isDynamicDeclarationRequired_loc ======================================================
%% Abstract:
%%  Helper function to select dynamic coder data groups to be declared within a model. This will also return true
%%  for statically initialized groups when we are externally declaring the group
%%
%function isDynamicDeclarationRequired_loc(prefix,instanceData) void
    %if (instanceData.group.AsStructure == "None" && instanceData.elementDataInit == "Static") || ...
        (instanceData.group.AsStructure != "None" && SLibDataGroupStaticInit(instanceData.group))
        %return TLC_FALSE
    %else
        %assign isAllocatedInCppClass = instanceData.group.AsStructure == "InSelf" && GenerateClassInterface
        %assign AllocateGroup = SLibAllocatesCoderDataGroup(instanceData.group) || isAllocatedInCppClass
        %return AllocateGroup || (prefix == "static")
    %endif
%endfunction

%% Function: isStaticDeclarationRequired_loc =======================================================
%% Abstract:
%%  Helper function to select statically initialized coder data groups to be declared within a model.
%%
%function isStaticDeclarationRequired_loc(prefix,instanceData) void
    %if (instanceData.group.AsStructure == "None" && instanceData.elementDataInit != "Static") || ...
        (instanceData.group.AsStructure != "None" && !SLibDataGroupStaticInit(instanceData.group))
        %return TLC_FALSE
        %% Speical case for declare instP group even when not allocated
    %elseif (prefix == "extern") && instanceData.group.ContainsInstanceSpecificParameter
        %return TLC_TRUE
    %else
        %assign isAllocatedInCppClass = instanceData.group.AsStructure == "InSelf" && GenerateClassInterface
        %assign AllocateGroup = SLibAllocatesCoderDataGroup(instanceData.group) || isAllocatedInCppClass
        %return AllocateGroup || (prefix == "static")
    %endif
%endfunction

%% Function: isDeclarationRequiredForNoneInit_loc ==================================================
%% Abstract:
%%  Helper function to select coder data groups to be declared within a model even if the
%%  data initialization is 'None'.
%%
%function isDeclarationRequiredForNoneInit_loc(instanceData) void
    %return (instanceData.elementDataInit == "None") ...
        && (SLibDataGroupNoneInit(instanceData.group))
%endfunction

%% Function: isImportExportGroupEmitted_loc ========================================================
%% Abstract:
%%  Helper function to filter coder groups based on wheter they are exported or imported (needed for testing purposes)
%%
%function isImportExportGroupEmitted_loc(group,instanceFilter) void
    %if SLibCoderDataGroupIsImportedFromFile(group)
        %return (instanceFilter.Imported == TLC_TRUE)
    %else
        %return (instanceFilter.Exported == TLC_TRUE)
    %endif
%endfunction

%% Function: isAsStructureGroupEmitted =============================================================
%% Abstract:
%%  Helper function to filter coder groups based on their AsStructure property
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function isAsStructureGroupEmitted(group,instanceFilter) void
    %if SLibStandAloneSingleInstance(group) || group.AsStructure == "None"
        %return (instanceFilter.AccessStandalone == TLC_TRUE)
    %elseif group.AsStructure == "InSelf"
        %return (instanceFilter.AccessInSelf == TLC_TRUE)
    %else
        %% Either InParent or multi-instance standalone
        %return (instanceFilter.AccessInParent == TLC_TRUE)
    %endif
%endfunction

%% Function: SLibGenerateOnlyBanked ================================================================
%% Abstract:
%%  Helper function to filter coder groups based on their GenerateOnlyBanked  property
%%  Returns false for non variant bank coder groups, so they are always filtered.
%%
%function SLibGenerateOnlyBanked(group, instanceFilter) void
    %if ISFIELD(instanceFilter, "GenerateOnlyBanked")
        %if (instanceFilter.GenerateOnlyBanked == TLC_TRUE)
            %% return true only for banked coder groups
            %return SLibIsVariantParamBankCoderGroup(group)
        %endif
        %% Do not generate code for coder groups that are not variant banks
        %return TLC_FALSE
    %endif

    %% Generate code for coder groups that are not variant banks
    %return !SLibIsVariantParamBankCoderGroup(group)
%endfunction %% SLibGenerateOnlyBanked

%% Function: FcnCommentCoderGroupElement ===========================================================
%% Abstract:
%%  Return comment for coder group element if usntructured
%function FcnCommentCoderGroupElement(instanceData) void
    %assign rootVarGroupIdx = SLibGetRootVarGroupIdxForCoderGroup(instanceData.group)
    %if (-1 < rootVarGroupIdx) && !SLibVarGroupIsStruct(rootVarGroupIdx)
        %assign varGroup = ::CompiledModel.VarGroups.VarGroup[rootVarGroupIdx]
        %assign idnum = IDNUM(varGroup.VarGroupElements[instanceData.emittedVarIdx])
        %assign recType = idnum[0]
        %assign recIdx  = idnum[1]
        %return SLibGetCommentForVarGroupMember(recType, recIdx)
    %endif
%endfunction

%% Function: FcnClassQualifierForGroup =============================================================
%% Abstract:
%%  Construct class qualifier for a group
%%
%function FcnClassQualifierForGroup(group) void
    %assign classQualifier = ""
    %if GenerateClassInterface
        %if !WHITE_SPACE(::NamespaceName)
            %assign classQualifier = ::NamespaceName + "::"
        %else
            %assign classQualifier = ""
        %endif
        %assign classQualifier = classQualifier + ::CPPClassName + "::"
    %endif
    %return classQualifier
%endfunction

%% Function: SLibConstructDeclarationForStaticInitCoderDataGroupInstance ===========================
%% Abstract:
%%  Construct and returns the declaration of statically initialized data. This is a
%%  worker function for SLibEmitStaticInitCoderDataGroup(...) and, at the point of
%%  refactoring, SLibEmitNoneInitCoderDataGroup(...).
%%
%function SLibConstructDeclarationForStaticInitCoderDataGroupInstance(system,prefix,group,instanceData) void
    %assign declaration = ""
    %assign isExtern = (prefix == "extern")
    %if isExtern
        %% Extern declaration is added after memory section to avoid compiler warnings
        %assign prefix = ""
        %assign init = ""
    %else
        %assign instanceInit = instanceData.group.AsStructure == "InSelf" ? instanceData.group.Initializer : group.Initializer
        %if ISEMPTY(instanceInit)
            %assign init = ""
        %else
            %assign init = " = " + SLibCoderDataGroupElementInit(instanceData.group, instanceInit, instanceData.emittedVarIdx)
        %endif
    %endif
    %openfile declaration
    %assign comment = ""
    %assign comment = FcnCommentCoderGroupElement(instanceData)
    %if !ISEMPTY(init)
        %assign ptrDataInit = SLibGetBusPointerDataInitBuf()
        %if !WHITE_SPACE(ptrDataInit)
            %<ptrDataInit>
        %endif
    %endif
    %if SLibAutosarCompilerAbstractionRequired()
        %<prefix> %<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, instanceData.baseType, TLC_FALSE, TLC_FALSE, instanceData.identifier, "DataGlobal")>%<init>; %<comment>
    %else
        %assert !WHITE_SPACE(instanceData.baseType) && !WHITE_SPACE(instanceData.identifier)
        %% If this CoderGroup is pointer typed with Exported scope,
        %% and this is NOT an extern declaration, create and initialize a
        %% static variable, and initialize the pointer with its address.
        %%
        %% (To support Simulink Real Time Page Switching.)
        %%
        %% TODO:  Permit customization of naming for the implementation variable
        %assign typeQualifier = FcnClassQualifierForGroup(group)
        %assign dataQualifier = ""
        %if !group.IsInstanceSpecific && !SLibIsVariantParamBankCoderGroup(group)
            %assign dataQualifier = typeQualifier
        %endif
        %assign baseType = instanceData.baseType
        %if SLibIsSystemTypesModelClassNamespace(::CompiledModel.System[NumSystems-1]) && !SLibIsVariantParamBankCoderGroup(group)
            %assign baseType = typeQualifier + baseType
        %endif
        %if group.IsPointer && \
            group.DataScope == "Exported" && \
            group.AsStructure == "Standalone"
            %assign varGrpIdx = SLibGetRootVarGroupIdxForCoderGroup(group)
            %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGrpIdx]
            %assign implIdentifier = varGroup.StructureExportedPointerImplName
            %assign arraySize = 0
            %assign activeChoiceIndex = 0
            %if ISFIELD(varGroup, "BankSize")
                %assign arraySize = varGroup.BankSize
            %endif
            %if ISFIELD(varGroup, "ActiveChoiceIndex")
                %assign activeChoiceIndex = varGroup.ActiveChoiceIndex
            %endif
            %if arraySize > 0
                %assign arraySizeStr = "[%<arraySize>]"
                %<baseType> %<implIdentifier>%<arraySizeStr>%<init>; %<comment>
            %else
                %<baseType> %<implIdentifier>%<init>; %<comment>
            %endif
            %% This declaration gets the prefix from the memory section
            %%- we need to prefix the pointer too
            %assign prefix = isExtern ? "extern" : ""
            %if !WHITE_SPACE(init)
                %if arraySize > 0
                    %assign init = " = &%<implIdentifier>[%<activeChoiceIndex>]"
                %else
                    %assign init = " = &%<implIdentifier>"
                %endif
            %endif
        %endif
        %assign ptr = group.IsPointer ? "*" : ""
        %assign definition = ...
            "%<prefix> %<baseType> %<ptr>%<dataQualifier>%<instanceData.identifier>%<init>;"
        %if CGMODEL_ACCESS("CGModel.getCustomDataTraceIsEnabled")
            %<LibGetCppBracedInitStr(definition)> %<comment> \
        %else
            %<LibGetCppBracedInitStr(definition)> %<comment>
        %endif
    %endif
    %closefile declaration
    %return declaration
%endfunction
%% for SLibConstructDeclarationForStaticInitCoderDataGroupInstance


%% Function: SLibEmitStaticInitCoderDataGroup ======================================================
%% Abstract:
%%  Return declaration of staticically initialized data
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function SLibEmitStaticInitCoderDataGroup(system,prefix,group,instanceData) void
    %if isStaticDeclarationRequired_loc(prefix,instanceData)
        %return SLibConstructDeclarationForStaticInitCoderDataGroupInstance(system,prefix,group,instanceData)
    %endif
    %return ""
%endfunction

%% Function: SLibEmitDynamicInitCoderDataGroup =====================================================
%% Abstract:
%%  Return declaration of dynamically initialized data
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function SLibEmitDynamicInitCoderDataGroup(system,prefix,group,instanceData) void
    %assign declaration = ""
    %if prefix == "extern"
        %% Extern declaration is added after memory section to avoid compiler warnings
        %assign prefix = ""
    %endif
    %if isDynamicDeclarationRequired_loc(prefix,instanceData)
        %assign typeQualifier = FcnClassQualifierForGroup(group)
        %assign dataQualifier = ""
        %if !group.IsInstanceSpecific
            %assign dataQualifier = typeQualifier
        %endif
        %assign baseType = instanceData.baseType
        %if SLibIsSystemTypesModelClassNamespace(::CompiledModel.System[NumSystems-1])
            %assign baseType = typeQualifier + baseType
        %endif

        %openfile declaration
        %if SLibAutosarCompilerAbstractionRequired()
            %<prefix> %<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, baseType, TLC_FALSE, TLC_FALSE, instanceData.identifier, "DataGlobal")>;
        %else
            %assert (!WHITE_SPACE(baseType) && !WHITE_SPACE(instanceData.identifier))
            %assign defToEmit = "%<prefix> %<baseType> %<dataQualifier>%<instanceData.identifier>"
            %if instanceData.dataAlignment > 0
                %assign alignSyntax = SLibGetAlignmentSyntax(::CompiledModel.Name, instanceData.identifier, baseType, instanceData.dataAlignment, "DATA_ALIGNMENT_GLOBAL_VAR")
                %assign defToEmit = LibGlobalDefinitionWithAlignment(defToEmit, "", alignSyntax)
            %endif
            %if CGMODEL_ACCESS("CGModel.getCustomDataTraceIsEnabled")
                %<defToEmit>; \
            %else
                %<defToEmit>;
            %endif
        %endif
        %closefile declaration
    %endif
    %return declaration
%endfunction

%% Function: SLibEmitNoneInitCoderDataGroup ========================================================
%% Abstract:
%%  Return declaration of data with 'None' initialization
%%
%function SLibEmitNoneInitCoderDataGroup(system,prefix,group,instanceData) void
    %if isDeclarationRequiredForNoneInit_loc(instanceData)
        %return SLibConstructDeclarationForStaticInitCoderDataGroupInstance(system,prefix,group,instanceData)
    %endif
    %return ""
%endfunction

%% Function: FcnShouldPropagateCoderDataGroup ======================================================
%% Abstract:
%%  Should the coder group be propagated to upper level model?
%%
%function FcnShouldPropagateCoderDataGroup(group, varIdx, isDefinition, recType) void
    %if CGMODEL_ACCESS("CGModel.allowNewStorageClassAtMdlRefIO")
        %assign dataRec = SLibCoderDataGroupElementDataRecord(group, varIdx)
        %assign isBlkOutputDrivingMdlRefRootOutport = (recType == "B") &&...
            ISFIELD(dataRec, "DrivesModelRefRootOutport") &&...
            dataRec.DrivesModelRefRootOutport == "yes"
        %if isDefinition
            %% Model reference root IO with new storage class should be propagated to upper level model
            %% So is the block output signal driving model ref IO, since it virtualizes the outport.
            %if ((recType == "U" || recType == "Y") && IsModelReferenceTarget()) || isBlkOutputDrivingMdlRefRootOutport
                %return TLC_TRUE
            %endif
        %endif
    %endif
    %return TLC_FALSE
%endfunction

%% Function: FcnSkipDeclareCoderDataGroupInstance_loc ==============================================
%% Abstract:
%%  Should we skip declaring an instance for this coder data group element?
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function FcnSkipDeclareCoderDataGroupInstance_loc(system, groupIdx, varIdx, isDefinition) void
    %assign group      = ::CompiledModel.CoderDataGroup[groupIdx]
    %assign baseType   = SLibCoderDataGroupElementBaseType(group, varIdx)
    %assign crossgroup = SLibCrossCoderDataGroupElement(group,varIdx)
    %assert !ISEMPTY(group)
    %if (baseType == "fcn_call") || ...
        (ISFIELD(group, "IsSelf") && group.IsSelf ? ...
        !ISEMPTY(crossgroup) && SLibCoderDataGroupNumElements(crossgroup) == 0 : ...
        SLibCoderDataGroupNumElements(group) == 0)
        %return TLC_TRUE
    %endif
    %if group.AsStructure == "None"
        %assign varGroupIdx = SLibGetVarGroupIdxForCoderGroup(system.SystemIdx, groupIdx)
        %assign varGroupElement = SLibVarGroupElementSource(varGroupIdx, varIdx)
        %assign idnum = IDNUM(varGroupElement)
        %assign recType = idnum[0]
        %if recType != "VG"
            %if FcnShouldPropagateCoderDataGroup(group, varIdx, isDefinition, recType)
                %return TLC_TRUE
            %endif
            %assign needDef = SLibNeedGenDataDefFromVarGroup(varGroupElement, system.SystemIdx)
            %return TLC_FALSE == needDef[0] && WHITE_SPACE(needDef[2])
        %endif
    %endif
    %return TLC_FALSE
%endfunction

%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function FcnVarGroupHeaderFile(varGroup, system) void
    %assign varGroupHeaderFile = SLibGetFileNameWithoutExtension(varGroup.CoderDataGroupHeaderFile)
    %assign useDefaultFile = TLC_FALSE
    %if ISEMPTY(varGroupHeaderFile)
        %assign useDefaultFile = TLC_TRUE
    %elseif (varGroupHeaderFile == CGMODEL_ACCESS("CGModel.System.HeaderFileName", system.SystemIdx)) && ...
        (!SLibIsCoderGroupVarGroup(varGroup) || ...
        FcnGetCoderGroupForVarGroup(varGroup).IsSynthesized)
        %assign useDefaultFile = TLC_TRUE
    %endif
    %if useDefaultFile
        %assign varGroupHeaderFile = ""
    %endif
    %return varGroupHeaderFile
%endfunction

%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function FcnVarGroupDefinitionFile(varGroup, system) void
    %assign varGroupDefinitionFile = SLibGetFileNameWithoutExtension(varGroup.CoderDataGroupDefinitionFile)
    %assign useDefaultFile = TLC_FALSE
    %if ISEMPTY(varGroupDefinitionFile)
        %assign useDefaultFile = TLC_TRUE
    %elseif (varGroupDefinitionFile == CGMODEL_ACCESS("CGModel.System.SourceFileName", system.SystemIdx)) && ...
        (!SLibIsCoderGroupVarGroup(varGroup) || ...
        FcnGetCoderGroupForVarGroup(varGroup).IsSynthesized)
        %assign useDefaultFile = TLC_TRUE
    %endif
    %if useDefaultFile
        %assign varGroupDefinitionFile = ""
    %endif
    %return varGroupDefinitionFile
%endfunction

%function FcnGetVariantConditonFromCoderDataGroupFromVarGroup(varGroup, varIdx)

    %% decide which DataGroup to lookinto by using group-path infrom vargroup
    %if varGroup.Category == "HierarchicalCoderData"

        %% This can be empty if vargroup is not packaged structure
        %if !EXISTS(varGroup.VarGroupElementIds)
            %return ""
        %endif

        %assign varGroupElementIds = varGroup.VarGroupElementIds
        %assign id = varGroup.VarGroupElementIds[varIdx]

        %% find the VariantCondition from ::CompiledModel.CoderDataGroups for the
        %% corresponding Group
        %if EXISTS(::CompiledModel.CoderDataGroups) && ...
            !ISEMPTY(::CompiledModel.CoderDataGroups)
            %foreach idx = SIZE(::CompiledModel.CoderDataGroups.CoderDataGroup, 1)
                %assign group = ::CompiledModel.CoderDataGroups.CoderDataGroup[idx]
                %if group.GroupPath == id
                    %if EXISTS(group.NetVariantCondition)
                        %return group.NetVariantCondition
                    %endif
                %endif
            %endforeach
        %endif
    %endif

    %% If there's no VariantCondition on the CoderGroup, it may be on the record
    %assign dataRec = SLibCoderDataGroupElementDataRecord(FcnGetCoderGroupForVarGroup(varGroup), varIdx)
    %% Actually saw a test failure due to dataRec being empty
    %if ISEMPTY(dataRec)
        %return ""
    %endif
    %return SLibDataGetInlineVariantCondition(dataRec)
%endfunction

%% Apply memory section code to declaration
%function SLibApplyMemorySectionCodeToDeclaration(...
    system, prefix, declaration, group, instanceData, needsHideChild, ...
    varIdx, isFirstElement, lastElementIndex, ppIf, ppEndIf) void
    %if !WHITE_SPACE(declaration)
        %openfile declarationWithMemSection
        %% Data Store References must be made available to ancestor models
        %if needsHideChild
            %<GetHideChildDefineSymbol("ifndef")>\
        %endif
        %assign treatAsModelData = !(SLibIsGroupSelfCoderGroup(group) && group.AsStructure == "None" && instanceData.sysIdx != GetBaseSystemIdx())
        %assign varSys = instanceData.sysIdx > -1 ? ::CompiledModel.System[instanceData.sysIdx] : system
        %<SLibAddPreStructDeclarePragma(instanceData.identifier)>\
        %if IsModelReferenceSimTarget()
            %<prefix> %<declaration>\
        %else
            %<FcnApplyMemSecToDataDefnForGroup(declaration,instanceData.group,instanceData.identifier, varSys, ...
                treatAsModelData, (prefix == "extern"), isFirstElement,(varIdx==lastElementIndex), ppIf, ppEndIf)>\
        %endif
        %<SLibAddPostStructDeclarePragma(instanceData.identifier)>\
        %if needsHideChild
            %<GetHideChildDefineSymbol("endif")>\
        %endif
        %closefile declarationWithMemSection
        %return declarationWithMemSection
    %endif
    %return declaration
%endfunction
%% end of SLibApplyMemorySectionCodeToDeclaration

%% Function: newStorageClassCustomTraceMarker ======================================================
%function newStorageClassCustomTraceMarker(dataRec, newSC) void
    %% <SLibGetModelElemCategoryForIndividualMapping(dataRec)> may assert for zcSignalInfo
    %assign props = ["StorageClass"]
    %assign values = ["%<newSC>"]
    %if ISFIELD(dataRec, "IsSpecifiedAsNewStorageClass") && dataRec.IsSpecifiedAsNewStorageClass
        %assign props = props +  "StorageClassSource"
        %assign values = values + "Individual"
    %endif
    %return SLibAddCustomTraces(props, values)
%endfunction

%% Function: SLibIsCodeCompileNMVCoderGroup ========================================================
%% Abstract:
%%    Returns true if it's a coder group created for normal MATLAB variable.
%%
%function SLibIsCodeCompileNMVCoderGroup(coderGroup) void
    %return ISFIELD(coderGroup, "SynthesizedNamePrefix") && ...
        !ISEMPTY(coderGroup.SynthesizedNamePrefix) && ...
        (coderGroup.SynthesizedNamePrefix == "_CCVariants")
%endfunction

%% Function: SLibIsStartupNMVCoderGroup ============================================================
%% Abstract:
%%   Returns true if this is the startup coder group StartupVariants.
%%
%% TopTester: test/toolbox/simulink/variants/var-startup/tEnumsWithStartup.m
%function SLibIsStartupNMVCoderGroup(coderGroup) void
    %return ISFIELD(coderGroup, "SynthesizedNamePrefix") && ...
        !ISEMPTY(coderGroup.SynthesizedNamePrefix) && ...
        (coderGroup.SynthesizedNamePrefix == "_STVariants")
%endfunction


%% Function: SLibAddSharedCoderGroupDataToFileMap
%% Abstract:
%%   Adds declaration to objInfo array for  emitting code in shared location.
%%
%function SLibAddSharedDataToObjInfo(objInfoArr, group, instanceData, groupBuffer, externFileName) void
    %createrecord objCSCMSPackage { PackageName      "Simulink"; ...
        MemSecName       group.MemorySection; ...
        MemSecComment    ""; ...
        MemSecAddPragma  TLC_FALSE; ...
        MemSecPrepragma  ""; ...
        MemSecPostpragma ""; ...
        CSCName          group.Name; ...
        CSCComment       ""}

    %assign objInfoArr.NumInfo = objInfoArr.NumInfo + 1

    %assign baseType = instanceData.baseType
    %addtorecord objInfoArr objInfo { name instanceData.identifier; ...
        kind         "datadecl"; ...
        manglename   instanceData.identifier; ...
        file         externFileName; ...
        checksum     ""; ...
        definition   "%<groupBuffer>"; ...
        dependencies baseType; ...
        builtin      "0"; ...
        isComplex    "0"; ...
        isExclusive  "0"; ...
        isMultiword  "0"; ...
        isNonfiniteLiteral "0"; ...
        standardTypesHeaders SLibCoderBasicTypesFilenames(); ...
        aliasedType  ""; ...
        isVariantControl "0"}

    %addtorecord objInfoArr.objInfo[objInfoArr.NumInfo-1] cscmemsec { ...
        PackageName      objCSCMSPackage.PackageName; ...
        MemSecName       objCSCMSPackage.MemSecName; ...
        MemSecComment    objCSCMSPackage.MemSecComment; ...
        MemSecAddPragma  objCSCMSPackage.MemSecAddPragma; ...
        MemSecPrepragma  objCSCMSPackage.MemSecPrepragma; ...
        MemSecPostpragma objCSCMSPackage.MemSecPostpragma; ...
        CSCName          objCSCMSPackage.CSCName; ...
        CSCComment       objCSCMSPackage.CSCComment}

    %<SLibAddGeneratedFileToList(externFileName,"utility","header","")>
%endfunction %% SLibAddSharedDataToObjInfo


%% Function: SLibDeclareInstancesForOneCoderDataGroup_loc ==========================================
%% Abstract:
%%  For specified Coder Data Group, declare data based on supplied emit functions
%%
%function SLibDeclareInstancesForOneCoderDataGroup_loc(system,prefix,emitFunctions,instanceFilter, objInfoArr, groupIdx) void
    %assign returnBuffer = ""
    %assign externDecl = (prefix == "extern")
    %assign isDefinition = prefix != "extern"
    %assign group = ::CompiledModel.CoderDataGroup[groupIdx]
    %assign numVars = SLibCoderDataGroupNumElements(group)

    %% Generate no code if the group has no data
    %if numVars == 0
        %return
    %endif
    %if SLibIsCodeCompileNMVCoderGroup(group)
        %% Declaration of the normal MATLAB variables in _CCVariants coder group
        %% will be done through direct emission with sl_variants_emission_plugin
        %% plugin.
        %assign ::CompiledModel.IsCCNMVParamExist = TLC_TRUE
        %return
    %endif
    %if SLibIsStartupNMVCoderGroup(group)
        %% Declaration of the normal MATLAB variables in StartupVariants coder group
        %% will be done through direct emission with sl_variants_emission_plugin
        %% plugin.
        %return
    %endif
    %% Prescreen data groups based on traits independent of group properties like static/dynamic init,
    %% Generate no code if the group is opaque
    %if group.IsOpaque
        %return
    %endif
    %% Skip if AsStructure excluded from filter
    %if !isAsStructureGroupEmitted(group,instanceFilter)
        %return
    %endif
    %% Skip banked variant parameters if excluded from filter
    %if !SLibGenerateOnlyBanked(group, instanceFilter)
        %return
    %endif
    %% Skip if a legacy group because a legacy infrastructure declares and defines such data
    %if group.IsLegacyStorageClass
        %return
    %endif
    %% Skip if imported/exported excluded from filter
    %if !isImportExportGroupEmitted_loc(group,instanceFilter)
        %return
    %endif
    %% Skip model data group according to setting in filter
    %if (SLibIsGroupSelfCoderGroup(group) && (instanceFilter.SkipModelData == TLC_TRUE))
        %return
    %endif
    %% Skip if InSelf, dynamic and inside structured rtM
    %if (group.AsStructure == "InSelf" && ...
        SLibDataGroupDynamicInit(group) && ...
        (SLibIsSelfStructured() || ...
        !SLibGetUseRTMcgType() && !ISEMPTY(SLibCoderDataGroupRTMFieldName(group)) && !GenerateClassInterface))
        %return
    %endif
    %assign varGroupIdx = SLibGetVarGroupIdxForCoderGroup(system.SystemIdx, groupIdx)
    %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]


    %assign varGroupHeaderFile = FcnVarGroupHeaderFile(varGroup, system)
    %assign varGroupDefinitionFile = FcnVarGroupDefinitionFile(varGroup, system)

    %assign emitComment = TLC_TRUE
    %assign isFirstElement = TLC_TRUE
    %assign lastElementIndex = 0
    %foreach varIdx = numVars
        %if !FcnSkipDeclareCoderDataGroupInstance_loc(system, groupIdx, varIdx, isDefinition)
            %assign lastElementIndex = varIdx
        %endif
    %endforeach

    %% This flag will be used later by SLibApplyMemorySectionCodeToDeclaration
    %% to determine if generated declarations will be guarded by *_MDLREF_HIDE_CHILD_
    %assign needsHideChild = ...
        !IsRemoveHideChildFeatureOn() && ...
        (prefix == "extern") && ...
        CGMODEL_ACCESS("CGModel.isCoderDataGroupVarHiddenFromParent", ...
        CAST("Boolean", SLibCoderGroupHasDataStoreReference(group)))

    %assign emittedVarIdx = 0
    %foreach varIdx = numVars
        %assign declarationWithMemSection = ""
        %assign crossgroup = SLibCrossCoderDataGroupElement(group,varIdx)
        %if !ISEMPTY(crossgroup) &&  crossgroup.AsStructure == "InSelf" && ...
            group.IsSelf && SLibGetDoesSelfHasCoderDataGroup()
            %assert !SLibIsSelfStructured()
            %continue %% crossgroup already emitted
        %endif

        %assign elementDataInit = group.DataInit
        %if elementDataInit == "Auto"
            %assign memberElement = varGroup.VarGroupElements[varIdx]
            %assign idnum = IDNUM(memberElement)
            %assign recType = idnum[0]
            %assign elementDataInit = SLibVargroupElementAutoDataInitConversion(recType)
        %endif

        %% filter out fcn_call port types and empty coder data groups
        %if FcnSkipDeclareCoderDataGroupInstance_loc(system, groupIdx, varIdx, isDefinition)
            %continue
        %endif

        %% create closure of group instance specific data to stabilize emit function interfaces
        %if group.AsStructure == "InSelf" && GenerateClassInterface
            %assign groupIdentifier = SLibCoderDataGroupElementReference(group, varIdx)
        %else
            %assign groupIdentifier = SLibCoderDataGroupElementInstance(group, varIdx)
        %endif

        %% create instance data to emit
        %assign dataRec = SLibCoderDataGroupElementDataRecord(group, varIdx)
        %if !ISEMPTY(dataRec) && ISFIELD(dataRec, "Alignment")
            %assign alignmentVal = dataRec.Alignment
        %else
            %assign alignmentVal = -1
        %endif

        %createrecord instanceData { \
            emittedVarIdx emittedVarIdx \
            identifier groupIdentifier \
            baseType   SLibCoderDataGroupElementBaseType(group, varIdx) \
            sysIdx     SLibCrossSystemIdxElement(group, varIdx) \
            group      ISEMPTY(crossgroup)?group:crossgroup \
            elementDataInit elementDataInit \
            dataAlignment  alignmentVal \
        }
        %addtorecord instanceData groupToken "CoderDataGroup"+instanceData.group.Name
        %assign varElementVariantCond = FcnGetVariantConditonFromCoderDataGroupFromVarGroup(varGroup, varIdx)
        %assign ppIf = SLibIfVariantConditionForm(varElementVariantCond)
        %assign ppEndif = SLibEndIfVariantConditionForm(varElementVariantCond)

        %% cycle through emit functions to get declaration
        %assign emitted = TLC_FALSE
        %foreach fcnIdx = SIZE(emitFunctions,1)
            %assign tmpBuf = %<emitFunctions[fcnIdx]>(system,prefix,group,instanceData)
            %if !WHITE_SPACE(tmpBuf) && !emitted
                %if !ISEMPTY(dataRec) && CGMODEL_ACCESS("CGModel.getCustomDataTraceIsEnabled")
                    %assign customTraceMark = newStorageClassCustomTraceMarker(dataRec, group.Name)
                    %assign tmpBuf = SLibAddBlockTraceForDeclarationFromDataRec(dataRec, tmpBuf)
                %endif
                %assign tmpBuf = SLibApplyMemorySectionCodeToDeclaration(...
                    system, prefix, tmpBuf, group, instanceData, needsHideChild, ...
                    varIdx, isFirstElement, lastElementIndex, ...
                    ppIf, ppEndif)
                %assign declarationWithMemSection = declarationWithMemSection + tmpBuf + "\n"
                %assign emitted = TLC_TRUE
            %endif
        %endforeach

        %% Update the header/definition file if a sub vargroup and None
        %assign headerFile = varGroupHeaderFile
        %assign definitionFile = varGroupDefinitionFile
        %if group.AsStructure == "None"
            %assign member = varGroup.VarGroupElements[varIdx]
            %assign idnum = IDNUM(member)
            %if idnum[0] == "VG"
                %assign childVG = ::CompiledModel.VarGroups.VarGroup[idnum[1]]
                %if SLibIsCoderGroupVarGroup(childVG)
                    %assign headerFile = FcnVarGroupHeaderFile(childVG, system)
                    %assign definitionFile = FcnVarGroupDefinitionFile(childVG, system)
                %endif
            %endif
        %endif

        %% If this model is multi-instance top, and group is accessed through self,
        %% ignore the definition file, let be returned to declare/define nominally
        %if MultiInstanceERTCode && !IsModelReferenceTarget() && SLibAccessGroupThroughSelf(group)
            %assign headerFile = ""
            %assign definitionFile = ""
        %endif

        %% Cache declaration/definition
        %if !WHITE_SPACE(declarationWithMemSection)
            %% emit comment if we either are switching coder groups within the group or this is the first emitted var
            %assign comment = (emitComment || !ISEMPTY(crossgroup)) ? "/* "+instanceData.group.Identification+" */\n" : ""
            %% reset comment emission switch based on if we changed groups from the parent group
            %assign emitComment = !ISEMPTY(crossgroup)
            %assign emitToTestBuffer = (instanceFilter.EmitToTestBuffer == TLC_TRUE)
            %assign fileName = ""
            %assign declarationWithMemSection = comment + declarationWithMemSection
            %if isDefinition && !ISEMPTY(definitionFile) && !emitToTestBuffer
                %assign defFile = SLibAddModelFile("SystemBody", "Simulink", definitionFile)
                %<SLibSetModelFileAttribute(defFile, "Definitions", declarationWithMemSection)>
                %<SLibSetModelFileAttribute(defFile, "Group", "data")>
                %assign modelHeader = SLibGetFileNameForCode("mdl_hdr") + ".h"
                %<FcnAddDependentHeaderForCoderGroup(defFile,modelHeader)>
                %assign fileName = definitionFile + "." + ::LangFileExt
            %elseif !isDefinition && !ISEMPTY(headerFile) && group.DataScope != "Imported" && !emitToTestBuffer
                %assign memberElement = varGroup.VarGroupElements[varIdx]
                %assign traceMarker = SLibAddTrace2("ModelElemCategory", SLibGetModelElemCategory(memberElement), "StorageClass", instanceData.group.UserProvidedName)
                %assign declarationWithMemSection = SLibTraceBegin(traceMarker) + declarationWithMemSection + SLibTraceEnd(traceMarker)

                %if SLibIsSharedVarGroup(varGroup)
                    %assign fileName = headerFile + ".h"
                    %<SLibAddSharedDataToObjInfo(objInfoArr, group, instanceData, declarationWithMemSection, fileName)>
                %else
                    %% Write content into headerFile even if it is guarded by _MDLREF_HIDE_CHILD_ macro
                    %% because headerFile is explictly defined
                    %assign fileName = headerFile + ".h"
                    %assign declFile = SLibAddModelFile("SystemHeader", "Simulink", headerFile)
                    %<SLibSetModelFileAttribute(declFile, "Declarations", declarationWithMemSection)>
                    %<SLibSetModelFileAttribute(declFile, "Group", "data")>
                %endif
            %else
                %assign returnBuffer = returnBuffer + declarationWithMemSection
            %endif
            %if ISEMPTY(fileName) && !ISEMPTY(::CurrentBufferFileName)
                %assign fileName = ::CurrentBufferFileName
            %endif
            %if !ISEMPTY(fileName)
                %assign identifier = FcnGetIdentifierFromFullPath(instanceData.identifier)
                %if isDefinition
                    %<SLibUpdateLocalSymbolTableForFile(fileName, identifier)>
                %else
                    %<SLibUpdateGlobalSymbolTableForFile(fileName, identifier)>
                    %assign filePackagingInfo = SLibCoderDataGroupElementTypeFilePackagingInfo(group, varIdx)
                    %if filePackagingInfo[0] >= 0
                        %<SLibUpdateCGTypeUsedByFile(fileName, filePackagingInfo[0])>
                    %else
                        %<SLibUpdateLocalSymbolTableForFile(fileName, filePackagingInfo[1])>
                    %endif
                %endif

                %% include model_types.h if there is variant condition
                %if !ISEMPTY(varElementVariantCond) && SLibGenModelTypesFile()
                    %assign incHeaderFile = SLibGetFileNameForCode("data_simulink_variant_define") + ".h"
                    %<SLibUpdateHeadersNeededByFile(fileName, incHeaderFile)>
                %endif
            %endif
        %endif
        %assign isFirstElement = TLC_FALSE

        %assign emittedVarIdx = emittedVarIdx + 1
    %endforeach /% numVars %/

    %return returnBuffer
%endfunction /% SLibDeclareInstancesForOneCoderDataGroup_loc %/

%% Function: SLibDeclareCoderDataGroupInstances_loc ================================================
%% Abstract:
%%  Loop through Coder Data Groups and declare data based on supplied emit functions
%%
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function SLibDeclareCoderDataGroupInstances_loc(system,prefix,emitFunctions,instanceFilter, objInfoArr) void
    %assign returnBuffer = ""

    %foreach groupIdx = ::CompiledModel.NumCoderDataGroups
        %assign returnBuffer = returnBuffer + ...
            SLibDeclareInstancesForOneCoderDataGroup_loc(system,prefix,emitFunctions,instanceFilter, objInfoArr, groupIdx)
    %endforeach /% ::CompiledModel.NumCoderDataGroups %/

    %return returnBuffer
%endfunction /% SLibDeclareCoderDataGroupInstances_loc %/

%% Function: SLibDeclareCoderDataGroupsEmitfunctions_loc ===========================================
%% Abstract:
%%  Generates emit functions based on information from InstanceFilter
%function SLibDeclareCoderDataGroupsEmitfunctions_loc(InstanceFilter) void
    %assign emitFunctions = ""
    %assign comma = ""

    %if (InstanceFilter.Static == TLC_TRUE)
        %assign emitFunctions = emitFunctions+comma+"\"SLibEmitStaticInitCoderDataGroup\""
        %assign comma = ","
    %endif
    %if (InstanceFilter.Dynamic == TLC_TRUE)
        %assign emitFunctions = emitFunctions+comma+"\"SLibEmitDynamicInitCoderDataGroup\""
        %assign comma = ","
    %endif
    %if (InstanceFilter.NoneInit == TLC_TRUE)
        %assign emitFunctions = emitFunctions+comma+"\"SLibEmitNoneInitCoderDataGroup\""
        %assign comma = ","
    %endif
    %return [%<emitFunctions>]
%endfunction %% SLibDeclareCoderDataGroupsEmitfunctions_loc

%% Function: SLibDeclareCoderDataGroupsWObjInfo ====================================================
%% Abstract:
%%  Generates coder data group declarations to objInfo array for shared coder groups
%function SLibDeclareCoderDataGroupsWObjInfo(system,prefix,InstanceFilter, objInfoArr) void
    %assign emitFunctions = SLibDeclareCoderDataGroupsEmitfunctions_loc(InstanceFilter)
    %return SLibDeclareCoderDataGroupInstances_loc(system,prefix,[%<emitFunctions>],InstanceFilter, objInfoArr)
%endfunction %% SLibDeclareCoderDataGroupsWObjInfo

%% Function: SLibDeclareCoderDataGroupInstances ====================================================
%% Abstract:
%%  Return declaration of both static and dynamic initialized coder data groups
%% Filter supplied can specify what type of data group
%%   - Dynamic: dynamic initialized groups
%%   - Static: static initialized groups
%%   - NoneInit: groups with None data init that should be extern declared
%%   - Imported: imported groups not in model.h
%%   - Exported: exported groups and imported groups in model.h
%%   - AccessStandalone: groups with AsStructure set to Standalone
%%   - AccessInSelf: groups with AsStructure set to InSelf
%%   - AccessInParent: groups with AsStructure set to InParent
%%   - SkipModelData: suppress code for self data group
%%   - EmitToTestBuffer: emit code to test buffers
%%   - GenerateOnlyBanked: emit code only for banked coder data groups
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function SLibDeclareCoderDataGroupInstances(system,prefix,InstanceFilter) void
    %createrecord objInfoArr { NumInfo 0 }
    %return SLibDeclareCoderDataGroupsWObjInfo(system, prefix, InstanceFilter, objInfoArr)
%endfunction %% SLibDeclareCoderDataGroupInstances

%% Function: SLibDeclareCoderDataGroupInstancesInPrivate ===========================================
%% Abstract:
%% This function should only be called when RemoveMdlrefHideChild feature on.
%% This function works similar as SLibDeclareCoderDataGroupInstances except that
%% it only generates instances for groups that will/will not be dumped to model private file
%% based on the value of inPrivate
%function SLibDeclareCoderDataGroupInstancesInPrivate(system,prefix,InstanceFilter, inPrivate) void
    %assert IsRemoveHideChildFeatureOn()

    %createrecord objInfoArr { NumInfo 0 }
    %assign emitFunctions = SLibDeclareCoderDataGroupsEmitfunctions_loc(InstanceFilter)
    %assign returnBuffer = ""

    %foreach groupIdx = ::CompiledModel.NumCoderDataGroups
        %assign group = ::CompiledModel.CoderDataGroup[groupIdx]
        %assign isInPrivate = ...
            (prefix == "extern") && ...
            CGMODEL_ACCESS("CGModel.dumpCoderDataGroupVarIntoPrivateFile", ...
            CAST("Boolean", SLibCoderGroupHasDataStoreReference(group)), ...
            CAST("Boolean", group.IsSynthesized))

        %if isInPrivate == inPrivate
            %assign returnBuffer = returnBuffer + ...
                SLibDeclareInstancesForOneCoderDataGroup_loc(system,prefix,emitFunctions,InstanceFilter, objInfoArr, groupIdx)
        %endif
    %endforeach /% ::CompiledModel.NumCoderDataGroups %/

    %return returnBuffer
%endfunction %% SLibDeclareCoderDataGroupInstancesWithGuard

%function SLibStandAloneMultiInstance(group) void
    %return (group.AsStructure == "Standalone") && ...
        group.IsInstanceSpecific && SLibMultiInstance()
%endfunction

%function SLibStandAloneSingleInstance(group) void
    %return (group.AsStructure == "Standalone") && ...
        (!group.IsInstanceSpecific || !SLibMultiInstance())
%endfunction

%function SLibAccessViaPointerInSelf(group) void
    %if !SLibMultiInstance()
        %return TLC_FALSE
    %else
        %return (group.AsStructure == "InParent") || SLibStandAloneMultiInstance(group)
    %endif
%endfunction

%% Function: SLibGetSingleInstanceGroupIdx =========================================================
%% Abstract: Given a group, return the corresponding group's index with single-instance
%%           implementation and same user provided name as the given group.
%function SLibGetSingleInstanceGroupIdx(aGroup)
    %if aGroup.ImplementationType == "SingleInstance"
        %return aGroup.GroupIndex
    %endif
    %if aGroup.IsPolymorphic
        %foreach idx = ::CompiledModel.NumCoderDataGroups
            %assign group = ::CompiledModel.CoderDataGroup[idx]
            %if group.UserProvidedName == aGroup.UserProvidedName && ...
                group.ImplementationType == "SingleInstance"
                %return idx
            %endif
        %endforeach
    %endif
    %return -1
%endfunction

%% Function: FcnSetServiceDataGroupElements
%% Abstract:
%%   Adds message serice info into coder data group info
%function FcnSetServiceDataGroupElements(groupToken, baseIdx, groupIdx) void
    %assign varGroupIdx = FcnSysVarGroupIndex(::CompiledModel.System[baseIdx], groupToken, 0)
    %assign aVarGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
    %assign numElements = aVarGroup.NumVarGroupElements
    %assign elemIdx = 0
    %foreach eIdx = numElements
        %assign varGroupElement = aVarGroup.VarGroupElements[eIdx]
        %assign idnum = IDNUM(varGroupElement)
        %assign recType = idnum[0]
        %assign recIdx  = idnum[1]
        %if recType == "W"
            %assign dataRec = SLibGetDataRecForVarGroupMember(recType, recIdx)
            %if dataRec.Name == "CompMsgService" && dataRec.SigSrc[0] >= 0 && dataRec.SigSrc[2] >= 0 %% not virtual
                %assign ownerBlk = ...
                    ::CompiledModel.System[dataRec.SigSrc[0]].Block[dataRec.SigSrc[2]]
                %%BlockHierarchyMap.Subsystem[dataRec.SigSrc[0]].Block[dataRec.SigSrc[2]]
                %assign aSID = ownerBlk.SID
                %assign blkName = ownerBlk.Name
                %assign numDworks = ownerBlk.NumDWork
                %foreach dIdx = numDworks
                    %assign thisDwork = ownerBlk.DWork[dIdx]
                    %if thisDwork.Name == "CompMsgService"
                        %assign name = thisDwork.Name
                        %assign dworkIdx = thisDwork.FirstRootIdx
                        %addtorecord ::CompiledModel.CoderDataGroups.CoderDataGroup[groupIdx] GroupElement { \
                            BlockName blkName; \
                            BlockSID aSID; \
                            DWorkName name; \
                            DWorkIdx dworkIdx \
                        }
                    %endif
                %endforeach
            %endif
        %endif
    %endforeach
%endfunction

%% Function: SLibNonEmptyParamCoderGroupExists
%% Abstract:
%%   Returns true iff atleast one parameter coder group exists
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants6.m
%%
%function SLibNonEmptyParamCoderGroupExists() void
    %if ::CompiledModel.NumCoderDataGroups <= 0
        %return TLC_FALSE
    %endif
    %foreach varGroupIndex = ::CompiledModel.VarGroups.NumVarGroups
        %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIndex]
        %if varGroup.NumVarGroupElements <= 0
            %continue
        %endif
        %if SLibIsCoderGroupVarGroup(varGroup)
            %assign coderGroupIndex = varGroup.CoderDataGroupIndex
            %assign coderGroup = ::CompiledModel.CoderDataGroup[coderGroupIndex]
            %if SLibDataGroupStaticInit(coderGroup)
                %return TLC_TRUE
            %endif
        %endif
    %endforeach
    %return TLC_FALSE
%endfunction

%function shouldInitializeSignalObject(dataRec) Output
    %return ISFIELD(dataRec, "InitialValue") && !ISEMPTY(dataRec.InitialValue) && ...
        (dataRec.RecordType == "ExternalInput" || dataRec.RecordType == "ExternalOutput" || dataRec.RecordType == "BlockOutput") && ...
        (!ISFIELD(dataRec, "TID") || TYPE(dataRec.TID) == "Number" || dataRec.TID != "constant")
%endfunction

%function InitializeDataObjectWithCustomInitialValue(extInp, varName) void
    %if !FcnSkipDataInitialValueInReg(extInp)
        %%
        %% InitialValue are provided for non-imported-storage-class
        %% signals that have signal object InitialValue applied on them
        %%
        %assign initValue = extInp.InitialValue
        %if SLibRemoveZeroInitForData(extInp, initValue)
            %return
        %endif
        %%
        %if extInp.StorageClass == "Auto"
            %% Make sure the extInp is marked as accessed
            %<SLibAccessArgHelper(extInp,"","")>
            %if SLibDataRecordIsInCoderGroup(extInp)
                %assign coderGroupId = ...
                    SLibGetCoderGroupIdForDataRecord(extInp)
                %<SLibCG_TrackCoderDataGroup(GetBaseSystemIdx(), ...
                    coderGroupId)>
            %endif
        %endif
        %%
        %return FcnInitDataInitialValue(extInp, varName)
    %endif
%endfunction


%% Function: SLibInitializeUnstructuredGroup =======================================================
%% Abstract:
%%  Given an unstructured coder group, initializes its elements.
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function SLibInitializeUnstructuredGroup(aGroupIdx) void
    %assign group = ::CompiledModel.CoderDataGroup[aGroupIdx]
    %assign rootVarGroupIdx = SLibGetRootVarGroupIdxForCoderGroup(group)
    %if rootVarGroupIdx < 0
        %return ""
    %endif

    %assign varGroup = ::CompiledModel.VarGroups.VarGroup[rootVarGroupIdx]

    %assert !varGroup.PackageAsStruct

    %assign skipGroup = ...
        group.AsStructure != "None" || ...
        group.DataInit == "Static" || ...
        group.DataInit == "None" || ...
        group.DataScope == "Imported"
    %if skipGroup
        %return ""
    %endif

    %openfile buff

    %assert varGroup.NumVarGroupElements == SIZE(varGroup.VarGroupElements, 1)
    %assert varGroup.NumVarGroupElements == SIZE(varGroup.VarGroupElementIds, 1)
    %assert varGroup.NumVarGroupElements == SIZE(varGroup.VarGroupElementCGTypes, 1)
    %foreach elIdx = varGroup.NumVarGroupElements
        %assign element = SLibVarGroupElementSource(rootVarGroupIdx, elIdx)
        %assign idnum  = IDNUM(element)
        %assign recType = idnum[0]
        %assign recIdx  = idnum[1]
        %if recType == "PCDG" || recType == "RCDG" || recType == "VG" || SLibIsLocalVariableRecordType(rootVarGroupIdx, elIdx)
            %continue
        %endif
        %%parameter with Auto DataInit will only be statically initialized
        %if group.DataInit == "Auto" && SLibVargroupElementAutoDataInitConversion(recType) == "Static"
            %continue
        %endif

        %assign dataRec = SLibGetDataRecForVarGroupMember(recType, recIdx)
        %if ISEMPTY(dataRec)
            %% This will be empty for service ports
            %continue
        %endif
        %if shouldInitializeSignalObject(dataRec)
            %<InitializeDataObjectWithCustomInitialValue(dataRec, LibGetRecordIdentifier(dataRec))>
            %continue
        %endif

        %with dataRec
            %if recType == "ZE" && !dataRec.NeedsEvent && !Accelerator
                %continue
            %endif

            %if recType == "B" && FcnShouldSkipDataInitializationForConstant(dataRec, "Custom")
                %continue
            %endif

            %% If the modelRef IO will be propagated to upper level,
            %% skip the initialization because it should be initialized in the same model level as defined
            %if FcnShouldPropagateCoderDataGroup(group, elIdx, TLC_TRUE, recType)
                %continue
            %endif

            %if recType == "Y"
                %assign sysIdx        = dataRec.Block[0]
                %assign blkIdx        = dataRec.Block[1]
                %assign outportBlock  = System[sysIdx].Block[blkIdx]
                %with outportBlock
                    %if SLibRemoveZeroInitForDataDefault(dataRec)
                        %continue
                    %endif
                %endwith
            %elseif SLibRemoveZeroInitForDataDefault(dataRec)
                %continue
            %endif

            %assign cgTypeIdx = LibGetRecordCGTypeIdx(dataRec)
            %if LibCGTypeIsUnknown(cgTypeIdx)
                %continue
            %endif

            %assign slTypeIdx = LibGetDataTypeIdAliasedThruToFromId(LibGetRecordDataTypeId(dataRec))
            %assign id = varGroup.VarGroupElementIds[elIdx]
            %assign isComplex = LibGetRecordIsComplex(dataRec)
            %assign width = LibGetRecordSymbolicWidth(dataRec)
            %assign hasSymbolicWidth = LibRecordHasSymbolicWidth(dataRec)
            %assign isScalar = (width == "1")
            %assign isMultiWord = LibIsDataTypeMultiWordFixpt(slTypeIdx)
            %assign sep = "."
            %% See if we can use memset
            %if (!isScalar || isMultiWord) && FcnMemsetToZeroInitSuffice(slTypeIdx)
                %assign dtName = SLibGetRecordContainerBaseTypeName(dataRec)

                %assign srcLoc = id
                %if !isScalar
                    %assign srcLoc = id + "[0]"
                %endif

                %if hasSymbolicWidth
                    %assign memsetWidth = "%<width>"
                %else
                    %assign memsetWidth = "%<width>U"
                %endif
                %if isScalar && !isComplex
                    %assign memsetWidthStr = "sizeof(%<dtName>)"
                %elseif isScalar && isComplex
                    %assign memsetWidthStr = "2*sizeof(%<dtName>)"
                %elseif !isScalar && !isComplex
                    %assign memsetWidthStr = "%<memsetWidth>*sizeof(%<dtName>)"
                %else %% !isScalar && isComplex
                    %assign memsetWidthStr = "2*%<memsetWidth>*sizeof(%<dtName>)"
                %endif

                (void) %<LibGenMemFcnCall("memset", "&%<srcLoc>", "0", memsetWidthStr)>;
            %else %% if we can not use memset
                %if LibCGTypeIsChar(cgTypeIdx)
                    %assign initVal = "'a'"
                    %assign isComplex = TLC_FALSE
                %elseif isMultiWord
                    %assign initVal = SLibGetDtGroundName(slTypeIdx, isComplex, tRealPart)
                %else
                    %assign initVal = SLibGetDefaultInitialValue(dataRec, tRealPart)
                %endif

                %assign dataRecNumDims = LibGetRecordNumDimsFromContainerCgTypeIdx(dataRec)
                %assign idLhsAccess = LibGetAddressOfFirstElement(id, dataRecNumDims)

                %if isScalar
                    %if isComplex
                        %<id>%<sep>%<tRealPart> = %<initVal>;
                        %<id>%<sep>%<tImagPart> = %<initVal>;
                    %else
                        %<varGroup.VarGroupElementIds[elIdx]> = %<initVal>;
                    %endif
                %elseif  %<width> >= RollThreshold
                    %assign loopCode = SLibEmitForLoopCounterCode(width, "i")
                    {
                        %<loopCode[0]>
                        %<loopCode[1]> {
                            %if isComplex
                                %<idLhsAccess>[i]%<sep>%<tRealPart> = %<initVal>;
                                %<idLhsAccess>[i]%<sep>%<tImagPart> = %<initVal>;
                            %else
                                %<idLhsAccess>[i] = %<initVal>;
                            %endif
                        }
                    }
                %else
                    %foreach initIdx = %<width>
                        %if isComplex
                            %<idLhsAccess>[%<initIdx>]%<sep>%<tRealPart> = %<initVal>;
                            %<idLhsAccess>[%<initIdx>]%<sep>%<tImagPart> = %<initVal>;
                        %else
                            %<idLhsAccess>[%<initIdx>] = %<initVal>;
                        %endif
                    %endforeach
                %endif
            %endif
        %endwith
    %endforeach

    %closefile buff


    %if !ISEMPTY(buff) && !WHITE_SPACE(buff)
        %openfile buffWithVariant
        %assign comment = "/* Unstructured storage class initialization */"
        %assign vcRecord = SLibGetDataInlineVariantNetConditions(dataRec)
        %assign ifCond = vcRecord.ifCond
        %assign ifEndCond = vcRecord.endIfCond

        %<ifCond>
        %<comment>
        %<buff>
        %<ifEndCond>

        %closefile buffWithVariant

        %assign buff = buffWithVariant
    %endif

    %return buff
%endfunction

%% Function: SLibIsCoderGroupInVolatileMemory ======================================================
%% Abstract:
%%  Given a group index, tells whether the group has a volatile memory section.
%function SLibIsCoderGroupInVolatileMemory(aGroupIdx) void
    %if (aGroupIdx >= 0)
        %return ::CompiledModel.CoderDataGroup[aGroupIdx].IsMemorySectionVolatile
    %endif
    %return TLC_FALSE
%endfunction

%function SLibGetVarGroupStorageClass(varGroup) void
    %assign groupIdx = ISFIELD(varGroup,"CoderDataGroupIndex") ? ...
        varGroup.CoderDataGroupIndex : -1
    %if groupIdx >= 0
        %assign groupName = CoderDataGroup[groupIdx].UserProvidedName
        %if CoderDataGroup[groupIdx].IsSynthesized == 1 && groupName == "_SharedDSM"
            %assign groupName = "Default"
        %endif
        %return groupName
    %else
        %return "Default"
    %endif
%endfunction

%% Function: SLibStandaloneMultiInstanceInTopModel =================================================
%% Abstract:
%%   Return true if the given coder group is standalone multi-instance and in top model
%%
%function SLibStandaloneMultiInstanceInTopModel(group) void
    %% This function is to differentiate the standalone multi-instance coder
    %% groups that are in top model (CTypedPIM) from the ones in model reference
    %% (AutosarPIP and PIM)

    %return SLibStandAloneMultiInstance(group) && !IsModelReferenceTarget()
%endfunction

%% Function: SLibIsGroupNeededInCodeInfoInternalData ===============================================
%% Abstract:
%%   Check if a coder group should be added into the internal data of codeInfo
%%
%function SLibIsGroupNeededInCodeInfoInternalData(group) void
    %% The StructTypeDefScope is checked to prevent adding ArTypedPIM code group to codeInfo's
    %% internal data (g2825005).
    %assign IsNonEmptyStandaloneMultiInstCoderGroup = SLibStandaloneMultiInstanceInTopModel(group) && ...
        group.GroupContains != "NoElement" && !SLibStructTypeDefScopeIsImported(group)

    %return IsNonEmptyStandaloneMultiInstCoderGroup || ...
        (SLibHaveRootDataGroupVarGroup(group) && ...
        (group.AsStructure == "InParent" || (group.AsStructure == "InSelf" && !IsModelReferenceSimTarget())) && ...
        !SLibIsGroupSelfCoderGroup(group))
%endfunction

%% Function: SLibIsAutosarPIPGroupNeededInCodeInfoInternalData =====================================
%% Abstract:
%%   Check if AUTOSAR PIP coder group should be added into the internal data of codeInfo
%%
%function SLibIsAutosarPIPGroupNeededInCodeInfoInternalData(group) void
    %% True if this is AUTOSAR PIP coder group and it contains elements
    %return SLibAutosarCompliant() && group.ContainsInstanceSpecificParameter && ...
        group.GroupContains != "NoElement"
%endfunction

%endif%%  _DATAGROUPLIB_
