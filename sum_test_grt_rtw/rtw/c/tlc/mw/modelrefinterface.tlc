%% ============================================================================
%%
%%
%%
%% Abstract:
%%   This system file contains helper functions to create an
%% S-Function wrapper for any target.
%%
%% Copyright 1994-2023 The MathWorks, Inc.
%%

%include "blkio_internalapi.tlc"

%if EXISTS(_MODELREFINTERFACE_) == 0
%assign _MODELREFINTERFACE_ = 1

%include "paramlib.tlc"

%% Function: SLibAddModelReferenceModelInterface
%% Abstract:
%%     Cache model reference target specific data in the MAT file
%% TopTester: test/toolbox/simulink/variants/var-bus-general/modelref/tVariantBusProtected.m
%% TopTester: test/toolbox/rtw/targets/AUTOSAR/Variants/modelref/tModelRefVariants.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function SLibAddModelReferenceModelInterface(blkInterface) void
    %assign booleanType = LibGetDataTypeNameFromId(::CompiledModel.tSS_BOOLEAN)
    %assign realType = LibGetDataTypeNameFromId(::CompiledModel.tSS_DOUBLE)
    %assert(EXISTS(blkInterface) && !ISEMPTY(blkInterface))
    %assert(IsModelReferenceTarget())
    %with ::CompiledModel
        %% mdlRTW: no code is generated. this information is cached in binfo.mat
        %assign rootIdx    = NumSystems-1
        %assign sysIdx = NumSystems-2
        %assign thisSystem = System[sysIdx]
        %assign interface  = thisSystem.Interface
        %assign fileName   = SLibGetSystemOutputHdrFileBaseName(System[sysIdx])

        %with interface
            %if ::ProtectedModelReferenceTarget
                %addtorecord blkInterface ProtectedModelReferenceTarget 1
            %else
                %addtorecord blkInterface ProtectedModelReferenceTarget 0
            %endif

            %if CompiledModel.GenProtectedModelOrSubmodel
                %addtorecord blkInterface ProtectingModelOrSubmodel 1
            %else
                %addtorecord blkInterface ProtectingModelOrSubmodel 0
            %endif

            %if SLibSingleTasking()
                %addtorecord blkInterface SingleTasking 1
            %else
                %addtorecord blkInterface SingleTasking 0
            %endif

            %addtorecord blkInterface Tid01Eq %<Tid01Eq>

            %if ModelrefBlockNeedsDwork() && IsModelReferenceSimTarget()
                %addtorecord blkInterface DWorkType "%<tsysMdlrefDWorkType>"
            %endif

            %assign numInputs  = ExternalInputs.NumExternalInputs
            %assign numOutputs = ExternalOutputs.NumExternalOutputs

            %addtorecord blkInterface HasNonContOutput %<HasNonContSigFeedingOutport()>
            %addtorecord blkInterface NonContOutports %<GetNonContOutputPorts()>

            %assert(%<numInputs> >= %<NumCanonicalInputArgDefs>)
            %assert(%<numOutputs> >= %<NumCanonicalOutputArgDefs>)

            %if( EXISTS(ExternalInputs.OriginalPortBusTypesInports))
                %assign numInfos = ExternalInputs.NumOriginalPortBusTypesInports
                %foreach idx = numInfos
                    %addtorecord blkInterface OriginalInputPortBusTypes {\
                        Port    ExternalInputs.OriginalPortBusTypesInports[idx].Port;\
                        BusType ExternalInputs.OriginalPortBusTypesInports[idx].BusType\
                    }
                %endforeach
            %else
                %addtorecord blkInterface OriginalInputPortBusTypes []
            %endif

            %if( EXISTS(ExternalOutputs.OriginalPortBusTypesOutports))
                %assign numInfos = ExternalOutputs.NumOriginalPortBusTypesOutports
                %foreach idx = numInfos
                    %addtorecord blkInterface OriginalOutputPortBusTypes {\
                        Port    ExternalOutputs.OriginalPortBusTypesOutports[idx].Port;\
                        BusType ExternalOutputs.OriginalPortBusTypesOutports[idx].BusType\
                    }
                %endforeach
            %else
                %addtorecord blkInterface OriginalOutputPortBusTypes []
            %endif

            %addtorecord blkInterface NumInputs %<numInputs>
            %addtorecord blkInterface NumOutputs %<numOutputs>

            %addtorecord blkInterface OkToMultiInstance %<OkToMultiInstanceModelref>
            %assign thisModule = ::CompiledModel.RTWCGModules.RTWCGModule[thisSystem.CGIRModuleIdx]
            %assign fcnIdx = ISFIELD(thisModule,"SystemFunctionTypes") && ISFIELD(thisModule.SystemFunctionTypes,"ModelConstructor") ...
                ? GETFIELD(thisModule.SystemFunctionTypes,"ModelConstructor") : -1
            %assign nonDefaultCtor = TLC_FALSE
            %if fcnIdx > -1 && ::GenerateClassInterface
                %assign ctorFcn = thisModule.Function[fcnIdx]
                %if ctorFcn.NumArgs > 0
                    %assign nonDefaultCtor = TLC_TRUE
                %endif
            %endif
            %addtorecord blkInterface hasNonDefaultCtor %<nonDefaultCtor>
            %addtorecord blkInterface usesSimplifiedInterface %<thisModule.SimplifiedInterface>
            %assign allocatedInParent = FcnRTMAllocateInParent()
            %addtorecord blkInterface rtmAllocateInParent %<allocatedInParent>

            %addtorecord blkInterface NonFiniteInfo [%<::NeedRealInf>, %<::NeedRealMinusInf>, %<::NeedRealNaN>]
            %addtorecord blkInterface FileName "%<fileName>"
            %addtorecord blkInterface AncestorAllocatesCoderDataGroups ::CompiledModel.AncestorAllocatesCoderDataGroups
            %if !IsModelRefScalableBuild()
                %addtorecord blkInterface xDataType    "%<FcnSysVarGroupType(System[sysIdx],"ContStates")>"
                %addtorecord blkInterface xDotDataType "%<FcnSysVarGroupType(System[sysIdx],"ContStatesDerivative")>"
                %addtorecord blkInterface xDisDataType "%<FcnSysVarGroupType(System[sysIdx],"ContStatesDisabled")>"
                %addtorecord blkInterface xAbsTolDataType "%<FcnSysVarGroupType(System[sysIdx],"ContStatesAbsoluteTolerance")>"
                %addtorecord blkInterface xPerturbMinDataType "%<FcnSysVarGroupType(System[sysIdx],"ContStatesPerturbMin")>"
                %addtorecord blkInterface xPerturbMaxDataType "%<FcnSysVarGroupType(System[sysIdx],"ContStatesPerturbMax")>"
                %addtorecord blkInterface xOptWidth    1
                %addtorecord blkInterface zcOptWidth 1
                %addtorecord blkInterface zcDataType "%<FcnSysVarGroupType(System[sysIdx],"ZCSV")>"
                %addtorecord blkInterface zcDataTypeHeader "%<SLibGetVarGroupInstDeclarationFile("ZCSV")>"
                %addtorecord blkInterface IsScalableBuild 0
            %else
                %addtorecord blkInterface xDataType    realType
                %addtorecord blkInterface xDotDataType realType
                %addtorecord blkInterface xDisDataType booleanType
                %addtorecord blkInterface xAbsTolDataType realType
                %addtorecord blkInterface xPerturbMinDataType realType
                %addtorecord blkInterface xPerturbMaxDataType realType
                %addtorecord blkInterface xOptWidth    %<::CompiledModel.NumContStates>
                %addtorecord blkInterface zcOptWidth   %<::CompiledModel.ZCVectorlength>
                %addtorecord blkInterface zcDataType   realType
                %addtorecord blkInterface IsScalableBuild 1
                %addtorecord blkInterface HideChildDefineSymbol "%<GetHideChildDefineSymbol("define")>"
            %endif
            %if IsModelReferenceForASimstructBasedTarget()
                %addtorecord blkInterface StopReqAccessed "0"
            %else
                %% Either this model has used the stopReq flag, or there is a model
                %% block that is using the flag.
                %assign stopReqAcc = RTMStopReqAccessed() || ::CompiledModel.ModelBlocksUseStopReq
                %addtorecord blkInterface StopReqAccessed %<stopReqAcc>
            %endif
            %addtorecord blkInterface ContTimeOutputInconsistentWithStateAtMajorStepAccessed %<ISFIELD(::CompiledModel, "HasContTimeOutputInconsistentWithStateAtMajorStep")>

            %% Absolute tolerance control flag for referenced model
            %if IsVariableStepModelReferenceTarget() && NumContStates > 0
                %addtorecord blkInterface refAbsTolControl %<VariableStepOpts.AbsTolControl>
            %endif

            %% Adding NumTimers from top model
            %assign numTimers = ::CompiledModel.NumTimers
            %addtorecord blkInterface NumTimers %<numTimers>

            %% Adding NeedsGlobalTimerIndices from top model
            %assign needsGlobalTimerIndices = ::CompiledModel.NeedsGlobalTimerIndices
            %addtorecord blkInterface NeedsGlobalTimerIndices "%<needsGlobalTimerIndices>"

            %% Adding NumExternalRuntimeEvents from top model
            %assign numExternalRuntimeEvents = ::CompiledModel.NumExternalRuntimeEvents
            %addtorecord blkInterface NumExternalRuntimeEvents %<numExternalRuntimeEvents>

            %% Adding NeedsGlobalRuntimeEventIndices from top model
            %assign needsGlobalRuntimeEventIndices = ::CompiledModel.NeedsGlobalRuntimeEventIndices
            %addtorecord blkInterface NeedsGlobalRuntimeEventIndices "%<needsGlobalRuntimeEventIndices>"

            %% Adding NumDataTransfers from top model
            %if ISFIELD(::CompiledModel, "NumDataTransfers")
                %assign numDataTransfers = ::CompiledModel.NumDataTransfers
                %addtorecord blkInterface NumDataTransfers %<numDataTransfers>
            %endif

            %% clock Tick
            %assign  clockTicksReq = CreateVectorWithValue(NumSampleTimes, 0)
            %foreach tidIdx = NumSampleTimes
                %assign clockTicksReq[tidIdx] = ClockTickForTIDIsReqFcn(tidIdx)
            %endforeach
            %addtorecord blkInterface ClockTicksReq  %<clockTicksReq>

            %% Long clock Tick
            %assign  longClockTicksReq = CreateVectorWithValue(NumSampleTimes, 0)
            %foreach tidIdx = NumSampleTimes
                %assign longClockTicksReq[tidIdx] = LongClockTickForTIDIsReqFcn(tidIdx)
            %endforeach
            %addtorecord blkInterface LongClockTicksReq  %<longClockTicksReq>

            %% NeedFloatTime
            %assign needFloatTime = CreateVectorWithValue(NumSampleTimes, 0)
            %foreach tidIdx = NumSampleTimes
                %assign needFloatTime[tidIdx] = ::CompiledModel.SampleTime[tidIdx].NeedFloatTime == "yes"
            %endforeach
            %addtorecord blkInterface NeedFloatTime %<needFloatTime>

            %addtorecord blkInterface RequireMultiRateSampleHits %<ERTPerTaskSampleHitsIsReqFcn()>

            %% Rate interactions
            %addtorecord blkInterface ActualRateInteraction  %<::CompiledModel.MatrixOfRequireRateInteraction>

            %addtorecord blkInterface  HasInternalParameterRate %<MdlRefHasInternalParameterRate()>

            %addtorecord blkInterface HasParameterRateOutput %<MdlRefHasParameterRateOutput()>

            %% CAPI Flag
            %addtorecord blkInterface RegFcnNeedsCAPIArgs %<::CompiledModel.RTWCAPI>

            %if ::CompiledModel.RTWCAPI
                %% ModelRefCanonicalInputNeededByCAPI Flag
                %addtorecord blkInterface ModelRefCanonicalInputNeededByCAPI %<IsModelRefCanonicalInputNeededByCAPI()>
            %else
                %addtorecord blkInterface ModelRefCanonicalInputNeededByCAPI TLC_FALSE
            %endif

            %% Has a function-call subsystem that is set to inherited
            %with InheritedFunctionCallSystems
                %assign numInhSys = NumInheritedFunctionCallSystems
                %if numInhSys > 0
                    %foreach idx = numInhSys
                        %addtorecord blkInterface InheritedFcnCallSystems { \
                            FcnCallSystemName InheritedFunctionCallSystem[idx].FcnCallSystemName;\
                            IsStateflowChart InheritedFunctionCallSystem[idx].IsStateflowChart\
                        }
                    %endforeach
                %else
                    %addtorecord blkInterface InheritedFcnCallSystems []
                %endif
            %endwith

            %addtorecord blkInterface NeedsTIDArgs %<::tMdlRefNeedTIDArgs>
            %addtorecord blkInterface NeedCtrlRateMdlRefTiming %<SLibModelHasControllableRate()>

            %addtorecord blkInterface NeedsErrorStatus %<!SuppressErrorStatus>

            %addtorecord blkInterface InitInternalMem %<SLibZeroMemory("RTM")>

            %addtorecord blkInterface RTMAccessed %<RealTimeModelAccessed>

            %addtorecord blkInterface RTMTypeName "%<tSimStructType>"

            %assign rtmTypeHeaderFile = fileName + ".h"
            %assign selfVarGroupIndex = SLibGetSelfVarGroupIndex()
            %if selfVarGroupIndex >= 0
                %assign selfVarGroup = ::CompiledModel.VarGroups.VarGroup[selfVarGroupIndex]
                %assign rtmTypeHeaderFile = selfVarGroup.CoderDataGroupHeaderFile
            %endif

            %addtorecord blkInterface RTMTypeHeaderFile "%<rtmTypeHeaderFile>"

            %if !EXISTS(::NamespaceName)
                %addtorecord blkInterface ModelNamespace ""
            %else
                %addtorecord blkInterface ModelNamespace "%<::NamespaceName>"
            %endif

            %if SelfCoderDataGroupIndex > -1 && ...
                ((GenerateClassInterface && (NumSimulinkFunctions > 0 || SLibGetSelfVarGroupIndex() > 0 )) || ...
                (OkToMultiInstanceModelref && IsModelReferenceSimTarget()))
                %addtorecord blkInterface ClassDWorkAllocation TLC_FALSE
            %else
                %addtorecord blkInterface ClassDWorkAllocation TLC_TRUE
            %endif

            %addtorecord blkInterface TypesInModelClassNamespace SLibIsSystemTypesModelClassNamespace(System[GetBaseSystemIdx()])

        %endwith %% interface

        %<SLibWriteIOAttributes(blkInterface)>

        %if IsModelReferenceRTWTarget()
            %<SLibWriteVarsAndParamsUsed(blkInterface)>
        %endif

        %if MdlRefHasConstantOutput()
            %addtorecord blkInterface HasConstantOutput TLC_TRUE
        %else
            %addtorecord blkInterface HasConstantOutput TLC_FALSE
        %endif

        %addtorecord blkInterface CodeVariants %<SLibGetCodeVariants()>

        %% write out some things common to SIM and Simulink Coder targets
        %<SLibWriteScopedDSMInitializerForMultiInstanceDWork(blkInterface)>
        %<SLibWriteScopedDSMInitializerForSingleInstance(blkInterface)>
        %<SLibWriteZeroCrossingInfo(blkInterface)>
        %<SLibWriteTunableParameters(blkInterface)>

        %if (IsModelReferenceSimTarget())
            %% Cache the const output code buf for writing out the mdlOutputs function
            %if ISFIELD(::CompiledModel, "TmpCodeBufForMdlOutputs")
                %addtorecord blkInterface TmpCodeBufForMdlOutputs "%<::CompiledModel.TmpCodeBufForMdlOutputs>"
            %endif

            %<SLibWriteDWorks(blkInterface)>
            %<SLibWriteParameters(blkInterface)>
            %<SLibWriteModelCanonicalParams(blkInterface)>
            %<SLibWriteModelTestpointedParams(blkInterface)>
            %<SLibWriteVariableSampleTimeInfo(blkInterface)>
            %<SLibWriteControllableRateInfo(blkInterface)>
            %<SLibWriteForEachInfo(blkInterface)>
        %endif
        %<SLibWriteMultiInstanceInfo(blkInterface)>

        %% Always add the DenormalBehavior setting to the block interface.
        %% See g1761204 for details.
        %addtorecord blkInterface DenormalBehavior ...
            "%<::CompiledModel.ConfigSet.DenormalBehavior>"

    %endwith %% ::CompiledModel
%endfunction

/* Computes Simulink Variant objects' Name, Condition and IsImported properties
along with AUTOSAR.Parameters'(which are associated with AUTOSAR.SystemConstant
CSC) name and value */
%% TopTester: test/toolbox/simulink/blocks/sb2sl/tsb2slmdlref2.m
%% TopTester: test/toolbox/rtw/targets/AUTOSAR/Variants/modelref/tModelRefVariants.m
%%
%function SLibGetCodeVariants()  void
    %createrecord VariantData {}

    %if ISFIELD(::CompiledModel, "CodeVariants")
        %assign codeVariants = ::CompiledModel.CodeVariants
        %with codeVariants
            %assign numSVIdxs = NumVariantObjectOrderedIndexs
            %foreach svIdxIdx = numSVIdxs
                %% get the index of the SV object from the table of indexes,
                %% which is in SV object dependency order
                %assign svIdx = VariantObjectOrderedIndexs[svIdxIdx]
                %with SimulinkVariantObject[svIdx]
                    %createrecord Variant {}
                    %addtorecord Variant Name Name
                    %addtorecord Variant Condition Condition
                    %addtorecord Variant IsImported IsImported
                    %addtorecord VariantData Variant %<Variant>
                %endwith
            %endforeach
        %endwith
    %endif

    /* Compute the AUTOSAR Parameters associated with SystemConstant CSC.*/
    %createrecord ParamData {}

    %if ISFIELD(::CompiledModel, "ModelParameters")
        %assign mdlParams = ::CompiledModel.ModelParameters
        %foreach pIdx=mdlParams.NumParameters
            %assign mdlParam = mdlParams.Parameter[pIdx]
            %if (LibHasCustomStorage(mdlParam) && ...
                ISEQUAL(LibGetRTWInfoObjectPackage(mdlParam), "AUTOSAR") && ...
                ISEQUAL(LibGetCustomStorageClassName(mdlParam), "SystemConstant") )
                %assign paramName = LibGetRecordIdentifier(mdlParam)
                %assign paramValue = SLibGetParameterValue(mdlParam)[0]

                %createrecord Pair {}
                %addtorecord Pair ParamName paramName
                %addtorecord Pair ParamValue STRING(paramValue)

                %addtorecord ParamData Pair %<Pair>
            %endif
        %endforeach
    %endif

    /* Now get variant controls and parameters from submodels */
    %if(ISFIELD(::CompiledModel, "SubModelCodeVariants"))
        %assign subModelVariants = ::CompiledModel.SubModelCodeVariants.VariantControl
        %if(ISFIELD(subModelVariants, "Variant"))
            %assign numVars = SIZE(subModelVariants.Variant, 1)

            %foreach idx = numVars
                %assign variant = subModelVariants.Variant[idx]
                %addtorecord VariantData Variant %<variant>
            %endforeach
        %endif

        %assign subModelParams = ::CompiledModel.SubModelCodeVariants.VariantParameter
        %if(ISFIELD(subModelParams, "Pair"))
            %assign numParams = SIZE(subModelParams.Pair, 1)

            %foreach idx = numParams
                %assign paramData = subModelParams.Pair[idx]
                %addtorecord ParamData Pair %<paramData>
            %endforeach
        %endif
    %endif

    /* Combine variant control and variant parameters */
    %createrecord VariantAndParamsData {}
    %addtorecord VariantAndParamsData VariantControl %<VariantData>
    %addtorecord VariantAndParamsData VariantParameter %<ParamData>
    %return VariantAndParamsData
%endfunction


%function FcnRTMAllocateInParent() void
    %return OkToMultiInstanceModelref && SLibGetUseRTMcgType()
%endfunction

%% TopTester: test/toolbox/simulink/blocks/sb2sl/tsb2slmdlref2.m
%%
%function SLibGetNonInlinedSFcnNames()
    %createrecord functions {}

    %assign numSFunctions = NumChildSFunctions
    %foreach idx = numSFunctions
        %assign thisBlock = ChildSFunctionList[idx]
        %assign inlined = thisBlock.ParamSettings.Inlined
        %if inlined == "no"
            %assign name = thisBlock.ParamSettings.FunctionName
            %addtorecord functions Function { Name STRING(name) }
        %endif
    %endforeach

    %if(ISFIELD(::CompiledModel, "SubModelNonInlinedSFunctions"))
        %assign subModelSFcns = ::CompiledModel.SubModelNonInlinedSFunctions
        %assign numSFcns = SIZE(subModelSFcns.Function, 1)

        %foreach idx = numSFcns
            %assign sfcn = subModelSFcns.Function[idx]
            %addtorecord functions Function %<sfcn>
        %endforeach
    %endif

    %return functions
%endfunction

%% TopTester: test/toolbox/simulink/variants/modelVariants/tVariantsBasic_g724566.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tvss_code_variants.m
%%
%function SLibWriteIOAttributes(blkInterface) void
    %assign numInputs  = ExternalInputs.NumExternalInputs
    %assign numOutputs = ExternalOutputs.NumExternalOutputs

    %assign globalVec = []
    %assign notReuseVec = []
    %assign alignVec = []
    %foreach portIdx = numOutputs
        %assign extOut = ExternalOutputs.ExternalOutput[portIdx]
        %assign globalVec = globalVec + ((extOut.GlobalInRTW == "yes") ? 1 : 0)
        %assign notReuseVec = notReuseVec + ((extOut.NotReusable == "yes") ? 1 : 0)
        %if extOut.Alignment > 0
            %assign alignVec = alignVec + extOut.Alignment
        %else
            %assign alignVec = alignVec + -1
        %endif
    %endforeach

    %addtorecord blkInterface OutputPortGlobal %<globalVec>
    %addtorecord blkInterface OutputPortNotReusable %<notReuseVec>
    %addtorecord blkInterface OutputPortAlignment %<alignVec>

    %assign globalVec = []
    %assign notReuseVec = []
    %assign overwritableVec = []
    %assign alignVec = []
    %assign fcnCallInputVec = []
    %assign directFeedThrough = []
    %foreach portIdx = numInputs
        %assign extInp = ExternalInputs.ExternalInput[portIdx]
        %assign globalVec = globalVec + ((extInp.GlobalInRTW == "yes") ? 1 : 0)
        %assign notReuseVec = notReuseVec + ((extInp.NotReusable == "yes") ? 1 : 0)
        %assign overwritableVec = overwritableVec + ((extInp.OverWritable == "yes") ? 1 : 0)
        %assign fcnCallInputVec = fcnCallInputVec + ((extInp.FunctionCallInitiator == "yes") ? 1 : 0)
        %assign directFeedThrough = directFeedThrough + ((ExternalInputs.ExternalInput[portIdx].DirectFeedThrough == "yes") ? 1 : 0)
        %if extInp.Alignment > 0
            %assign alignVec = alignVec + extInp.Alignment
        %else
            %assign alignVec = alignVec + -1
        %endif
    %endforeach

    %addtorecord blkInterface InputPortGlobal %<globalVec>
    %addtorecord blkInterface InputPortNotReusable %<notReuseVec>
    %addtorecord blkInterface InputPortOverWritable %<overwritableVec>
    %addtorecord blkInterface InputPortFcnCallInitiator %<fcnCallInputVec>
    %addtorecord blkInterface InputPortAlignment %<alignVec>
    %addtorecord blkInterface DirectFeedThrough %<directFeedThrough>
%endfunction


%% This routine mimics SLibGenModelRefGlobalParamReg() and has
%% a similar structure
%% TopTester: test/toolbox/simulink/variants/modelVariants/tVariantsBasic_g724566.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants10.m
%%
%function SLibWriteVarsAndParamsUsed(blkInterface) void
    %%
    %% By default, create an entry in blkInterface for AUTOSAR specific information
    %if !ISFIELD(blkInterface, "AutosarParamAccessInfo")
        %addtorecord blkInterface AutosarParamAccessInfo { \
            InitializeAccess {}; \
            OutputAccess     {}  \
        }
    %endif

    %if InlineParameters != 0
        %% Write out real variables used by the sub-model to the model reference interface
        %% so that such information can be propagated to the top model.
        %with ::CompiledModel.ModelParameters
            %foreach prmIdx=NumParameters
                %assign param = Parameter[prmIdx]
                %if param.Tunable == "yes" && ...
                    !ISEMPTY(param.WorkspaceVarName) && ...
                    !param.IsPublic && param.IsGlobal

                    %assign identifier = LibGetRecordVarName(param)
                    %assign dims = LibBlockParameterDimensions(param)
                    %assign nDims = SIZE(dims, 1)
                    %assign isComplex = LibGetRecordIsComplex(param)
                    %assign dtId = LibCGTypeToSLType(param.CGTypeIdx)
                    %assert (dtId != -1)
                    %assign dtName = LibGetDataTypeSLNameFromId(dtId)
                    %assign parentDtId = -10
                    %assign dtChecksum = []
                    %assign isAnonymous = TLC_FALSE
                    %assign isFixpt = TLC_FALSE
                    %assign isScaledFloat = TLC_FALSE
                    %assign isSigned = TLC_FALSE
                    %assign requiredBits = 0
                    %assign fracSlope = 0
                    %assign fixedExp = 0
                    %assign bias = 0
                    %assign isHalf = TLC_FALSE
                    %if LibIsBuiltInDataType(dtId)
                        %% Doing nothing whereas SLibGenModelRefGlobalParamReg()
                        %% is able to do something
                    %elseif LibIsEnumDataType(dtId)
                        %% Doing nothing whereas SLibGenModelRefGlobalParamReg()
                        %% is able to do something
                    %elseif LibIsStructDataType(dtId) && !LibIsDataTypeFixpt(dtId)
                        %assign dtName = LibGetDataTypeNameFromId(dtId)
                        %assign dtChecksum = DataTypes.DataType[dtId].StructDtChecksum
                        %assign isAnonymous = LibDataTypeIsAnonymousStruct(dtId)
                    %elseif LibIsStringDataType(dtId)
                        %% No string support for model arguments
                        %assign errTxt = ...
                            "String data type is not supported for interface parameters."
                        %<LibReportFatalError(errTxt)>
                    %else %% Fixed-point (we hope)
                        %assign curDT = FixPt_GetDataTypeFromIndex(dtId)
                        %%
                        %if LibIsHalfDataType(dtId)
                            %assign isHalf = TLC_TRUE
                            %assign dtName = LibGetDataTypeNameFromId(dtId)
                            %assign requiredBits = curDT.RequiredBits
                        %elseif curDT.IsFixedPoint
                            %assign isFixpt = TLC_TRUE
                            %assign isScaledFloat = FixPt_DataTypeIsFloat(curDT)
                            %assign isSigned = (curDT.IsSigned == 1.0)
                            %assign requiredBits = curDT.RequiredBits
                            %assign fracSlope = curDT.FracSlope
                            %assign fixedExp = curDT.FixedExp
                            %assign bias = curDT.Bias
                        %else
                            %assign errTxt = ...
                                "User-defined data types not supported for interface parameters."
                            %<LibReportFatalError(errTxt)>
                        %endif
                    %endif
                    %addtorecord blkInterface GlobalParams { \
                        Identifier      identifier; \
                        NDims           nDims; \
                        Dims            dims; \
                        Complex         isComplex; \
                        DtChecksum      dtChecksum; \
                        DataTypeName    dtName; \
                        IsAnonymous     isAnonymous; \
                        IsFixpt         isFixpt; \
                        IsScaledFloat   isScaledFloat; \
                        IsSigned        isSigned; \
                        RequiredBits    requiredBits; \
                        FracSlope       fracSlope; \
                        FixedExp        fixedExp; \
                        Bias            bias; \
                        IsHalfPrecision isHalf \
                    }
                    %%
                    %% If this param were a AUTOSAR parameter (declared using AUTOSAR.Parameter),
                    %% it will have some additional information. This information needs to be
                    %% propagated up via blkInterface
                    %if ISFIELD(param, "RunnableAccessInfo")
                        %assign pAccessInfo = blkInterface.AutosarParamAccessInfo
                        %if ISFIELD(param.RunnableAccessInfo, "MdlRefInitializeFcn")
                            %addtorecord pAccessInfo.InitializeAccess %<identifier> 1
                        %endif
                        %if ISFIELD(param.RunnableAccessInfo, "MdlRefOutputFcn")
                            %addtorecord pAccessInfo.OutputAccess %<identifier> 1
                        %endif
                    %endif
                %endif %% (param.Tunable == "yes")
            %endforeach %% prmIdx=NumParameters
        %endwith %% ::CompiledModel.ModelParameters
    %endif %% InlineParameters

    %assign globalVars = ::CompiledModel.ModelParameters.GlobalParamsList
    %foreach idx = SIZE(globalVars, 1)
        %addtorecord blkInterface GlobalVars { \
            Identifier globalVars[idx] \
        }
    %endforeach

    %% Loop through model reference blocks and gather up their Autosar specific info
    %assign mdlRefBlks = ISFIELD(::CompiledModel,"ModelReferenceBlocks") ? ...
        ::CompiledModel.ModelReferenceBlocks : []
    %if !ISEMPTY(mdlRefBlks)
        %foreach rowIdx = SIZE(mdlRefBlks,0)
            %assign mdlRefInfo  = mdlRefBlks[rowIdx]
            %assign mSysIdx     = mdlRefInfo[0]
            %assign bIdx        = mdlRefInfo[1]
            %assign subMdlIntrf = GetModelrefInterface(System[mSysIdx].Block[bIdx])
            %assign pAccessInfo = blkInterface.AutosarParamAccessInfo
            %%
            %% Add Init Runnable Access
            %assign initAccess = ...
                FIELDNAMES(subMdlIntrf.AutosarParamAccessInfo.InitializeAccess)
            %assign numInitAccess = SIZE(initAccess, 1)
            %foreach pIdx = numInitAccess
                %assign paramName = initAccess[pIdx]
                %addtorecord pAccessInfo.InitializeAccess %<paramName> 1
            %endforeach
            %%
            %% Add Out Runnable Access
            %assign outAccess = ...
                FIELDNAMES(subMdlIntrf.AutosarParamAccessInfo.OutputAccess)
            %assign numOutAccess = SIZE(outAccess, 1)
            %foreach pIdx = numOutAccess
                %assign paramName = outAccess[pIdx]
                %addtorecord pAccessInfo.OutputAccess %<paramName> 1
            %endforeach
        %endforeach
    %endif

%endfunction

%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function SLibWriteDWorks(blkInterface) void
    %with ::CompiledModel
        %with DWorks
            %addtorecord blkInterface DWorks { \
                NumSFcnWrapperDWorks NumSFcnWrapperDWorks \
            }
        %endwith
    %endwith
%endfunction


%function SLibWriteGlobalParamList(blkInterface) void
    %assign globalVars = ::CompiledModel.ModelParameters.GlobalParamsList
    %foreach idx = SIZE(globalVars, 1)
        %addtorecord blkInterface GlobalVars { \
            Identifier globalVars[idx] \
        }
    %endforeach
%endfunction



%% This function has similar logic to SLibGenModelRefGlobalParamReg
%function SLibWriteParameters(blkInterface) void
    %with ::CompiledModel.ModelParameters
        %assert (NumInrtP == (NumParameters - NumConstPrmsWithInit - NumConstPrms))
        %foreach prmIdx=NumInrtP
            %assign param = Parameter[prmIdx]
            %if param.Tunable == "yes" && ...
                !ISEMPTY(param.WorkspaceVarName) && ...
                (param.TestpointIndex < 0)
                %<SLibWriteParams(blkInterface, param, prmIdx, "Parameters")>
            %endif
        %endforeach
    %endwith
%endfunction

%function SLibWriteTunableParameters(blkInterface) void
    %<writeStringVector(blkInterface, ::CompiledModel.ModelParameters.TunableParamsList, "TunableParamsList")>
%endfunction

%function writeStringVector(blkInterface, varList, recordName) void
    %foreach idx = SIZE(varList, 1)
        %addtorecord blkInterface %<recordName> { \
            Identifier varList[idx] \
        }
    %endforeach
%endfunction

%function SLibWriteModelCanonicalParams(blkInterface) void
    %assign baseIdx = GetBaseSystemIdx()
    %with System[baseIdx].Interface
        %foreach argIdx=NumCanonicalPrmArgDefs
            %assign param = CanonicalPrmArgDef[argIdx]
            %<SLibWriteParams(blkInterface, param, argIdx, "CanonicalParameters")>
        %endforeach
    %endwith
%endfunction

%function SLibWriteModelTestpointedParams(blkInterface) void
    %assign tpSrcs = ::CompiledModel.TestPointedBlockParametersLogicalSrc
    %assign numTp = SIZE(tpSrcs, 1)
    %foreach tpIdx = numTp
        %assign id = IDNUM(tpSrcs[tpIdx])
        %assign param = ::CompiledModel.ModelParameters.Parameter[id[1]]
        %<SLibWriteParams(blkInterface, param, tpIdx, "TestpointedParameters")>
    %endforeach
%endfunction

%% TopTester: matlab/test/toolbox/simulink/compiletime_xform/lutToPLookupInterpND/tPir2EngineLutGecks04.m
%% TopTester: test/toolbox/simulink/blocks/tconcat.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tvss_code_variants.m
%% TopTester: test/toolbox/simulink/coreblocks/lib_MathOperations/Gain/rtw/tNumerics_Gainblk_blas_misc.m
%% TopTester: matlab/test/toolbox/simulink/compiletime_xform/lutToPLookupInterpND/tPir2EngineLutGecks04.m
%%
%function SLibWriteParams(blkInterface, param, prmIdx, recordName) void
    %assign identifier = LibGetRecordIdentifier(param)

    %assign dims = LibBlockParameterDimensions(param)
    %assign nDims = SIZE(dims, 1)

    %assign dtId = param.OriginalDataTypeIdx

    %% For model reference
    %assign isComplex = LibGetRecordIsComplex(param)
    %assign isBuiltin = LibIsBuiltInDataType(dtId)
    %assign isEnum = TLC_FALSE
    %assign isStruct = TLC_FALSE
    %assign isFixpt = TLC_FALSE
    %assign hasParamWrite = TLC_FALSE
    %assign hasDescendantParamWrite = TLC_FALSE
    %assign isHalf = TLC_FALSE

    isTunable = TLC_FALSE
    %if ISFIELD(param, "Tunable")
        %assign isTunable = (param.Tunable == "yes")
    %else
        %assign isTunable = TLC_FALSE
    %endif

    %assign testpointIndex = -1
    %if recordName == "TestpointedParameters"
        %if ISFIELD(param, "TestpointIndex")
            %assign testpointedParam = param
            %assign testpointIndex = param.TestpointIndex
        %endif
        %if param.HasParamWrite > 0
            %assign hasParamWrite = TLC_TRUE
        %endif
        %if param.HasDescendantParamWrite > 0
            %assign hasDescendantParamWrite = TLC_TRUE
        %endif
    %elseif recordName == "CanonicalParameters"
        %assign modelArgIndex = ::CompiledModel.TestPointedModelArgumentsLogicalSrc[prmIdx]
        %if modelArgIndex != "NONE"
            %assign id = IDNUM(modelArgIndex)
            %assign testpointedParam = ::CompiledModel.ModelParameters.Parameter[id[1]]
            %assign testpointIndex = testpointedParam.TestpointIndex
            %if testpointedParam.HasParamWrite > 0
                %assign hasParamWrite = TLC_TRUE
            %endif
        %endif
    %endif

    %if (ISFIELD(param, "IsUsed") && (param.IsUsed == "yes")) || ...
        (testpointIndex >= 0)
        %assign isUsed = TLC_TRUE
    %else
        %assign isUsed = TLC_FALSE
    %endif

    %if recordName == "TestpointedParameters"
        %if ISEMPTY(param.WorkspaceVarName)
            %assign identifier = param.Identifier
        %else
            %assign identifier = param.WorkspaceVarName
        %endif
    %endif

    %assign coderGroup  = ""
    %if ISFIELD(param, "ModelParamGroup")
        %assign coderGroup = param.ModelParamGroup
        %assign identifier = param.Identifier
    %endif

    %assign dtName = ""
    %if dtId >= 0
        %if isComplex
            %assign dtName = LibGetDataTypeComplexNameFromId(dtId)
        %else
            %assign dtName = LibGetDataTypeNameFromId(dtId)
        %endif
        %assign dtEnum = ""
    %endif

    %% For structured param
    %assign dtChecksum = []
    %assign isAnonymous = TLC_FALSE

    %% For fixed-point param
    %assign isFloat = TLC_FALSE
    %assign isSigned = TLC_FALSE
    %assign requiredBits = 0
    %assign fracSlope = 0
    %assign fixedExp = 0
    %assign bias = 0

    %% Need identifier for worksapce variable for some global params
    %assign wksVarName = ""
    %if ISFIELD(param, "WorkspaceVarName")
        %assign wksVarName = param.WorkspaceVarName
    %endif

    %if LibIsBuiltInDataType(dtId)
        %if dtId > -1
            %assign dtEnum = LibGetDataTypeEnumFromId(dtId)
        %else
            %assign dtEnum = "DYNAMICALLY_TYPED"
        %endif
    %elseif LibIsEnumDataType(dtId)
        %assign dtName = LibGetDataTypeNameFromId(dtId)
        %assign isEnum = LibIsEnumDataType(dtId)
    %elseif LibIsStructDataType(dtId) && !LibIsDataTypeFixpt(dtId)
        %assign dtName = LibGetDataTypeNameFromId(dtId)
        %assign isStruct = LibIsStructDataType(dtId)
        %assign dtChecksum = DataTypes.DataType[dtId].StructDtChecksum
        %assign isAnonymous = LibDataTypeIsAnonymousStruct(dtId)
    %elseif LibIsStringDataType(dtId)
        %% No string support for model arguments
        %assign errTxt = ...
            "String data type is not supported for interface parameters."
        %<LibReportFatalError(errTxt)>
    %else %% Fixed-point (we hope)
        %assign curDT = FixPt_GetDataTypeFromIndex(dtId)
        %%
        %if LibIsHalfDataType(dtId)
            %assign isHalf = TLC_TRUE
            %assign dtName = LibGetDataTypeNameFromId(dtId)
            %assign dtEnum = LibGetDataTypeEnumFromId(dtId)
            %assign requiredBits = curDT.RequiredBits
        %elseif curDT.IsFixedPoint
            %assign isFixpt = TLC_TRUE
            %assign isFloat = FixPt_DataTypeIsFloat(curDT)
            %assign isSigned = (curDT.IsSigned == 1.0)
            %assign requiredBits = curDT.RequiredBits
            %assign fracSlope = curDT.FracSlope
            %assign fixedExp = curDT.FixedExp
            %assign bias = curDT.Bias
        %else
            %assign errTxt = ...
                "User-defined data types not supported for interface parameters."
            %<LibReportFatalError(errTxt)>
        %endif
    %endif

    %addtorecord blkInterface %<recordName> { \
        Identifier    identifier; \
        WorkspaceVarName wksVarName; \
        NDims         nDims; \
        Dims          dims; \
        IsBuiltin     isBuiltin; \
        IsEnum        isEnum; \
        Complex       isComplex; \
        IsStruct      isStruct; \
        IsUsed        isUsed; \
        Tunable       isTunable; \
        DtChecksum    dtChecksum; \
        DataTypeId    dtId; \
        DataTypeName  dtName; \
        DataTypeEnum  dtEnum; \
        IsAnonymous   isAnonymous; \
        IsFixpt       isFixpt; \
        IsScaledFloat isFloat; \
        IsSigned      isSigned; \
        RequiredBits  requiredBits; \
        FracSlope     STRING(fracSlope); \
        FixedExp      fixedExp; \
        Bias          STRING(bias); \
        IsHalfPrecision isHalf; \
        TestpointIndex testpointIndex; \
        HasParamWrite hasParamWrite; \
        HasDescendantParamWrite hasDescendantParamWrite; \
        CoderGroup    coderGroup \
    }
%endfunction

%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% Toptetser: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortFcnCall3.m
%% TopTester: test/toolbox/rtw/targets/AUTOSAR/Variants/dimensionVariants/tDimensionVariants.m
%function SLibWriteExternalInputs(blkInterface) void
    %% Write information for Inports
    %foreach idx = ExternalInputs.NumExternalInputs
        %assign inport = ExternalInputs.ExternalInput[idx]
        %with inport

            %% A subset of the information for Inports is always emitted, including
            %% for the "right-click/subsystem build" case

            %if SLibGetRecordIsUnitsEnabled()
                %assign unitExpr = SLibGetRecordASCIIEscapedUnitExpr(inport)
            %else
                %assign unitExpr = ""
            %endif

            %assign recordDataTypeId = LibGetRecordDataTypeId(inport)
            %assign dataTypeEnumFromId = LibGetDataTypeEnumFromId(recordDataTypeId)
            %assign isFcnCall        = dataTypeEnumFromId == "SS_FCN_CALL"

            %assign dataTypeIdx      = recordDataTypeId

            %assign dynamicArrayDataTypeIdx = -1
            %assign isDynamicArray = LibDataTypeIsDynamicMatrix(recordDataTypeId)
            %if isDynamicArray
                %assign dynamicArrayDataTypeIdx = recordDataTypeId
                %assign dataTypeIdx = SLibDynamicArrayContainedDataTypeFromId(recordDataTypeId)
            %endif

            %assign directFT         = (DirectFeedThrough == "yes")
            %assign isBus            = LibDataTypeIsBus(dataTypeIdx)

            %% A DWork index is not written into model.rtw for Top Model root I/O
            %% with variable dims
            %if IsModelReferenceTarget()
                %assign isVarDim           = SLibGetExternalIOIsVarDims(inport)
            %else
                %assign isVarDim           = ISFIELD(inport, "HasVarDims")
            %endif

            %% process the rest of the information only for ModelRefTarget or
            %% "non-right-click / non-subsystem" builds
            %if !CompiledModel.RightClickBuild
                %assign sigID            = LibGetRecordIdentifier(inport) + ":"
                %assign dims             = LibGetRecordDimensions(inport)
                %assign symbolicDims     = LibGetRecordSymbolicDimensions(inport)
                %assign numDimensions    = SIZE(%<dims>,1)
                %assign isFunctionCallInitiator = !(inport.FunctionCallInitiator == "no")


                %assign portWidth        = LibGetRecordWidth(inport)
                %assign symbPortWidth    = LibGetRecordSymbolicWidth(inport)
                %if TYPE(TID) == "Number" && TID != -2
                    %assign sampleTime       = SampleTime[TID].PeriodAndOffset[0]
                    %assign offsetTime       = SampleTime[TID].PeriodAndOffset[1]
                    %assert(TID==SampleTime[TID].TID)
                %else
                    %% Inport block could get constant sample time. see
                    %% tmg1247472_VC1.m:testGeneratedCode
                    %assign sampleTime    = "mxGetInf()"
                    %assign offsetTime    = 0
                %endif

                %assign isBuiltin        = LibIsFundamentalBuiltInDataType(dataTypeIdx)
                %assign isComplex        = LibGetRecordIsComplex(inport)
                %assign isFrame          = (FrameData == "yes")

                %assign isAlias          = LibIsAliasDataType(dataTypeIdx)

                %assign isString         = LibIsStringDataType(dataTypeIdx)
                %assign stringMaxLength  = LibGetStringTypeMaxLength(dataTypeIdx)
                %assign OriPrtIdx = inport.OriginalPortIndex
                %if IsModelReferenceTarget()
                    %assign isReusable       = !(NotReusable == "yes")
                    %assign isGlobalInRTW    = GlobalInRTW == "yes"
                    %assign overwritable     = OverWritable == "yes" ? "true" : "false"
                %else
                    %% For now, specify default values for these properties
                    %% which maintains previous Model block SIL/PIL behavior
                    %assign isReusable    = TLC_FALSE
                    %assign isGlobalInRTW = TLC_TRUE
                    %assign overwritable  = "false"
                %endif
                %assign isAsyncTriggered   = LibAsynchronousTriggeredTID(TID) && !SLibNonInlinedModelWideEventTID(TID)
                %assign isUnion            = SLibUnionSampletimeTID(TID)
                %if isUnion
                    %assign containedTs = ::CompiledModel.SampleTime[TID].ContainedTs
                %else
                    %assign containedTs = TID
                %endif
                %assign isControllableRate = SLibControllableRateTID(TID)
                %assign isZeroBased        = LibBlockIsIndexZeroBased(inport)
                %assign isOneBased         = LibBlockIsIndexOneBased(inport)

                %assign dataTypeName       = getDataTypeName(dataTypeIdx)
                %assign dataEnum           = dataTypeEnumFromId

                %assign isPointer        = dataEnum == "SS_POINTER"
                %assign isInteger        = dataEnum == "SS_INTEGER"

                %assign containedDataTypeId = -1
                %assign isContainedDataComplex = TLC_FALSE
                %assign containedDataDimensions = -1
                %if isDynamicArray
                    %assign containedDataTypeId = SLibDynamicArrayContainedDataTypeFromId(dynamicArrayDataTypeIdx)
                    %assign isContainedDataComplex = SLibDynamicArrayIsContainedDataComplexFromId(dynamicArrayDataTypeIdx)
                    %assign containedDataDimensions = SLibDynamicArrayContainedDataDimensionsFromId(dynamicArrayDataTypeIdx)
                %endif

                %% For image data
                %assign isImage = TLC_FALSE
                %assign imageColorFormat = ""
                %assign pixelDataType = ""
                %assign pixelLayout = ""
                %assign imageNumRows = 0
                %assign imageNumCols = 0
                %assign imageNumChannels = 0
                %if LibIsImageDataType(dataTypeIdx)
                    %assign isImage = TLC_TRUE
                    %assign imageColorFormat = SLibImageColorFormatFromId(dataTypeIdx)
                    %assign pixelDataType = SLibImageBaseTypeFromId(dataTypeIdx)
                    %assign pixelLayout = SLibImageLayoutFromId(dataTypeIdx)
                    %assign imageNumRows = SLibImageNumRowsFromId(dataTypeIdx)
                    %assign imageNumCols = SLibImageNumColsFromId(dataTypeIdx)
                    %assign imageNumChannels = SLibImageNumChannelsFromId(dataTypeIdx)
                %endif

                %% For fixed-point data
                %assign curDT = FixPt_GetDataTypeFromIndex(dataTypeIdx)
                %assign isHalf = TLC_FALSE
                %assign isFixpt = TLC_FALSE
                %assign isScaledFloat = TLC_FALSE
                %assign isSigned = TLC_FALSE
                %assign requiredBits = 0
                %assign fracSlope = 0
                %assign fixedExp = 0
                %assign bias = 0
                %if LibIsHalfDataType(dataTypeIdx)
                    %assign isHalf = TLC_TRUE
                    %assign requiredBits = curDT.RequiredBits
                %else
                    %if curDT.IsFixedPoint
                        %assign isFixpt = TLC_TRUE
                        %assign isScaledFloat = FixPt_DataTypeIsFloat(curDT)
                        %assign isSigned = (curDT.IsSigned == 1.0)
                        %assign requiredBits = curDT.RequiredBits
                        %assign fracSlope = curDT.FracSlope
                        %assign fixedExp = curDT.FixedExp
                        %assign bias = curDT.Bias
                    %endif
                %endif

                %% For Messages
                %assign isMsg = inport.IsMessage
                %if isMsg
                    %assign msgQueueLen  = inport.MessageQueueLength
                    %assign msgQueueType = inport.MessageQueueType
                    %assign msgQueuePOrder = inport.MessageQueuePriorityOrder
                    %assign msgQueueID = inport.MessageQueueID
                    %assign msgQueueExInportIdx = inport.MessageExInportID
                %else
                    %assign msgQueueLen  = -1
                    %assign msgQueueType = ""
                    %assign msgQueuePOrder = ""
                    %assign msgQueueID = -1
                    %assign msgQueueExInportIdx = -1
                %endif

            %endif
        %endwith

        %% Always add UnitExpr and IsFcnCall to the interface Inports: this is to
        %% provide features that work with generated code (for example, SIL) with
        %% information on Simulink Units for inports, even in the case of
        %% "right-click/subsystem" builds, as this is not available in CodeInfo
        %addtorecord blkInterface Inports { \
            UnitExpr                  unitExpr; \
            IsFcnCall                 isFcnCall; \
            DirectFeedThrough         directFT; \
            IsStruct                  isBus; \
            IsVarDim                  isVarDim; \
            IsDynamicArray            isDynamicArray \
        }


        %% add the other fields only for 'non-right-click/non-subsystem' builds
        %if !CompiledModel.RightClickBuild
            %assign designMin = STRING(inport.DesignMin[0])
            %assign designMax = STRING(inport.DesignMax[0])
            %% Some fields are not generated for the RTW target
            %if IsModelReferenceSimTarget()
                %assign feedsDerivPort = inport.FeedsDerivPort
            %else
                %assign feedsDerivPort = []
            %endif

            %addtorecord blkInterface.Inports[idx] \
            DynamicArrayTypeData { \
                ContainedDataTypeId containedDataTypeId \
                IsContainedDataComplex isContainedDataComplex \
                ContainedDataDimensions containedDataDimensions \
            } \
            SID                       sigID; \
            FeedsDerivPort            feedsDerivPort; \
            DesignMin                 designMin; \
            DesignMax                 designMax; \
            FunctionCallInitiator     isFunctionCallInitiator; \
            Dims                      dims; \
            SymbolicDims              symbolicDims; \
            NDims                     numDimensions; \
            DataTypeName              dataTypeName; \
            DataEnum                  dataEnum; \
            PortWidth                 portWidth; \
            SymbolicPortWidth         symbPortWidth; \
            IsBuiltin                 isBuiltin; \
            IsComplex                 isComplex; \
            IsFrame                   isFrame; \
            IsString                  isString; \
            StringMaxLength           stringMaxLength; \
            IsPointer                 isPointer; \
            IsInteger                 isInteger; \
            SampleTime                {Period STRING(sampleTime); \
            Offset STRING(offsetTime)}; \
            IsReusable                isReusable; \
            OverWritable              overwritable; \
            IsAsyncTriggered          isAsyncTriggered; \
            IsUnion                   isUnion; \
            ContainedTs               containedTs; \
            IsControllableRate        isControllableRate; \
            IsZeroBased               isZeroBased; \
            IsOneBased                isOneBased; \
            IsAlias                   isAlias; \
            IsConstant                TLC_FALSE; \
            GlobalInRTW               isGlobalInRTW; \
            IsFixpt                   isFixpt; \
            IsScaledFloat             isScaledFloat; \
            IsSigned                  isSigned; \
            RequiredBits              requiredBits; \
            FracSlope                 STRING(fracSlope); \
            FixedExp                  fixedExp; \
            Bias                      STRING(bias); \
            IsHalfPrecision           isHalf; \
            IsImage                   isImage; \
            ImageColorFormat          imageColorFormat; \
            ImageLayout               pixelLayout; \
            ImageBaseType             pixelDataType; \
            ImageNumRows              imageNumRows; \
            ImageNumCols              imageNumCols; \
            ImageNumChannels          imageNumChannels; \
            OriginalPortIndex         OriPrtIdx \
            IsMessage                 isMsg \
            MessageData { \
                QueueLength           msgQueueLen \
                QueueType             msgQueueType \
                QueuePriorityOrder    msgQueuePOrder \
                QueueID               msgQueueID \
                QueueExInportIdx      msgQueueExInportIdx \
            } \

        %endif
    %endforeach
%endfunction

%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%% TopTester: test/toolbox/simulink/variants/var-general/tStringSupport.m
%% Toptetser: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function SLibWriteExternalOutputs(blkInterface) void
    %% do this outside of the loop because this is a costly operation that
    %% loops over all inputs
    %assign modelOutputSizeDependOnlyInputSize = SLibModelOutputSizeDependOnlyInputSize()

    %foreach idx = ExternalOutputs.NumExternalOutputs
        %with ExternalOutputs
            %% Need cache this information since we can't not get the correct portWidth information
            %% from CodeInfo.
            %assign outport       = ExternalOutput[idx]
            %assign sysIdx        = outport.Block[0]
            %assign blkIdx        = outport.Block[1]
            %assign outportBlock  = System[sysIdx].Block[blkIdx]
            %with System[sysIdx]
                %with outportBlock
                    %% A subset of the information for Outports is always emitted,
                    %% including for the "right-click/subsystem build" case

                    %if SLibGetRecordIsUnitsEnabled()
                        %assign unitExpr      = LibBlockInputSignalASCIIEscapedUnitExpr(0)
                    %else
                        %assign unitExpr      = ""
                    %endif

                    %assign blockInputSignalDataTypeId = LibBlockInputSignalDataTypeId(0)
                    %assign dataTypeEnumFromId = LibGetDataTypeEnumFromId(blockInputSignalDataTypeId)
                    %assign isFcnCall = (dataTypeEnumFromId == "SS_FCN_CALL")
                %endwith
            %endwith

            %assign dataTypeIdx   = blockInputSignalDataTypeId

            %assign dynamicArrayDataTypeIdx = -1
            %assign isDynamicArray = LibDataTypeIsDynamicMatrix(blockInputSignalDataTypeId)
            %if isDynamicArray
                %assign dynamicArrayDataTypeIdx = blockInputSignalDataTypeId
                %assign dataTypeIdx = SLibDynamicArrayContainedDataTypeFromId(blockInputSignalDataTypeId)
            %endif

            %assign isBus = LibDataTypeIsBus(dataTypeIdx)

            %% A DWork index is not written into model.rtw for Top Model root I/O
            %% with variable dims
            %if IsModelReferenceTarget()
                %assign isVarDim  = SLibGetExternalIOIsVarDims(outport)
            %else
                %assign isVarDim  = ISFIELD(outport, "HasVarDims")
            %endif

            %% process the rest of the information only for ModelRefTarget or
            %% for "non-right-click / non-subsystem" builds
            %if !CompiledModel.RightClickBuild
                %assign sigID         = ""
                %assign dims          = LibGetRecordDimensions(outport)
                %assign numDimensions = SIZE(%<dims>,1)

                %assign isZeroBased      = LibBlockIsIndexZeroBased(outport)
                %assign isOneBased       = LibBlockIsIndexOneBased(outport)

                %if ISFIELD(ExternalOutput[idx],"BlkIOUpdatedInAnotherExecContext")
                    %if ExternalOutput[idx].BlkIOUpdatedInAnotherExecContext == "yes"
                        %assign updatedInAnotherCtx = "true"
                    %else
                        %assign updatedInAnotherCtx = "false"
                    %endif
                %else
                    %assign updatedInAnotherCtx = ""
                %endif

                %if EXISTS(ExternalOutput[idx].ICAttributes)
                    %assign hasICAtributes = TLC_TRUE
                    %assign icaStart           = (ExternalOutput[idx].ICAttributes.Start == "yes")
                    %assign icaFirstInitialize = (ExternalOutput[idx].ICAttributes.FirstInitialize == "yes")
                    %assign icaDisable         = (ExternalOutput[idx].ICAttributes.Disable == "yes")
                %else
                    %assign hasICAtributes = TLC_FALSE
                    %assign icaStart = TLC_FALSE
                    %assign icaFirstInitialize = TLC_FALSE
                    %assign icaDisable = TLC_FALSE
                %endif

                %with System[sysIdx]
                    %with outportBlock
                        %assign portWidth     = LibBlockInputSignalWidth(0)
                        %assign symbPortWidth = LibBlockInputSignalSymbolicWidth(0)
                        %assign dims          = SLibBlockInputSignalDimensions(0)
                        %assign symbolicDims  = LibBlockInputSignalSymbolicDimensions(0)

                        %% get the data type name
                        %assign dtName        = getDataTypeName(dataTypeIdx)
                        %assign numDimensions = LibBlockInputSignalNumDimensions(0)
                        %assign isComplex     = LibBlockInputSignalIsComplex(0)
                        %assign isFrame       = LibBlockInputSignalIsFrameData(0)
                        %if TYPE(TID) == "Number" && !SLibParameterChangeEventTID(TID)
                            %assign sampleTime    = SampleTime[TID].PeriodAndOffset[0]
                            %assign offsetTime    = SampleTime[TID].PeriodAndOffset[1]
                            %assert(TID==SampleTime[TID].TID)
                            %assign isConstant    = 0
                        %elseif SLibParameterChangeEventTID(TID)
                            %assign sampleTime    = "mxGetInf()"
                            %assign offsetTime    = 0
                            %assign isConstant    = 1
                            %% At least for now, parameter and constant are both
                            %% treated like legacy constant
                        %else
                            %assign sampleTime    = "mxGetInf()"
                            %assign offsetTime    = "mxGetInf()"
                            %assign isConstant    = 1
                        %endif

                        %assign isString           = LibIsStringDataType(dataTypeIdx)
                        %assign stringMaxLength  = LibGetStringTypeMaxLength(dataTypeIdx)
                        %assign isAsyncTriggered   = LibAsynchronousTriggeredTID(TID) && !SLibNonInlinedModelWideEventTID(TID)
                        %assign isUnion            = SLibUnionSampletimeTID(TID)
                        %if isUnion
                            %assign containedTs = ::CompiledModel.SampleTime[TID].ContainedTs
                        %else
                            %assign containedTs = TID
                        %endif
                        %assign isControllableRate = SLibControllableRateTID(TID)
                        %assign designMin = STRING(ExternalOutputs.ExternalOutput[idx].DesignMin[0])
                        %assign designMax = STRING(ExternalOutputs.ExternalOutput[idx].DesignMax[0])

                        %% Some fields are not generated for the RTW target
                        %if IsModelReferenceSimTarget()
                            %assign discreteValuedOutput = (outport.DiscreteValuedOutput == "yes")
                            %assign fedByBlockWithModesNoZCs = ExternalOutputs.ExternalOutput[idx].FedByBlockWithModesNoZCs
                            %assign nonContinuous = ExternalOutputs.ExternalOutput[idx].NonContinuous
                        %else
                            %assert(!ISFIELD(outport,"DiscreteValuedOutput"))
                            %assert(!ISFIELD(outport,"fedByBlockWithModesNoZCs"))
                            %assert(!ISFIELD(outport,"nonContinuous"))
                            %assign discreteValuedOutput = []
                            %assign fedByBlockWithModesNoZCs = []
                            %assign nonContinuous = []
                        %endif

                        %assign OriPrtIdx    = outport.OriginalPortIndex
                        %if IsModelReferenceTarget()
                            %assign isReusable  = !(outport.NotReusable == "yes")
                            %assign globalInRTW = outport.GlobalInRTW == "yes"
                            %assign okToMerge = outport.OkToMerge
                        %else
                            %% For now, specify default values for these properties
                            %% which maintains previous Model block SIL/PIL behavior
                            %assert(!ISFIELD(outport,"OkToMerge"))
                            %assign isReusable  = TLC_FALSE
                            %assign globalInRTW = TLC_TRUE
                            %assign okToMerge = []
                        %endif

                        %assign isBuiltin = LibIsFundamentalBuiltInDataType(dataTypeIdx)
                        %assign isAlias = LibIsAliasDataType(dataTypeIdx)
                        %assign curDT = FixPt_GetDataTypeFromIndex(dataTypeIdx)
                        %assign isFixpt = TLC_FALSE
                        %assign isHalf = TLC_FALSE
                        %assign isScaledFloat = TLC_FALSE
                        %assign isSigned = TLC_FALSE
                        %assign requiredBits = 0
                        %assign fracSlope = 0
                        %assign fixedExp = 0
                        %assign bias = 0

                        %% For image data
                        %assign isImage = TLC_FALSE
                        %assign imageColorFormat = ""
                        %assign pixelDataType = ""
                        %assign pixelLayout = ""
                        %assign imageNumRows = 0
                        %assign imageNumCols = 0
                        %assign imageNumChannels = 0
                        %if LibIsImageDataType(dataTypeIdx)
                            %assign isImage = TLC_TRUE
                            %assign imageColorFormat = SLibImageColorFormatFromId(dataTypeIdx)
                            %assign pixelDataType = SLibImageBaseTypeFromId(dataTypeIdx)
                            %assign pixelLayout = SLibImageLayoutFromId(dataTypeIdx)
                            %assign imageNumRows = SLibImageNumRowsFromId(dataTypeIdx)
                            %assign imageNumCols = SLibImageNumColsFromId(dataTypeIdx)
                            %assign imageNumChannels = SLibImageNumChannelsFromId(dataTypeIdx)
                        %endif

                        %if LibIsHalfDataType(dataTypeIdx)
                            %assign isHalf = TLC_TRUE
                            %assign requiredBits = curDT.RequiredBits
                        %else
                            %if curDT.IsFixedPoint
                                %assign isFixpt = TLC_TRUE
                                %assign isScaledFloat = FixPt_DataTypeIsFloat(curDT)
                                %assign isSigned = (curDT.IsSigned == 1.0)
                                %assign requiredBits = curDT.RequiredBits
                                %assign fracSlope = curDT.FracSlope
                                %assign fixedExp = curDT.FixedExp
                                %assign bias = curDT.Bias
                            %endif
                        %endif

                        %assign dtEnum = dataTypeEnumFromId
                        %assign isPointer = (dtEnum == "SS_POINTER")
                        %assign isInteger = (dtEnum == "SS_INTEGER")

                        %assign containedDataTypeId = -1
                        %assign isContainedDataComplex = TLC_FALSE
                        %assign containedDataDimensions = -1
                        %if isDynamicArray
                            %assign containedDataTypeId = SLibDynamicArrayContainedDataTypeFromId(dynamicArrayDataTypeIdx)
                            %assign isContainedDataComplex = SLibDynamicArrayIsContainedDataComplexFromId(dynamicArrayDataTypeIdx)
                            %assign containedDataDimensions = SLibDynamicArrayContainedDataDimensionsFromId(dynamicArrayDataTypeIdx)
                        %endif

                        %% Copy the logic from SLibDumpRegisterSetOutputSizeRuleTerms()

                        %assign NumInputsDimsDependRules = []
                        %assign DimsDependRulesInputIndices = []
                        %if modelOutputSizeDependOnlyInputSize
                            %if isVarDim
                                %assign NumInputsDimsDependRules = outport.NumInputsDimsDependRules
                                %assign DimsDependRulesInputIndices = outport.DimsDependRulesInputIndices
                            %endif
                        %endif

                        %% For Messages
                        %assign isMsg = outport.IsMessage

                    %endwith
                %endwith
            %endif
        %endwith

        %% Always add UnitExpr and IsFcnCall to the interface Outports: this is to
        %% provide features that work with generated code (for example, SIL) with
        %% information on Simulink Units for inports, even in the case of
        %% "right-click/subsystem" builds, as this is not available in CodeInfo
        %addtorecord blkInterface Outports { \
            UnitExpr                       unitExpr; \
            IsFcnCall                      isFcnCall; \
            IsStruct                       isBus; \
            IsVarDim                       isVarDim; \
            IsDynamicArray            isDynamicArray \
        }

        %% add the other fields only for 'non-right-click/non-subsystem' builds
        %if !CompiledModel.RightClickBuild
            %addtorecord blkInterface.Outports[idx]  \
            DynamicArrayTypeData { \
                ContainedDataTypeId containedDataTypeId \
                IsContainedDataComplex isContainedDataComplex \
                ContainedDataDimensions containedDataDimensions \
            }; \
            SID                            sigID; \
            Dims                           dims; \
            SymbolicDims                   symbolicDims; \
            NDims                          numDimensions; \
            DataTypeIdx                    dataTypeIdx; \
            OkToMerge                      okToMerge; \
            FedByBlockWithModesNoZCs       fedByBlockWithModesNoZCs; \
            NonContinuous                  nonContinuous; \
            DesignMin                      designMin; \
            DesignMax                      designMax; \
            PortWidth                      portWidth; \
            SymbolicPortWidth              symbPortWidth; \
            IsComplex                      isComplex; \
            IsFrame                        isFrame; \
            IsBuiltin                      isBuiltin; \
            IsString                       isString; \
            StringMaxLength                stringMaxLength; \
            IsPointer                      isPointer; \
            IsInteger                      isInteger; \
            DataTypeName                   dtName; \
            IsReusable                     isReusable; \
            GlobalInRTW                    globalInRTW; \
            HasICAtributes                 hasICAtributes; \
            ICAttributes { \
                Start           icaStart \
                FirstInitialize icaFirstInitialize \
                Disable         icaDisable \
            }; \
            IsConstant                       isConstant; \
            SampleTime                       {Period STRING(sampleTime); \
            Offset STRING(offsetTime)  }; \
            BlkIOUpdatedInAnotherExecContext updatedInAnotherCtx; \
            IsAsyncTriggered                 isAsyncTriggered; \
            IsUnion                          isUnion; \
            ContainedTs                      containedTs; \
            IsControllableRate               isControllableRate; \
            IsZeroBased                      isZeroBased; \
            IsOneBased                       isOneBased; \
            IsAlias                          isAlias; \
            DiscreteValuedOutput             discreteValuedOutput; \
            IsFixpt                   isFixpt; \
            IsScaledFloat             isScaledFloat; \
            IsSigned                  isSigned; \
            RequiredBits              requiredBits; \
            FracSlope                 STRING(fracSlope); \
            FixedExp                  fixedExp; \
            Bias                      STRING(bias); \
            IsHalfPrecision           isHalf; \
            IsImage                   isImage; \
            ImageColorFormat          imageColorFormat; \
            ImageLayout               pixelLayout; \
            ImageBaseType             pixelDataType; \
            ImageNumRows              imageNumRows; \
            ImageNumCols              imageNumCols; \
            ImageNumChannels          imageNumChannels; \
            NumInputsDimsDependRules  NumInputsDimsDependRules; \
            DimsDependRulesInputIndices DimsDependRulesInputIndices; \
            OriginalPortIndex         OriPrtIdx \
            IsMessage                 isMsg \

        %endif
    %endforeach
%endfunction

%% Function: SLibCreateModelInterface
%% Abstract:
%%     Cache cross-target data in the MAT file
%%     This data is applicable to model reference and standalone
%%     code generation targets.
%% TopTester: test/toolbox/simulink/blocks/CPPCodeGen/tsmlk_core_cpp_coverage.m
%% TopTester: test/toolbox/simulink/coreblocks/lib_SignalAttributes/InitialCondition/rtw/tinitcond.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/simulink/variants/modelVariants/tVariantsBasic_g724566.m
%% TopTester: test/toolbox/simulink/variants/var-general/tTypesToPrivate.m
%%
%function SLibCreateModelInterface()
    %createrecord blkInterface { Name  "%<Name>"}

    %% check for a model reference build or for
    %% "non-right-click / non-subsystem" builds
    %if !CompiledModel.RightClickBuild

        %addtorecord blkInterface ParameterChangeEventTID %<SLibTidOfParameterChangeEvent()>

        %addtorecord blkInterface DisallowSampleTimeInheritance %<MdlRefDisallowSampleTimeInheritance()>

        %% StartTime
        %addtorecord blkInterface StartTime "%<StartTime>"
        %% StopTime
        %addtorecord blkInterface StopTime "%<StopTime>"
        %% EvaledLifeSpan
        %addtorecord blkInterface EvaledLifeSpan ...
            "%<::CompiledModel.ConfigSet.EvaledLifeSpan>"

        %addtorecord blkInterface FixedStepSizeBasedOnHeuristic (::CompiledModel.FixedStepSizeBasedOnHeuristic == "yes")

        %% It's possible that the SIM and Coder targets have different requirements
        %% for absolute time, so we store it in the interface. (See InitCond block)
        %addtorecord blkInterface NeedAbsoluteTime SLibNeedAbsoluteTime()

        %% It's possible that the SIM and Coder targets have different results for
        %% for inheritance allowed, so we store it in the interface. (For example,
        %% If a model has no inports and only prmTs outports, for sim targets it is
        %% disallowed, but for rtw targets the outports can be the fundTs and then
        %% inheritance can be allowed (see g1497319)
        %addtorecord blkInterface ModelRefTsInheritanceAllowed ::CompiledModel.ModelSampleTimeInheritanceDetails.AllowedOverall == "yes" ? TLC_TRUE : TLC_FALSE

        %addtorecord blkInterface ModelRefTsInheritance      "%<ModelRefTsInheritance>"

        %% StartTime
        %addtorecord blkInterface SolverType "%<SolverType>"

        %% Adding NumRuntimeExportedRates from top model
        %assign numRuntimeExportedRates = ::CompiledModel.NumRuntimeExportedRates
        %addtorecord blkInterface NumRuntimeExportedRates %<numRuntimeExportedRates>

        %% Adding HasPartitions from top model
        %assign hasPartitions = ::CompiledModel.HasPartitions
        %addtorecord blkInterface HasPartitions "%<hasPartitions>"

        %if IsModelReferenceTarget()
            %addtorecord blkInterface IsConstant %<MdlRefIsConstSampleBlock()>
        %else
            %% IsConstant: Currently only available for referenced models, but
            %% SIL/PIL doesn't support constant Model blocks anyway (g753925)
            %% so for now, hardcode to false.
            %addtorecord blkInterface IsConstant TLC_FALSE
        %endif

        %addtorecord blkInterface IsExportFcnDiagram         SLibIsExportFcnDiagram()

        %addtorecord blkInterface IsAPeriodicTriggered %<MdlRefIsAPERTriggeredBlock()>
        %addtorecord blkInterface MatrixDimensionThreshhold  matrixDimensionThreshhold

        %<SLibWriteExternalPortGroups(blkInterface)>
        %<SLibWriteFunctionCallInfo(blkInterface)>

    %endif
    %if EXISTS(::UseMemberFunctionsForRTM)
        %addtorecord blkInterface UseMemberFunctionsForRTM ::UseMemberFunctionsForRTM
    %endif
    %% process this information also for a subsystem build
    %<SLibWriteSimulinkFunctions(blkInterface)>
    %<SLibWriteServicePorts(blkInterface)>
    %<SLibWriteExternalOutputs(blkInterface)>
    %<SLibWriteExternalInputs(blkInterface)>

    %<SLibWriteModelWideEventsInfo(blkInterface)>
    %return blkInterface
%endfunction

%function SLibAddCommonModelInterface(blkInterface) void
    %% Add information common to model reference and top model interfaces
    %% to modelInterface.
    %%

    %% Non-inlined s-function
    %addtorecord blkInterface HasNonInlinedSfcn SLibModelHierarchyContainsNoninlinedSfcn()
    %addtorecord blkInterface NonInlinedSFcnNames %<SLibGetNonInlinedSFcnNames()>

    %% FirstInitCond flag
    %addtorecord blkInterface FirstInitConditionReq SLibGetIsFirstInitCondAccessed()

    %% FcnCallMdlRefTriggerTIDIsReq
    %if (IsModelReferenceTarget() || HasModelReferenceBlocks())
        %addtorecord blkInterface FcnCallMdlRefTriggerTIDIsReq SLibModelNeedsTriggerTIDArg()
    %else
        %addtorecord blkInterface FcnCallMdlRefTriggerTIDIsReq TLC_FALSE
    %endif

    %% Global DSM declarations
    %addtorecord blkInterface GlobalDSMDeclarations      %<SLibGetModelRefGlobalDSMDeclarations()>

    %% Needs global timing engine
    %addtorecord blkInterface NeedsGlobalTimingEngine %<::tMdlRefTimingBridgeAccessed>

    %% RateGrouped
    %if SLibIsPeriodicRateGrouping()
        %addtorecord blkInterface RateGrouped 1
    %else
        %addtorecord blkInterface RateGrouped 0
    %endif

    %% HasDWork - ModelrefBlockNeedsDwork() does not give the correct answer
    %% if called from SLibAddModelReferenceModelInterface because
    %% EmptyRealTimeObject is not set to its final value at that point.
    %addtorecord blkInterface HasDWork %<ModelrefBlockNeedsDwork()>

    %% HasPrivateDWork - This is added for rapid accelerator simulation of Model
    %% block with initialize port. The top model needs to save and restore some
    %% of the DWork content. For multi-instance, this is straight forward since
    %% the top model can easily access the "InstanceData" DWork of the Model
    %% block. For single instance, the DWork struct is hidden. We use this flag
    %% to indicate such case.
    %addtorecord blkInterface HasPrivateDWork %<ModelRefBlockHasPrivateDWork()>

    %%----------
    %% Even though we don't inline function calls to "Top Model"
    %% code through a model block in generated code these records must be
    %% added for the Top Model code interface as well as the Model Reference
    %% code interface, to trigger the inlining of the correct calls back
    %% into Simulink when simulating a Top Model in Accelerator mode that
    %% contains one or more Model Blocks configured for SIL/PIL with a
    %% Top Model code interface *when using an ERT (or ERT-derived) target*.
    %assign needFunctionInfoInModelInterface = ...
        IsModelReferenceTarget() || SLibIsERTTarget()
    %if !needFunctionInfoInModelInterface
        %% Return early if the function info is not needed in modelInterface.
        %return blkInterface
    %endif

    %assign sysIdx = GetBaseSystemIdx()
    %if IsModelReferenceTarget()
        %assign rootIdx = sysIdx+1
    %else
        %assign rootIdx = sysIdx
    %endif
    %assign baseSystem = ::CompiledModel.System[sysIdx]

    %<FcnAppendToBlockInterface(sysIdx, rootIdx, "SystemInitialize", "", blkInterface)>

    %% Do not add the Initialize or Enable methods to the interface for
    %% models with Enable port at the root.  This is because the enabling
    %% behavior is controlled internally by the model, and shouldn't be called
    %% by the parent.
    %if (::CompiledModel.HasRootEnablePort == "no")
        %<FcnAppendToBlockInterface(sysIdx, rootIdx, "SystemReset", "", blkInterface)>
        %<FcnAppendToBlockInterface(sysIdx, rootIdx, "Enable", "", blkInterface)>
    %endif
    %<FcnAppendToBlockInterface(sysIdx, rootIdx, "SetupRuntimeResources", "", blkInterface)>
    %<FcnAppendToBlockInterface(sysIdx, rootIdx, "Start", "", blkInterface)>
    %<FcnAppendToBlockInterface(sysIdx, rootIdx, "Disable", "", blkInterface)>

    %if IsModelReferenceTarget()
        %% Write out the arguments for the registration function, this
        %% will be called from the parent registration function.
        %if !SLibGetEmptyModelRefInitializeFcn()
            %<FcnAppendToBlockInterface(sysIdx, rootIdx, "Registration", "", blkInterface)>
        %endif
    %endif

    %foreach idx = SLibNumTidsWithModelEntryPoints()
        %assign tid = SLibModelEntryPointTid(idx, TLC_TRUE)
        %<FcnAppendToBlockInterface(sysIdx, rootIdx, "Output", tid, blkInterface)>
    %endforeach
    %%

    %foreach idx = SLibNumTidsWithModelEntryPoints()
        %assign tid = SLibModelEntryPointTid(idx, TLC_TRUE)
        %<FcnAppendToBlockInterface(sysIdx, rootIdx, "OutputUpdate", tid, blkInterface)>
    %endforeach
    %%

    %foreach idx = SLibNumTidsWithModelEntryPoints()
        %assign tid = SLibModelEntryPointTid(idx, TLC_TRUE)
        %% Model wide events do not have update functions.
        %if !SLibNonInlinedIRTEventTID(tid)
            %<FcnAppendToBlockInterface(sysIdx, rootIdx, "Update",tid, blkInterface)>
        %endif
    %endforeach

    %<FcnAppendToBlockInterface(sysIdx, rootIdx, "SetDims", "", blkInterface)>
    %<FcnAppendToBlockInterface(sysIdx, rootIdx, "FinalizeDims", "", blkInterface)>
    %<FcnAppendToBlockInterface(sysIdx, rootIdx, "Projection", "", blkInterface)>
    %<FcnAppendToBlockInterface(sysIdx, rootIdx, "ZeroCrossing", "", blkInterface)>
    %<FcnAppendToBlockInterface(sysIdx, rootIdx, "Derivative", "", blkInterface)>

    %<FcnAppendToBlockInterface(sysIdx, rootIdx, "MassMatrix", "", blkInterface)>
    %<FcnAppendToBlockInterface(sysIdx, rootIdx, "ForcingFunction", "", blkInterface)>

    %<FcnAppendToBlockInterface(sysIdx, rootIdx, "Terminate", "", blkInterface)>
    %<FcnAppendToBlockInterface(sysIdx, rootIdx, "CleanupRuntimeResources", "", blkInterface)>
    %%
    %%----------
    %return blkInterface
%endfunction

%% TopTester: test/toolbox/simulink/coreblocks/lib_SignalAttributes/InitialCondition/rtw/tinitcond.m
%% TopTester: test/toolbox/simulink/variants/modelVariants/tVariantsBasic_g724566.m
%%
%function SLibWriteModelSettings(blkInterface) void
    %% Coder Data Groups local to this model
    %<SLibWriteCoderDataGroupsInfo(blkInterface)>
    %% process this information only for ModelRefTarget or
    %% "non-right-click / non-subsystem" builds
    %if !CompiledModel.RightClickBuild
        %addtorecord blkInterface LibSystemFcnIsEmpty LibSystemFcnIsEmpty(System[GetBaseSystemIdx()], "FinalizeDims")

        %if ISFIELD(::CompiledModel, "SignalSizeComputeType")
            %addtorecord blkInterface SignalSizeComputeType ISEQUAL(::CompiledModel.SignalSizeComputeType, "FromInputSize")
        %endif

        %if (IsModelReferenceTarget())
            %addtorecord blkInterface GlobalScopeTid "%<::CompiledModel.GlobalScope.tTID>"
            %addtorecord blkInterface DisallowsMdlRefFromVarStepTop "%<::CompiledModel.DisallowsMdlRefFromVarStepTop>"
            %addtorecord blkInterface MdlGenRateGroupingCode     "%<::CompiledModel.MdlGenPeriodicRateGroupingCode>"
            %addtorecord blkInterface ModelMassMatrixType        %<::CompiledModel.ModelMassMatrixType>
            %addtorecord blkInterface ModelMassMatrixNzMax       %<::CompiledModel.ModelMassMatrixNzMax>
            %addtorecord blkInterface NumContStates              %<::CompiledModel.NumContStates>
            %assign numPeriodicContStates = ::CompiledModel.NumPeriodicContStates
            %addtorecord blkInterface NumPeriodicContStates      %<numPeriodicContStates>
            %if numPeriodicContStates > 0
                %addtorecord blkInterface PeriodicCStateIndices      %<::CompiledModel.PeriodicCStateIndices>
                %addtorecord blkInterface PeriodicCStateRanges       %<::CompiledModel.PeriodicCStateRanges>
            %endif

            %addtorecord blkInterface NumSLBuiltInDataTypes      ::CompiledModel.DataTypes.NumSLBuiltInDataTypes
            %addtorecord blkInterface UsePortBasedTs             SLibUsePortBasedSampleTime()
        %endif

        %% Referenced models can support multithreading if they
        %%  1. Don't use any global or shared DSMs
        %%  2. Don't have any Simulink Functions or Callers
        %%  3. Don't contain a Model block that doesn't support multi-threading
        %%  4. Don't contain any calls to reset the solver
        %%  5. The model is not completely constant
        %%  6. Don't have any to or from file blocks
        %%
        %% See the file src/sl_compile/mdlref/ModelRefMultiThreadingBlockers.cpp for details,
        %% there remains one check that needs to be done in TLC for resetting solver
        %if IsModelReferenceTarget()
            %assign supportsMultiThreading = CGMODEL_ACCESS("CGModel.SupportsMultiThreading") && ...
                !::CompiledModel.ReferencedModelMayResetSolver
        %else
            %% SupportsMultiThreading entry must be present in modelInterface for
            %% Top Model code interface so that modelInterface from a Top Model
            %% can be used when referencing a model block in SIL/PIL mode from
            %% a parent model in Accelerator mode without needing to build a SIM
            %% target that would otherwise not be used.
            %assign supportsMultiThreading = TLC_FALSE
        %endif
        %addtorecord blkInterface SupportsMultiThreading %<supportsMultiThreading>

        %% For mdlInitSystemMatrices
        %addtorecord blkInterface ModelIsLinearlyImplicit (ModelIsLinearlyImplicit == "yes")
        %if (ModelIsLinearlyImplicit == "yes")
            %addtorecord blkInterface ModelMassMatrixJc %<ModelMassMatrixJc>
            %addtorecord blkInterface ModelMassMatrixIr %<ModelMassMatrixIr>
        %endif

        %% For StateEnableSubsystem feature
        %if EXISTS(AllowInStateEnabledSubsystem)
            %addtorecord blkInterface AllowInStateEnabledSubsystem (AllowInStateEnabledSubsystem == "yes")
        %endif

        %if ISFIELD(::CompiledModel, "IndexMode")
            %addtorecord blkInterface IndexMode           "%<::CompiledModel.IndexMode>"
        %endif

        %addtorecord blkInterface SolverName     "%<Solver>"
        %if SolverType == "FixedStep"
            %addtorecord blkInterface FixedStepOpts {FixedStep STRING(FixedStepOpts.FixedStep) SolverMode FixedStepOpts.SolverMode}
        %else
            %if SolverType == "VariableStep" && NumContStates > 0
                %assign AbsTolControl = VariableStepOpts.AbsTolControl
            %else
                %assign AbsTolControl = []
            %endif

            %addtorecord blkInterface VariableStepOpts { \
                MaxOrder      STRING(VariableStepOpts.MaxOrder); \
                RelTol        STRING(VariableStepOpts.RelTol); \
                MaxStep       STRING(VariableStepOpts.MaxStep); \
                MinStep       STRING(VariableStepOpts.MinStep); \
                InitialStep   STRING(VariableStepOpts.InitialStep); \
                AbsTolControl AbsTolControl \
            }
        %endif
        %% Cache SolverResetInfo
        %assign NumNonContOutputSignals = []
        %if EXISTS(SolverResetInfo.NonContOutputSignals)
            %foreach idx = ExternalOutputs.NumExternalOutputs
                %assign nonContOut = SolverResetInfo.NonContOutputSignals.NonContOutput[idx]
                %assign NumNonContOutputSignals = NumNonContOutputSignals + nonContOut.NumNonContOutputSignals
            %endforeach

        %endif
        %assign NumNonContDerivSignals = SolverResetInfo.NumNonContDerivSignals
        %addtorecord blkInterface SolverResetInfo { \
            ZCCacheNeedsReset SolverResetInfo.ZCCacheNeedsReset; \
            DerivCacheNeedsReset SolverResetInfo.DerivCacheNeedsReset \
            NumNonContOutputSignals NumNonContOutputSignals \
            NumNonContDerivSignals NumNonContDerivSignals \
        }

        %% For mdlStart S-function
        %if (IsModelReferenceTarget())
            %addtorecord blkInterface SFcnNonFiniteBuffer SLibGetSFcnNonFinite()
            %addtorecord blkInterface RealNonFinitesRequired SLibRealNonFinitesRequired()
            %addtorecord blkInterface IsModelRefScalableBuild IsModelRefScalableBuild()
        %endif

        %if !::GenerateClassInterface && IsModelReferenceSimTarget()
            %addtorecord blkInterface SFcnDWorkIdentifier FcnGetSFcnDWorkIdentifier(System[GetBaseSystemIdx()])
        %endif

        %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
        %% We must call these two functions from the S-function to allow
        %% loading and saving of SimState from accelerator mode models
        %%
        %addtorecord blkInterface ...
            ModelGetDWorkFcnName SLibCreateGetDWorkFcnNameForModel(Name)
        %addtorecord blkInterface ...
            ModelSetDWorkFcnName SLibCreateSetDWorkFcnNameForModel(Name)

        %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
        %% We also need to find out which models, if any, have disallowed blocks,
        %% and report a reason why they are disallowed.
        %%
        %addtorecord blkInterface ...
            ModelGetSimStateDisallowedBlocksFcnName ...
            SLibCreateGetSimStateDisallowedBlocksFcnNameForModel(Name)

        %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
        %% We obtain the checksum directly from the model. This prevents structural
        %% changes that do not affect the interface from triggering rebuilds of
        %% models that reference the current target. This also allows changes to the
        %% SimState checksum to be pulled up to the top model without regenerating
        %% the code for intermediate models. Thus, only the name of the function
        %% called to get the checksum goes into the interface, and not the
        %% checksum itself.
        %%
        %addtorecord blkInterface ...
            ModelRegisterSimStateChecksumFcnName ...
            SLibCreateRegisterSimStateChecksumFcnNameForModel(Name)

        %% Cache tofile and fromfile information
        %foreach idx = SIZE(UniqueFromFiles,1)
            %addtorecord blkInterface UniqueFromFiles {Name STRING(UniqueFromFiles[idx])}
        %endforeach

        %foreach idx = SIZE(UniqueToFiles,1)
            %addtorecord blkInterface UniqueToFiles {Name STRING(UniqueToFiles[idx])}
        %endforeach
    %endif

    %% Local message queues
    %if ISFIELD(::CompiledModel, "LocalMessageQueues")
        %foreach locQIdx = ::CompiledModel.LocalMessageQueues.NumLocalMessageQueues
            %assign qSpec = ::CompiledModel.LocalMessageQueues.MessageQueue[locQIdx]
            %assign qType = STRING(qSpec.QueueType)
            %assign qLen = qSpec.QueueLength
            %assign qOrder = STRING(qSpec.PriorityOrder)
            %assign qDType = qSpec.DataType
            %assign qDSize = qSpec.DataSize
            %assign qDCplx = STRING(qSpec.DataComplexity)
            %assign qDDims = qSpec.DataDims
            %assign qExtInpIdx = qSpec.ExternalInputIdx
            %createrecord LocalMessageQueueInfo {}
            %addtorecord LocalMessageQueueInfo QueueType qType
            %addtorecord LocalMessageQueueInfo QueueLength qLen
            %addtorecord LocalMessageQueueInfo PriorityOrder qOrder
            %addtorecord LocalMessageQueueInfo DataType qDType
            %addtorecord LocalMessageQueueInfo DataSize qDSize
            %addtorecord LocalMessageQueueInfo DataComplexity qDCplx
            %addtorecord LocalMessageQueueInfo DataDims qDDims
            %addtorecord LocalMessageQueueInfo ExternalInputIdx qExtInpIdx
            %addtorecord blkInterface LocalMessageQueueInfo %<LocalMessageQueueInfo>
        %endforeach
    %endif
%endfunction

%function FcnGetScopedDSMInitializerForGroup(group, selfPath) void
    %assign baseSystem = ::CompiledModel.System[GetBaseSystemIdx()]
    %assign varGroupIndex = FcnSysVarGroupIndex(baseSystem, "CoderDataGroup" + group.Name, 0)
    %createrecord scopedDSMs {}
    %if varGroupIndex != -1
        %assign group = FcnGetCoderGroupForVarGroup(::CompiledModel.VarGroups.VarGroup[varGroupIndex])
        %assign separator = FcnGetSeparatorForGroup(group)
        %assign insideForEach = TLC_FALSE
        %<FcnGetVarGroupScopedDSMInitializer(varGroupIndex, scopedDSMs, selfPath + separator, insideForEach)>
    %endif
    %return scopedDSMs
%endfunction

%function FcnGetScopedDSMInitializerForMultiInstanceDWork() void
    %assign singleInstMdlRef = IsModelReferenceTarget() && ...
        !::CompiledModel.OkToMultiInstanceModelref
    %if singleInstMdlRef
        %return
    %endif
    %assign baseSystem = ::CompiledModel.System[GetBaseSystemIdx()]
    %assign varGroupIndex = FcnSysVarGroupIndex(baseSystem, "DWork", 0)
    %if varGroupIndex >= 0
        %assign path = (GenerateClassInterface ? ::tDWork : (SLibGetUseRTMcgType() ? "dwork" : "rtdw")) + "."
        %assign insideForEach = TLC_FALSE
        %<FcnGetVarGroupScopedDSMInitializer(varGroupIndex, ::CompiledModel.ScopedDSMInMultiInstanceDWork, path, insideForEach)>
    %endif
%endfunction

%function FcnGetScopedDSMInitializerForSingleInstance() void
    %assign singleInstMdlRef = IsModelReferenceTarget() && ...
        !::CompiledModel.OkToMultiInstanceModelref
    %if !singleInstMdlRef
        %return
    %endif
    %assign insideForEach = TLC_FALSE
    %assign baseSystem = ::CompiledModel.System[GetBaseSystemIdx()]
    %% First, dwork
    %assign varGroupIndex = FcnSysVarGroupIndex(baseSystem, "DWork", 0)
    %if varGroupIndex >= 0
        %assign path = FcnSysVarGroupNonreusedName(baseSystem, "DWork") + "."
        %<FcnGetVarGroupScopedDSMInitializer(varGroupIndex, ::CompiledModel.ScopedDSMInSingleInstance, path, insideForEach)>
    %endif
    %% Next, all single-instance vargroups
    %assign numGroups = ::CompiledModel.NumCoderDataGroups
    %foreach groupIdx = numGroups
        %assign group = ::CompiledModel.CoderDataGroup[groupIdx]
        %if !group.IsInstanceSpecific
            %assign groupName = group.Name
            %assign groupToken = "CoderDataGroup" + groupName
            %assign varGroupIndex = FcnSysVarGroupIndex(baseSystem, groupToken, 0)
            %if varGroupIndex >= 0
                %if group.AsStructure == "None"
                    %assign path = ""
                %else
                    %assign path = FcnSysVarGroupNonreusedName(baseSystem, groupToken) + "."
                %endif
                %<FcnGetVarGroupScopedDSMInitializer(varGroupIndex, ::CompiledModel.ScopedDSMInSingleInstance, path, insideForEach)>
            %endif
        %endif
    %endforeach
%endfunction

%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function SLibWriteCoderDataGroupsInfo(blkInterface) void
    %% Coder Data Groups local to this model
    %assign baseIdx = GetBaseSystemIdx()
    %assign numGroups = ::CompiledModel.NumCoderDataGroups
    %assign singleInstMdlRef = IsModelReferenceTarget() && ...
        !::CompiledModel.OkToMultiInstanceModelref
    %if numGroups > 0
        %assign groupIdx = 0
        %foreach gIdx = numGroups
            %assign group = ::CompiledModel.CoderDataGroup[gIdx]
            %assign groupInstanceInParent = SLibAccessViaPointerInSelf(group) && IsModelReferenceTarget()
            %assign selfPointerInit = FcnGetCoderGroupSelfPointerInit(group)
            %if !SLibAllocatesCoderDataGroup(group) || !IsModelReferenceTarget()
                %if (((group.IsInstanceSpecific || group.ContainsInstanceSpecificParameter) && ...
                    SLibDataGroupStaticInit(group)) || ...
                    groupInstanceInParent)
                    %if !SLibCoderGroupPackageAsStruct(group) ...
                        || (LibCoderDataGroupStructIsEmpty(group) ...
                        && !SLibHaveRootDataGroupVarGroup(group))
                        %continue
                    %endif

                    %% Populate Self related attributes for Coder Group
                    %assign selfCoderGroupIndex = SLibGetSelfCoderDataGroupIndex()
                    %assign groupSelfInstanceName = ""
                    %if gIdx == selfCoderGroupIndex
                        %assign selfVarGroupIndex = SLibGetSelfVarGroupIndex()
                        %assert selfVarGroupIndex != -1
                        %assign selfVarGroup = ::CompiledModel.VarGroups.VarGroup[selfVarGroupIndex]
                        %assign groupSelfInstanceName = selfVarGroup.SelfStructureInstanceName
                    %endif

                    %% Compute SelfPath. First, IsSelf
                    %if group.IsSelf
                        %assign selfPath = ""

                        %% Next, single-instance
                    %elseif !SLibMultiInstance()
                        %assign selfPath = SLibCoderDataGroupInstance(group)
                        %% Next, multi-instance mdlref
                    %elseif IsModelReferenceTarget()
                        %if ::CompiledModel.ModelRefSimpInterface || FcnRTMAllocateInParent()
                            %assign selfPath = SLibCoderDataGroupRTMFieldName(group)
                        %else
                            %if ::CompiledModel.SLCI == "on"
                                %assign MODELDATA = "ModelData."
                            %else
                                %assign MODELDATA = ""
                            %endif
                            %assign selfPath = "rtm." + MODELDATA + SLibCoderDataGroupRTMFieldName(group)
                        %endif

                        %% Finally, top multi-instance
                    %else
                        %assign selfPath = SLibGetCoderDataGroupPointerFromRTM(group, 0)
                    %endif

                    %% Compute GroupPath, the path independent of self
                    %% Obviously this has meaning for InParent, but this can
                    %% also has meaning for InSelf groups which copy to the
                    %% memory in self from a mirror. It also has meaning for
                    %% multi-instance standalone groups.
                    %assign groupToken = "CoderDataGroup" + group.Name

                    %% First, Inparent
                    %if group.AsStructure == "InParent"
                        %assign groupPath = ""
                        %assign varGroupIdx = SLibGetRootVarGroupIdxForCoderGroup(group)
                        %if !SLibMultiInstance() && (varGroupIdx >= 0)
                            %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
                            %assign structInstance = ISFIELD(varGroup, "StructureInstanceName") ? ...
                                varGroup.StructureInstanceName : varGroup.SelfStructureInstanceName
                            %assign groupPath = structInstance
                        %endif

                        %% Special handling for AUTOSAR
                    %elseif SLibIsAutosarPIMCoderGroup(group) || SLibIsAutosarInstPCoderGroup(group)
                        %%Omit the first _ for AutosarPIM coder group, otherwise, a PIM name with double underscore
                        %%is created, and it is not valid for Autosar.
                        %assign len = SIZE(group.Name, 1)
                        %assign groupPath = Substring(group.Name, 1, len)

                        %% Now, multi-instance Standalone or InSelf
                    %elseif SLibMultiInstance() && ((group.AsStructure == "Standalone") || ...
                        (group.AsStructure == "InSelf"))
                        %assign groupPath = group.Name

                        %% Finally, single-instance Standalone
                    %else
                        %assign groupPath = selfPath
                    %endif

                    %assign type = FcnSysVarGroupType(::CompiledModel.System[baseIdx], groupToken)
                    %createrecord dynamicInit%<gIdx> {}
                    %assign isImportedFromFile = SLibCoderDataGroupIsImportedFromFile(group)
                    %if SLibIsCoderDataGroupInitializerEmpty(isImportedFromFile, group)
                        %assign initializer = ""
                    %else
                        %assign initializer = FcnGetDataGroupInitializer(group, selfPath, dynamicInit%<gIdx>)
                    %endif

                    %assign scopedDSMs%<gIdx> = FcnGetScopedDSMInitializerForGroup(group, selfPath)

                    %if group.ContainsInstanceSpecificParameter && singleInstMdlRef
                        %assign varGroupIdx = SLibRootCoderGroupVarGroupIdx(group)
                        %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
                        %assign singleInstanceHeaderFile = FcnVarGroupHeaderFile(varGroup, System[GetBaseSystemIdx()])
                        %assign singleInstanceDefinitionFileRule = group.DefinitionFileRule
                    %else
                        %assign singleInstanceHeaderFile = ""
                        %assign singleInstanceDefinitionFileRule = ""
                    %endif
                    %if !SLibMultiInstance()
                        %assign singleInstanceType = SLibCoderDataGroupType(group)
                    %else
                        %assign singleInstanceType = ""
                    %endif

                    %assign typeHeaderFile = ""
                    %assign varGroupIdx = SLibRootCoderGroupVarGroupIdx(group)
                    %if varGroupIdx >= 0
                        %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
                        %assign typeHeaderFile = varGroup.CoderDataGroupHeaderFile
                    %endif

                    %addtorecord ::CompiledModel.CoderDataGroups CoderDataGroup { \
                        Name group.Name \
                        UserProvidedName group.UserProvidedName \
                        Description group.Description \
                        Identification group.Identification \
                        Type type \
                        Depth 0 \
                        SelfPath selfPath \
                        PPCondition "" \
                        InstancePath "" \
                        GraphicalPath "" \
                        GroupPath groupPath \
                        DataInit group.DataInit \
                        SelfPointerInit selfPointerInit \
                        SingleInstanceDefiner singleInstMdlRef \
                        SingleInstancePropagator singleInstMdlRef \
                        SingleInstanceType singleInstanceType \
                        IsInstanceSpecific group.IsInstanceSpecific \
                        Initializer initializer \
                        IsMemorySectionConst group.IsMemorySectionConst \
                        IsMemorySectionVolatile group.IsMemorySectionVolatile \
                        MemorySectionQualifier group.MemorySectionQualifier \
                        MemorySection group.MemorySection \
                        MemorySectionIsLegacy group.MemorySectionIsLegacy \
                        DynamicInitializer dynamicInit%<gIdx> \
                        ScopedDSMs scopedDSMs%<gIdx> \
                        IsImportedFromFile isImportedFromFile \
                        AsStructure group.AsStructure \
                        IsSelf group.IsSelf \
                        IsSynthesized group.IsSynthesized \
                        IsHiddenFromParent group.IsHiddenFromParent \
                        SynthesizedNamePrefix group.SynthesizedNamePrefix \
                        SingleInstanceHeaderFile singleInstanceHeaderFile \
                        SingleInstanceDefinitionFileRule singleInstanceDefinitionFileRule \
                        IsOpaque group.IsOpaque \
                        IsPolymorphic group.IsPolymorphic \
                        ImplementationType group.ImplementationType \
                        SelfStructureInstanceName groupSelfInstanceName \
                        CompiledModelBlockIndex -1 \
                        SID STRING(group.GroupIndex) \
                        CoderDataGroupIndex group.GroupIndex \
                        ContainsInstanceSpecificParameter group.ContainsInstanceSpecificParameter \
                        HasAccessMethod group.HasAccessMethod \
                        IsDataTransferGroup group.IsDataTransferGroup \
                        GroupContains group.GroupContains \
                        TypeHeaderFile typeHeaderFile \
                        HasElement group.HasElement \
                    }

                    %addtorecord ::CompiledModel.CoderGroupInitLoop CoderDataGroupInitLoop { \
                        LoopStart "" \
                        LoopEnd "" \
                    }

                    %if group.Name == "_MsgServices"
                        %<FcnSetServiceDataGroupElements(groupToken, baseIdx, groupIdx)>
                    %endif
                    %assign groupIdx = groupIdx + 1
                %endif
            %endif
        %endforeach
    %endif

    %if !ISEMPTY(::CompiledModel.CoderDataGroups)
        %addtorecord blkInterface CoderDataGroups ::CompiledModel.CoderDataGroups
    %endif

    %if !ISEMPTY(::CompiledModel.CoderGroupInitLoop)
        %addtorecord blkInterface CoderDataGroupsInitLoop ::CompiledModel.CoderGroupInitLoop
    %endif

%endfunction

%function SLibWriteScopedDSMInitializerForMultiInstanceDWork(blkInterface) void
    %% Get DSM refs in this model and add them to unresolved, propagated DSM refs
    %<FcnGetScopedDSMInitializerForMultiInstanceDWork()>
    %addtorecord blkInterface ScopedDSMInMultiInstanceDWork ::CompiledModel.ScopedDSMInMultiInstanceDWork
%endfunction

%function SLibWriteScopedDSMInitializerForSingleInstance(blkInterface) void
    %% Get DSM refs in this model and add them to unresolved, propagated DSM refs
    %<FcnGetScopedDSMInitializerForSingleInstance()>
    %addtorecord blkInterface ScopedDSMInSingleInstance ::CompiledModel.ScopedDSMInSingleInstance
%endfunction

%% TopTester: test/toolbox/simulink/modelref/CodeInfo/tMdlZeroCrossingWriter.m
%% Add record to block interface for each ZcSignalInfo registered in the model.
%% To do this, we need to loop over each block ZC record (one record for
%% each block that registers Zc) and loop over each zcSignalInfo in each
%% record (One block can register multiple zcSignalInfo). g2862585
%function SLibWriteZeroCrossingInfo(blkInterface) void
    %assign zcVectorLen = ::CompiledModel.ZCVectorlength
    %addtorecord blkInterface ZCVectorLength %<zcVectorLen>
    %foreach idx = ::CompiledModel.ZcRec.NumBlkZcRecs
        %assign blkZcRec = ::CompiledModel.ZcRec.BlkZcRec[idx]
        %foreach jdx = blkZcRec.NumZcSignalInfos
            %assign zcSignalInfo = blkZcRec.ZcSignalInfo[jdx]
            %assign zcBlkRecId = idx
            %assign zcSignalInfoId = jdx

            %if !ISFIELD(zcSignalInfo, "IsElementDisc")
                %assign isElementDisc = []
            %else
                %assign isElementDisc = zcSignalInfo.IsElementDisc
            %endif

            %addtorecord blkInterface ZcSignalInfos { \
                ZcBlkRecId      zcBlkRecId; \
                ZcSignalInfoId  zcSignalInfoId; \
                Width           zcSignalInfo.Width; \
                Name            zcSignalInfo.Name; \
                ZcEventType     zcSignalInfo.ZcEventType; \
                ZcSignalType    zcSignalInfo.ZcSignalType; \
                IsElementDisc   isElementDisc; \
                ZcVectorIndices zcSignalInfo.ZcVectorIndices \
            }
        %endforeach
    %endforeach
%endfunction

%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortHighlight.m
%%
%function SLibWriteVariableSampleTimeInfo(blkInterface) void
    %assign VariableSampleTime = []
    %assign uid = ""
    %foreach idx = NumSampleTimes
        %if ISFIELD(SampleTime[idx], "VCRFullUID")
            %assign uid = SampleTime[idx].VCRFullUID
        %endif
        %addtorecord blkInterface VariableSampleTime {uid uid}
    %endforeach
%endfunction

%% TopTester: test/toolbox/simulink/variants/var-inline-general/tCSCDefine.m
%% TopTester: test/toolbox/simulink/variants/var-general/tStringSupport.m
%%
%function SLibWriteControllableRateInfo(blkInterface) void
    %assign ControllableRateUIDs = []
    %assign uid = ""
    %assign ctrlRateOffset = -1
    %foreach idx = NumSampleTimes
        %if ISFIELD(SampleTime[idx], "CtrlRateFullUID")
            %assign uid = SampleTime[idx].CtrlRateFullUID
            %assign ctrlRateOffset = SampleTime[idx].PeriodAndOffset[1]
        %endif
        %addtorecord blkInterface ControllableRateUIDs {ctrlRateOffset %<ctrlRateOffset>;  uid uid}
    %endforeach
%endfunction

%% TopTester: test/toolbox/simulink/variants/var-general/tTypesToPrivate.m
%%
%function SLibWriteModelWideEventsInfo(blkInterface) void
    %assign ModelWideEvents = []
    %assign id = ""
    %assign tid = -1
    %assign eventType = "" %% eventType could be "PowerUpEvent", "ResetEvent", "ResetWithInitEvent", and "PowerDownEvent"
    %foreach idx = NumSampleTimes
        %if SLibModelWideEventTID(idx)
            %if ISFIELD(SampleTime[idx], "EventSourceName")
                %assign id = SampleTime[idx].EventSourceName
            %else
                %assign id = SampleTime[idx].EventSourceType
            %endif
            %assign tid = SampleTime[idx].TID
            %assign offset = SampleTime[idx].PeriodAndOffset[1]
            %assign eventType = SampleTime[idx].EventSourceType
            %addtorecord blkInterface ModelWideEvents {offset %<offset>; tid %<tid>; id id; eventType eventType}
        %endif
    %endforeach
%endfunction

%function SLibWriteMultiInstanceInfo(blkInterface) void
    %% Write out information for multiple exec instances
    %if ISFIELD(::CompiledModel,"ModelSupportsMultipleExecInstances") && ...
        ::CompiledModel.ModelSupportsMultipleExecInstances
        %addtorecord blkInterface ModelSupportsMultipleExecInstances ModelSupportsMultipleExecInstances
    %else
        %addtorecord blkInterface ModelMultipleExecInstancesNoSupportMsg STRING(::CompiledModel.ModelMultipleExecInstancesNoSupportMsg)
    %endif
%endfunction


%function SLibWriteForEachInfo(blkInterface) void
    %% For ForEach
    %if ISFIELD(::CompiledModel,"ModelHasStateInsideForEachSS") && ...
        ::CompiledModel.ModelHasStateInsideForEachSS
        %addtorecord blkInterface ModelHasStateInsideForEachSS ModelHasStateInsideForEachSS
    %endif
%endfunction


%function SLibWriteFunctionCallInfo(blkInterface) void
    %with ::CompiledModel
        %assign thisSystem = System[GetBaseSystemIdx()]

        %if LibIsSystemField(thisSystem, "FcnCallInputInfo")
            %<WriteFunctionCallInputInfo(blkInterface, thisSystem)>
        %endif
    %endwith
%endfunction

%% TopTester: test/toolbox/simulink/variants/var-inline-general/twipervariant.m
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tmg1396738_inlined_VC1.m
%%
%function FcnGenArgCGTypeDetails(i, symbId) void
    %% Generate a record for a type used by a Simulink
    %% function argument.
    %assign dims = LibCGTypeDimensions(i)
    %assign nDims = LibCGTypeNumDimensions(i)
    %assign width = LibCGTypeWidth(i)
    %% For model reference
    %assign isComplex = LibCGTypeIsComplex(i)
    %assign isBuiltin = TLC_FALSE
    %assign isEnum = TLC_FALSE
    %assign isStruct = TLC_FALSE
    %assign isFixpt = TLC_FALSE
    %assign isHalf = TLC_FALSE
    %assign isImage = TLC_FALSE
    %assign isCoderArray = LibCGTypeIsCoderArray(i)
    %assign dtName = ""
    %assign flatName = LibCGTypeName(i)
    %% For structured param
    %assign dtChecksum = []
    %assign isAnonymous = TLC_FALSE
    %% For fixed-point param
    %assign isFloat = TLC_FALSE
    %assign isSigned = TLC_FALSE
    %assign requiredBits = 0
    %assign fracSlope = 0
    %assign fixedExp = 0
    %assign bias = 0
    %assign dtId = LibCGTypeToSLType(i)
    %assign isAlias = LibIsAliasDataType(dtId)

    %assign dataEnum = LibGetDataTypeEnumFromId(dtId)
    %assign isPointer = dataEnum == "SS_POINTER"
    %assign isInteger = dataEnum == "SS_INTEGER"
    %assign isFcnCall = dataEnum == "SS_FCN_CALL"

    %assign hasSymbDims = TLC_FALSE
    %assign symbDimsStr = ""
    %assign cgSymbTypeRec = ::CompiledModel.CGTypes.CGType[symbId]
    %if ISFIELD(cgSymbTypeRec, "SymbolicDimensions")
        %assign hasSymbDims = TLC_TRUE
        %assign symbDims = cgSymbTypeRec.SymbolicDimensions
        %assign sep = ""
        %foreach symbDimsIdx = SIZE(symbDims,1)
            %assign symbDimsStr = symbDimsStr + sep + symbDims[symbDimsIdx]
            %assign sep = ","
        %endforeach
        %assign symbDimsStr = "[" + symbDimsStr + "]"
    %endif
    %if dtId == -1
    %elseif LibIsBuiltInDataType(dtId)
        %assign isBuiltin = LibIsBuiltInDataType(dtId)
        %if dtId > -1
            %assign dtName = LibGetDataTypeEnumFromId(dtId)
        %else
            %assign dtName = "DYNAMICALLY_TYPED"
        %endif
    %elseif LibIsEnumDataType(dtId)
        %assign dtName = LibGetDataTypeNameFromId(dtId)
        %assign isEnum = LibIsEnumDataType(dtId)
    %elseif LibIsStructDataType(dtId) && !LibIsDataTypeFixpt(dtId)
        %assign dtName = LibGetDataTypeNameFromId(dtId)
        %assign isStruct = LibIsStructDataType(dtId)
        %assign dtChecksum = DataTypes.DataType[dtId].StructDtChecksum
        %assign isAnonymous = LibDataTypeIsAnonymousStruct(dtId)
    %elseif LibIsStringDataType(dtId)
        %% No string support for model arguments or Simulink Function I/O
        %assign errTxt = ...
            "String data type is not supported for interface parameters."
        %<LibReportFatalError(errTxt)>
    %elseif LibIsImageDataType(dtId)
        %assign dtName = LibGetDataTypeNameFromId(dtId)
        %assign isImage = TLC_TRUE
    %else %% Fixed-point
        %assign curDT = FixPt_GetDataTypeFromIndex(dtId)
        %%
        %if LibIsHalfDataType(dtId)
            %assign isHalf = TLC_TRUE
            %assign requiredBits = curDT.RequiredBits
            %assign dtName = LibGetDataTypeNameFromId(dtId)
        %elseif curDT.IsFixedPoint
            %assign isFixpt = TLC_TRUE
            %assign isFloat = FixPt_DataTypeIsFloat(curDT)
            %assign isSigned = (curDT.IsSigned == 1.0)
            %assign requiredBits = curDT.RequiredBits
            %assign fracSlope = curDT.FracSlope
            %assign fixedExp = curDT.FixedExp
            %assign bias = curDT.Bias
        %else
            %assign errTxt = ...
                "User-defined data types not supported for interface parameters."
            %<LibReportFatalError(errTxt)>
        %endif
    %endif

    %createrecord CGTypeRec { \
        NDims           nDims; \
        Dims            dims; \
        Width           width; \
        IsBuiltin       isBuiltin; \
        IsEnum          isEnum; \
        Complex         isComplex; \
        IsStruct        isStruct; \
        DtChecksum      dtChecksum; \
        DataTypeId      dtId; \
        DataTypeName    dtName; \
        FlatName        flatName; \
        HasSymbDims     hasSymbDims; \
        SymbDimsStr     STRING(symbDimsStr); \
        IsAnonymous     isAnonymous; \
        IsAlias         isAlias; \
        IsPointer       isPointer; \
        IsFcnCall       isFcnCall; \
        IsInteger       isInteger; \
        IsFixpt         isFixpt; \
        IsScaledFloat   isFloat; \
        IsSigned        isSigned; \
        RequiredBits    requiredBits; \
        FracSlope       STRING(fracSlope); \
        FixedExp        fixedExp; \
        Bias            STRING(bias); \
        IsHalfPrecision isHalf \
        IsImage         isImage \
        IsCoderArray    isCoderArray \
    }

    %return CGTypeRec

%endfunction

%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortFcnCall3.m
%%
%function FcnCacheArgCTTypeIdx(blkInterface, origCGTypeIdx, symbCGTypeIdx) Output
    %% We create a single list of CG types of all arguments.
    %with blkInterface
        %foreach i = NumSimulinkFunctionArgType
            %if SimulinkFunctionArgType[i].OrigCGTypeIdx == origCGTypeIdx && ...
                SimulinkFunctionArgType[i].SymbCGTypeIdx == symbCGTypeIdx
                %return i
            %endif
        %endforeach
        %% The given CGTypeIdx was not already cached
        %assign cgTypeDetails = FcnGenArgCGTypeDetails(origCGTypeIdx, symbCGTypeIdx)
        %addtorecord blkInterface SimulinkFunctionArgType { \
            OrigCGTypeIdx origCGTypeIdx; \
            SymbCGTypeIdx symbCGTypeIdx; \
            CGTypeDetails  %<cgTypeDetails> \
        }
        %assign blkInterface.NumSimulinkFunctionArgType = NumSimulinkFunctionArgType + 1
        %return NumSimulinkFunctionArgType-1
    %endwith
%endfunction


%function SLibWriteServicePorts(blkInterface) void
    %if !EXISTS(NumServicePorts)
        %% ServiceFunction feature is off
        %return
    %endif
    %addtorecord blkInterface NumServicePorts NumServicePorts
    %with ServicePortInfoMap
        %foreach portIdx = NumServicePorts
            %assign thisPort = ServicePort[portIdx]
            %assign blockPath = thisPort.BlockPath
            %assign aSID = thisPort.SID
            %assign aServicePortType = thisPort.ServicePortType
            %assign aServicePortIdx = thisPort.ServicePortIdx
            %assign aExternalPortIdx = thisPort.ExternalPortIdx
            %assign aKind = thisPort.Kind
            %assign aCGName = thisPort.CGName
            %assign isDelegating = thisPort.IsDelegating
            %assign delegatedFcnSvcPortHost = thisPort.DelegatedFcnSvcPortHost
            %assign delegatedFcnSvcPortName = thisPort.DelegatedFcnSvcPortName
            %addtorecord blkInterface ServicePort { \
                BlockPath blockPath \
                SID aSID \
                ServicePortType aServicePortType \
                ServicePortIdx aServicePortIdx \
                ExternalPortIdx aExternalPortIdx \
                Kind aKind \
                CGName aCGName \
                IsDelegating isDelegating \
                DelegatedFcnSvcPortHost delegatedFcnSvcPortHost \
                DelegatedFcnSvcPortName delegatedFcnSvcPortName \
            }
            %if ::GenerateClassInterface
                %addtorecord blkInterface.ServicePort[portIdx] AccessorName thisPort.AccessorName
                %addtorecord blkInterface.ServicePort[portIdx] ModelConstructorArgIdx thisPort.ModelConstructorArgIdx
            %endif
            %assign requestingServices = thisPort.RequestingServices
            %if !ISEMPTY(requestingServices)
                %assign numRequestingSvc = SIZE(requestingServices.RequestingService)[1]
                %foreach i=numRequestingSvc
                    %assign aRequestingService = requestingServices.RequestingService[i]
                    %assign name = aRequestingService.Name
                    %assign numInArgs = aRequestingService.NumInArgs
                    %assign numOutArgs = aRequestingService.NumOutArgs
                    %assign dworkIdx = aRequestingService.DworkIdx
                    %assign dworkPath = ""
                    %assign dworkPathFromModelSelf = ""
                    %assign dworkVariantCondition = ""
                    %if dworkIdx >= 0
                        %assign dwRec = ::CompiledModel.DWorks.DWork[dworkIdx]
                        %if ISFIELD(dwRec, "VarGroupIdx") && IsModelReferenceTarget() && aExternalPortIdx > -1
                            %assign dworkVariantCondition = dwRec.VariantCondition
                            %assign group = ::CompiledModel.VarGroups.VarGroup[dwRec.VarGroupIdx[0]]
                            %assign varGroupElemId = FcnSLibCGIRGetVarGroupMemberName(dwRec.VarGroupIdx[0], dwRec.VarGroupIdx[1])
                            %assign isCoderData = (group.Category == "HierarchicalCoderData")
                            %if isCoderData
                                %assign varGroupElemId = group.StructureReferenceName + "->" + varGroupElemId
                            %endif
                            %assign dworkPath = SLibGetCompleteServiceDWorkPath(varGroupElemId, isCoderData)
                            %if !ISEMPTY(dworkPath)
                                %assign dworkPathFromModelSelf = SLibGetServiceDWorkPathFromModelSelfIfNecessary(varGroupElemId, isCoderData)
                            %endif
                        %endif
                    %endif
                    %assign delegatedPortIdx = aRequestingService.DelegatedPortIdx
                    %assign delegatedDworkIdx = aRequestingService.DelegatedDworkIdx
                    %assign delegatedServiceInfo = SLibGetDelegatedServiceInfo(thisPort, aRequestingService)
                    %assign delegatedDworkPath = delegatedServiceInfo.path
                    %assign delegatedHost = delegatedServiceInfo.host
                    %assign delegatedServiceName = delegatedServiceInfo.serviceName
                    %assign delegatedVC = delegatedServiceInfo.variantCondition
                    %assign delegatedSID = aRequestingService.DelegatedSID
                    %assign cgFcnName = aRequestingService.CGFcnName
                    %assign accessFcnName = aRequestingService.AccessorFcnName
                    %assign modelConstructorArgIdx = aRequestingService.ModelConstructorArgIdx
                    %addtorecord blkInterface.ServicePort[portIdx] RequestingService { \
                        Name name \
                        NumInArgs numInArgs \
                        NumOutArgs numOutArgs \
                        DWorkIdx dworkIdx \
                        DWorkPath dworkPath \
                        DWorkPathFromModelSelf dworkPathFromModelSelf \
                        DWorkVariantCondition dworkVariantCondition \
                        DelegatedPortIdx delegatedPortIdx \
                        DelegatedDworkIdx delegatedDworkIdx \
                        DelegatedDworkPath delegatedDworkPath \
                        DelegatedVariantCondition delegatedVC \
                        DelegatedHost delegatedHost \
                        DelegatedSID delegatedSID \
                        DelegatedServiceName delegatedServiceName \
                        CGFcnName cgFcnName \
                        AccessorFcnName accessFcnName \
                        ModelConstructorArgIdx modelConstructorArgIdx \
                    }
                %endforeach
            %endif
            %assign providingServices = thisPort.ProvidingServices
            %if !ISEMPTY(providingServices)
                %assign numProvidingSvc = SIZE(providingServices.ProvidingService)[1]
                %foreach i=numProvidingSvc
                    %assign aProvidingService = providingServices.ProvidingService[i]
                    %assign name = aProvidingService.Name
                    %assign numInArgs = aProvidingService.NumInArgs
                    %assign numOutArgs = aProvidingService.NumOutArgs
                    %assign dworkIdx = aProvidingService.DworkIdx
                    %assign dworkPath = ""
                    %assign dworkPathFromModelSelf = ""
                    %assign dworkVariantCondition = ""
                    %if dworkIdx >= 0
                        %assign dwRec = ::CompiledModel.DWorks.DWork[dworkIdx]
                        %if ISFIELD(dwRec, "VarGroupIdx") && IsModelReferenceTarget() && aExternalPortIdx > -1
                            %assign dworkVariantCondition = dwRec.VariantCondition
                            %assign group = ::CompiledModel.VarGroups.VarGroup[dwRec.VarGroupIdx[0]]
                            %assign varGroupElemId = FcnSLibCGIRGetVarGroupMemberName(dwRec.VarGroupIdx[0], dwRec.VarGroupIdx[1])
                            %assign isCoderData = (group.Category == "HierarchicalCoderData")
                            %if isCoderData
                                %assign varGroupElemId = group.StructureReferenceName + "->" + varGroupElemId
                            %endif
                            %assign dworkPath = SLibGetCompleteServiceDWorkPath(varGroupElemId, isCoderData)
                            %if !ISEMPTY(dworkPath)
                                %assign dworkPathFromModelSelf = SLibGetServiceDWorkPathFromModelSelfIfNecessary(varGroupElemId, isCoderData)
                            %endif
                        %endif
                    %endif
                    %assign delegatedPortIdx = aProvidingService.DelegatedPortIdx
                    %assign delegatedDworkIdx = aProvidingService.DelegatedDworkIdx
                    %assign delegatedServiceInfo = SLibGetDelegatedServiceInfo(thisPort, aProvidingService)
                    %assign delegatedDworkPath = delegatedServiceInfo.path
                    %assign delegatedHost = delegatedServiceInfo.host
                    %assign delegatedServiceName = delegatedServiceInfo.serviceName
                    %assign delegatedVC = delegatedServiceInfo.variantCondition
                    %assign delegatedSID = aProvidingService.DelegatedSID
                    %assign cgFcnName = aProvidingService.CGFcnName
                    %assign accessFcnName = aProvidingService.AccessorFcnName
                    %assign modelConstructorArgIdx = aProvidingService.ModelConstructorArgIdx
                    %addtorecord blkInterface.ServicePort[portIdx] ProvidingService { \
                        Name name \
                        NumInArgs numInArgs \
                        NumOutArgs numOutArgs \
                        DWorkIdx dworkIdx \
                        DWorkPath dworkPath \
                        DWorkPathFromModelSelf dworkPathFromModelSelf \
                        DelegatedPortIdx delegatedPortIdx \
                        DelegatedDworkIdx delegatedDworkIdx \
                        DelegatedDworkPath delegatedDworkPath \
                        DelegatedVariantCondition delegatedVC \
                        DWorkVariantCondition dworkVariantCondition \
                        DelegatedHost delegatedHost \
                        DelegatedSID delegatedSID \
                        DelegatedServiceName delegatedServiceName \
                        CGFcnName cgFcnName \
                        AccessorFcnName accessFcnName \
                        ModelConstructorArgIdx modelConstructorArgIdx \
                    }
                %endforeach
            %endif
        %endforeach
    %endwith
%endfunction

%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortFcnCall3.m
%% TopTester: test/toolbox/simulink/variants/var-simulinkfcns/tAutoInherit.m
%% TopTester: test/toolbox/rtw/targets/AUTOSAR/Variants/dimensionVariants/tDimensionVariants5.m
%%
%function SLibWriteSimulinkFunctions(blkInterface) void
    %% Create a record in binfo, to write out model reference S-Function
    %% wrappers and registration methods for Simulink Functions.

    %addtorecord blkInterface NumSimulinkFunctions NumSimulinkFunctions
    %addtorecord blkInterface NumSimulinkFunctionArgType 0
    %addtorecord blkInterface NumPortlessSimulinkFunctionPortGroups %<::CompiledModel.NumPortlessSimulinkFunctionPortGroups>
    %foreach groupIdx = NumSimulinkFunctions
        %with SimulinkFunction[groupIdx]

            %assign arginCGTypeIdxFlat = ArginCGTypeIdxFlat
            %assign argoutCGTypeIdxFlat = ArgoutCGTypeIdxFlat

            %% Add input argument flat CGTYpeInfo
            %foreach i = SIZE(ArginCGTypeIdxFlat)[1]
                %assign arginCGTypeIdxFlat[i] = FcnCacheArgCTTypeIdx(blkInterface,  arginCGTypeIdxFlat[i], ArginCGTypeIdxSymb[i])
            %endforeach

            %% Add output argument flat CGTYpeInfo
            %foreach i = SIZE(ArgoutCGTypeIdxFlat)[1]
                %assign argoutCGTypeIdxFlat[i] = FcnCacheArgCTTypeIdx(blkInterface,  argoutCGTypeIdxFlat[i], ArgoutCGTypeIdxSymb[i])
            %endforeach

            %assign AUTOSARPortName = ""
            %assign AUTOSAROperationName = ""
            %if SLibAutosarActive()
                %if (IsCalled == "yes") && (IsSupportedForAUTOSAR == "yes")
                    %assign AUTOSARPortName = CallerPortName
                    %assign AUTOSAROperationName = CallerOperationName
                    %assert(!ISEMPTY(AUTOSARPortName))
                    %assert(!ISEMPTY(AUTOSAROperationName))
                %endif
            %endif

            %assign slFcnPrototype = ""
            %if ISFIELD(SimulinkFunction[groupIdx],"Prototype")
                %assign slFcnPrototype = SimulinkFunction[groupIdx].Prototype
            %endif

            %assign slFcnIsFromMapping = "no"
            %if ISFIELD(SimulinkFunction[groupIdx],"IsFromMapping")
                %assign slFcnIsFromMapping = SimulinkFunction[groupIdx].IsFromMapping
            %endif

            %assign isSlFcnFPCSynthesized = "no"
            %if ISFIELD(SimulinkFunction[groupIdx],"IsSynthesizedFPC")
                %assign isSlFcnFPCSynthesized = SimulinkFunction[groupIdx].IsSynthesizedFPC
            %endif

            %addtorecord blkInterface SimulinkFunction { \
                Name Name; \
                CGFunctionName CGFunctionName; \
                FullPathToFunction FullPathToFunction; \
                IsExtern IsExtern; \
                IsDefined IsDefined; \
                IsCalled  IsCalled; \
                IsConstUncalledFunction IsConstUncalledFunction; \
                IsMultiInstance IsMultiInstance; \
                ArginCGTypeIdxFlat arginCGTypeIdxFlat; \
                ArgoutCGTypeIdxFlat argoutCGTypeIdxFlat; \
                ArgIndices    ArgIndices; \
                ReturnArgIndex ReturnArgIndex; \
                AUTOSARPortName "%<AUTOSARPortName>"; \
                AUTOSAROperationName "%<AUTOSAROperationName>"; \
                Prototype "%<slFcnPrototype>"; \
                IsFromMapping "%<slFcnIsFromMapping>" \
                IsSynthesizedFPC "%<isSlFcnFPCSynthesized>" \
            }
        %endwith
    %endforeach
%endfunction

%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortFcnCall3.m
%%
%function SLibWriteExternalPortGroups(blkInterface) void
    %if EXISTS(ExternalPortGroups)
        %with ExternalPortGroups
            %% Write FcnCallPortGroup
            %foreach groupIdx = NumFcnCallPortGroups
                %with FcnCallPortGroup[groupIdx]
                    %addtorecord blkInterface ExternalPortGroups { \
                        IsAsync (IsAsync == "true"); \
                        GrFcnCallInputPort GrFcnCallInputPort; \
                        CompFcnCallInputPort CompFcnCallInputPort; \
                        CallerNames CallerNames; \
                        CallerFullPaths CallerFullPaths; \
                        SimulinkFunctionName SimulinkFunctionName; \
                        SimulinkFunctionFullPath SimulinkFunctionFullPath; \
                        GrDataInputPorts GrDataInputPorts; \
                        CompDataInputPorts CompDataInputPorts; \
                        CompLatchedDataInputPorts CompLatchedDataInputPorts; \
                        PortGroupsWithDataTransferConnection PortGroupsWithDataTransferConnection;\
                        GrDataOutputPorts GrDataOutputPorts; \
                        CompDataOutputPorts CompDataOutputPorts; \
                        SrcPortGroups SrcPortGroups; \
                        MuxedPortGroups MuxedPortGroups; \
                        Tid Tid; \
                        HasTaskPriority HasTaskPriority; \
                        TaskPriority TaskPriority; \
                        SchedulingPriority SchedulingPriority; \
                        IsSimulinkFunction IsSimulinkFunction; \
                        HasEnableMethod HasEnableMethod; \
                        HasDisableMethod HasDisableMethod; \
                        NeedAbsoluteTime NeedAbsoluteTime; \
                        SpecifiedTsPeriodAndOffset SpecifiedTsPeriodAndOffset \
                        IsPeriodicFcnCall IsPeriodicFcnCall \
                    }
                %endwith
            %endforeach
        %endwith
    %endif
%endfunction

%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortFcnCall3.m
%% Toptetser: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%%
%function getDataTypeName(dataTypeIdx)
    %if LibIsFundamentalBuiltInDataType(dataTypeIdx)
        %assign dtName = LibGetDataTypeEnumFromId(dataTypeIdx)
    %else
        %assign curDT = FixPt_GetDataTypeFromIndex(dataTypeIdx)
        %if curDT.IsFixedPoint && !LibIsAliasDataType(dataTypeIdx)
            %assign dtName = "fixed"
        %else
            %assign dtEnum = LibGetDataTypeEnumFromId(dataTypeIdx)
            %if dtEnum == "SS_POINTER" || dtEnum == "SS_INTEGER" || dtEnum == "SS_FCN_CALL"
                %assign dtName = LibGetDataTypeEnumFromId(dataTypeIdx)
            %else
                %assign dtName = LibGetDataTypeNameFromId(dataTypeIdx)
            %endif
        %endif
    %endif
    %return dtName
%endfunction

%% TopTester: test/toolbox/simulink/variants/var-general/tTypesToPrivate.m
%%
%function WriteFunctionCallInputInfo(blkInterface, currentSystem) void
    %assign fcnCallInfo = LibGetSystemField(currentSystem, "FcnCallInputInfo")
    %foreach idx = SIZE(fcnCallInfo.FcnCallInfo,1)
        %assign info = fcnCallInfo.FcnCallInfo[idx]
        %assign fcnRec = CreateModelReferenceFcnRec(GetBaseSystemIdx(), info.FcnType, info.TaskName, info.TID, blkInterface, TLC_TRUE)
        %addtorecord blkInterface FcnCallInputs %<info>
        %addtorecord blkInterface.FcnCallInputs[idx] TaskFcnInfo %<fcnRec>
    %endforeach
%endfunction


%% Abstract:
%%   This function optionally add CanonicalInputNeededByCAPI flag to ::CompiledModel
%%   if and only if all of the following are true:
%%      1. ModelRef target(s)
%%      2. CAPI needs to access canonical inputs due to
%%         various reasons: e.g., RTWCAPISignals being true and
%%         one of the signals is being test pointed and its signal source is a
%%         Canonical inpput.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants3.m
%%
%function FcnOptionallyAddModelRefCanonicalInputNeededByCAPIFlag(sigRec) void
    %if !IsModelReferenceTarget()
        %return
    %endif
    %if !ISEMPTY(sigRec) && ISFIELD(sigRec, "RecordType") && sigRec.RecordType == "ExternalInput"
        %% Find canonical input corresponding to sigRec
        %assign baseSysIdx = GetBaseSystemIdx()
        %with System[baseSysIdx].Interface
            %foreach ciIdx = NumCanonicalInputArgDefs
                %assign ci = CanonicalInputArgDef[ciIdx]
                %assign inputPortInfo = ci.SignalSrc
                %assign u_str_idx     = IDNUM(inputPortInfo[0])
                %if (u_str_idx[0] != "U")
                    %<LibReportFatalError("CI Error")>
                %endif
                %assign u_idx = u_str_idx[1]
                %assign ei = ::CompiledModel.ExternalInputs.ExternalInput[u_idx]
                %if ei==sigRec
                    %% Register the canonical input as argument of model_initialize
                    %% function
                    %<SLibAccessArgHelper(ci,"","")>
                    %break
                %endif
            %endforeach
        %endwith
        %if ISFIELD(::CompiledModel, "ModelRefCanonicalInputNeededByCAPI") && ...
            ::CompiledModel.ModelRefCanonicalInputNeededByCAPI == "yes"
            %% only need to mark it once
            %return
        %else
            %<LibAddToCompiledModel("ModelRefCanonicalInputNeededByCAPI", "yes")>
        %endif
    %endif
%endfunction

%% Abstract:
%%   Function to query if a canonical input is needed by CAPI for a modelref
%%   target after the flag has been populated.
%% TopTester: test/toolbox/simulink/variants/var-bus-general/tVariantBusGecks.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%%
%function IsModelRefCanonicalInputNeededByCAPI() void
    %if ISFIELD(::CompiledModel, "ModelRefCanonicalInputNeededByCAPI") && ...
        ::CompiledModel.ModelRefCanonicalInputNeededByCAPI == "yes"
        %return TLC_TRUE
    %elseif !IsModelReferenceTarget()
        %return TLC_FALSE
    %else
        %% Even if this model itself does not have any canonical input
        %% needed by capi, its canonical inputs can still be needed
        %% by capi, if there are referenced models
        %% whose inputs are connected to this model's canonical inputs
        %% and that referenced model's block interface
        %% ModelRefCanonicalInputNeededByCAPI is true
        %if ISFIELD(::CompiledModel, "NumModelReferenceBlocks")
            %foreach idIdx = NumModelReferenceBlocks
                %assign blkIdx    = ModelReferenceBlocks[idIdx]
                %assign mdlBlock  = System[blkIdx[0]].Block[blkIdx[1]]
                %assign blockInterface = GetModelrefInterface(mdlBlock)
                %if !blockInterface.ModelRefCanonicalInputNeededByCAPI
                    %continue
                %endif
                %foreach portIdx = mdlBlock.NumDataInputPorts
                    %assign port = mdlBlock.DataInputPort[portIdx]
                    %assign idNum = IDNUM(port.SignalSrc[0])
                    %if idNum[0] == "u"
                        %return TLC_TRUE
                    %endif
                %endforeach
            %endforeach
        %endif

        %return TLC_FALSE
    %endif
%endfunction

%endif %% _MODELREFINTERFACE_
%% [EOF] modelrefinterface.tlc
