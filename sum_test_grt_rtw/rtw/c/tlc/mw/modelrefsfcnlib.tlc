%% ============================================================================
%%
%% Abstract:
%%   This system file contains helper functions to create an
%%   S-Function wrapper for any target.
%%
%% Copyright 1994-2024 The MathWorks, Inc.
%%

%include "ertmdlreftiming.tlc"
%include "sfcnlib.tlc"
%include "ertfcnprotocontrol.tlc"
%include "servicelib.tlc"


%% Function MdlRefHasConstantOutput =========================================
%% Abstract:
%%     Return true if there are any output ports with a constant sample time
%%
%function MdlRefHasConstantOutput()

    %return (::CompiledModel.HasConstantOutput == "yes")
%endfunction %%MdlRefHasConstantOutput

%% Function MdlRefHasParameterRateOutput =========================================
%% Abstract:
%%     Return true if there are any output ports with a parameter sample time
%%
%function MdlRefHasParameterRateOutput()

    %return (::CompiledModel.HasParameterRateOutput == "yes")
%endfunction %%MdlRefHasParameterRateOutput

%% Function MdlRefHasInternalParameterRate ======================================
%% Abstract:
%%     Return true if there is any internal usage of a parameter sample time
%%
%function MdlRefHasInternalParameterRate()
    %return (::CompiledModel.HasInternalParameterRate == "yes")
%endfunction


%% Function MdlRefHasParameterRate ===========================================
%% Abstract:
%%     Return true if there is any usage of a parameter sample time
%%
%function MdlRefHasParameterRate()
    %return MdlRefHasInternalParameterRate() || MdlRefHasParameterRateOutput()
%endfunction


%% Function  MdlRefIsConstSampleBlock=========================================
%% Abstract:
%%       Return true if all block sample times are constant.
%function MdlRefIsConstSampleBlock()

    %return (::CompiledModel.IsModelConstant == "yes")
%endfunction %%MdlRefIsConstSampleBlock

%% Function  ===================================================================
%function MdlRefIsFcnCallBlock()
    %return (::CompiledModel.HasRootTriggerPort == "yes") && ...
        (::CompiledModel.RootTriggerType == "function-call")
%endfunction

%% Function  ===================================================================
%function MdlRefIsTriggerBlock()
    %return (::CompiledModel.HasRootTriggerPort == "yes") && ...
        (::CompiledModel.RootTriggerType != "function-call")
%endfunction

%% Function  ===================================================================
%function MdlRefIsAPERTriggeredBlock()
    %return (::CompiledModel.IsAPERRootTriggeredSystem == "yes")
%endfunction

%% Function  ===================================================================
%function MdlRefDisallowSampleTimeInheritance()
    %return (::CompiledModel.ModelRefTsInheritance == ...
        "DISALLOW_SAMPLE_TIME_INHERITANCE")
%endfunction

%function HasRootEnablePort()
    %return (::CompiledModel.HasRootEnablePort == "yes")
%endfunction

%% =============================================================================
%%
%function MdlRefIsVarStepMultiRate() void
    %return ( IsModelReferenceForASimstructBasedTarget() && ...
        SolverType == "VariableStep" && ...
        LibIsContinuous(0) && NumSampleTimes > 1)
%endfunction

%% Function: DumpTimeConditioningCode ==============================================================
%% Abstract:
%%
%function DumpTimeConditioningCode() Output
    %assign intType = LibGetDataTypeNameFromId(::CompiledModel.tSS_INTEGER)
    %if !SLibSingleTasking()
        {
            %<intType> localTid = 0;
            %foreach idx = NumRuntimeExportedRates
                if (ssIsSampleHit(S, %<idx>, %<::CompiledModel.GlobalScope.tTID> )) {
                    %if Tid01Eq && ISEQUAL(idx,1)
                        localTid = 0;
                    %else
                        localTid = %<idx>;
                    %endif
                }
            %endforeach
            %<::CompiledModel.GlobalScope.tTID> = localTid;
        }
    %endif
%endfunction %% DumpTimeConditioningCode


%% Function: GenerateSFunctionOutputSignalDefinition ===============================================
%% Abstract:
%%   This function generates the S-Function output signal definition for the
%%   mdlOutputs function.
%%
%% Syntax:
%%   GenerateSFunctionOutputSignalDefinition(prefix)
%%
%% Arguments:
%%   prefix - signal name prefix
%%
%% Returns:
%%   real_T *<prefix>_0 = ssGetOutputPortSignal(S, 0);
%%
%function GenerateSFunctionOutputSignalDefinition(prefix) Output
    %foreach idx = ExternalOutputs.NumExternalOutputs
        %assign extOut       = ExternalOutputs.ExternalOutput[idx]
        %assign sysIdx       = extOut.Block[0]
        %assign blkIdx       = extOut.Block[1]
        %assign outportBlock = System[sysIdx].Block[blkIdx]
        %with System[sysIdx]
            %with outportBlock
                %assign dataType  = LibBlockInputSignalDataTypeName(0, "")
                %<dataType> *%<prefix>%<idx> = ssGetOutputPortSignal(S, %<idx>);
            %endwith %% outportBlock
        %endwith %% System[sysIdx]
    %endforeach
%endfunction %% GenerateSFunctionOutputSignalDefinition


%% Function: GetConstBIOExternBuf ==================================================================
%% Abstract:
%% TopTester: test/toolbox/simulink/variants/var-general/tStringSupport.m
%%
%function GetConstBIOExternBuf()
    %openfile extCBIOExtern
    %if !LibConstBlockIOInstanceIsEmpty()
        %assign qualifiers = SLibGetConstBlockIOQualifiers()
        %assign typePrefix = SLibGetModelTypesNamespacePrefix()
        /* Invariant block signals (%<::AutoOrDefaultStorageClass> storage) */
        %openfile extCBIODecl
        %<qualifiers> %<typePrefix>%<FcnSysVarGroupType(System[NumSystems-2],"ConstBlockIO")>  %<::tConstBlockIOStruct>;
        %closefile extCBIODecl
        %<SLibApplyMemSecToDataDecl(extCBIODecl, "MemSecDataConstants", "%<::tConstBlockIOStruct>")>
    %endif
    %closefile extCBIOExtern
    %return extCBIOExtern
%endfunction %% GetConstBIOExternBuf


%% Function: GetConstPrmExternBuf ==================================================================
%% Abstract:
%%
%function GetConstPrmExternBuf()
    %openfile extCPrmExtern
    %if !SLibPrmBufferIsEmpty("Const", "Typedef")
        %assign qualifiers = SLibGetConstParamQualifiers()
        %assign typePrefix = SLibGetModelTypesNamespacePrefix()
        /* Constant parameters (%<::AutoOrDefaultStorageClass> storage) */
        %openfile extCPrmExternDecl
        %<qualifiers> %<typePrefix>%<::tConstParamType> %<::tConstParamStruct>;
        %closefile extCPrmExternDecl
        %<SLibApplyMemSecToDataDecl(extCPrmExternDecl, "MemSecDataConstants", "%<::tConstParamStruct>")>
    %endif
    %closefile extCPrmExtern
    %return extCPrmExtern
%endfunction %% GetConstPrmExternBuf


%% Function: GetConstPrmWithInitExternBuf ==========================================================
%% Abstract:
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function GetConstPrmWithInitExternBuf()
    %openfile extCPrmExtern
    %if !SLibPrmBufferIsEmpty("ConstWithInit", "Typedef")
        %assign qualifiers = SLibGetConstParamWithInitQualifiers()
        %assign typePrefix = SLibGetModelTypesNamespacePrefix()
        /* Constant parameters with dynamic initialization (%<::AutoOrDefaultStorageClass> storage) */
        %openfile extCPrmExternDecl
        %<qualifiers> %<typePrefix>%<::tConstParamWithInitType> %<::tConstParamWithInitStruct>;
        %closefile extCPrmExternDecl
        %<SLibApplyMemSecToDataDecl(extCPrmExternDecl, "MemSecDataConstants", "%<::tConstParamWithInitStruct>")>
    %endif
    %closefile extCPrmExtern
    %return extCPrmExtern
%endfunction %% GetConstPrmWithInitExternBuf


%% Function: SLibWriteModelrefSFunctionMethods =====================================================
%% Abstract:
%%  Write out the model reference S-Function methods to a file.
%% TODO: Migrate the content of this function then clean it up.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function SLibWriteModelrefSFunctionMethods() void
    %assign sFunctionName = GetModelrefSFunctionName(Name)
    %assign opFile = SLibAddModelFile("SystemBody","Simulink", sFunctionName)
    %<SLibSetModelFileAttribute(opFile, "Group", "interface")>

    %assign cBIOExtBuf = GetConstBIOExternBuf()
    %<SLibCacheCodeToFile("mdlsfcn_extern_data_defn", cBIOExtBuf)>

    %% Generate code for each of the sfcn methods
    %openfile fcnsBuf
    %<WriteModelrefSFunctionVarDimsSetDimsMethods("SetDims")>
    %<WriteModelrefSFunctionVarDimsSetDimsMethods("FinalizeDims")>
    %closefile fcnsBuf

    %<SLibCacheCodeToFile("mdlsfcn_fcn_defn", fcnsBuf)>
%endfunction

%% Function: ModelrefBlockNeedsDwork ===============================================================
%% Abstract:
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%% TopTester: test/toolbox/rtw/targets/AUTOSAR/Variants/modelref/tModelRefVariants.m
%% TopTester: test/toolbox/simulink/variants/var-simulinkfcns/tAutoInherit.m
%%
%function ModelrefBlockNeedsDwork() void
    %if IsModelRefScalableBuild()
        %return TLC_FALSE
    %else
        %assign baseSystem = ::CompiledModel.System[GetBaseSystemIdx()]
        %if (baseSystem.HasBlockIOArg || baseSystem.HasDWorkArg ...
            || !EmptyRealTimeObject || baseSystem.HasZCEventArg)
            %return TLC_TRUE
        %else
            %return TLC_FALSE
        %endif
    %endif
%endfunction %%ModelrefBlockNeedsDwork

%% Function: ModelRefBlockHasPrivateDWork ==========================================================
%% Abstract:
%%   This is added for rapid accelerator simulation of Model block with
%%   initialize port. The top model needs to save and restore some of the DWork
%%   content. For multi-instance, this is straight forward since the top model
%%   can easily access the "InstanceData" DWork of the Model block. For single
%%   instance, the DWork struct is hidden. We use this function to query such
%%   case.
%function ModelRefBlockHasPrivateDWork() void
    %return IsModelRefScalableBuild() && !GenerateClassInterface && !LibDWorkStructIsEmpty()
%endfunction %%ModelRefBlockHasPrivateDWork

%% Function: SLibDeclareModelReferenceLocalVars ====================================================
%% Abstract:
%%   For the given system, declare the global variables that are used.
%%   The function may be passed a string to prepend the declaration (such as
%%   "extern")
%%
%%   When feature RemoveMdlrefHideChild is off,
%%   all code generated from this function should be guarded by an NONEMPTY hide_child symbol.
%%   Otherwise, the code should be declared in SLibDeclareModelReferenceExportedVars.
%%
%function SLibDeclareModelReferenceLocalVars(system, extern) void
    %openfile tmpbuf
    %assign needsHideChild = !IsRemoveHideChildFeatureOn()

    %assign isBlockIOHiddenFromParent = (extern == "extern") && ...
        CGMODEL_ACCESS("CGModel.isPredefinedVarGroupHiddenFromParent", "BlockIO")
    %if system.HasBlockIOArg && isBlockIOHiddenFromParent
        %if needsHideChild
            %<GetHideChildDefineSymbol("ifndef")>\
        %endif
        /* Block signals (%<::AutoOrDefaultStorageClass> storage) */
        %<SLibDeclareStandaloneVarType(system, [], "BlockIO", extern)>
        %if needsHideChild
            %<GetHideChildDefineSymbol("endif")>\
        %endif
    %endif

    %assign isDWorkHiddenFromParent = (extern == "extern") && ...
        CGMODEL_ACCESS("CGModel.isPredefinedVarGroupHiddenFromParent", "DWork")
    %if system.HasDWorkArg && isDWorkHiddenFromParent
        %if needsHideChild
            %<GetHideChildDefineSymbol("ifndef")>\
        %endif
        /* Block states (%<::AutoOrDefaultStorageClass> storage) */
        %<SLibDeclareStandaloneVarType(system, [], "DWork", extern)>

        %if needsHideChild
            %<GetHideChildDefineSymbol("endif")>\
        %endif
    %endif

    %assign isZCEventHiddenFromParent = (extern == "extern") && ...
        CGMODEL_ACCESS("CGModel.isPredefinedVarGroupHiddenFromParent", "ZCEvent")
    %if system.HasZCEventArg && isZCEventHiddenFromParent
        %if needsHideChild
            %<GetHideChildDefineSymbol("ifndef")>\
        %endif
        /* Previous zero-crossings (trigger) states */
        %<SLibDeclareStandaloneVarType(system, [], "ZCEvent", extern)>
        %if needsHideChild
            %<GetHideChildDefineSymbol("endif")>\
        %endif
    %endif
    %closefile tmpbuf
    %return tmpbuf
%endfunction  %% SLibDeclareModelReferenceLocalVars

%% Function: SLibDeclareModelReferenceExportedVars =================================================
%% Abstract:
%%   For the given system, declare the global variables that are used.
%%   The function may be passed a string to prepend the declaration (such as
%%   "extern")
%%
%%   All variables declared here might be exposed to parent model.
%%
%function SLibDeclareModelReferenceExportedVars(system, extern) void
    %openfile tmpbuf
    %assign isBlockIOHiddenFromParent = (extern == "extern") && ...
        CGMODEL_ACCESS("CGModel.isPredefinedVarGroupHiddenFromParent", "BlockIO")
    %if system.HasBlockIOArg && !isBlockIOHiddenFromParent
        /* Block signals (%<::AutoOrDefaultStorageClass> storage) */
        %<SLibDeclareStandaloneVarType(system, [], "BlockIO", extern)>
    %endif

    %assign isDWorkHiddenFromParent = (extern == "extern") && ...
        CGMODEL_ACCESS("CGModel.isPredefinedVarGroupHiddenFromParent", "DWork")
    %if system.HasDWorkArg && !isDWorkHiddenFromParent
        /* Block states (%<::AutoOrDefaultStorageClass> storage) */
        %<SLibDeclareStandaloneVarType(system, [], "DWork", extern)>
    %endif

    %assign isZCEventHiddenFromParent = (extern == "extern") && ...
        CGMODEL_ACCESS("CGModel.isPredefinedVarGroupHiddenFromParent", "ZCEvent")
    %if system.HasZCEventArg && !isZCEventHiddenFromParent
        /* Previous zero-crossings (trigger) states */
        %<SLibDeclareStandaloneVarType(system, [], "ZCEvent", extern)>
    %endif
    %closefile tmpbuf
    %return tmpbuf
%endfunction  %% SLibDeclareModelReferenceExportedVars

%function SLibCacheModelReferenceCoderDataGroupInstances(system, isModelRefScalableBuild, extern) void
    %% Emit declarations/definitions for all exported coder data groups, except
    %% InSelf and InParent for multi-instance mdlref
    %createrecord groupFilter { \
        Static TLC_TRUE \
        Dynamic TLC_TRUE \
        NoneInit (extern == "extern") \
        AccessStandalone TLC_TRUE \
        AccessInSelf isModelRefScalableBuild \
        AccessInParent isModelRefScalableBuild \
        Exported TLC_TRUE \
        Imported TLC_FALSE \
        SkipModelData TLC_FALSE \
        EmitToTestBuffer TLC_FALSE \
    }
    %if extern == ""
        %% always falls into model source file
        %assign defnBuf = SLibDeclareCoderDataGroupInstances(system,extern,groupFilter)
        %<SLibCacheCodeToModelFile("data_DWork_defn", SLibGetVarGroupInstDefinitionFile("DWork"), defnBuf)>
    %else %% means extern == "extern"
        %if IsRemoveHideChildFeatureOn()
            %% these extern declarations go into effective private file.
            %assign privateBuf = SLibDeclareCoderDataGroupInstancesInPrivate(system,extern,groupFilter, TLC_TRUE)
            %<SLibCacheCodeToFile("mdl_priv_extern_data_decl", privateBuf)>
            %% these extern declarations go into header file.
            %assign headerBuf = SLibDeclareCoderDataGroupInstancesInPrivate(system,extern,groupFilter, TLC_FALSE)
            %<SLibCacheCodeToFile("data_DWork_decl", headerBuf)>
        %else
            %assign declBuf = SLibDeclareCoderDataGroupInstances(system,extern,groupFilter)
            %<SLibCacheCodeToModelFile("data_DWork_decl", SLibGetVarGroupInstDeclarationFile("DWork"), declBuf)>
        %endif
    %endif
%endfunction

%function SLibModelReferenceDWorkNeedsRTM()
    %return !EmptyRealTimeObject && !CompiledModel.ModelRefSimpInterface
%endfunction

%% Function: SLibGenerateSFcnDWork =================================================================
%% Abstract:
%%  Generate dwork structure for the reference model
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function SLibModelReferenceGenerateDWork() void
    %assert IsModelReferenceTarget()
    %assign baseSystem = ::CompiledModel.System[GetBaseSystemIdx()]
    %assign genMdlRefDWork = CGMODEL_ACCESS("CGModel.generateModelrefDWork")

    %openfile dwBuf
    %assign dwHasNonRTMField = TLC_FALSE
    %if genMdlRefDWork && baseSystem.HasBlockIOArg && !SLibIsSelfInPluggableInterface()
        %<FcnSysVarGroupType(baseSystem,"BlockIO")> rtb;
        %assign dwHasNonRTMField = TLC_TRUE
    %endif
    %if genMdlRefDWork && baseSystem.HasDWorkArg && !SLibIsSelfInPluggableInterface()
        %<FcnSysVarGroupType(baseSystem,"DWork")> rtdw;
        %assign dwHasNonRTMField = TLC_TRUE
    %endif
    %if SLibModelReferenceDWorkNeedsRTM()
        %<::tSimStructType> rtm;
    %endif
    %if genMdlRefDWork && baseSystem.HasZCEventArg && !SLibIsSelfInPluggableInterface()
        %<FcnSysVarGroupType(baseSystem,"ZCEvent")> rtzce;
        %assign dwHasNonRTMField = TLC_TRUE
    %endif
    %closefile dwBuf

    %if !EmptyRealTimeObject && CompiledModel.ModelRefSimpInterface && !CompiledModel.OkToMultiInstanceModelref
        %%% If using simplfied interface, and in Modelref single-instance case, we still need to define the singleton RTM variable.
        %assign allocatedVarName = SLibGetSimStructAllocatedVarName()
        %assign refVarName = SLibGetSimStructReferenceVarName()
        %assign def = "%<::tSimStructType> %<allocatedVarName>;\n"
        %assign rtmDef = SLibGetQualifiedRTMType() + " *const %<refVarName> = &%<allocatedVarName>;"
        %assign def = def + rtmDef
        %openfile dWorkDefn
        %<SLibApplyMemSecToDataDefn(def, "MemSecDataInternal", "")>\
        %closefile dWorkDefn
        %<SLibCacheCodeToFile("data_DWork_defn", dWorkDefn)>
        %undef dWorkDefn
    %endif

    %assign needsHideChild = !IsRemoveHideChildFeatureOn()
    %if !WHITE_SPACE(dwBuf)
        %assign skipMdlRefDWorkTypedef = SLibIsSelfInPluggableInterface() && !IsModelReferenceSimTarget()
        %assign isHiddenFromParent = CGMODEL_ACCESS("CGModel.isMdlrefDWorkHiddenFromParent")
        %assign dWorkType = FcnGetSFcnDWorkType(baseSystem)
        %assign dWorkIdentifier = FcnGetSFcnDWorkIdentifier(baseSystem)

        %if !skipMdlRefDWorkTypedef
            %if SLibSimTargetUsesModelSelf() && dwHasNonRTMField
                %<LibReportFatalError("Internal error: Unexpected field in MdlrefDW")>
            %endif
            %openfile dworkBuf
            %if isHiddenFromParent && needsHideChild
                %<GetHideChildDefineSymbol("ifndef")>\
            %endif
            %assign structTag = dWorkType
            %<SLibGetStructDefHeader("", structTag, "")>
            %<dwBuf>\
            %<SLibGetStructDefTail(structTag, "")>
            %if isHiddenFromParent && needsHideChild
                %<GetHideChildDefineSymbol("endif")>\
            %endif
            %closefile dworkBuf

            %if isHiddenFromParent && RemoveNonEmptyHideChildSymbol()
                %% Cache this decalaration into private file(modular)/header file(compact)
                %% Note that this declaration might be used by other .c/cpp files so it cannot go into
                %% model.c/cpp file
                %<SLibCacheCodeToFile("mdl_priv_constParam_typedef", dworkBuf)>
                %assign targetFile = SLibGetFullFileNameForCode("mdl_priv_constParam_typedef")
            %else
                %<SLibCacheCodeToFile("data_DWork_typedef", dworkBuf)>
                %assign targetFile = SLibGetFullFileNameForCode("data_DWork_typedef")
            %endif
            %if SLibModelReferenceDWorkNeedsRTM()
                %<SLibUpdateLocalSymbolTableForFile(targetFile, SLibGetFcnDeclarationRTMSymbolName())>
            %endif
        %endif

        %if IsModelRefScalableBuild()
            %assign declaration = "%<dWorkType> %<dWorkIdentifier>;"
            %openfile dWorkDecl
            %if isHiddenFromParent && needsHideChild
                %<GetHideChildDefineSymbol("ifndef")>\
            %endif
            %<SLibApplyMemSecToDataDecl(declaration, "MemSecDataInternal", "%<dWorkIdentifier>")>\
            %if isHiddenFromParent && needsHideChild
                %<GetHideChildDefineSymbol("endif")>\
            %endif
            %closefile dWorkDecl
            %if isHiddenFromParent && RemoveNonEmptyHideChildSymbol()
                %% Cache this decalaration into private file(modular)/header file(compact)
                %% Note that this declaration might be used by other .c/cpp files so it cannot go into
                %% model.c/cpp file
                %<SLibCacheCodeToFile("mdl_priv_extern_data_decl", dWorkDecl)>
                %assign declFile = SLibGetFullFileNameForCode("mdl_priv_extern_data_decl")
            %else
                %<SLibCacheCodeToFile("data_DWork_decl", dWorkDecl)>
                %assign declFile = SLibGetFullFileNameForCode("data_DWork_decl")
            %endif
            %<SLibUpdateGlobalSymbolTableForFile(declFile, dWorkIdentifier)>\

            %assert !GenerateClassInterface

            %assign def = "%<dWorkType> %<dWorkIdentifier>;"
            %openfile dWorkDefn
            %<SLibApplyMemSecToDataDefn(def, "MemSecDataInternal", "%<dWorkIdentifier>")>\
            %closefile dWorkDefn
            %<SLibCacheCodeToFile("data_DWork_defn", dWorkDefn)>
        %endif
    %endif

    %if !genMdlRefDWork && IsModelRefScalableBuild()
        %% Cache model ref local variable declarations into header/private file
        %assign mdlRefLocalVars = ...
            SLibDeclareModelReferenceLocalVars(baseSystem, "extern")
        %if !WHITE_SPACE(mdlRefLocalVars)
            %if IsRemoveHideChildFeatureOn()
                %% Cache this decalaration into private file(modular)/header file(compact)
                %% Note that this declaration might be used by other .c/cpp files so it cannot go into
                %% model.c/cpp file
                %<SLibCacheCodeToFile("mdl_priv_extern_data_decl", mdlRefLocalVars)>
            %else
                %<SLibCacheCodeToModelFile("data_DWork_decl", SLibGetVarGroupInstDeclarationFile("DWork"), mdlRefLocalVars)>
            %endif
        %endif

        %% Cache model ref exported variable declarations into header file
        %assign mdlRefExportedVars = ...
            SLibDeclareModelReferenceExportedVars(baseSystem, "extern")
        %if !WHITE_SPACE(mdlRefExportedVars)
            %<SLibCacheCodeToModelFile("data_DWork_decl", SLibGetVarGroupInstDeclarationFile("DWork"), mdlRefExportedVars)>
        %endif

        %% Cache model ref variable declarations into src file (with no extern keyword)
        %assign mdlrefVars = ""
        %openfile mdlrefVars
        %<SLibDeclareModelReferenceLocalVars(baseSystem, "")>
        %<SLibDeclareModelReferenceExportedVars(baseSystem, "")>
        %closefile mdlrefVars
        %if !WHITE_SPACE(mdlrefVars)
            %<SLibCacheCodeToModelFile("data_DWork_defn", SLibGetVarGroupInstDefinitionFile("DWork"), mdlrefVars)>
        %endif
    %endif

    %<SLibCacheModelReferenceCoderDataGroupInstances(baseSystem, IsModelRefScalableBuild(), "extern")>
    %<SLibCacheModelReferenceCoderDataGroupInstances(baseSystem, IsModelRefScalableBuild(), "")>
%endfunction

%function FcnGetSFcnDWorkIdentifier(system) void
    %if !IsModelReferenceSimTarget() && SLibIsSelfInPluggableInterface() && system.SystemIdx == GetBaseSystemIdx()
        %return "%<::CompiledModel.GlobalScope.tRTM>"
    %else
        %return "%<system.Interface.tsysMdlrefDWork>"
    %endif
%endfunction

%function FcnGetSFcnDWorkType(system) void
    %if !IsModelReferenceSimTarget() && SLibIsSelfInPluggableInterface() && system.SystemIdx == GetBaseSystemIdx()
        %return "%<tSimStructType>"
    %else
        %return "%<system.Interface.tsysMdlrefDWorkType>"
    %endif
%endfunction

%function FcnGetSFcnDWorkRTM() void
    %assert IsModelReferenceSimTarget() && SLibGetUseRTMcgType()
    %assign modelDW = FcnGetSFcnDWorkIdentifier(::CompiledModel.System[baseSystemIdx])
    %return modelDW + ".rtm"
%endfunction

%% Function: LibGetFcnInfo =========================================================================
%% Abstract:
%%    Return fcnInfo record of the system.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/simulink/variants/var-general/tTypesToPrivate.m
%%
%function LibGetFcnInfo(system, fcnType, tid) void
    %% Output may have been combined with update
    %if fcnType == "Output" && !ISFIELD(system,"OutputFcn") &&  ...
        !(ISFIELD(system,"OutputCalledInUpdate") &&  ...
        system.OutputCalledInUpdate == "yes")
        %assign fcnType = "OutputUpdate"
    %endif
    %if LibIsSingleRateSystem(system) && ...
        LibSystemIsReusedFcn(system) && ...
        !SLibNonInlinedModelWideEventTID(tid)
        %assign tid = FcnGetSubsystemCodeBufTID(system)
    %endif
    %if (SLibSystemFcnPeriodicRateGrouping(system, fcnType) || ...
        (LibAsynchronousTriggeredTID(tid)  && ...
        (fcnType == "Output" || fcnType == "Update" || ...
        fcnType == "OutputUpdate")))
        %assign tidStr = "TID%<tid>"
    %else
        %assign tidStr = ""
    %endif
    %if !ISEMPTY(tidStr) && SLibPartitionGroupingSystem(system)
        %if IsModelReferenceTarget()
            %assign pid = "PID%<system.CurrentPID>"
        %else
            %% For top model code interface, system.CurrentPID is set to -1
            %assign pidVec = SLibGetPidFromTid(tid)
            %if ISEMPTY(pidVec)
                %assign pid = ""
            %else
                %assign pid = "PID%<pidVec[0]>"
            %endif
        %endif
    %else
        %assign pid = ""
    %endif
    %assign fieldname = fcnType + "%<tidStr>%<pid>FcnInfo"
    %if LibIsSystemField(system, fieldname)
        %assign fcnInfo = LibGetSystemField(system, fieldname)
    %else
        %assign fcnInfo = ""
    %endif
    %return fcnInfo
%endfunction

%% Function: CreateModelrefSFunctionForTopSystem ===================================================
%% Abstract:
%%    Create ModelrefSFunction record for the hidden subsystem
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function CreateModelrefSFunctionForTopSystem() void

    %assert IsModelReferenceTarget()
    %% If we are generating an S-function, add cached variables for
    %% all the s-fcn entry points to the record ModelrefSFunction
    %assert ::CompiledModel.NumSystems > 1

    %addtorecord ::CompiledModel.System[NumSystems-2] ModelrefSFunction { ...
        CachedFcnCallInputBuffers ""; ...
        CachedInitializeSizesDeclarations ""; ...
        CachedInitializeSizesBody ""; ...
        CachedInitializeSampleTimesDeclarations ""; ...
        CachedInitializeSampleTimesBody ""; ...
        CachedInitializeConditionsDeclarations ""; ...
        CachedInitializeConditionsBody ""; ...
        CachedSystemInitializeDeclarations ""; ...
        CachedSystemInitializeBody ""; ...
        CachedSystemResetDeclarations ""; ...
        CachedSystemResetBody ""; ...
        CachedSetWorkWidthsDeclarations ""; ...
        CachedSetWorkWidthsBody ""; ...
        CachedProcessParametersDeclarations ""; ...
        CachedProcessParametersBody ""; ...
        CachedStartDeclarations ""; ...
        CachedStartBody ""; ...
        CachedEnableDeclarations ""; ...
        CachedEnableBody ""; ...
        CachedDisableDeclarations ""; ...
        CachedDisableBody ""; ...
        CachedOutputsDeclarations ""; ...
        CachedOutputsBody ""; ...
        CachedUpdateDeclarations ""; ...
        CachedUpdateBody ""; ...
        CachedZeroCrossingsDeclarations ""; ...
        CachedZeroCrossingsBody ""; ...
        CachedDerivativesDeclarations ""; ...
        CachedDerivativesBody ""; ...
        CachedProjectionDeclarations ""; ...
        CachedProjectionBody ""; ...
        CachedForcingFunctionDeclarations ""; ...
        CachedForcingFunctionBody ""; ...
        CachedMassMatrixDeclarations ""; ...
        CachedMassMatrixBody ""; ...
        CachedTerminateDeclarations ""; ...
        CachedTerminateBody ""...
    }
%endfunction


%% Function: AppendZeroToString ====================================================================
%% Abstract:
%%      Append the inStr with zero
%function AppendZeroToString(inStr, comma, num) void
    %foreach i = num
        %assign inStr =  "%<inStr>%<comma>0"
        %assign comma = ", "
    %endforeach
    %return inStr
%endfunction

%% Function FcnAppendToBlockInterface =========================================
%% Abstract:
%%    Helper function for FcnAppendToBlockInterface.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/simulink/blocks/tconcat.m
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%% TopTester: test/toolbox/simulink/variants/var-vss-general/tMdlrefToVSS.m
%%
%function SLibGetModelRefFcnNames(thisSystem, blockFcn, fcnCallTaskName, ...
    currentTID, isPeriodicRateGrouping)

    %assign tlcFcn = ""
    %assign tlcFcnName = ""
    %assign sysFcnName = ""
    %assign CGIRName = ""
    %if blockFcn == "Registration"
        %assert ISEMPTY(fcnCallTaskName)
        %assign sysFcnName = "%<blockFcn>Fcn"
        %if ::GenerateClassInterface
            %if CGMODEL_ACCESS("CGModel.isCPPMappingEnabled")
                %assign initFcnName = "%<CGMODEL_ACCESS("CGModel.getModelEntryFunctionName","Initialize", "")>"
            %else
                %assign initFcnName = "initialize"
            %endif
            %assign fcnName = "%<::CPPClassName>::%<initFcnName>"
        %else
            %assign fcnName = GetModelRefRegistrationFcnName()
        %endif
        %assign tlcFcnName = []
    %else
        %assign fcnRecord = LibGetFcnInfo(thisSystem, blockFcn, currentTID)
        %assert (TYPE(fcnRecord) == "Scope")
        %assign fcnName = fcnRecord.Name
        %if ISFIELD(fcnRecord, "CGIRName")
            %assign CGIRName = fcnRecord.CGIRName
        %endif

        %switch (blockFcn)
          %case "Output"
          %case "OutputUpdate"
            %assign tlcFcn = "Outputs"
            %break
          %case "SetupRuntimeResources"
            %assign tlcFcn = "SetupRuntimeResources"
            %break
          %case "Initialize"
            %assign tlcFcn = "InitializeConditions"
            %break
          %case "SystemInitialize"
            %assign tlcFcn = "SystemInitialize"
            %break
          %case "SystemReset"
            %assign tlcFcn = "SystemReset"
            %break
          %case "Derivative"
            %assign tlcFcn = "Derivatives"
            %break
          %case "ZeroCrossing"
            %assign tlcFcn = "ZeroCrossings"
            %break
          %case "CleanupRuntimeResources"
            %assign tlcFcn = "CleanupRuntimeResources"
            %break
          %default
            %assign tlcFcn = blockFcn
            %break
        %endswitch

        %if !isPeriodicRateGrouping && ...
            !(SLibIsExportFcnDiagram() && SLibSystemFcnIsRateGroupType(blockFcn) && !ISEQUAL(currentTID,"")) && ...
            !LibSystemFcnIsEmpty(thisSystem, blockFcn)
            %assign sysFcnName = blockFcn + "Fcn"
            %assign tlcFcnName = tlcFcn + "_Function"
        %elseif !LibSystemFcnIsEmptyForTID(thisSystem, blockFcn)
            %assign sysFcnName = blockFcn + "TID%<thisSystem.CurrentTID>Fcn"
            %assign tlcFcnName = tlcFcn + "_FunctionTID%<thisSystem.CurrentTID>"
        %endif
    %endif

    %assign retRec = ["%<sysFcnName>", "%<tlcFcnName>", "%<fcnName>", "%<CGIRName>"]
    %return retRec
%endfunction

%% Function: SLibGetModelRefRootInputIdx ===========================================================
%% Abstract:
%%   Returns the root input port for a canonical input index
%%
%function SLibGetModelRefRootInputIdx(sysIdx, canInputIdx)
    %assign thisSystem = ::CompiledModel.System[sysIdx]
    %assign ci = thisSystem.Interface.CanonicalInputArgDef[canInputIdx].SignalSrc
    %assign idNum = IDNUM(ci[0])
    %assert (idNum[0] == "U" || idNum[0] == "M")
    %assign rootInputPortIdx = idNum[1]
    %return rootInputPortIdx
%endfunction %% SLibGetModelRefRootInputIdx

%% Function: SLibGetModelRefRootOutputIdx ==========================================================
%% Abstract:
%%   Returns the root input port for a canonical input index
%%
%function SLibGetModelRefRootOutputIdx(sysIdx, canOutputIdx)
    %assign thisSystem = ::CompiledModel.System[sysIdx]
    %return thisSystem.Interface.CanonicalOutputArgDef[canOutputIdx].RootOutputIdx
%endfunction %% SLibGetModelRefRootOutputIdx

%% Function: CreateModelReferenceFcnRec ============================================================
%% Abstract:
%%    Helper function for FcnAppendToBlockInterface
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/simulink/blocks/tconcat.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%% TopTester: test/toolbox/simulink/variants/var-inline-general/tCSCDefine.m
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%% TopTester: test/toolbox/simulink/variants/var-vss-general/tMdlrefToVSS.m
%%
%function CreateModelReferenceFcnRec(sysIdx, blockFcn, sysFcnName, tid, blkInterface, useSysFcnName) void
    %assign thisSystem = ::CompiledModel.System[sysIdx]
    %assign modIdx = thisSystem.CGIRModuleIdx
    %assign thisModule = ::CompiledModel.RTWCGModules.RTWCGModule[modIdx]
    %assign hasSimplifiedInterface = thisModule.SimplifiedInterface
    %assign origTID = thisSystem.CurrentTID
    %assign thisSystem.CurrentTID = tid
    %assign currentTID     = tid

    %assign isPeriodicRateGrouping = SLibSystemFcnPeriodicRateGrouping(thisSystem, blockFcn) || ...
        (SLibSystemFcnIsRateGroupType(blockFcn) && SLibIsModelRefAsyncTID(tid))

    %assign isWritable = !ISEMPTY(blkInterface)

    %if isWritable && !ISFIELD(blkInterface, "NumBlockFcns")
        %addtorecord blkInterface NumBlockFcns 0
    %endif

    %if(useSysFcnName)
        %assign keyFcnName = sysFcnName
    %else
        %assign keyFcnName = blockFcn
    %endif


    %% LibSystemFcnIsEmpty has side affect. (When output is passed,
    %% it may check for OutputUpdate!)
    %assign isRateGroupedAsync = FcnSysModuleIsRateGrouping(thisSystem,blockFcn)
    %if blockFcn != "Registration" && ...
        (!SLibIsModelRefAsyncTID(tid) || SLibNonInlinedModelWideEventTID(tid)) && ...
        !useSysFcnName && ...
        (!ISFIELD(thisSystem,"%<keyFcnName>Fcn") || ...
        ((isRateGroupedAsync) && LibSystemFcnIsEmptyForTID(thisSystem, keyFcnName)) || ...
        LibSystemFcnIsEmpty(thisSystem, keyFcnName))
        %assign thisSystem.CurrentTID = origTID

        %createrecord retRec { \
            SysFcnName ""; \
            FcnRec     ""\
        }
        %return retRec
    %endif

    %assign fcnNames = SLibGetModelRefFcnNames(thisSystem, blockFcn, ...
        sysFcnName, currentTID, isPeriodicRateGrouping)

    %assign sysFcnName = fcnNames[0]
    %assign tlcFcnName = fcnNames[1]
    %assign fcnName = fcnNames[2]
    %assign cgirName = fcnNames[3]

    %% For Async code gen, we always track argument based on func names, keyFcnName.
    %% For all other rates, we track argument based on func type, which is blockFcn.
    %% The 2nd option is the rate grouping code path.
    %if SLibExplicitTaskingTID(tid)
        %assign ::BlockFcn = blockFcn
    %else
        %assign ::BlockFcn = keyFcnName
    %endif

    %with thisSystem.Interface
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %% Canonical input argument
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %assign  comma = ""
        %assign  inStr = ""
        %assign  inCounter = 0
        %assign  numInputs = ExternalInputs.NumExternalInputs
        %foreach argIdx = NumCanonicalInputArgDefs
            %assign idx = SLibGetModelRefRootInputIdx(sysIdx, argIdx)

            %% fill 0 for unused inputs
            %assign numZeroToAdd = idx - inCounter
            %if  numZeroToAdd > 0
                %assign inStr = AppendZeroToString(inStr, comma, numZeroToAdd)
                %assign comma = ", "
            %endif
            %assign inCounter = idx

            %if FcnArgNeeded(CanonicalInputArgDef[argIdx],currentTID,isPeriodicRateGrouping)
                %if CanonicalInputArgDef[argIdx].DeclareAsPointer == "yes"
                    %assign inStr = "%<inStr>%<comma>2"
                %else
                    %assign inStr = "%<inStr>%<comma>1"
                %endif
            %else
                %assign inStr = "%<inStr>%<comma>0"
            %endif
            %assign comma = ", "
            %assign inCounter = inCounter + 1
        %endforeach

        %assign numZeroToAdd = numInputs - inCounter
        %if  numZeroToAdd > 0
            %assign inStr = AppendZeroToString(inStr, comma, numZeroToAdd)
            %assign comma = ", "
        %endif
        %assign inCounter = numInputs
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %% Canonical dimsize dwork argument for input
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %assign inDWStr = GetBlockInputCanDimSizeDWInterface(sysIdx, blockFcn, tid)
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %% Canonical output argument
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %assign comma  = ""
        %assign outStr = ""
        %assign outCounter = 0
        %assign  numOutputs = ExternalOutputs.NumExternalOutputs
        %foreach argIdx = NumCanonicalOutputArgDefs
            %assign idx = SLibGetModelRefRootOutputIdx(sysIdx, argIdx)

            %% fill 0 for unused outputs
            %assign numZeroToAdd = idx - outCounter
            %if  numZeroToAdd > 0
                %assign outStr = AppendZeroToString(outStr, comma, numZeroToAdd)
                %assign comma = ", "
            %endif
            %assign outCounter = idx

            %if FcnArgNeeded(CanonicalOutputArgDef[argIdx],currentTID,isPeriodicRateGrouping)
                %assign outStr = "%<outStr>%<comma>1"
            %else
                %assign outStr = "%<outStr>%<comma>0"
            %endif
            %assign comma = ", "
            %assign outCounter = outCounter + 1
        %endforeach

        %assign numZeroToAdd = numOutputs - outCounter
        %if  numZeroToAdd > 0
            %assign outStr = AppendZeroToString(outStr, comma, numZeroToAdd)
            %assign comma = ", "
        %endif
        %assign outCounter = numOutputs
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %% Canonical dimsize dwork argument for output
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %assign outDWStr = GetBlockOutputCanDimSizeDWInterface(sysIdx, blockFcn, tid)
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %% Other flags
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %% Args: [oIdx, rIdx, TID, rtModel, BlockIo, DWork, CState, CStateDeriv, CStateDis, CStateAbsTol, ZC, ZCEvent]

        %% Note the following order is used in blocks/modelref.tlc.
        %% If you update this order, you must update the order in SLibCallModelBlockFunction in this file and
        %% FcnAddMdlRefFcnInterface in codeinfomdlreflib.tlc
        %% [oIdx, rIdx, TID, rtModel, BlockIo, DWork, CState, CStateDeriv, CStateDis, CStateAbsTol, ZC, ZCEvent]
        %assign args = ""
        %assign comma = ""

        %% oIdx and rIdx
        %if blockFcn == "SetDims"
            %assign val = 1
            %assign args = "%<args>%<comma>%<val>"
            %assign args = "%<args>%<comma>%<val>"
        %endif

        %% TID
        %if (SLibIsModelRefAsyncTID(tid))
            %% Because we know async is single instance, always return
            %% false for needs TID.  (LibSystemFcnNeedsTID returns needs
            %% TID for the model, which does need TID, but the async doesn't,
            %% which causes code that won't compile)
            %assign val = TLC_FALSE
        %else
            %assign val = LibSystemFcnNeedsTID(thisSystem, blockFcn)
        %endif
        %assign args = "%<args>%<comma>%<val>"
        %assign comma = ", "
        %%rtModel
        %assign val = FcnArgNeeded(RTMArgDef,currentTID,isPeriodicRateGrouping) || hasSimplifiedInterface
        %if val && (IsModelRefScalableBuild() || GenerateClassInterface)
            %assign val = 0
        %endif
        %assign args = "%<args>%<comma>%<val>"
        %assign comma = ", "
        %% BlockIo argument
        %assign val = FcnArgNeeded(BlockIOArgDef,currentTID,isPeriodicRateGrouping)
        %if val && (IsModelRefScalableBuild() || GenerateClassInterface || hasSimplifiedInterface)
            %assign val = 0
        %endif
        %assign args = "%<args>%<comma>%<val>"
        %% DWork argument
        %assign val = FcnArgNeeded(DWorkArgDef,currentTID,isPeriodicRateGrouping)
        %if val && (IsModelRefScalableBuild() || GenerateClassInterface || hasSimplifiedInterface)
            %assign val = 0
        %endif
        %assign args = "%<args>%<comma>%<val>"
        %% Continuous States argument
        %assign val = FcnArgNeeded(ContStatesArgDef,currentTID,isPeriodicRateGrouping)
        %assert !(val && GenerateClassInterface)
        %assign args = "%<args>%<comma>%<val>"
        %% Continuous States Derivative argument
        %assign val = FcnArgNeeded(ContStatesDerivativeArgDef,currentTID,isPeriodicRateGrouping)
        %assert !(val && GenerateClassInterface && IsModelReferenceTarget())
        %assign args = "%<args>%<comma>%<val>"
        %% Continuous States Disabled argument
        %assign val = FcnArgNeeded(ContStatesDisabledArgDef,currentTID,isPeriodicRateGrouping)
        %assert !(val && GenerateClassInterface && IsModelReferenceTarget())
        %assign args = "%<args>%<comma>%<val>"
        %% Continuous States Absolute Tolerance argument
        %assign val = FcnArgNeeded(ContStatesAbsoluteToleranceArgDef,currentTID,isPeriodicRateGrouping)
        %assert !(val && GenerateClassInterface)
        %assign args = "%<args>%<comma>%<val>"

        %% Continuous States Perturb Min argument
        %assign val = FcnArgNeeded(ContStatesPerturbMinArgDef,currentTID,isPeriodicRateGrouping)
        %assert !(val && GenerateClassInterface)
        %assign args = "%<args>%<comma>%<val>"

        %% Continuous States Perturb Max argument
        %assign val = FcnArgNeeded(ContStatesPerturbMaxArgDef,currentTID,isPeriodicRateGrouping)
        %assert !(val && GenerateClassInterface)
        %assign args = "%<args>%<comma>%<val>"


        %% Non Sampled Zero Crossing argument
        %assign val = FcnArgNeeded(ZCSVArgDef,currentTID,isPeriodicRateGrouping)
        %assert !(val && GenerateClassInterface)
        %assign args = "%<args>%<comma>%<val>"
        %% ZCEvent H-Valuct argument
        %assign val = FcnArgNeeded(ZCEventArgDef,currentTID,isPeriodicRateGrouping)
        %if val && (IsModelRefScalableBuild() || GenerateClassInterface || hasSimplifiedInterface)
            %assign val = 0
        %endif
        %assign args = "%<args>%<comma>%<val>"
        %%
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %% Canonical parameter argument
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %assign   comma  = ""
        %assign   prmStr = ""
        %assign  prmType = []
        %assign prmIsPtr = []
        %foreach argIdx = NumCanonicalPrmArgDefs
            %assign argDef = CanonicalPrmArgDef[argIdx]
            %if isCanonicalParamRetained(argDef)
                %if FcnArgNeeded(argDef,currentTID,isPeriodicRateGrouping)
                    %assign prmWidth = LibBlockParameterWidth(argDef)
                    %assign prmStr = "%<prmStr>%<comma>%<prmWidth>"
                %else
                    %% Not needed, so arbitrary "0" as a placeholder suffices.
                    %assign prmStr = "%<prmStr>%<comma>0"
                %endif
                %assign  dtName = ...
                    LibGetDataTypeNameFromId(LibGetRecordContainerDataTypeId(argDef))
                %assign prmType = prmType + dtName
                %assign comma = ", "
                %assign prmIsPtr = prmIsPtr + (argDef.DeclareAsPointer == "yes")
            %else
                %assert argDef.IsUsed == "no"
            %endif
        %endforeach

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %% Canonical dwork argument
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %assign comma  = ""
        %assign canDWStr = ""
        %foreach argIdx = NumCanonicalDWorkArgDefs
            %assign argDef = CanonicalDWorkArgDef[argIdx]
            %if FcnArgNeeded(argDef,currentTID,isPeriodicRateGrouping)
                %assign dwIdx    = argDef.FirstSignalSrc
                %assign dwRec    = ::CompiledModel.DWorks.DWork[dwIdx]
                %assign dwWidth  = SLibDWorkWidth(dwRec)
                %assign canDWStr = "%<canDWStr>%<comma>%<dwWidth>"
            %else
                %assign canDWStr = "%<canDWStr>%<comma>0"
            %endif
            %assign comma = ", "
        %endforeach

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %% Computed stack size
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %assign stackSize = 0
        %assign blockFcnRecAdded = TLC_FALSE

        %if blockFcn != "Registration"
            %if !ISEMPTY(tlcFcnName) && ISFIELD(RTWCGModules.RTWCGModule[thisSystem.CGIRModuleIdx], "RTWFcnConst")
                %assign rtwFcnConst = ...
                    RTWCGModules.RTWCGModule[thisSystem.CGIRModuleIdx].RTWFcnConst
                %if ISFIELD(rtwFcnConst, tlcFcnName)
                    %assign stackSize = rtwFcnConst.%<tlcFcnName>.StackSize
                %endif
            %endif
            %assign localTaskID = isPeriodicRateGrouping ? currentTID : -1
            %createrecord blockFcnRec {   \
                BlockFcnType "%<blockFcn>"; \
                RateGrouping %<isPeriodicRateGrouping>; \
                TaskID       %<localTaskID>;    \
                StackSize    %<stackSize>;      \
                ArgSource    []                 \
                ArgAccessed  []                 \
            }
            %if isWritable
                %assign blkInterface.NumBlockFcns = blkInterface.NumBlockFcns + 1
                %addtorecord blkInterface BlockFcns %<blockFcnRec>
                %assign blockFcnRecAdded = TLC_TRUE
            %endif
        %endif

        %assign numArgs = 0
        %assign argSourceVec  = []
        %assign argAccessedVec = []
        %assign associationVec = []

        %if ISFIELD(thisModule, "SystemFunctions") && ...
            (ISFIELD(thisModule.SystemFunctions, fcnName) || ISFIELD(thisModule.SystemFunctions, cgirName))
            %% G1719775 During C++ Class Generation, the fcnName is not used in CGIR phase
            %% Using cgirName to get the correct function prototype
            %if ISFIELD(thisModule.SystemFunctions, fcnName)
                %assign fcnIndex = GETFIELD(thisModule.SystemFunctions, fcnName)
            %else
                %assign fcnIndex = GETFIELD(thisModule.SystemFunctions, cgirName)
            %endif

            %assign thisFcn  = thisModule.Function[fcnIndex]
            %if thisFcn.IsRateGroupedSLFcn
                %createrecord retRec { \
                    SysFcnName ""; \
                    FcnRec     ""\
                }
                %assign thisSystem.CurrentTID = origTID

                %return retRec
            %endif

            %assert SIZE(thisFcn.ArgAccessed, 1) == thisFcn.NumArgs
            %assert SIZE(thisFcn.ArgSource, 1) == thisFcn.NumArgs

            %assign argAccessedVec = thisFcn.ArgAccessed
            %foreach argIdx = thisFcn.NumArgs
                %if thisFcn.ArgAccessed[argIdx] > 0
                    %if ISFIELD(thisFcn, "Association")
                        %assign association = thisFcn.Association[argIdx]
                    %else
                        %assign association = ""
                    %endif
                    %assign argSource = thisFcn.ArgSource[argIdx]
                    %assign idNum = SLibSafeIDNUM(thisFcn.ArgSource, argIdx)
                    %assign argSrc = idNum[0]
                    %assign argSrcIdx = idNum[1]
                    %switch argSrc
                      %case "I" %% canonical input
                        %assign idx = SLibGetModelRefRootInputIdx(sysIdx, argSrcIdx)
                        %assign argSource = "I%<idx>"
                        %break
                      %case "O" %% canonical output
                        %assign idx = SLibGetModelRefRootOutputIdx(sysIdx, argSrcIdx)
                        %assign argSource = "O%<idx>"
                        %break
                      %case "Y" %% root outport not being canonical output, occur in FPC only
                        %assign argSource = "O%<argSrcIdx>"
                        %break
                      %case "D" %% canonical dwork
                        %if ISFIELD(thisFcn, "Association")
                            %assign dimsIdNum = SLibSafeIDNUM(thisFcn.Association, argIdx)
                            %assign dimsSrc = dimsIdNum[0]
                            %assign dimsSrcIdx = dimsIdNum[1]
                            %if "I" == dimsSrc
                                %assign idx = SLibGetModelRefRootInputIdx(sysIdx, dimsSrcIdx)
                                %assign association = "I%<idx>"
                            %else
                                %assert "O" == dimsSrc
                                %assign idx = SLibGetModelRefRootOutputIdx(sysIdx, dimsSrcIdx)
                                %assign association = "O%<idx>"
                            %endif
                        %endif
                        %break
                      %case "P" %% canonical parameter
                        %assert ISFIELD(thisFcn, "Association")
                        %assert SIZE(thisFcn.Association, 1) == thisFcn.NumArgs
                        %assert !ISEMPTY("%<association>")
                        %assign argSource = association
                        %break
                      %case "RTM"
                      %case "LB" %% block IO
                      %case "LC" %% constat block IO
                      %case "LW" %% dwork
                      %case "LP"  %% parameter
                      %case "LCP" %% constant parameter
                      %case "LPI" %% const parameter with init
                      %case "LX" %% continues states
                      %case "LDX" %% derivatives
                      %case "LXDI" %% continues state disabled
                      %case "LXAT" %% continues state absolute tolerance
                      %case "LXPTMIN" %% continues state perturb min
                      %case "LXPTMAX" %% continues state perturb max
                      %case "LZ" %% non-sampled zero crossings
                      %case "LZE" %% zero crossing events
                      %case "X" %% unknown argument
                      %case "LCDG"
                      %case "U"  %% external input
                        %break
                      %default
                        %%START_ASSERT
                        %assign errTxt = "Unhandled argument type '%<argSrc>'."
                        %<LibBlockReportError([],errTxt)>
                        %break
                        %%END_ASSERT
                    %endswitch
                    %assign argSourceVec = argSourceVec + argSource
                    %if ISFIELD(thisFcn, "Association")
                        %assign associationVec = associationVec + association
                    %endif
                    %assign numArgs = numArgs + 1
                %endif
            %endforeach
        %endif

        %%
        %% This code path handles cached model IO arguments in the model start function
        %% to support a pluggable interface
        %%
        %if 0 == numArgs
            %if blockFcn == "Start"
                %assign cTID = currentTID
                %assign isRG = isPeriodicRateGrouping
                %foreach argIdx = NumCanonicalInputArgDefs
                    %assign argDef = CanonicalInputArgDef[argIdx]
                    %if FcnArgNeeded(argDef,cTID,isRG)
                        %assign idx = SLibGetModelRefRootInputIdx(sysIdx, argIdx)
                        %assign argSourceVec = argSourceVec + "I%<idx>"
                        %assign argAccessedVec = argAccessedVec + 1
                        %assign numArgs = numArgs + 1
                    %endif
                %endforeach
                %foreach argIdx = NumCanonicalOutputArgDefs
                    %assign argDef = CanonicalOutputArgDef[argIdx]
                    %if FcnArgNeeded(argDef,cTID,isRG)
                        %assign idx = SLibGetModelRefRootOutputIdx(sysIdx, argIdx)
                        %assign argSourceVec = argSourceVec + "O%<idx>"
                        %assign argAccessedVec = argAccessedVec + 1
                        %assign numArgs = numArgs + 1
                    %endif
                %endforeach
                %assign prmArgIdx = 0
                %foreach argIdx = NumCanonicalPrmArgDefs
                    %assign argDef = CanonicalPrmArgDef[argIdx]
                    %if isCanonicalParamRetained(argDef)
                        %if FcnArgNeeded(argDef,cTID,isRG)
                            %assign argSourceVec = argSourceVec + "P%<prmArgIdx>"
                            %assign argAccessedVec = argAccessedVec + 1
                            %assign numArgs = numArgs + 1
                        %endif
                        %assign prmArgIdx = prmArgIdx + 1
                    %endif
                %endforeach
                %foreach argIdx = NumCanonicalDWorkArgDefs
                    %assign argDef = CanonicalDWorkArgDef[argIdx]
                    %if FcnArgNeeded(argDef,cTID,isRG)
                        %assign argSourceVec = argSourceVec + "D%<argIdx>"
                        %assign argAccessedVec = argAccessedVec + 1
                        %assign numArgs = numArgs + 1
                    %endif
                %endforeach
            %endif
        %endif

        %assign headerFile = CGMODEL_ACCESS("FileRepository.getHeaderFileForFunctionName", fcnName)
        %assign sourceFile = CGMODEL_ACCESS("FileRepository.getSourceFileForFunctionName", fcnName)
        %if (ISEMPTY(headerFile) && ISEMPTY(sourceFile))
            %% OutputUpdate function is registered using CG name in the File Repository
            %assign headerFile = CGMODEL_ACCESS("FileRepository.getHeaderFileForFunctionName", cgirName)
            %assign sourceFile = CGMODEL_ACCESS("FileRepository.getSourceFileForFunctionName", cgirName)
        %endif

        %createrecord BlkFcnRec {     \
            FcnName       fcnName;       \
            ArgInfo       [%<args>];     \
            Outputs       [%<outStr>];   \
            OutDimSizeDW  [%<outDWStr>]; \
            Inputs        [%<inStr>];    \
            InDimSizeDW   [%<inDWStr>];  \
            PrmArgs       [%<prmStr>];   \
            PrmTypes      prmType;       \
            PrmIsPointer  prmIsPtr;      \
            DWArgs        [%<canDWStr>]; \
            NumArgs       numArgs;       \
            ArgSource     argSourceVec;  \
            ArgAccessed   argAccessedVec; \
            Association   associationVec; \
            CGIRName      cgirName \
            FcnHeaderFile headerFile  \
            FcnSourceFile sourceFile  \
        }

        %if blockFcnRecAdded
            %assign blkInterface.BlockFcns[blkInterface.NumBlockFcns-1].ArgSource = argSourceVec
            %assign blkInterface.BlockFcns[blkInterface.NumBlockFcns-1].ArgAccessed = argAccessedVec
        %endif

        %assign ::BlockFcn = "Unknown"
    %endwith %% thisSystem.Interface

    %assign thisSystem.CurrentTID = origTID

    %createrecord retRec { \
        SysFcnName "%<sysFcnName>"; \
        FcnRec     %<BlkFcnRec>\
    }
    %return retRec
%endfunction


%% Function FcnAppendToBlockInterface =========================================
%% Abstract:
%%    The following order is used in FcnGetAdditionalArgs and
%%    FcnAddNeededParameter. We must use the same order:
%%           Tid
%%           oIdx,
%%           rIdx,
%%           CanonicalInput
%%           CanonicalDWork for CanonicalInput
%%           CanonicalOutput
%%           CanonicalDWork for CanonicalOutput
%%           RTModel
%%           BlockIO
%%           ConstBlockIO (not needed. This is global for all instances)
%%           DWork
%%           Prm (?)
%%           ContStates
%%           ContStatesDerivative
%%           ContStatesDisabled
%%           ContStatesAbsoluteTolerance
%%           ContStatesPerturbMin
%%           ContStatesPerturbMax
%%           NonsampledZC
%%           ZCEvent
%%           NumCanonicalPrm
%%           CanDWork (?)
%%
%function FcnAppendToBlockInterface(sysIdx, accessSysIdx, blockFcn, tid, blkInterface) void

    %assign fcnRec = CreateModelReferenceFcnRec(sysIdx, blockFcn, "", tid, blkInterface, TLC_FALSE)

    %assign fcnName = fcnRec.SysFcnName
    %assign BlkFcnRec = fcnRec.FcnRec

    %if fcnName != ""
        %addtorecord blkInterface %<fcnName> %<BlkFcnRec>
        %<SLibDumpBlkInterfaceDebugInfo(sysIdx, fcnRec)>
    %endif

%endfunction %%FcnAppendToBlockInterface

%% Function: FcnCacheMRRegFcnLocalVars =============================================================
%% Abstract:
%%   This function adds the needed local variables to the registration function
%%   body e.g. "localB, localDW, localX ..."
%%   The additional local variables are needed if we are doing a model ref
%%   scalable build. e.g.
%%
%%      void mr_ModelName_intialize(const int32_T *rtu_0, int32_T *rty_0)
%%      {
%%           rtB_mr_myecdemo   *localB = &(mr_myecdemo_DW.rtb);
%%           rtDW_mr_myecdemo *localDW = &(mr_myecdemo_DW.rtdw);
%%           ....
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function FcnCacheMRRegFcnLocalVars(thisSystem) void

    %assign thisSystem.CurrentTID = ""
    %assign currentTID     = ""
    %assign isPeriodicRateGrouping = SLibSystemFcnPeriodicRateGrouping(thisSystem, "Registration")
    %assign scalarTokens = LibGetScalarDataInitTokens()

    %assign ::BlockFcn = "Registration"

    %with thisSystem.Interface
        %% Args: [TID, rtModel, BlockIo, DWork, CState, CStateDriv, CStateDis, ZC, ZCEvent]
        %%rtModel
        %assign val = FcnArgNeeded(RTMArgDef,currentTID,isPeriodicRateGrouping)
        %if val && IsModelRefScalableBuild() && !SLibIsSelfInPluggableInterface()
            %openfile localRTMVar
            %assign rtmAccess = ".rtm"
            %<SLibGetQualifiedRTMType()> *const %<::tSimStruct>%<scalarTokens[0]>&(%<FcnGetSFcnDWorkIdentifier(thisSystem)>%<rtmAccess>)%<scalarTokens[1]>;
            %closefile localRTMVar
            %<FcnCacheModelRefLocalVars(thisSystem, "Registration", "", localRTMVar)>
        %endif

        %% CoderDataGroups
        %if !CompiledModel.SuppressSelf
            %openfile coderDataGroupVar
            %foreach gIdx = ::CompiledModel.NumCoderDataGroups
                %assign group = ::CompiledModel.CoderDataGroup[gIdx]
                %if SLibIsGroupSelfCoderGroup(group)
                    %continue
                %endif
                %assign groupToken = "CoderDataGroup" + group.Name
                %assign argDef = %<groupToken + "ArgDef">
                %if FcnArgNeeded(argDef,currentTID,isPeriodicRateGrouping)
                    %assign varGroupIdx = FcnSysVarGroupIndex(thisSystem, groupToken, 0)
                    %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
                    %assign varGroupType = FcnSysVarGroupType(thisSystem, groupToken)
                    %assign varName = varGroup.LocalName
                    %assign typeQualifier = SLibTypeQualifierForGroup(group)
                    %% Based on the SuprressSelf logic, we can get here when either the model is multi-instance
                    %% or self has a coder datagroup.
                    %% In multi-instance case, self is structured or there is no self (RTM would be used).
                    %% In single-instance case (self vargroup is AsStructureNone) we access group instance.
                    %if SLibAccessGroupThroughSelf(group) && ...
                        (::CompiledModel.SelfCoderDataGroupIndex == -1 || SLibIsSelfStructured())
                        %<typeQualifier> %<varGroupType> *%<varName>%<scalarTokens[0]>%<SLibGetCoderDataGroupPointerFromRTM(group, 1)>%<scalarTokens[1]>;
                    %else
                        %assign addrOp = varGroup.IsPointer ? "" : "&"
                        %<typeQualifier> %<varGroupType> *%<varName>%<scalarTokens[0]>%<addrOp>%<SLibCoderDataGroupInstance(group)>%<scalarTokens[1]>;
                    %endif
                %endif
            %endforeach
            %closefile coderDataGroupVar
            %if !ISEMPTY(coderDataGroupVar)
                %<FcnCacheModelRefLocalVars(thisSystem, "Registration", "", coderDataGroupVar)>
            %endif
        %endif

        %% Service port initialization
        %if SLibCacheAndRestoreServiceDWorkNeeded()
            %openfile servicePortVars
            %<SLibCacheServicePortDWork()>
            %closefile servicePortVars
            %if !ISEMPTY(servicePortVars)
                %<FcnCacheModelRefLocalVars(thisSystem, "Registration", "", servicePortVars)>
            %endif
        %endif

        %% Continuous States argument
        %assign val = FcnArgNeeded(ContStatesArgDef,currentTID,isPeriodicRateGrouping)
        %if (val && IsModelRefScalableBuild()) && !::CompiledModel.ModelRefSimpInterface
            %openfile localCStateVar
            %assign varGroupType = FcnSysVarGroupType(thisSystem,"ContStates")
            %<varGroupType> *localX%<scalarTokens[0]>(%<varGroupType> *) localX_%<scalarTokens[1]>;
            %closefile localCStateVar
            %<FcnCacheModelRefLocalVars(thisSystem, "Registration", "", localCStateVar)>
        %endif
        %% Continuous States Derivative argument
        %assign val = FcnArgNeeded(ContStatesDerivativeArgDef,currentTID,isPeriodicRateGrouping)
        %if (val && IsModelRefScalableBuild()) && !::CompiledModel.ModelRefSimpInterface
            %openfile localCStateVar
            %assign varGroupType = FcnSysVarGroupType(thisSystem,"ContStatesDerivative")
            %<varGroupType> *localXdot%<scalarTokens[0]>(%<varGroupType> *) localXdot_%<scalarTokens[1]>;
            %closefile localCStateVar
            %<FcnCacheModelRefLocalVars(thisSystem, "Registration", "", localCStateVar)>
        %endif
        %% Continuous States Disabled argument
        %assign val = FcnArgNeeded(ContStatesDisabledArgDef,currentTID,isPeriodicRateGrouping)
        %if (val && IsModelRefScalableBuild()) && !::CompiledModel.ModelRefSimpInterface
            %openfile localCStateVar
            %assign varGroupType = FcnSysVarGroupType(thisSystem,"ContStatesDisabled")
            %<varGroupType> *localXdis%<scalarTokens[0]>(%<varGroupType> *) localXdis_%<scalarTokens[1]>;
            %closefile localCStateVar
            %<FcnCacheModelRefLocalVars(thisSystem, "Registration", "", localCStateVar)>
        %endif
        %% Continuous States Absolute Rolerance argument
        %assign val = FcnArgNeeded(ContStatesAbsoluteToleranceArgDef,currentTID,isPeriodicRateGrouping)
        %if (val && IsModelRefScalableBuild()) && !::CompiledModel.ModelRefSimpInterface
            %openfile localCStateVar
            %assign varGroupType = FcnSysVarGroupType(thisSystem,"ContStatesAbsoluteTolerance")
            %<varGroupType> *localXAbsTol%<scalarTokens[0]>(%<varGroupType> *) localXAbsTol_%<scalarTokens[1]>;
            %closefile localCStateVar
            %<FcnCacheModelRefLocalVars(thisSystem, "Registration", "", localCStateVar)>
        %endif

        %% Continuous States Perturb Min argument
        %assign val = FcnArgNeeded(ContStatesPerturbMinArgDef,currentTID,isPeriodicRateGrouping)
        %if (val && IsModelRefScalableBuild()) && !::CompiledModel.ModelRefSimpInterface
            %openfile localCStateVar
            %assign varGroupType = FcnSysVarGroupType(thisSystem,"ContStatesPerturbMin")
            %<varGroupType> *localXPerturbMin%<scalarTokens[0]>(%<varGroupType> *) localXPerturbMin_%<scalarTokens[1]>;
            %closefile localCStateVar
            %<FcnCacheModelRefLocalVars(thisSystem, "Registration", "", localCStateVar)>
        %endif

        %% Continuous States Perturb Max argument
        %assign val = FcnArgNeeded(ContStatesPerturbMaxArgDef,currentTID,isPeriodicRateGrouping)
        %if (val && IsModelRefScalableBuild()) && !::CompiledModel.ModelRefSimpInterface
            %openfile localCStateVar
            %assign varGroupType = FcnSysVarGroupType(thisSystem,"ContStatesPerturbMax")
            %<varGroupType> *localXPerturbMax%<scalarTokens[0]>(%<varGroupType> *) localXPerturbMax_%<scalarTokens[1]>;
            %closefile localCStateVar
            %<FcnCacheModelRefLocalVars(thisSystem, "Registration", "", localCStateVar)>
        %endif

        %% Non Sampled Zero Crossing argument
        %assign val = FcnArgNeeded(ZCSVArgDef,currentTID,isPeriodicRateGrouping)
        %if (val && IsModelRefScalableBuild()) && !::CompiledModel.ModelRefSimpInterface
            %openfile localCStateVar
            %assign varGroupType = FcnSysVarGroupType(thisSystem,"ZCSV")
            %<varGroupType> *localZCSV%<scalarTokens[0]>(%<varGroupType> *) localZCSV_%<scalarTokens[1]>;
            %closefile localCStateVar
            %<FcnCacheModelRefLocalVars(thisSystem, "Registration", "", localCStateVar)>
        %endif
        %assign ::BlockFcn = "Unknown"
    %endwith %% System[sysIdx].Interface

%endfunction %%FcnCacheMRRegFcnLocalVars

%% Function: FcnCacheModelRefFcnLocalVars ==========================================================
%% Abstract:
%%   This function adds the needed local variables to the function body.
%%   e.g. "localB, localDW, localX ..."
%%   The additional local variables are needed if we are doing a model ref
%%   scalable build. e.g.
%%
%%      void mr_ModelName(const int32_T *rtu_0, int32_T *rty_0)
%%      {
%%           rtB_mr_myecdemo   *localB = &(mr_myecdemo_DW.rtb);
%%           rtDW_mr_myecdemo *localDW = &(mr_myecdemo_DW.rtdw);
%%           ....
%%
%function FcnCacheModelRefLocalVars(system, function, tid, localVars) void
    %assign cacheName = "MR" + function + "%<tid>" + "LocalVars"
    %if !LibIsSystemField(system, cacheName)
        %<LibAddToSystem(system, cacheName, localVars)>
    %else
        %<LibAddToSystemField(system, cacheName, localVars)>
    %endif
%endfunction

%% Function: SLibResetModelRefFcnLocalVars =========================================================
%% Abstract:
%%   This function resets the list of needed local variables for the function body.
%function SLibResetModelRefLocalVars(system, function, tid) void
    %assign cacheName = "MR" + function + "%<tid>" + "LocalVars"
    %if LibIsSystemField(system, cacheName)
        %<LibSetSystemField(system, cacheName, "")>
    %endif
%endfunction

%% Function: FcnDumpModelRefFcnLocalVars ===========================================================
%% Abstract:
%%   This function adds the needed local variables to the function body.
%%   e.g. "localB, localDW, localX ..."
%%   The additional local variables are needed if we are doing a model ref
%%   scalable build. e.g.
%%
%%      void mr_ModelName(const int32_T *rtu_0, int32_T *rty_0)
%%      {
%%           rtB_mr_myecdemo   *localB = &(mr_myecdemo_DW.rtb);
%%           rtDW_mr_myecdemo *localDW = &(mr_myecdemo_DW.rtdw);
%%           ....
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%%
%function FcnDumpMRLocalVars(system, function, tid) void

    %if !IsModelReferenceBaseSys(system)
        %return ""
    %endif

    %if ::GenerateClassInterface
        %return ""
    %endif

    %% For functions that don't use rate-grouping, make sure we clear out the TID
    %if !SLibSystemFcnIsRateGroupType(function)
        %assign tid = ""
    %endif

    %assign cacheName = "MR" + function + "%<tid>" + "LocalVars"
    %if LibIsSystemField(system, cacheName)
        %assign cacheVal = LibGetSystemField(system, cacheName)
        %if !WHITE_SPACE(cacheVal)
            %return cacheVal
        %endif
    %endif
    %return ""
%endfunction


%% Function: SLibModelReferenceAppendInputsOutputs =================================================
%% Abstract:
%%   Used for the model reference SIM target to define the arguments to
%%   a function, or call that function from the S-Function.
%% TopTester: test/toolbox/simulink/blocks/tconcat.m
%% TopTester: test/toolbox/simulink/variants/var-bus-general/tVariantBusGecks.m
%%
%function SLibModelReferenceAppendInputsOutputs(blockFcn, ...
    fcnName, isPeriodicRateGrouping, currentTID, recArgs) void
    %assign origBlockFcn = ::BlockFcn
    %assign ::BlockFcn = blockFcn
    %assign baseSystem = ::CompiledModel.System[GetBaseSystemIdx()]
    %assign modIdx = baseSystem.CGIRModuleIdx
    %assign thisModule = ::CompiledModel.RTWCGModules.RTWCGModule[modIdx]

    %with baseSystem.Interface
        %%
        %% The following TLC code is used to prune the CGIR function call
        %% arguments and transfer the CGIR argument tracking
        %% information to the legacy TLC tracking infrastructure.
        %%
        %assign skipCanInput = ...
            Vector(%<NumCanonicalInputArgDefs>) [0@%<NumCanonicalInputArgDefs>]
        %assign skipInputDims = ...
            Vector(%<NumCanonicalInputArgDefs>) [0@%<NumCanonicalInputArgDefs>]
        %assign skipCanOutput = ...
            Vector(%<NumCanonicalOutputArgDefs>) [0@%<NumCanonicalOutputArgDefs>]
        %assign skipOutputDims = ...
            Vector(%<NumCanonicalOutputArgDefs>) [0@%<NumCanonicalOutputArgDefs>]
        %assign skipCanDWork = ...
            Vector(%<NumCanonicalDWorkArgDefs>) [0@%<NumCanonicalDWorkArgDefs>]
        %assign skipCanParam = ...
            Vector(%<NumCanonicalPrmArgDefs>) [0@%<NumCanonicalPrmArgDefs>]

        %if !ISEMPTY(fcnName) && ISFIELD(thisModule, "SystemFunctions") && ...
            ISFIELD(thisModule.SystemFunctions, fcnName)
            %assign fcnIndex = GETFIELD(thisModule.SystemFunctions, fcnName)
            %assign thisFcn  = thisModule.Function[fcnIndex]
            %assign irParams = REGEXPREP( thisFcn.ProtoType, ...
                "^[^\(]*\(", "")
            %if !ISEMPTY(cgirParams) && !WHITE_SPACE(cgirParams)
                %assign recArgs = recArgs + irParams
            %endif
            %foreach argIdx=thisFcn.NumArgs
                %if thisFcn.ArgAccessed[argIdx] > 0
                    %assign idNum = SLibSafeIDNUM(thisFcn.ArgSource, argIdx)
                    %assign argSrc = idNum[0]
                    %assign argSrcIdx = idNum[1]
                    %switch argSrc
                      %case "I"
                        %assign skipCanInput[argSrcIdx] = 1
                        %break
                      %case "O"
                        %assign skipCanOutput[argSrcIdx] = 1
                        %break
                      %case "D"
                        %assert ISFIELD(thisFcn, "Association")
                        %assert SIZE(thisFcn.Association, 1) == thisFcn.NumArgs
                        %assign dimsIdNum = SLibSafeIDNUM(thisFcn.Association, argIdx)
                        %assign dimsSrc = dimsIdNum[0]
                        %assign dimsSrcIdx = dimsIdNum[1]
                        %assert "I" == dimsSrc || "O" == dimsSrc
                        %if "I" == dimsSrc
                            %assign skipInputDims[dimsSrcIdx] = 1
                        %else
                            %assign skipOutputDims[dimsSrcIdx] = 1
                        %endif
                        %assign skipCanDWork[argSrcIdx] = 1
                        %break
                      %case "P"
                        %assign skipCanParam[argSrcIdx] = 1
                        %break
                      %case "RTM"
                      %case "X"
                        %break
                      %default
                        %%START_ASSERT
                        %assign errTxt = "Unhandled argument type '%<argSrc>'."
                        %<LibBlockReportError([],errTxt)>
                        %break
                        %%END_ASSERT
                    %endswitch
                %endif
            %endforeach
        %endif

        %foreach argIdx = NumCanonicalInputArgDefs
            %if !skipCanInput[argIdx] && ...
                FcnArgNeeded(CanonicalInputArgDef[argIdx], currentTID,isPeriodicRateGrouping)
                %assign ci        = CanonicalInputArgDef[argIdx]
                %assign identi    = LibGetRecordIdentifier(ci)
                %assign dataType  = SLibGetRecordDataTypeName(ci, "")
                %assign optWidth  = LibOptionalVectorWidth(LibGetRecordWidth(ci))
                %assign optStar   = (LibGetRecordWidth(ci) == 1 && ...
                    !(IsModelReferenceRTWTarget() && !FcnPassCanonicalInputByPtr(ci))) ? " *" : " "
                %assign dataType  = "const %<dataType> "
                %if SLibGetCanIOIsVarDims(ci)
                    %assign   argDef  = dataType + identi + "[]"
                %else
                    %assign   argDef  = dataType + optStar + identi + optWidth
                %endif
                %assign recArgs   = recArgs + argDef
            %endif
            %if !skipInputDims[argIdx]
                %assign recArgs = ...
                    AppendModelReferenceRegFcnInputCanDimSizeDWArgs(argIdx, ...
                    currentTID, isPeriodicRateGrouping, recArgs)
            %endif
        %endforeach

        %foreach argIdx = NumCanonicalOutputArgDefs
            %if !skipCanOutput[argIdx] && ...
                FcnArgNeeded(CanonicalOutputArgDef[argIdx], currentTID,isPeriodicRateGrouping)
                %assign       co = CanonicalOutputArgDef[argIdx]
                %assign   identi = LibGetRecordIdentifier(co)
                %assign dataType = SLibGetRecordDataTypeName(co, "")
                %assign  optStar = LibGetRecordWidth(co) == 1 ? " *" : " "
                %assign optWidth = LibOptionalVectorWidth(LibGetRecordWidth(co))
                %if SLibGetCanIOIsVarDims(co)
                    %assign   argDef = dataType + " " + identi + "[]"
                %else
                    %assign   argDef = dataType + optStar + identi + optWidth
                %endif
                %assign recArgs  = recArgs + argDef
            %endif
            %if !skipOutputDims[argIdx]
                %assign recArgs = ...
                    AppendModelReferenceRegFcnOutputCanDimSizeDWArgs(argIdx, ...
                    currentTID, isPeriodicRateGrouping, recArgs)
            %endif
        %endforeach


        %foreach argIdx = NumCanonicalPrmArgDefs
            %if !skipCanParam[argIdx] && ...
                FcnArgNeeded(CanonicalPrmArgDef[argIdx], currentTID,isPeriodicRateGrouping)
                %assign       prm = CanonicalPrmArgDef[argIdx]
                %assign    identi = LibGetRecordIdentifier(prm)
                %assign  dataType = SLibGetRecordDataTypeName(prm, "")
                %assign     width = LibBlockParameterWidth(prm)
                %assign  optWidth = LibOptionalVectorWidth(width)
                %assign declAsPtr = prm.DeclareAsPointer == "yes"
                %assign  optConst = ((width > 1) || declAsPtr) ? "const " : ""
                %assign  dataType = "%<optConst>%<dataType> "
                %assign   optStar = declAsPtr ? " *" : " "
                %assign    argDef = dataType + optStar + identi + optWidth
                %assign   recArgs = recArgs + argDef
            %endif
        %endforeach

    %endwith

    %assign ::BlockFcn = origBlockFcn
    %return recArgs

%endfunction



%% Function: SLibModelReferenceRegFcnArgs ==========================================================
%% Abstract:
%%   Generate model fcn arg list.
%%
%% The following order should be maintianied for ref args. See GetFunctionStr()
%%           TID
%%           CanonicalInput
%%           CanonicalDWork for CanonicalInput
%%           CanonicalOutput
%%           CanonicalDWork for CanonicalOutput
%%           SimStruct
%%           rtModel
%%           BlockIO
%%           ConstBlockIO (?)
%%           DWork
%%           Prm (?)
%%           ContStates
%%           ContStatesDerivative
%%           ContStatesDisabled
%%           NonsampledZC
%%           ZCEvent
%%           MassMatrix
%%           NumCanonicalPrm
%%           CanDWork (?)
%%           C-API required arguments (optional)
%%             o sysRan        (mdlrefsim target required)
%%             o sysTID        (mdlrefsim target required)
%%             o MMI           (mdlrefsim required, rtwtarget if RTWCAPI==true)
%%             o block Path    (mdlrefsim required, rtwtarget if RTWCAPI==true)
%%             o child Idx     (mdlrefsim required, rtwtarget if RTWCAPI==true)
%%             o Cont State Idx(mdlrefsim required, rtwtarget if RTWCAPI==true)
%% TopTester: test/toolbox/simulink/blocks/tconcat.m
%% TopTester: test/toolbox/simulink/variants/var-general/tVariantGecks.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tvss_code_variants.m
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortReset3.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function SLibModelReferenceRegFcnArgs() void
    %assign uint32Type = LibGetDataTypeNameFromId(::CompiledModel.tSS_UINT32)
    %assign booleanType = LibGetDataTypeNameFromId(::CompiledModel.tSS_BOOLEAN)
    %assign charType = LibGetDataTypeNameFromId(::CompiledModel.tSS_CHAR)
    %assign intType = LibGetDataTypeNameFromId(::CompiledModel.tSS_INTEGER)
    %assign realType = LibGetDataTypeNameFromId(::CompiledModel.tSS_DOUBLE)
    %assign recArgs = []
    %assign rootSystem        = System[NumSystems-1]
    %assign baseSystem        = System[NumSystems-2]
    %assign isPeriodicRateGrouping    = SLibIsMultiRateAndPeriodicRateGrouping(rootSystem)

    %assert IsModelReferenceTarget()

    %assign ::BlockFcn = "Registration"

    %if !IsModelReferenceForASimstructBasedTarget()
        %% ModelInitializeIsEmpty is computed in ertreg.tlc
        %% Why do we need this?  Who calls it with 0?

        %if !SuppressErrorStatus
            %assign recArgs = recArgs + "const %<LibGetDataTypeNameFromId(::CompiledModel.tSS_CHAR)> **rt_errorStatus"
        %endif

        %if RTMStopReqAccessed() || ::CompiledModel.ModelBlocksUseStopReq
            %assign recArgs = recArgs + "%<LibGetDataTypeNameFromId(::CompiledModel.tSS_BOOLEAN)> *rt_stopRequested"
        %endif

        %if LibIsContinuous(0) || SLibModelHierarchyContainsNoninlinedSfcn()
            %assign recArgs = recArgs + "RTWSolverInfo *rt_solverInfo"
        %endif

        %if SLibModelHierarchyContainsNoninlinedSfcn()
            %assign recArgs = recArgs + "RTWSfcnInfo *rt_sfcnInfo"
        %endif

    %endif

    %% Add the canonical inputs/outputs to the interface
    %assign recArgs = SLibModelReferenceAppendInputsOutputs(...
        "Registration", "", isPeriodicRateGrouping, rootSystem.CurrentTID, recArgs)

    %if IsModelReferenceForASimstructBasedTarget()
        %assign recArgs = recArgs + "%<tMdlRefSfcnSType> %<tMdlRefSfcnS>"

        %if HasNonContSigFeedingOutport()
            %assign recArgs = recArgs + "ssNonContDerivSigFeedingOutports **mr_nonContOutputArray"
        %endif
    %endif %% !IsModelReferenceForASimstructBasedTarget()

    %% Add information to generate the correct model block's
    %% initialize function signature

    %% add pointer to GlobalTimerIndices
    %if ::CompiledModel.NeedsGlobalTimerIndices == "yes"
        %assign recArgs = recArgs + "const %<uint32Type> *globalTimerIndices"
    %endif

    %% add pointer to GlobalRuntimeEventIndices
    %if ::CompiledModel.NeedsGlobalRuntimeEventIndices == "yes"
        %assign recArgs = recArgs + "const %<uint32Type> *globalRuntimeEventIndices"
    %endif

    %if ISFIELD(::CompiledModel, "NumDataTransfers") && ::CompiledModel.NumDataTransfers > 0
        %assign recArgs = recArgs + "const %<uint32Type> *gblDataTransferIds"
    %endif

    %% Pass the timing info to the registration function, we only
    %% do this for non simstruct based targets.
    %if !IsModelReferenceForASimstructBasedTarget() && ...
        ::tMdlRefTimingBridgeAccessed
        %assert SLibIsERTCodeFormat()
        %assign recArgs = recArgs + "const rtTimingBridge *timingBridge"
    %endif

    %if !IsModelReferenceForASimstructBasedTarget() && ...
        SLibModelHasControllableRate()
        %assert SLibIsERTCodeFormat()
        %assign recArgs = recArgs + "rtCtrlRateMdlRefTiming *CtrlRateMdlRefTimingPtr"
    %endif

    %% Only loop over the sample times if the model reference
    %% block will not become constant/triggered.
    %if ::tMdlRefNeedTIDArgs
        %if !MdlRefIsConstSampleBlock() || MdlRefHasParameterRate()
            %foreach idx = SLibGetNumTIDsForGlobalTIDMap()
                %% skip service task tid which is
                %% used for service infrastructure only
                %if SLibIsServiceTaskTID(idx) || SLibSimEventTID(idx)
                    %continue
                %endif

                %% We do not access union rate without task TIDs in referenced models.
                %if SLibIsUnionSampleTimeTIDWithoutTask(idx)
                    %continue
                %endif

                %assign recArgs = recArgs + "%<intType> mdlref_TID%<idx>"
            %endforeach
        %else
            %assign recArgs = recArgs + "%<intType> mdlref_TID0"
        %endif

        %if SLibModelNeedsTriggerTIDArg()
            %assign recArgs = recArgs + "%<intType> mdlref_TriggerTID"
        %endif
    %endif
    %assign selfAccess = ::CompiledModel.ModelRefSimpInterface || SLibGetDoesSelfExist()
    %with baseSystem.Interface
        %if !IsModelRefScalableBuild()
            %if FcnArgNeeded(RTMArgDef,rootSystem.CurrentTID,isPeriodicRateGrouping) || selfAccess
                %assign rtmArg = SLibGetQualifiedRTMType() + " *const %<::tSimStruct>"
                %assign recArgs = recArgs + rtmArg
            %endif
            %if FcnArgNeeded(BlockIOArgDef,rootSystem.CurrentTID,isPeriodicRateGrouping) && !selfAccess
                %assign blockIOCallee = "localB"
                %assign blockIOType = FcnSysVarGroupType(System[NumSystems-2],"BlockIO")
                %assign recArgs = recArgs + "%<blockIOType> *%<blockIOCallee>"
            %endif
            %if FcnArgNeeded(DWorkArgDef,rootSystem.CurrentTID,isPeriodicRateGrouping) && !selfAccess
                %assign dworkCallee = "localDW"
                %assign dworkType = FcnSysVarGroupType(System[NumSystems-2],"DWork")
                %assign recArgs = recArgs + "%<dworkType> *%<dworkCallee>"
            %endif
        %endif %% scalable
        %if FcnArgNeeded(ContStatesArgDef,rootSystem.CurrentTID,isPeriodicRateGrouping)
            %assign contState = IsModelRefScalableBuild() ? ...
                "localX_" : "localX"
            %assign contStateType = IsModelRefScalableBuild() ? ...
                realType : FcnSysVarGroupType(System[NumSystems-2],"ContStates")
            %assign recArgs = recArgs + "%<contStateType> *%<contState>"
        %endif
        %if FcnArgNeeded(ContStatesDerivativeArgDef, ...
            rootSystem.CurrentTID,isPeriodicRateGrouping)
            %assign contDerivState = IsModelRefScalableBuild() ? ...
                "localdX_" :"localdX"
            %assign contDerivStateType = IsModelRefScalableBuild() ? ...
                realType : FcnSysVarGroupType(System[NumSystems-2],"ContStatesDerivative")
            %assign recArgs = recArgs + "%<contDerivStateType> *%<contDerivState>"
        %endif
        %if FcnArgNeeded(ContStatesDisabledArgDef, ...
            rootSystem.CurrentTID,isPeriodicRateGrouping)
            %assign contDisState = IsModelRefScalableBuild() ? ...
                "localXdis_" :"localXdis"
            %assign contDisStateType = IsModelRefScalableBuild() ? ...
                booleanType : FcnSysVarGroupType(System[NumSystems-2],"ContStatesDisabled")
            %assign recArgs = recArgs + "%<contDisStateType> *%<contDisState>"
        %endif
        %if FcnArgNeeded(ContStatesPerturbMinArgDef, ...
            rootSystem.CurrentTID,isPeriodicRateGrouping)
            %assign contPerturbMin = IsModelRefScalableBuild() ? ...
                "localXPerturbMin_" :"localXPerturbMin"
            %assign contPerturbMinType = IsModelRefScalableBuild() ? ...
                realType : FcnSysVarGroupType(System[NumSystems-2],"ContStatesPerturbMin")
            %assign recArgs = recArgs + "%<contPerturbMinType> *%<contPerturbMin>"
        %endif
        %if FcnArgNeeded(ContStatesPerturbMaxArgDef, ...
            rootSystem.CurrentTID,isPeriodicRateGrouping)
            %assign contPerturbMax = IsModelRefScalableBuild() ? ...
                "localXPerturbMax_" :"localXPerturbMax"
            %assign contPerturbMaxType = IsModelRefScalableBuild() ? ...
                realType : FcnSysVarGroupType(System[NumSystems-2],"ContStatesPerturbMax")
            %assign recArgs = recArgs + "%<contPerturbMaxType> *%<contPerturbMax>"
        %endif
        %if !IsModelRefScalableBuild()
            %if FcnArgNeeded(ZCEventArgDef,rootSystem.CurrentTID,isPeriodicRateGrouping)
                %assign prevZCCallee = "localZCE"
                %assign prevZCEvType = FcnSysVarGroupType(System[NumSystems-2],"ZCEvent")
                %assign recArgs = recArgs + "%<prevZCEvType> *%<prevZCCallee>"
            %endif
        %endif

        %% Mass Matrix is not exposed to the top model if a local solver is used
        %if (::CompiledModel.ModelIsLinearlyImplicit == "yes" && !RTMMdlRefHasLocalSolver())
            %assign prevMMCallee = "localMM"
            %assign prevMMType = realType
            %assign recArgs = recArgs + "%<prevMMType> *%<prevMMCallee>"
        %endif

        %% Add pointer to full ModelRefDW to args for local solver. Need to
        %% cache it on the local solver simstruct
        %if RTMNeedLocalSolverDWork()
            %assign mdlrefDWorkCallee = "localMdlRefDW"
            %% Note: Type from baseSystem.Interface.tsysMdlrefDWorkType
            %assign recArgs = recArgs + "%<tsysMdlrefDWorkType> *%<mdlrefDWorkCallee>"
        %endif

        %% Add local solver input and output compensation modes
        %if RTMMdlRefHasLocalSolver()
            %assign recArgs = recArgs + "%<intType> inputCompMode"
            %assign recArgs = recArgs + "%<intType> outputCompMode"
        %endif

    %endwith

    %%
    %% Pass in the initial context system and tid
    %%
    %if IsModelReferenceSimTarget()
        %assign recArgs = recArgs + "void *sysRanPtr"
        %assign recArgs = recArgs + "int contextTid"
    %endif

    %%
    %if (RTWCAPI == 1) && !GenerateClassInterface
        %assign recArgs = recArgs + "rtwCAPI_ModelMappingInfo *rt_ParentMMI"
        %assign recArgs = recArgs + "const %<charType> *rt_ChildPath"
        %assign recArgs = recArgs + "%<intType> rt_ChildMMIIdx"
        %assign recArgs = recArgs + "%<intType> rt_CSTATEIdx"
    %endif

    %assign ::BlockFcn = "Unknown"

    %if ISEMPTY(recArgs)
        %return "void"
    %endif

    %return SLibSerializeFcnArgs(recArgs)
%endfunction %%SLibModelReferenceRegFcnArgs


%% Function: FcnGetNoncontMangledName ==============================================================
%% Abstract:
%%  Get the mangled name for the array of noncontinuous signals.
%function FcnGetNoncontMangledName(name, systemIdx, blockIdx, instIdx) void
    %assign instance = instIdx < 0 ? 0 : instIdx
    %return "%<name>_%<systemIdx>_%<blockIdx>_%<instance>"
%endfunction

%% Function: FcnCheckForConstConsistency ===========================================================
%% Abstract:
%%    Check whether the model being called passes the signal as a non-const
%%    pointer, yet this signal is a const arg to this model's step function.
%%    block, argIdx, portIdx, and FPC all pertain to the submodel being called.
%% TopTester: test/toolbox/simulink/variants/var-normal-matlabvariable-support/tNormalMatlabVariable2.m
%%
%function FcnCheckForConstConsistency(sysIdx, block, argIdx, portIdx, FPC) void
    %% See if the signal is passed to the child model by pointer or reference,
    %% without a const qualifier; if not, exit.
    %if FPC.ArgSpecData[argIdx].Category != "Pointer" && ...
        FPC.ArgSpecData[argIdx].Category != "Reference"
        %return TLC_TRUE
    %endif
    %assign hasConstQualifier = TLC_FALSE
    %switch FPC.ArgSpecData[argIdx].Qualifier
      %case "none"
        %break
      %case "const"
      %case "const *"
      %case "const * const"
      %case "const &"
        %assign hasConstQualifier = TLC_TRUE
        %break
      %default
        %assign errTxt = "Unhandled qualifier"
        %<LibReportFatalError(errTxt)>
        %break
    %endswitch
    %if hasConstQualifier
        %return TLC_TRUE
    %endif

    %% If we get to this point, the child model passes the input by pointer or ref
    %% without a const qualifier.  Now see if the parent model or reusable
    %% subsystem declares the input with a const qualifier

    %assign portObj  = FcnGetInputPortRecord(portIdx)
    %% We only have to check element 0 because if the input to the mdlref block
    %% is discontiguous, we insert a hidden buffer, and then the signal can't be
    %% const.  We only can get const if the input arg is specified as const by FPC
    %% and passed directly into the mdlref block.
    %assign sigRecAndMapInfo = ...
        SLibGetSourceRecordAndMapInfo(portObj, 0, TLC_TRUE, TLC_TRUE)

    %% See if the signal is coming from the root inport in the parent model; if not,
    %% no worry: it is not const.
    %if sigRecAndMapInfo.mapSrc == "U"
        %if SLibFcnProtoCtrlActive() || ...
            GenerateClassInterface
            %assign sigRec = sigRecAndMapInfo.sigRec

            %% Trouble if the root input is passed as const
            %if FcnPassExternalInputAsConst(sigRec)
                %return TLC_FALSE
            %else
                %return TLC_TRUE
            %endif

            %% Just a "vanilla" root input; no problem.
        %else
            %return TLC_TRUE
        %endif

        %% If a canonical input
    %elseif sigRecAndMapInfo.mapSrc == "u"
        %assign sigRec = sigRecAndMapInfo.sigRec

        %% Default interface model reference build interface has const from IR

        %if SLibIsCPPModelRefStepVoidVoid()
            %return TLC_FALSE
        %endif

        %% Trouble if the canonical input is passed as const
        %if FcnPassCanonicalInputAsConst(sysIdx, sigRec)
            %return TLC_FALSE
        %else
            %return TLC_TRUE
        %endif
    %elseif sigRecAndMapInfo.mapSrc == "C"
        %%%% The source is a constant
        %return TLC_FALSE
    %else
        %return TLC_TRUE

    %endif

%endfunction

%function SLibAttachIRTEventArgs(block, args)
    %foreach tid = NumSampleTimes
        %if SLibInitResetTermEventTID(tid)
            %assign childTid = MapParentTID2ChildTID(block, tid)
            %if childTid != -1
                %assign args = args + STRING(tid)
            %endif
        %endif
    %endforeach
    %return args
%endfunction

%% TopTester: test/toolbox/simulink/variants/var-normal-matlabvariable-support/tNormalMatlabVariable2.m
%%
%function SLibAttachTimingArgsForCPPEncap(block, blockInterface, inArgs)
    %assert SLibIsCPPEncapMdlRefBuild() || ...
        (GenerateClassInterface && block.MdlRefIsCPPClassGenMode)
    %assign args = inArgs
    %if !IsModelReferenceForASimstructBasedTarget()
        %if blockInterface.NeedsGlobalTimingEngine
            %if IsModelReferenceTarget()
                %assign args = args + "%<SLibGetGlobalTimingBridge()>"
            %else
                %assign args = args + "&%<SLibGetGlobalTimingBridge()>"
            %endif
        %endif
    %endif

    %% If the block is completely constant, then just
    %% pass 0 as the TID.  If it is inherited, pass the
    %% TID that this instance is running at.  This will
    %% help with data logging.
    %if blockInterface.NeedsTIDArgs
        %assign ::tMdlRefNeedTIDArgs = TLC_TRUE
        %assign blockTid = block.TID
        %if TYPE(blockTid) == "Vector"
            %assign nonModelWideEventTids = []
            %assign numTids = SIZE(blockTid)[1]
            %foreach idx = numTids
                %if !SLibModelWideEventTID(blockTid[idx])
                    %assign nonModelWideEventTids = nonModelWideEventTids + blockTid[idx]
                %endif
            %endforeach
            %if SIZE(nonModelWideEventTids)[1] == 1
                %assign blockTid = nonModelWideEventTids[0]
            %endif
        %endif
        %if TYPE(blockTid) != "Identifier"
            %if LibAsynchronousTriggeredTID(blockTid)
                %% if it is in async fcn-call subsystem,
                %% pass -1
                %assign args = args + "-1"
            %else
                %% constant is handled in the loop
                %foreach idx = NumRuntimeExportedRates
                    %assign childTID = MapParentTID2ChildTID(block, idx)
                    %if childTID != -1
                        %if IsModelReferenceTarget()
                            %assign args = args + "%<FcnGetMdlRefGlobalTIDMap("")>[%<idx>]"
                        %else
                            %assign args = args + "%<idx>"
                        %endif
                    %endif
                %endforeach
                %% Add parameter rate if used by model block, since that rate is not
                %% represented in the ChildTidToParentTidMap
                %if blockInterface.HasInternalParameterRate || ...
                    blockInterface.HasParameterRateOutput
                    %assign args = args + STRING(SLibTidOfParameterChangeEvent())
                %endif

                %% Add irt event rate if used by model block
                %assign args = SLibAttachIRTEventArgs(block, args)
            %endif
        %else
            %% There is only one TID in the model and it
            %% is constant/triggered, pass 0 if it is constant
            %% and pass -1 if it is triggered.
            %if ISEQUAL(blockTid, "triggered")
                %assign args = args + "-1"
            %else
                %assign args = args + "0"
            %endif
        %endif

        %if GetModelRefFcnCallTriggerTIDIsReq(block)
            %if SLibModelNeedsTriggerTIDArg()
                %assign args = args + "%<FcnGetMdlRefTriggerTIDMap("")>"
            %else
                %assert ISEQUAL(blockTid, "triggered") || ...
                    LibAsynchronousTriggeredTID(blockTid)
                %if LibAsynchronousTriggeredTID(blockTid)
                    %assign args = args + "%<blockTid>"
                %else
                    %assign trigTid = block.TriggerTID[0]
                    %if IsModelReferenceTarget()
                        %assign args = args + "%<FcnGetMdlRefGlobalTIDMap("")>[%<trigTid>]"
                    %else
                        %assign args = args + "%<trigTid>"
                    %endif
                %endif
            %endif
        %endif
    %endif
    %return args
%endfunction %%SLibAttachTimingArgsForCPPEncap

%% Function: SLibGetModelBlockInput ================================================================
%% Abstract:
%%   Return the input for a model reference block and port index
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants3.m
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortReset3.m
%%
%function SLibGetModelBlockInput(sysIdx, block, sysFcnName, mdlRefIdx, portIdx, ...
    canInputInfo, FPC, argIdx) void
    %assign arg = []
    %if sysFcnName == "RegistrationFcn"
        %assign baseSystem = ::CompiledModel.System[GetBaseSystemIdx()]
        %assign thisModelBlock = ::CompiledModel.ModelBlock[mdlRefIdx]
        %assign dataPort = thisModelBlock.DataInputPort[portIdx]
        %assign id = IDNUM(dataPort.SignalSrc[0])
        %switch id[0]
          %case "y"
            %assign canOut = baseSystem.Interface.CanonicalOutputArgDef[id[1]]
            %assign arg = LibGetRecordIdentifier(canOut)
            %<SLibAccessArgHelper(canOut,"","")>
            %if ISFIELD(dataPort, "BusSelElIdx")
                %assign arg = "(*%<arg>)%<dataPort.BusSelElIdx[0]>"
                %if dataPort.SignalOffset[0] == 0
                    %assign arg = "&%<arg>"
                %endif
            %endif
            %if dataPort.SignalOffset[0] != 0
                %assign arg = "&(%<arg>[%<dataPort.SignalOffset[0]>])"
            %endif
            %break
          %case "u"
            %assign canIn = baseSystem.Interface.CanonicalInputArgDef[id[1]]
            %assign arg = LibGetRecordIdentifier(canIn)
            %<SLibAccessArgHelper(canIn,"","")>
            %if ISFIELD(dataPort, "BusSelElIdx")
                %assign arg = "(*%<arg>)%<dataPort.BusSelElIdx[0]>"
                %if dataPort.SignalOffset[0] == 0
                    %assign arg = "&%<arg>"
                %endif
            %endif
            %if dataPort.SignalOffset[0] != 0
                %assign arg = "&(%<arg>[%<dataPort.SignalOffset[0]>])"
            %endif
            %break
          %default
            %with thisModelBlock
                %assign arg = LibBlockInputSignalAddr(portIdx, "", "", 0)
                %break
            %endwith
        %endswitch
    %else
        %assign isMatrix = LibBlockInputSignalIsMatrix(portIdx)
        %if isMatrix || (canInputInfo[portIdx] == 2) ||  ...
            (!IsFPCIgnored(FPC) && ...
            (FPC.ArgSpecData[argIdx].Category == "Pointer" || ...
            FPC.ArgSpecData[argIdx].Category == "Reference"))
            %assign calleePassByRef = !IsFPCIgnored(FPC) && FPC.ArgSpecData[argIdx].Category == "Reference"
            %assign isCoderArrayType = LibBlockInputSignalDataTypeIsCoderArray(portIdx)
            %if calleePassByRef || isCoderArrayType
                %% To avoid code like *(&arr[0]). arr[0] is more desirable
                %assign arg = LibBlockInputSignal(portIdx, "", "", 0)
            %else
                %assign arg = LibBlockInputSignalAddr(portIdx, "", "", 0)
            %endif

            %assign dtypeName = LibBlockInputSignalDataTypeName(portIdx, "")

            %if calleePassByRef
                %% pass by reference (C++) case
                %if isMatrix
                    %assign symbWidth = LibBlockInputSignalSymbolicWidth(portIdx)
                    %assign arg = "(" + dtypeName + "(&)" + "[" + symbWidth + "])" + arg
                %endif
            %endif

            %if !IsFPCIgnored(FPC) && ...
                !FcnCheckForConstConsistency(sysIdx, block, argIdx, portIdx, FPC)
                %assign refModelName = block.ParamSettings.ReferencedModelName

                %assign argName = FPC.ArgSpecData[argIdx].ArgName
                %assign msgArgs = ["%<refModelName>", "%<block.Name>", "%<argName>", "%<argName>"]

                %if SLibIsCPPModelRefStepVoidVoid()
                    %<SLibReportErrorWithIdAndArgs(...
                        "Simulink:modelReference:DefaultInterfaceConstInconsistency", ...
                        msgArgs)>
                %endif

                %if ::GenCPP
                    %if !IsFPCIgnored(FPC) && FPC.ArgSpecData[argIdx].Category == "Reference"
                        %if !isMatrix
                            %%%% scalar signal
                            %assign arg = "const_cast<" + dtypeName + "&>(" + arg + ")"
                        %endif
                    %else
                        %assign arg = "const_cast<" + dtypeName + "*>(" + arg + ")"
                    %endif
                %else
                    %assign arg = "(" + dtypeName + "*)" + arg
                %endif

                %if !block.MdlRefIsCPPClassGenMode
                    %<SLibReportWarningWithIdAndArgs(...
                        "Simulink:modelReference:WarnAboutConstCastPrototypeFeature", ...
                        msgArgs)>
                %else
                    %<SLibReportWarningWithIdAndArgs(...
                        "Simulink:modelReference:WarnAboutConstCastIOArgFeature", ...
                        msgArgs)>
                %endif
            %endif
        %else
            %assign arg = LibBlockInputSignal(portIdx, "", "", 0)
        %endif
    %endif
    %return arg
%endfunction %% SLibGetModelBlockInput

%% Function: SLibGetModelBlockOutput ===============================================================
%% Abstract:
%%   Return the output for a model reference block and port index
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/rtw/targets/ert/dynamicarrays/tReusableAtomicSubSS.m
%%
%function SLibGetModelBlockOutput(sysFcnName, mdlRefIdx, portIdx, FPC, argIdx) void
    %assign isCoderArray = LibBlockOutputSignalDataTypeIsCoderArray(portIdx)
    %assign passByPtr = ...
        (IsFPCIgnored(FPC) || FPC.ArgSpecData[argIdx].Category == "Pointer") && !isCoderArray
    %assign passByRef = ...
        (!IsFPCIgnored(FPC) && FPC.ArgSpecData[argIdx].Category == "Reference") || isCoderArray

    %assign arg = []
    %if sysFcnName == "RegistrationFcn"
        %assign baseSystemIdx  = GetBaseSystemIdx()
        %assign baseSystem     = ::CompiledModel.System[baseSystemIdx]
        %assign thisModelBlock = ::CompiledModel.ModelBlock[mdlRefIdx]
        %assign dataPort       = thisModelBlock.DataOutputPort[portIdx]
        %assign id = IDNUM(dataPort.SignalSrc[0])
        %switch (id[0])
          %case "y"
            %assign canOut = baseSystem.Interface.CanonicalOutputArgDef[id[1]]
            %assign arg = LibGetRecordIdentifier(canOut)
            %<SLibAccessArgHelper(canOut,"","")>
            %assert !ISFIELD(dataPort, "BusSelElIdx")
            %if dataPort.SignalOffset[0] != 0
                %% must be passed as pointer arg to parent
                %assert canOut.PassByReturn == "no"
                %% if child takes as pointer
                %if passByPtr
                    %assign arg = "&%<arg>[%<dataPort.SignalOffset[0]>]"
                    %% if child passes as return
                %else
                    %assign arg = "%<arg>[%<dataPort.SignalOffset[0]>]"
                %endif
            %endif
            %% if passed by return from parent
            %if canOut.PassByReturn == "yes"
                %% if child takes as pointer
                %if passByPtr
                    %assign arg = "&(%<arg>)"
                    %% if child passes as retur
                %else
                    %% do nothing
                %endif
                %% else passed to parent as arg
            %else
                %% if child takes as pointer
                %if passByPtr
                    %% do nothing
                    %% if child passes as return
                %else
                    %assign arg = "*%<arg>"
                %endif
            %endif
            %break
          %case "b"
            %assign bo = ::CompiledModel.BlockOutputs.GlobalBlockOutput[id[1]]
            %%
            %assign cross = System[bo.SigSrc[0]].CrossNoArgFcnBound
            %assign name  = SLibCG_GetVarGroupElementPath(bo.VarGroupIdx, ...
                baseSystemIdx, cross)
            %assign opW   = SLibGet1DArrayIndexer(LibGetRecordSymbolicWidth(bo), "", "", dataPort.SignalOffset[0])
            %assign arg   = "%<name>%<opW>"
            %if passByPtr
                %assign arg = "&(%<arg>)"
            %endif
            %break
          %case "E"
            %if passByPtr
                %assign arg = LibBlockOutputSignalAddr(portIdx, "", "", 0)
            %else
                %assign arg = LibBlockOutputSignal(portIdx, "", "", 0)
            %endif
            %break
        %endswitch
    %else
        %if passByPtr
            %assign arg = LibBlockOutputSignalAddr(portIdx, "", "", 0)
        %elseif passByRef
            %% C++ pass by reference
            %assign arg = LibBlockOutputSignal(portIdx, "", "", 0)
            %if LibBlockOutputSignalIsMatrix(portIdx)
                %assign dtypeName = LibBlockOutputSignalDataTypeName(portIdx, "")
                %assign symbWidth = LibBlockOutputSignalSymbolicWidth(portIdx)
                %assign arg = "(" + dtypeName + "(&)" + "[" + symbWidth + "])"  +  arg
            %endif
        %endif
    %endif
    %assert !ISEMPTY(arg) || (!passByPtr && !passByRef)
    %return arg
%endfunction %% SLibGetModelBlockOutput

%% Function: LibBlockParamNonVolatilePtrCast =======================================================
%% Abstract:
%%   Get the cast that discards the volatility of a block parameter pointer.
%% TopTester: test/toolbox/simulink/variants/var-normal-matlabvariable-support/tNormalMatlabVariable2.m
%%
%function LibBlockParamNonVolatilePtrCast(param)
    %assign record = FcnBlockParameterIdxMemberStr(param)
    %assign paramIdx = record.param
    %assign cast = ""

    %% Only care volatile custom storage
    %if (paramIdx[0] != -1) && (!paramIdx[1])
        %assign mdlParam = ::CompiledModel.ModelParameters.Parameter[paramIdx[0]]
        %assign storageClass = mdlParam.StorageClass
        %if storageClass == "Custom"
            %assign msDefn = SLibGetMemorySectionDefForData(mdlParam)
            %assign dtypeId = LibGetRecordDataTypeId(mdlParam)
            %assign cmplx = LibGetRecordIsComplex(mdlParam)
            %assign cast = LibGetNonVolatileCmplxPointerCast(msDefn, dtypeId, cmplx, "")
        %endif
    %endif
    %return cast
%endfunction %%LibBlockParamNonVolatilePtrCast

%% Function: LibBlockParameterAddrForModelBlock ====================================================
%% Abstract:
%%   Get Block Parameter Addresss for Model Block
%% TopTester: test/toolbox/simulink/variants/var-normal-matlabvariable-support/tNormalMatlabVariable2.m
%%
%function LibBlockParameterAddrForModelBlock(param, blkPrmIdx)
    %assign prmSize = SLibGetSizeOfValueFromParamRec(param)
    %assign nRows   = prmSize[0]
    %assign nCols   = prmSize[1]
    %assign memberStr = ""

    %if nRows > 1
        %assign errTxt = "Number of rows greater than 1.  Must " ...
            "access parameter %<LibBlockParameterName(param)> using LibBlockMatrixParameterAddr."
        %<LibBlockReportError([], errTxt)>
    %endif

    %assign paramRef = SLibInvokeTLCInterface(SLibGetCurrentBlock(), ...
        "BlkParam", 0, blkPrmIdx, TLC_TRUE, "", "", 0, "")

    %assign cast = LibBlockParamNonVolatilePtrCast(param)

    %assign parsingEnabled = !ISEMPTY(paramRef)
    %if !parsingEnabled
        %return LibBlockParameterAddr(param, "", "", 0)
    %endif

    %return cast + paramRef
%endfunction

%% Function: LibBlockParameterForModelBlock
%% Abstract:
%%   Get block parameter for a model block with parameter index
%%   Note: this function is adapted from LibBlockParameter
%%
%function LibBlockParameterForModelBlock(param, blkPrmIdx)
    %% Determine the parameter's true size
    %assign prmSize = SLibGetSizeOfValueFromParamRec(param)
    %assign nRows   = prmSize[0]
    %assign nCols   = prmSize[1]
    %assign width   = nRows * nCols

    %if SLibGetTypeOfValueFromParamRec(param) == "Matrix"
        %% exit if the parameter is a true matrix,
        %% i.e., has more than one row or columns.
        %if nRows > 1
            %assign errTxt = "Must access parameter %<LibBlockParameterName(param)> using "...
                "LibBlockMatrixParameter."
            %<LibBlockReportError([], errTxt)>
        %endif
    %endif
    %with ::CompiledModel
        %assign accSysIdx = BlockIdx[0]
        %assign parentSys = System[accSysIdx]
        %if LibSystemIsRoot(parentSys)
            %assign callSite = [%<accSysIdx>, 0, %<accSysIdx>, %<BlockIdx[2]>]
        %else
            %assign callSite = parentSys.CallSites[0]
        %endif
    %endwith

    %assign str = SLibInvokeTLCInterface(SLibGetCurrentBlock(), ...
        "BlkParam", 0, blkPrmIdx, TLC_FALSE, "", "", "", "")

    %assign tlcIFv2Enabled = !ISEMPTY(str)

    %if tlcIFv2Enabled
        %return SLibProcessSafeExpression(Name, ...
            (NEEDS_PAREN(str) ? "(%<str>)" : str), 0)
    %else
        %return LibBlockParameter(param, "", "", 0)
    %endif
%endfunction

%% Function: SLibGetBaseTypeNameIfVariableSizeLUTParam =============================================
%% Abstract:
%%   Return the base name of a variable size LUT object type by stripping '$' and
%%   following checksum string. Return the original type name if the type is not a
%%   variable size LUT object type
%%
%function SLibGetBaseTypeNameIfVariableSizeLUTParam(aParamType)
    %assign p = CGMODEL_ACCESS("String.find", aParamType, "$")
    %if p >= 0
        %return CGMODEL_ACCESS("String.substr", aParamType, 0, p)
    %else
        %return aParamType
    %endif
%endfunction

%% Function: LibBlockParameterForMdlRef ============================================================
%% Abstract:
%%   Return the parameter for a model reference block and parameter index
%% TopTester: test/toolbox/simulink/variants/var-normal-matlabvariable-support/tNormalMatlabVariable2.m
%% TopTester: test/toolbox/simulink/blocks/tconcat.m
%%
%function SLibGetModelBlockParameter(aBlock, aPrmIdx, aArgInfo, ...
    argType, isPointer) void
    %assign blkParam = aBlock.Parameter[aPrmIdx]
    %if isPointer
        %assign cast = ""
        %assign blkParamType = ...
            LibGetDataTypeNameFromId(LibGetRecordContainerDataTypeId(blkParam))

        %assign argType = SLibGetBaseTypeNameIfVariableSizeLUTParam(argType)
        %assign blkParamType = SLibGetBaseTypeNameIfVariableSizeLUTParam(blkParamType)
        %if argType != blkParamType
            %assign cast = "(" + argType + "*)"
        %endif
        %return cast + LibBlockParameterAddrForModelBlock(blkParam, aPrmIdx)
    %elseif aArgInfo == 1
        %return LibBlockParameterForModelBlock(blkParam, aPrmIdx)
    %else
        %return LibBlockParameterAddrForModelBlock(blkParam, aPrmIdx)
    %endif
%endfunction

%% Function: SLibGetModelBlockVarGroupPath =========================================================
%% Abstract:
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function SLibGetModelBlockVarGroupPath(aBaseSystemIdx, aBlock, aInstanceIdx) void
    %assign thisSystem = ::CompiledModel.System[aBlock.BlockIdx[0]]
    %assign category = FcnGetModelBlockDWorkCategory(aBlock)
    %if category == "Self"
        %assign thisSystem = ::CompiledModel.System[baseSystemIdx]
        %assign varGroupIdx = thisSystem.SelfVarGroupIndex
    %else
        %assign varGroupIdx = FcnSysVarGroupIndex(thisSystem, category, aInstanceIdx)
    %endif

    %assign cross = thisSystem.CrossNoArgFcnBound
    %assign varGroupPath = SLibCGIRVarGroupPath(varGroupIdx, aBaseSystemIdx, cross)
    %return varGroupPath
%endfunction %% SLibGetModelBlockVarGroupPath

%% Function: SLibGetModelBlockVarGroupRoot( =====================================
%% Abstract:
%%
%function SLibGetModelBlockVarGroupRoot(aBlock) void
    %assign thisSystem = ::CompiledModel.System[GetBaseSystemIdx()]
    %assign category = FcnGetModelBlockDWorkCategory(aBlock)
    %if category == "Self"
        %assign thisSystem = ::CompiledModel.System[baseSystemIdx]
        %assign varGroupIdx = thisSystem.SelfVarGroupIndex
    %else
        %assign varGroupIdx = FcnSysVarGroupIndex(thisSystem, category, 0)
    %endif

    %assign cross = thisSystem.CrossNoArgFcnBound
    %assign varGroupPath = SLibCGIRVarGroupPath(varGroupIdx, GetBaseSystemIdx(), cross)
    %return varGroupPath
%endfunction %% SLibGetModelBlockVarGroupPath


%function SLibGetSelfVarGroupIndexForModelBlock(aBlock, aInstanceIndex) void
    %assign thisSystem = ::CompiledModel.System[aBlock.BlockIdx[0]]
    %assign selfVarGroupIdx = FcnSysVarGroupIndex(thisSystem, "CoderDataGroup_self", aInstanceIndex)
    %if selfVarGroupIdx < 0
        %assign selfVarGroupIdx = aBlock.ModelInstVarGroupIndex + aInstanceIndex
    %endif
    %assert selfVarGroupIdx > -1
    %return selfVarGroupIdx
%endfunction

%% Function: SLibGetModelBlockStructDWorkArg =======================================================
%% Abstract:
%%   Returns the dwork element of a model reference block, that contains
%%   its structured elements.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function SLibGetModelBlockStructDWorkArg (...
    aDWorkEl, aBaseSystemIdx, aBlock, aSysFcnType, aInstanceIdx) void
    %if !ISEMPTY(aDWorkEl)
        %return aDWorkEl
    %endif
    %assign blockInterface = GetModelrefInterface(aBlock)
    %assign isInstSpecific = (ISFIELD(aBlock, "ModelInstVarIndex") &&  aBlock.ModelInstVarIndex > -1)
    %assign rtmContainedInSelf = isInstSpecific || ...
        (blockInterface.rtmAllocateInParent)
    %assign baseSys = ::CompiledModel.System[GetBaseSystemIdx()]
    %if (::CompiledModel.RTWCGModules.RTWCGModule[baseSys.CGIRModuleIdx].SimplifiedInterface && ...
        blockInterface.usesSimplifiedInterface) || (GenerateClassInterface && SLibGetUseRTMcgType())
        %assign globalAccess = (aSysFcnType == "RegistrationFcn")
        %assign rtmField = SLibGetModelInstVariableAddressForSimplifiedInterface(aBlock,aInstanceIdx,globalAccess)
        %if !WHITE_SPACE(rtmField)
            %return "(*" + rtmField + ")"
        %endif
    %endif
    %if rtmContainedInSelf && SLibGetSelfVarGroupIndex() > -1 && isInstSpecific
        %if aInstanceIdx > 1
            %assign selfVarGroupIdx = SLibGetSelfVarGroupIndexForModelBlock(aBlock, aInstanceIdx)
        %else
            %assign selfVarGroupIdx = SLibGetSelfVarGroupIndex()
        %endif
        %assign selfCGTypeIdx = ::CompiledModel.VarGroups.VarGroup[selfVarGroupIdx].CGTypeIdx
        %if selfCGTypeIdx < 0
            %assign group = ::CompiledModel.CoderDataGroup[SLibGetSelfCoderDataGroupIndex()]
            %return SLibCoderDataGroupElementInstance(group, aBlock.ModelInstVarIndex)
        %endif
        %if LibCGTypeIsMatrix(selfCGTypeIdx)
            %assign selfCGTypeIdx = LibCGTypeBaseIndex(selfCGTypeIdx)
        %endif
        %assign fldName = LibCGTypeMemberName(selfCGTypeIdx, aBlock.ModelInstVarIndex)
        %if selfVarGroupIdx != SLibGetSelfVarGroupIndex()
            %% here we are not at the root level
            %return ::CompiledModel.VarGroups.VarGroup[selfVarGroupIdx].LocalName + "->" + fldName
        %elseif IsModelReferenceTarget() && IsModelRefScalableBuild()
            %% here we are in a single instance model that contains multi instance child models
            %assign modelDW = FcnGetSFcnDWorkIdentifier(::CompiledModel.System[baseSystemIdx])
            %assign slfAccess = IsModelReferenceSimTarget() ? ".rtm." : "."
            %return modelDW + slfAccess + fldName
        %else
            %if SLibIsSelfStructured()
                %<SLibCG_AccessRTM()>
            %endif
            %assign modelRTM = ::tSimStruct
            %return modelRTM + "->" + fldName
        %endif
    %elseif blockInterface.rtmAllocateInParent && !SLibIsSelfInSimTarget()
        %return aBlock.Identifier
    %endif
    %assign dworkIdx = SLibGetStructDWorkIdxForModelRefBlk(aBlock)

    %if "RegistrationFcn" == aSysFcnType
        %assign varGroupPath = ...
            SLibGetModelBlockVarGroupPath(aBaseSystemIdx, aBlock, aInstanceIdx)
        %assign dwRec = ...
            ::CompiledModel.DWorks.DWork[aBlock.DWork[dworkIdx].FirstRootIdx]
        %return varGroupPath + LibGetRecordIdentifier(dwRec)
    %endif

    %return LibBlockDWork(aBlock.DWork[dworkIdx], "","","0")
%endfunction

%% FunctionSLibModelBlockContinuousStateAddr ====================================
%% Abstract:
%%   Return the base address of the continues states argument of a model block.
%% TopTester: test/toolbox/simulink/blocks/tconcat.m
%%
%function SLibModelBlockContinuousStateAddr(aBaseSystemIdx, aModelSystemIdx, ...
    aBlock, aSysFcnType, aInstanceIdx) void
    %assign cs = ::CompiledModel.ContStates.ContState[aBlock.ContStates[1]]

    %if "RegistrationFcn" == aSysFcnType
        %assign thisSystem = ::CompiledModel.System[aBlock.BlockIdx[0]]
        %% State does not live in the ContStates VarGroup if controlled by local solver.
        %% In that case it lives in coder data group generated var group.
        %% Get VarGroupIdx directly form CState record. See rtwgen_contstates.cpp
        %% for explanation of ContStates.VarGroupIdx elements. This is how it is done
        %% in other functions such as SLibContinuousStateAddr, so should work.

        %% tmcphers: would like to use cs.VarGroupIdx[0] rather than FcnSysVarGroupIdx()
        %% here to cleanly support local solver, but in some cases the aBlock is the first
        %% instance rather than the actual model ref block we are interested in. So cannot
        %% rely on cs to be the actual cont state. It leads to varGroupPath (which should
        %% contain the instance name) always being the first instance.
        %% See rtwgen_mdlref.cpp --> GetRTWBlockIndex
        %% Since local solver does not change per-instance, we can trust the result of
        %% SLibIsCStateControlledByLocalSolver
        %if SLibIsCStateControlledByLocalSolver(cs, aModelSystemIdx)
            %% Locally controlled states are in CoderDataGroup_XLoc, not ContStatesVarGroup
            %assign varGroupIdx = FcnSysVarGroupIndex(thisSystem, "CoderDataGroup_XLoc", ...
                aInstanceIdx)
        %else
            %assign varGroupIdx = FcnSysVarGroupIndex(thisSystem, "ContStates", ...
                aInstanceIdx)
        %endif
        %assign  cross = thisSystem.CrossNoArgFcnBound
        %assign sysIdx =  LibIsDeploymentDiagram() ? aModelSystemIdx : aBaseSystemIdx
        %assign varGroupPath = SLibCGIRVarGroupPath(varGroupIdx, sysIdx, cross)
        %assign intrf    = GetModelrefInterface(aBlock)
        %assign optWidth = (intrf.xOptWidth > 1) ? "[0]" : ""
        %return "&(" + varGroupPath + cs.Identifier + optWidth + ")"
    %endif

    %return SLibContinuousStateAddr(cs, aModelSystemIdx)
%endfunction %% SLibModelBlockContinuousStateAddr

%% Function: SLibGetMdlRefArgumentForTID
%% Abstract:
%%    For the given TID, get the argument to be passed into the call to
%%    a referenced model function
%% TopTester: test/toolbox/simulink/variants/var-general/tStringSupport.m
%%
%function SLibGetMdlRefArgumentForTID(idx)
    %if IsModelReferenceTarget()
        %% if the idx is constant tid, return it. see g1339414
        %if idx == -2
            %assign arg = "%<idx>"
        %else
            %assign arg = "mdlref_TID%<idx>"
        %endif
    %elseif IsSimstructBasedTarget() && LibAsynchronousTriggeredTID(idx)
        %assign arg = "0"
    %else
        %assign arg ="%<idx>"
    %endif

    %return arg
%endfunction

%% Function: SLibGetPathToSimplifiedInterfaceModelBlock
%% Abstract:
%%   When using simplified interface, get the path to model block
%%   e.g. RTM->subsysSelf->
%%
%function SLibGetPathToSimplifiedInterfaceModelBlock(mdlBlk, instIdx)
    %assert mdlBlk.Type == "ModelReference" && SLibGetSelfVarGroupIndex() >= 0
    %assign selfVarGroupIdx = SLibGetSelfVarGroupIndexForModelBlock(mdlBlk, instIdx)
    %assign selfPath = SLibCGIRVarGroupPath(selfVarGroupIdx, GetBaseSystemIdx(), TLC_FALSE)
    %return selfPath
%endfunction

%% Function: SLibGetPathToModelBlockSelf
%% Abstract:
%%   When using pluggable interface, get the path to model block rtm
%%
%function SLibGetPathToModelBlockSelf(mdlBlk)
    %assert mdlBlk.Type == "ModelReference" && SLibGetSelfVarGroupIndex() >= 0
    %assign selfVarGroupIdx = SLibGetSelfVarGroupIndexForModelBlock(mdlBlk, 0) %% Ok to use the first instance of model block
    %assign rtmRecIdx = mdlBlk.ModelInstVarIndex
    %return FcnSLibCGIRGetVarGroupMemberName(selfVarGroupIdx, rtmRecIdx)
%endfunction

%% Function: SLibGetModelInstVariableAddressForSimplifiedInterface
%% Abstract:
%%   For ModelReference simplified interface, given a Model block
%%   return the pointer to the corresponding model variable access path
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function SLibGetModelInstVariableAddressForSimplifiedInterface(mBlock,aInstanceIdx,globalAccess) void
    %assert mBlock.Type == "ModelReference"
    %assign containedInVargroup = ISFIELD(mBlock, "ModelInstVarGroupIndex") && mBlock.ModelInstVarGroupIndex > -1 && ...
        !(GenerateClassInterface && mBlock.ModelInstVarGroupIndex == SLibGetSelfVarGroupIndex())

    %% Look for global self instance first
    %if SLibPassGlobalInstanceForBlocksSelf(mBlock) && !containedInVargroup
        %return SLibGetGlobalInstanceNameForBlocksSelf(mBlock)
    %endif

    %assign path = ""

    %% See if we can find a path via pointer in Self
    %if SLibIsBlockInstanceAccessedViaPointerInSelf(mBlock)
        %% An example of path here is "self->anotherGroup->inst1"
        %assign path = "(&" + SLibGetPathToInstanceFromSelf(mBlock) + ")"
    %endif

    %if !ISEMPTY(path)
        %return path
    %elseif ISFIELD(mBlock, "ModelInstVarIndex")
        %assign isClassField = (GenerateClassInterface && mBlock.ModelInstVarGroupIndex == SLibGetSelfVarGroupIndex())
        %assign rtmRecIndex = mBlock.ModelInstVarIndex
        %if isClassField && rtmRecIndex > -1
            %return "&" + mBlock.Identifier
        %elseif rtmRecIndex > -1
            %if mBlock.ModelInstVarGroupIndex == SLibGetSelfVarGroupIndex()
                %<SLibCG_AccessRTM()>
                %assign selfPath = getRTMFieldPointerFromCGType("STANDALONE",rtmRecIndex)
                %return "(" + selfPath  + ")"
            %else
                %assign selfVarGroupIdx = SLibGetSelfVarGroupIndexForModelBlock(mBlock, aInstanceIdx)
                %assign selfCGTypeIdx = ::CompiledModel.VarGroups.VarGroup[selfVarGroupIdx].CGTypeIdx
                %if LibCGTypeIsMatrix(selfCGTypeIdx)
                    %assign selfCGTypeIdx = LibCGTypeBaseIndex(selfCGTypeIdx)
                %endif
                %assign fldName = LibCGTypeMemberName(selfCGTypeIdx, mBlock.ModelInstVarIndex)
                %assign blkSystem = ::CompiledModel.System[mBlock.BlockIdx[0]]
                %with blkSystem
                    %assign graphParentSysIdx = CallSites[0][2]
                    %assign graphParentSys = ::CompiledModel.System[graphParentSysIdx]
                    %assign parentIsForEach = SLibGetSubsystemIsForEachSS(graphParentSys)
                %endwith
                %if globalAccess
                    %% we are accessing model instance via the topmost node of self
                    %assign vgPath = SLibCGIRVarGroupPath(selfVarGroupIdx,GetBaseSystemIdx(),TLC_TRUE)
                %elseif parentIsForEach
                    %assign forEachModuleIdx = graphParentSys.CGIRModuleIdx
                    %assign forEachModule = ::CompiledModel.RTWCGModules.RTWCGModule[forEachModuleIdx]
                    %assign isSameSys = (forEachModule.CGSystemIdx == graphParentSysIdx)
                    %assign isSimpInterf = isSameSys && forEachModule.SimplifiedInterface
                    %if isSimpInterf
                        %assign vgPath = SLibCGIRVarGroupPath(selfVarGroupIdx, graphParentSysIdx, graphParentSys.CrossNoArgFcnBound)
                    %else
                        %assign vgPath = SLibCGIRVarGroupPath(selfVarGroupIdx,GetBaseSystemIdx(),TLC_TRUE)
                    %endif
                %else
                    %assign vgPath = ::CompiledModel.VarGroups.VarGroup[selfVarGroupIdx].LocalName + "->"
                %endif
                %assign selfPath = "&" + vgPath + fldName
                %return "(" + selfPath  + ")"
            %endif
        %endif
    %endif

    %return ""
%endfunction

%function SLibGetMdlRefInstCPPVar(block, instIdx, mdlRefSysIdx)
    %assert GenerateClassInterface && block.MdlRefIsCPPClassGenMode
    %assign mdlRefInstCPPVar = ...
        SLibGetCPPMdlRefObjName(mdlRefSysIdx, block.BlockIdx[2])
    %assert(ISFIELD(block, "ParamSettings"))
    %assign subsysRegFcnForCPPClassModelRefBlock = block.MdlRefIsCPPClassGenMode && ...
        (!IsSystemReusableParentBaseSys(mdlRefSysIdx) || block.ParamSettings.InsideForEachSS) &&...
        (!IsModelRefScalableBuild() || GenerateClassInterface)

    %assign regFcn4MdlRefBlkCPPFromSubSys = subsysRegFcnForCPPClassModelRefBlock && ...
        ISFIELD(block,"CPPObjDWorkIdxInSubsys")

    %if regFcn4MdlRefBlkCPPFromSubSys
        %assign mdlRefInstCPPVar = ...
            SLibGetModelBlockVarGroupPath(baseSystemIdx, block, instIdx) ...
            + mdlRefInstCPPVar
    %elseif subsysRegFcnForCPPClassModelRefBlock && ...
        ISFIELD(block,"ModelInstVarGroupIndex") && ...
        block.ModelInstVarGroupIndex > -1
        %assign mdlRefInstCPPVar = ...
            SLibCGIRVarGroupPath(block.ModelInstVarGroupIndex,GetBaseSystemIdx(),TLC_FALSE) ...
            + mdlRefInstCPPVar
    %endif
    %return mdlRefInstCPPVar
%endfunction

%function SLibGetMdlRefCppEncapRTMInitCall(block, blockInterface, instIdx, mdlRefSysIdx)
    %assert GenerateClassInterface && IsModelReferenceRTWTarget() && ...
        block.MdlRefIsCPPClassGenMode && blockInterface.RTMAccessed

    %with block
        %assign mdlRefInstCPPVar = SLibGetMdlRefInstCPPVar(block, instIdx, mdlRefSysIdx)
        %assign dotOrArrow = SLibCPPDotOrArrowAccessOperator(block,blockInterface)
        %assign fcnArgs = SLibGetInitializeRTMFunctionArgs(block, blockInterface, instIdx, mdlRefSysIdx)
    %endwith

    %openfile modelRTMInitCallBuff
    %<mdlRefInstCPPVar>%<dotOrArrow>initializeRTM(%<fcnArgs>);
    %closefile modelRTMInitCallBuff

    %return modelRTMInitCallBuff
%endfunction

%function SLibGetModelBlockRegistrationFunctionForCppClassGen(block,blkPath,blockInterface,instIdx,childIdx,mdlRefSysIdx)
    %assert GenerateClassInterface && block.MdlRefIsCPPClassGenMode
    %assign mdlRefInstCPPVar = SLibGetMdlRefInstCPPVar(block, instIdx, mdlRefSysIdx)
    %assign subsysRegFcnForCPPClassModelRefBlock = block.MdlRefIsCPPClassGenMode && ...
        !IsSystemReusableParentBaseSys(BlockIdx[0]) &&...
        (!IsModelRefScalableBuild() || GenerateClassInterface)

    %assign regFcn4MdlRefBlkCPPFromSubSys = subsysRegFcnForCPPClassModelRefBlock && ...
        ISFIELD(block,"CPPObjDWorkIdxInSubsys")

    %assign dotOrArrow = SLibCPPDotOrArrowAccessOperator(block,blockInterface)
    %openfile tmp_file
    %%%% re-establish pointers for mdlref blocks in subsystems, if needed
    %if regFcn4MdlRefBlkCPPFromSubSys && ...
        CPPEncapNeedsLocalVars(TLC_FALSE) && ...
        !blockInterface.IsScalableBuild
        %assign restoreCode = SLibGetCPPEncapInitCopyCode(TLC_FALSE, TLC_FALSE)
        %<restoreCode>
    %endif

    %assign mdlRefInstAccessed = TLC_FALSE

    %%%% this must be called early on
    %if (blockInterface.RTMAccessed || blockInterface.NeedsGlobalTimingEngine) && ...
        (ISFIELD(blockInterface, "NeedsCPPInitRTM") && blockInterface.NeedsCPPInitRTM)
        %assign fcnArgs = SLibGetInitializeRTMFunctionArgs(block, blockInterface, instIdx, mdlRefSysIdx)
        %if !IsModelReferenceTarget()
            %openfile modelRTMInitCallBuff
            %assign fcnArgs = SLibGetInitializeRTMFunctionArgs(block, blockInterface, instIdx, mdlRefSysIdx)
            %<mdlRefInstCPPVar>%<dotOrArrow>initializeRTM(%<fcnArgs>);
            %closefile modelRTMInitCallBuff
            %<modelRTMInitCallBuff>
            %assign mdlRefInstAccessed = TLC_TRUE
        %endif
    %endif
    %if blockInterface.NeedsErrorStatus
        /* Set error status pointer for %<Type> Block: '%<Name>' */
        %<mdlRefInstCPPVar>%<dotOrArrow>setErrorStatusPointer(%<RTMsGet(System[GetBaseSystemIdx()],"ErrorStatusPointer")>);
        %assign mdlRefInstAccessed = TLC_TRUE
    %endif
    %% Setup the stop requested flag
    %if blockInterface.StopReqAccessed
        /* initialize stop requested flag */
        %<mdlRefInstCPPVar>%<dotOrArrow>setStopRequestPointer(%<RTMsGet(System[GetBaseSystemIdx()],"StopRequestedPtr")>);
        %assign mdlRefInstAccessed = TLC_TRUE
    %endif

    %if ISFIELD(blockInterface, "RegistrationFcn") && GenerateClassInterface
        %% Invoke C++ initialize before setting fields to non-zero values
        %<mdlRefInstCPPVar>%<dotOrArrow>initialize();
        %assign mdlRefInstAccessed = TLC_TRUE
    %endif

    %assert block.ContStates[0] <= 0

    %if ISFIELD(blockInterface, "RegFcnNeedsCAPIArgs") && ...
        blockInterface.RegFcnNeedsCAPIArgs

        %if RTWCAPI == 1 && !block.ParamSettings.InsideForEachSS
            %assign arg1 = "&(%<RTMGet("DataMapInfo")>.mmi)"
            %assign fcnArgs = "%<arg1>," + "\"%<blkPath>\"," + ...
                "%<childIdx>," + "-1"
        %else
            %assign capiArgs = []
            %assign capiArgs = capiArgs + SLibGetNullDefinitionFromTfl()
            %assign capiArgs = capiArgs + SLibGetNullDefinitionFromTfl()
            %assign capiArgs = capiArgs + "0"
            %assign capiArgs = capiArgs + "-1"

            %foreach idx = SIZE(capiArgs,1)
                %if idx == 0
                    %assign fcnArgs = capiArgs[idx]
                %else
                    %assign fcnArgs = fcnArgs + ", %<capiArgs[idx]>"
                %endif
            %endforeach
        %endif %% RTWCAPI == 1

        %<mdlRefInstCPPVar>%<dotOrArrow>setupCAPIInfo(%<fcnArgs>);
        %assign mdlRefInstAccessed = TLC_TRUE
    %endif %%RegFcnNeedsCAPIArgs
    %if ISFIELD(blockInterface, "RegistrationFcn") && !GenerateClassInterface
        %<mdlRefInstCPPVar>%<dotOrArrow>initialize();
        %assign mdlRefInstAccessed = TLC_TRUE
    %endif
    %closefile tmp_file

    %if mdlRefInstAccessed
        %<SLibUpdateLocalSymbolTableForFile(SLibGetFullFileNameForCode("mdl_src"), mdlRefInstCPPVar)>
    %endif

    %return tmp_file
%endfunction

%% When local solver is used the communication step size registered on the block may not exist in the model
%function SLibSkipTIDArgForLocalSolver(block, parentTID)
    %if !ISFIELD(block, "LocalSolverCommunicationStepRateIdx")
        %% The if condition is a proxy for matlab.internal.feature("SimulinkFastLocalSolver") > 0
        %return TLC_FALSE
    %else
        %return block.HasLocalSolver == "yes" && ...
            block.LocalSolverCommunicationStepRateIdx == parentTID && ...
            block.LocalSolverCommunicationRateExistsInReference == 0
    %endif
%endfunction

%% Function: SLibAddMdlRefTIDArgs ==================================================================
%% Abstract:
%%   This code appends the relevent TIDs (that should be availabe at a call site) to the a
%%   modelref's initialize arg list.
%%   If the block is completely constant, then just  pass 0 as the TID.  If it is inherited,
%%   pass the TID that this instance is running at.  This will help with data logging.
%%
%%   This may be used for calling a modelref initialize function, or in the case of C++ Class
%%   packaging in the initializeRTM function.
%%
%function SLibAddMdlRefTIDArgs(blockInterface, block, args)
    %if blockInterface.NeedsTIDArgs
        %assign ::tMdlRefNeedTIDArgs = TLC_TRUE
        %assign blockTid = block.TID
        %if TYPE(blockTid) == "Vector"
            %%while generating the arg list if blockTid has constant tid (-2)
            %%we don't need to generated a modelref_TID<idx> arg for constant rate.
            %assign nonConstantTids = []
            %assign numTids = SIZE(blockTid)[1]
            %foreach idx = numTids
                %if blockTid[idx] != -2
                    %assign nonConstantTids = nonConstantTids + blockTid[idx]
                %endif
            %endforeach
            %if SIZE(nonConstantTids)[1] == 1
                %assign blockTid = nonConstantTids[0]
            %elseif SIZE(nonConstantTids)[1] != SIZE(blockTid)[1]
                %assign blockTid = nonConstantTids
            %endif
        %endif

        %if TYPE(blockTid) == "Vector"
            %assign nonModelWideEventTids = []
            %assign numTids = SIZE(blockTid)[1]
            %foreach idx = numTids
                %if !SLibParameterChangeEventTID(blockTid[idx])
                    %assign nonModelWideEventTids = nonModelWideEventTids + blockTid[idx]
                %endif
            %endforeach
            %if SIZE(nonModelWideEventTids)[1] == 1
                %assign blockTid = nonModelWideEventTids[0]
            %endif
        %endif
        %if TYPE(blockTid) != "Identifier" || blockInterface.IsExportFcnDiagram
            %assign numTids = SIZE(blockTid)[1]
            %if ISFIELD(block.ParamSettings, "ChildTidToParentTidMap")
                %% Loop through TID map to find parent TID for each child TID.
                %assign childTidToParentMap = block.ParamSettings.ChildTidToParentTidMap
                %assign numTids = SIZE(childTidToParentMap,1)/2
                %foreach tidIdx = numTids
                    %assign parentTid = SLibGetMdlRefArgumentForTID(childTidToParentMap[numTids + tidIdx])
                    %assign args = args + parentTid
                %endforeach

            %elseif SLibGetUsingTimerServiceLevel() >= 3 && blockInterface.ModelRefTsInheritance == "USE_DEFAULT_FOR_DISCRETE_INHERITANCE"
                %assign args = args + "%<blockTid[0]>"
                %% Add parameter rate if used by model block
                %if blockInterface.HasInternalParameterRate || ...
                    blockInterface.HasParameterRateOutput
                    %assign args = args + STRING(SLibTidOfParameterChangeEvent())
                %endif
                %% Add irt event rate if used by model block
                %assign args = SLibAttachIRTEventArgs(block, args)

            %elseif (numTids == 1) && LibAsynchronousTriggeredTID(blockTid) && ...
                !ModelBlockHasAsyncInput(blockTid, block)
                %% if it is in async fcn-call subsystem, all blocks will access the base rate
                %assign args = args + "0"
                %% Add parameter rate if used by model block
                %if blockInterface.HasInternalParameterRate || ...
                    blockInterface.HasParameterRateOutput
                    %assign args = args + STRING(SLibTidOfParameterChangeEvent())
                %endif
                %% Add irt event rate if used by model block
                %assign args = SLibAttachIRTEventArgs(block, args)

            %else
                %% constant is handled in the loop
                %foreach idx = SLibGetNumTIDsForGlobalTIDMap()
                    %assign parentTID = idx

                    %% We do not access union rate without task TIDs in referenced models.
                    %if SLibIsUnionSampleTimeTIDWithoutTask(parentTID)
                        %continue
                    %endif

                    %assign childTID = MapParentTID2ChildTID(block, parentTID)
                    %if childTID != -1 && !SLibSkipTIDArgForLocalSolver(block, parentTID)
                        %assign args = args + SLibGetMdlRefArgumentForTID(idx)
                    %endif
                %endforeach
            %endif
        %else
            %% There is only one TID in the model and it
            %% is constant/triggered, pass 0 if it is constant.
            %if ISEQUAL(blockTid, "triggered")
                %if SLibGetUsingTimerServiceLevel() >= 3 && blockInterface.ModelRefTsInheritance == "USE_DEFAULT_FOR_DISCRETE_INHERITANCE"
                    %assign args = args + "%<block.TriggerTID[0]>"

                %elseif IsModelReferenceSimTarget()
                    %% Because of model-wide events, it is possible for the TriggerTID to be an array,
                    %% but the first TID is always the container TS.
                    %assign args = args + "mdlref_TID%<block.TriggerTID[0]>"
                %else
                    %assign args = args + "-1"
                %endif
                %if blockInterface.HasInternalParameterRate || blockInterface.HasParameterRateOutput
                    %assign args = args + STRING(SLibTidOfParameterChangeEvent())
                %endif
                %% Add irt event rate if used by model block
                %assign args = SLibAttachIRTEventArgs(block, args)
            %else
                %assign args = args + "0"
            %endif
        %endif

        %if GetModelRefFcnCallTriggerTIDIsReq(block)
            %if SLibModelNeedsTriggerTIDArg()
                %assign args = args + "mdlref_TriggerTID"
            %else
                %assert ISEQUAL(blockTid, "triggered") || ...
                    LibAsynchronousTriggeredTID(blockTid[0])
                %if !ISEQUAL(blockTid, "triggered") && LibAsynchronousTriggeredTID(blockTid[0])
                    %assign args = args + "%<blockTid[0]>"
                %else
                    %assign trigTid = block.TriggerTID[0]
                    %if IsModelReferenceTarget()
                        %assign args = args + "mdlref_TID%<trigTid>"
                    %else
                        %assign args = args + "%<trigTid>"
                    %endif
                %endif
            %endif
        %endif
    %endif
    %return args
%endfunction

%% Function: SLibGetSolverInfoVariableName =========================================================
%% Abstract:
%%   Returns the variable name of the solverInfo object. It the responsibility of
%%   the parent to make sure that a solverInfo object is going to be
%%   present in the RTM structure.
%%   This may be used for calling a modelref initialize function, or in the case of C++ Class
%%   packaging in the initializeRTM function.
%%
%function SLibGetSolverInfoVariableName(blkidx)
    %if LibIsDeploymentDiagram()
        %% find task idx to whom is mapped TID0 of system mSysIdx
        %assign rtmIdx = SLibDeploymentGetTaskIndexForBlock(blkidx, 0)
    %endif
    %if IsModelReferenceTarget()
        %assign arg = "rt_solverInfo"
    %elseif SLibIsERTCodeFormat()
        %if LibIsDeploymentDiagram()
            %if !ISEQUAL(rtmIdx, -1)
                %assign rtmName = SLibDeploymentGetTasksRTMVarName(rtmIdx)
                %assign arg = "&(%<SLibDeploymentRTMGet("RTWSolverInfo", rtmName)>)"
            %else
                %assign arg = "&(%<RTMGet("RTWSolverInfo")>)"
            %endif
        %else
            %if UsingMalloc
                %assign arg = "%<RTMGet("RTWSolverInfo")>"
            %else
                %assign arg = "&(%<RTMGet("RTWSolverInfo")>)"
            %endif
        %endif
    %elseif LibIsDeploymentDiagram()
        %if !ISEQUAL(rtmIdx, -1)
            %assign rtmName = SLibDeploymentGetTasksRTMVarName(rtmIdx)
            %assign arg = "%<SLibDeploymentRTMGet("RTWSolverInfo", rtmName)>"
        %else
            %assign arg = "%<RTMGet("RTWSolverInfo")>"
        %endif
    %else
        %assign arg = "%<RTMGet("RTWSolverInfo")>"
    %endif
    %return arg
%endfunction

%function SLibGetInitializeRTMFunctionArgs(block, blockInterface, instIdx, mdlRefSysIdx)
    %assert GenerateClassInterface && block.MdlRefIsCPPClassGenMode
    /* initialize real-time model for %<Type> Block: '%<Name>' */
    %assign args = []

    %%arg for initializing global timing engine
    %if !IsModelReferenceForASimstructBasedTarget()
        %if blockInterface.NeedsGlobalTimingEngine
            %if IsModelReferenceTarget()
                %assign args = args + "%<SLibGetGlobalTimingBridge()>"
            %elseif LibIsDeploymentDiagram()
                %assign timingBridgeIdx = 0
                %% Figure out the ModelReferenceBlock index for current block
                %% Update timingBridgeIdx if blkInterface.NeedsGlobalTimingEngine is true for previous mdlRefBlks
                %foreach rowIdx = SIZE(::CompiledModel.ModelReferenceBlocks, 0)
                    %assign mdlRefBlk = ::CompiledModel.ModelReferenceBlocks[rowIdx]
                    %if ((BlockIdx[0] == mdlRefBlk[0]) && (BlockIdx[2] == mdlRefBlk[1]) && ...
                        ((instIdx == mdlRefBlk[2]) || ...
                        (LibIsDeploymentDiagram() && !SLibDeploymentDiagramIsMapped(mdlRefBlk[0]))))
                        %break
                    %elseif SLibIsMappedSystemInDeploymentDiagram(mdlRefBlk[0])
                        %assign prvBlk          = System[mdlRefBlk[0]].Block[mdlRefBlk[1]]
                        %assign prvBlkInterface = GetModelrefInterface(prvBlk)
                        %if prvBlkInterface.NeedsGlobalTimingEngine
                            %assign timingBridgeIdx = timingBridgeIdx + 1
                        %endif
                    %endif
                %endforeach
                %assign args = args + "&%<SLibDeploymentGetTimingBridgeName()>[%<timingBridgeIdx>]"
            %else
                %assign args = args + "&%<SLibGetGlobalTimingBridge()>"
            %endif
        %endif
    %endif

    %if TYPE(TID) == "Vector"
        %assign tid0 = TID[0]
    %else
        %assign tid0 = TID
    %endif
    %if (TYPE(tid0) == "Number" && LibIsContinuous(tid0)) || blockInterface.HasNonInlinedSfcn
        %assign arg = "%<SLibGetSolverInfoVariableName(BlockIdx[2])>"
        %assign args =  args + "%<arg>"
    %endif
    %if blockInterface.HasNonInlinedSfcn
        %if IsModelReferenceTarget()
            %assign arg = "rt_sfcnInfo"
        %elseif SLibIsMappedSystemInDeploymentDiagram(mdlRefSysIdx)
            %assign sfcnInfoIdx     = 0
            %foreach rowIdx = SIZE(::CompiledModel.ModelReferenceBlocks, 0)
                %assign mdlRefBlk = ::CompiledModel.ModelReferenceBlocks[rowIdx]
                %if ((BlockIdx[0] == mdlRefBlk[0]) && (BlockIdx[2] == mdlRefBlk[1]) && ...
                    ((instIdx == mdlRefBlk[2]) ...
                    || (LibIsDeploymentDiagram() && ...
                    !SLibDeploymentDiagramIsMapped(mdlRefBlk[0]))))
                    %break
                %elseif SLibIsMappedSystemInDeploymentDiagram(mdlRefBlk[0]) && blkInterface.HasNonInlinedSfcn
                    %assign sfcnInfoIdx = sfcnInfoIdx + 1
                %endif
            %endforeach
            %assign arg = "(RTWSfcnInfo *)(%<SLibDeploymentGetTasksSfcnInfoVarName()>[%<sFcnInfoIdx>])"
        %else
            %assign arg = "(RTWSfcnInfo *)(%<RTMGet("RTWSfcnInfo")>)"
        %endif
        %assign args =  args + "%<arg>"
    %endif
    %assign args = SLibAddMdlRefTIDArgs(blockInterface, block, args)
    %assign fcnArgs = SLibSerializeFcnArgs(args)
    %return fcnArgs
%endfunction

%function SLibModelBlockRTMAllocateInParent(block, blockInterface)
    %return (SLibGetStructDWorkIdxForModelRefBlk(block) < 0 || blockInterface.rtmAllocateInParent) && !SLibIsSelfInSimTarget()
%endfunction

%function getRTMHelper(block, instIdx, sysFcnName, mdlBlkDWork)
    %assign blockInterface = GetModelrefInterface(block)
    %assign blkSimpInterface = blockInterface.usesSimplifiedInterface
    %assign rtmContainedInSelf = (ISFIELD(block, "ModelInstVarIndex") &&  block.ModelInstVarIndex > -1) || ...
        (blockInterface.rtmAllocateInParent && ::isRAccel)

    %if blkSimpInterface || (blockInterface.rtmAllocateInParent && rtmContainedInSelf)
        %assign rtmAccess = SLibGetModelInstVariableAddressForSimplifiedInterface(block,instIdx,TLC_FALSE)
    %elseif SLibModelBlockRTMAllocateInParent(block, blockInterface)
        %assign rtmAccess = "&" + block.Identifier
    %else
        %assign mdlBlkDWork = SLibGetModelBlockStructDWorkArg(mdlBlkDWork, ...
            baseSystemIdx, block, sysFcnName, instIdx)
        %assign rtmField = rtmContainedInSelf ? "" : ".rtm"
        %assign rtmAccess =  "&(%<mdlBlkDWork>%<rtmField>)"
    %endif
    %return rtmAccess
%endfunction

%function SLibGenModelRefLocalSolverCommStepHitGuard(block)
    %openfile tmpBuffer
    if (%<RTMIsSampleHit(block.LocalSolverCommunicationStepRateIdx)>) {
        %closefile tmpBuffer
        %return tmpBuffer
        %% comment on next line needed for sbindent to work properly
    %%}
%endfunction

%function SLibGenModelRefLocalSolverShouldRunOutputGuard(block)
    %openfile tmpBuffer
    %assign rtm = "(" + getRTMHelper(block, 0, "Output", "") + ")"
    %assign outputCompMode = rtm + "->LocalSolver.localSolverOutputCompensationMode"
    if (%<RTMIsSampleHit(block.LocalSolverCommunicationStepRateIdx)> || %<outputCompMode> > 0) {
        %closefile tmpBuffer
        %return tmpBuffer
        %% comment on next line needed for sbindent to work properly
    %%}
%endfunction

%% Function SLibGenModelRefPostUpdate =============================================================
%% Abstract: Generate code trailing the model update function callsite for local solver
%function SLibGenModelRefPostUpdate(block)
    %openfile tmpBuffer
    %assert block.HasLocalSolver == "yes"
    %% instIdx argument to GetFunctionStr is only needed to generate Registration. 0 is passed at all other call sites, so just use 0 for now.
    %assign instIdx = 0
    %assign sysFcnName = "Update"
    %assign blockInterface = GetModelrefInterface(block)
    %assign outputFcnInfo = blockInterface.OutputFcn
    %% Get local solver SimStruct pointer
    %assign rtm = "(" + getRTMHelper(block, instIdx, sysFcnName, "") + ")"
    %assign localSolverS = rtm + "->LocalSolver.mdlRefLocalSolverSPtr"
    %% Get original modelref sfcn SimStruct pointer
    %assign origMdlRefSfcnS = rtm + "->LocalSolver.origMdlRefSfcnS"
    %% Call advance
    ssAdvanceLocalContinuousTimeService(%<origMdlRefSfcnS>, %<localSolverS>);
    %% Close opening sample hit check
}
%closefile tmpBuffer
%return tmpBuffer
%endfunction

%% Function  SLibGenModelRefPostSetupRuntimeResources =============================================
%% Abstract: Generate code trailing the model setupRTR function callsite for local solver
%function SLibGenModelRefPostSetupRuntimeResources(block)
    %openfile tmpBuffer
    %assert block.HasLocalSolver == "yes"
    %% instIdx argument to GetFunctionStr is only needed to generate Registration. 0 is passed at all other call sites, so just use 0 for now.
    %assign instIdx = 0
    %assign sysFcnName = "Update"
    %assign blockInterface = GetModelrefInterface(block)
    %assign outputFcnInfo = blockInterface.OutputFcn
    %% Get local solver SimStruct pointer
    %assign rtm = "(" + getRTMHelper(block, instIdx, sysFcnName, "") + ")"
    %assign localSolverS = rtm + "->LocalSolver.mdlRefLocalSolverSPtr"
    %% Get original modelref sfcn SimStruct pointer
    %assign origMdlRefSfcnS = rtm + "->LocalSolver.origMdlRefSfcnS"
    %% Create local continuous time service
    %assign inputCompMode = block.LocalSolverInputCompensationMode
    %assign outputCompMode = block.LocalSolverOutputCompensationMode
    %if IsModelReferenceTarget()
        %% Generating code into a parent model that is also a model reference. Need to translate the idx in this parent model to a global sample time idx.
        %assign commStepGlobalSti = FcnGetMdlRefGlobalTIDMap("") + "[" + "%<block.LocalSolverCommunicationStepRateIdx>" +"]"
    %else
        %% Generating code into the top RAccel target. Therefore a MdlRefGlobalTIDMap is not generated, and not necessary since the comm step size rate idx is already a global idx.
        %assign commStepGlobalSti = block.LocalSolverCommunicationStepRateIdx
    %endif
    %% set finalized local solver fixed step in to local solver simstruct before creation
    %% of local solver
    _ssSetFixedStepSize(%<localSolverS>, %<block.FinalizedLocalSolverFixedStep>);
    ssCreateLocalContinuousTimeService(%<origMdlRefSfcnS>, %<localSolverS>, %<inputCompMode>, %<outputCompMode>, %<commStepGlobalSti>);
    %closefile tmpBuffer
    %return tmpBuffer
%endfunction



%% Function: SLibCallModelBlockFunction ============================================================
%% Abstract:
%%   Contruct a string which is a call to some function in a referenced model.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants4.m
%% TopTester: test/toolbox/simulink/blocks/tconcat.m
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%% TopTester: test/toolbox/simulink/variants/var-normal-matlabvariable-support/tNormalMatlabVariable2.m
%% TopTester: test/toolbox/simulink/variants/var-general/tStringSupport.m
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-codegen/localsGuarding/tmLG_forIterator.m
%% TopTester: test/toolbox/simulink/variants/var-vss-general/tMdlrefToVSS.m
%%
%function SLibCallModelBlockFunction(outAndRuleIdx, block, sysFcnName, ...
    blockInterface, fcnInfo, instIdx, tid, childIdx, blkPath)
    %% Initially assume there is no outport returned by value (set retArgPortIdx to -1)
    %assign retArgPortIdx = -1
    %assign fcnName = fcnInfo.FcnName
    %if block.MdlRefIsCPPClassGenMode
        %assign fcnName = REGEXPREP( fcnName,"^[a-zA-Z0-9_]*::", "")
    %endif
    %assign args  = []
    %assign canInputInfo = fcnInfo.Inputs
    %assign canOutputInfo = fcnInfo.Outputs
    %assign canPrmArgInfo = fcnInfo.PrmArgs
    %assign baseSystemIdx = GetBaseSystemIdx()
    %assign blkSimpInterface = blockInterface.usesSimplifiedInterface
    %if !SLibUpdateLocalSymbolForCurrentFunction(blockInterface.Name)
        %assign fileName = SLibGetFullFileNameForSystemCode("sys_fcn_defn", BlockIdx[0])
        %<SLibUpdateLocalSymbolTableForFile(fileName, blockInterface.Name)>
    %endif
    %if TYPE(fcnInfo.PrmTypes) == "Vector"
        %assign prmTypes = fcnInfo.PrmTypes
    %else
        %assign prmTypes = []
        %assign prmTypes = prmTypes + fcnInfo.PrmTypes
    %endif

    %if TYPE(fcnInfo.PrmIsPointer) == "Vector"
        %assign prmIsPointer = fcnInfo.PrmIsPointer
    %else
        %assign prmIsPointer = []
        %assign prmIsPointer = prmIsPointer + fcnInfo.PrmIsPointer
    %endif

    %% If we aren't generating the registration function, then
    %% instanceIdx must be 0 since we don't use it.
    %assert (sysFcnName == "RegistrationFcn") || (instIdx == 0)

    %assign TIDIdx = 0
    %assign RTModelIdx = 1
    %assign BlockIOIdx = 2
    %assign DWorkIdx   = 3
    %assign ContStatesIdx = 4
    %assign ContStatesDerivativeIdx = 5
    %assign ContStatesDisabledIdx   = 6
    %assign ContStatesAbsoluteToleranceIdx   = 7
    %assign ContStatesPerturbMinIdx   = 8
    %assign ContStatesPerturbMaxIdx   = 9

    %assign NonsampledZCIdx = 10
    %assign ZCEventIdx      = 11

    %% Variables for the sfcnInfo and timing bridge index of the components
    %% in a deployment diagram
    %assign sfcnInfoIdx     = 0
    %assign timingBridgeIdx = 0

    %if ::isRAccel
        %assign rtmFieldsCache = ""
    %endif

    %% figure out which model block we're looking at
    %assign mdlRefIdx   = -1
    %assign mSysIdx     = 0
    %foreach rowIdx = SIZE(::CompiledModel.ModelReferenceBlocks, 0)
        %assign mdlRefBlk = ::CompiledModel.ModelReferenceBlocks[rowIdx]
        %if ((BlockIdx[0] == mdlRefBlk[0]) && (BlockIdx[2] == mdlRefBlk[1]) && ...
            ((instIdx == mdlRefBlk[2]) ...
            || (LibIsDeploymentDiagram() && ...
            !SLibDeploymentDiagramIsMapped(mdlRefBlk[0]))))
            %assign mdlRefIdx  = rowIdx
            %assign mdlRefInfo = ::CompiledModel.ModelReferenceBlocks[mdlRefIdx]
            %assign mSysIdx    = mdlRefInfo[0]
            %break
        %elseif SLibIsMappedSystemInDeploymentDiagram(mdlRefBlk[0])
            %assign blk          = System[mdlRefBlk[0]].Block[mdlRefBlk[1]]
            %assign blkInterface = GetModelrefInterface(blk)
            %if blkInterface.NeedsGlobalTimingEngine
                %assign timingBridgeIdx = timingBridgeIdx + 1
            %endif
            %if blkInterface.HasNonInlinedSfcn
                %assign sfcnInfoIdx = sfcnInfoIdx + 1
            %endif
        %endif
    %endforeach

    %if LibIsDeploymentDiagram()
        %assign timingBridgeName = "%<SLibDeploymentGetTimingBridgeName()>[%<timingBridgeIdx>]"
    %endif

    %if (sysFcnName == "RegistrationFcn" && !IsSimstructBasedTarget())

        %if blockInterface.NeedsErrorStatus
            %assign arg = "%<RTMGet("ErrorStatusPointer")>"
            %assign args = args + "%<arg>"
        %endif

        %if blockInterface.StopReqAccessed
            %if IsModelReferenceTarget()
                %assign arg = "rt_stopRequested"
            %else
                %assign arg = "%<RTMGet("StopRequestedPtr")>"
            %endif
            %assign args = args + "%<arg>"
        %endif

        %if TYPE(TID) == "Vector"
            %assign tid0 = TID[0]
        %else
            %assign tid0 = TID
        %endif
        %% For continuous time referenced models, pass the
        %% solverInfo to the submodel.  In the case of
        %% non-ERT top models, the solverInfo is a pointer
        %% in the rtModel, but for ERT it's not a pointer.
        %if (TYPE(tid0) == "Number" && LibIsContinuous(tid0)) || blockInterface.HasNonInlinedSfcn
            %assign arg = "%<SLibGetSolverInfoVariableName(BlockIdx[2])>"
            %assign args =  args + "%<arg>"
        %endif

        %if blockInterface.HasNonInlinedSfcn
            %if IsModelReferenceTarget()
                %assign arg = "rt_sfcnInfo"
            %elseif SLibIsMappedSystemInDeploymentDiagram(mSysIdx)
                %assign arg = "(RTWSfcnInfo *)(%<SLibDeploymentGetTasksSfcnInfoVarName()>[%<sfcnInfoIdx>])"
            %else
                %assign arg = "(RTWSfcnInfo *)(%<RTMGet("RTWSfcnInfo")>)"
            %endif
            %assign args =  args + "%<arg>"
        %endif
    %endif
    %%
    %%
    %% TID
    %if fcnInfo.ArgInfo[TIDIdx] == 1
        %assert sysFcnName != "RegistrationFcn"
        %if ISEQUAL(tid,"")
            %assign arg = LibTID()
        %else
            %assign arg = %<tid>
        %endif
        %assign args = args + "%<arg>"
    %endif

    %if sysFcnName == "SetDimsFcn"
        %assign args = args + outAndRuleIdx[0]
        %assign args = args + outAndRuleIdx[1]
    %endif

    %assign FPC = []

    %% We do not honor the Function Prototype Control for a
    %% referenced model when generating code for:
    %%  * Model Reference SIM Target
    %%  * Top-level rapid-accelerator
    %if (sysFcnName == "OutputUpdateFcn") && ...
        !IsModelReferenceSimTarget() && ...
        !isRAccel
        %assign FPC = blockInterface.FPC
    %endif
    %if !ISEMPTY(FPC)
        %assign fcnName = FPC.FunctionName
    %endif

    %if GenerateClassInterface && block.MdlRefIsCPPClassGenMode
        %if sysFcnName == "RegistrationFcn"
            %assign fcnName = "initialize"
        %elseif sysFcnName == "InitializeFcn"
            %assign fcnName = "init"
        %elseif sysFcnName == "SystemInitializeFcn"
            %assign fcnName = "init"
        %elseif sysFcnName == "SystemResetFcn"
            %assign fcnName = "reset"
        %elseif sysFcnName == "StartFcn"
            %assign fcnName = "start"
        %elseif sysFcnName == "TerminateFcn"
            %assign fcnName = "terminate"
        %elseif sysFcnName == "DisableFcn"
            %assign fcnName = "disable"
        %elseif sysFcnName == "EnableFcn"
            %assign fcnName = "enable"
        %endif

        %assign mdlRefInstCPPVar = ...
            SLibGetCPPMdlRefObjName(System[BlockIdx[0]].SystemIdx,BlockIdx[2])

    %endif %% GenerateClassInterface && block.MdlRefIsCPPClassGenMode

    %assign NumInputs  = CAST("Number", blockInterface.NumInputs)
    %assign NumOutputs = CAST("Number", blockInterface.NumOutputs)

    %if IsFPCIgnored(FPC)
        %assign NumArgs = NumInputs + NumOutputs
    %else
        %assign NumArgs = SIZE(FPC.ArgSpecData,1)
    %endif

    %assign mdlBlkDWork = ""

    %%
    %% The following TLC code is used to prune the CGIR function call
    %% arguments and transfer the CGIR argument tracking
    %% information to the legacy TLC trackig infrastructure.
    %%
    %assign numCanDWorks   = SIZE(fcnInfo.DWArgs, 1)
    %assign numPrmArgs     = SIZE(canPrmArgInfo,1)
    %assign skipCanInput   = Vector(%<NumInputs>)    [0@%<NumInputs>]
    %assign skipInputDims  = Vector(%<NumInputs>)    [0@%<NumInputs>]
    %assign skipCanOutput  = Vector(%<NumOutputs>)   [0@%<NumOutputs>]
    %assign skipOutputDims = Vector(%<NumOutputs>)   [0@%<NumOutputs>]
    %assign skipCanDWork   = Vector(%<numCanDWorks>) [0@%<numCanDWorks>]
    %assign skipCanParam   = Vector(%<numPrmArgs>)   [0@%<numPrmArgs>]
    %assign rtmContainedInSelf = (ISFIELD(block, "ModelInstVarIndex") &&  block.ModelInstVarIndex > -1) || ...
        (blockInterface.rtmAllocateInParent && ::isRAccel)
    %assign skipRTM = 0
    %assign skipLocalB = blockInterface.usesSimplifiedInterface || (blockInterface.rtmAllocateInParent)
    %assign skipLocalDW = blockInterface.usesSimplifiedInterface || (blockInterface.rtmAllocateInParent)
    %assign skipLocalX = 0
    %assign skipLocalXdot = 0
    %assign skipLocalXdis = 0
    %assign skipLocalXabstol = 0
    %assign skipLocalXperturbmin = 0
    %assign skipLocalXperturbmax = 0
    %assign skipLocalZCSV = 0
    %assign skipLocalZCE = 0

    %if IsFPCIgnored(FPC)
        %assign numFcnInfoArgs = CAST("Number", fcnInfo.NumArgs)
        %foreach argIdx = numFcnInfoArgs
            %assign idNum = SLibSafeIDNUM(fcnInfo.ArgSource, argIdx)
            %assign argSrc = idNum[0]
            %assign argSrcIdx = idNum[1]
            %switch argSrc
              %case "I" %% canonical input
                %assign arg = SLibGetModelBlockInput(mSysIdx, block, sysFcnName, ...
                    mdlRefIdx, argSrcIdx, canInputInfo, FPC, argIdx)
                %assert !ISEMPTY(arg)
                %assign args = args + "%<arg>"
                %assign skipCanInput[argSrcIdx] = 1
                %break
              %case "O" %% canonical output
                %assign arg = SLibGetModelBlockOutput(sysFcnName,  mdlRefIdx, ...
                    argSrcIdx, FPC, argIdx)
                %assert !ISEMPTY(arg)
                %assign args = args + "%<arg>"
                %assign skipCanOutput[argSrcIdx] = 1
                %break
              %case "D" %% canonical dwork
                %assign dimsIdNum = SLibSafeIDNUM(fcnInfo.Association, argIdx)
                %assign dimsSrc = dimsIdNum[0]
                %assign dimsSrcIdx = dimsIdNum[1]
                %assert "I" == dimsSrc || "O" == dimsSrc
                %if "I" == dimsSrc
                    %assign arg = SLibGetInputCanDimSizeDWForFunctionStr(block, ...
                        dimsSrcIdx, fcnInfo, sysFcnName)
                    %assert !ISEMPTY(arg)
                    %assign args = args + "%<arg>"
                    %assign skipInputDims[dimsSrcIdx] = 1
                %else
                    %assign arg = SLibGetOutputCanDimSizeDWForFunctionStr(block, ...
                        dimsSrcIdx, fcnInfo, sysFcnName)
                    %assert !ISEMPTY(arg)
                    %assign args = args + "%<arg>"
                    %assign skipOutputDims[dimsSrcIdx] = 1
                %endif
                %assign skipCanDWork[argSrcIdx] = 1
                %break
              %case "P" %% canonical parameter
                %if blkSimpInterface
                    %break
                %endif
                %assign argInfo = canPrmArgInfo[argSrcIdx]
                %assign prmType = prmTypes[argSrcIdx]
                %assign isPointer = (1 == prmIsPointer[argSrcIdx])
                %assert argInfo >= 1
                %assign numBlockParamArgs = block.ParamSettings.NumBlockParamArgs
                %assign arg = SLibGetModelBlockParameter(block, argSrcIdx+numBlockParamArgs, argInfo, ...
                    prmType, isPointer)
                %assert !ISEMPTY(arg)
                %assign args = args + "%<arg>"
                %assign skipCanParam[argSrcIdx] = 1
                %break
              %case "RTM"
                %assign rtmAccess = getRTMHelper(block, instIdx, sysFcnName, mdlBlkDWork)
                %assign args = args + rtmAccess
                %assign skipRTM = 1
                %break
              %case "LB" %% block IO
                %if blkSimpInterface
                    %assign skipLocalB = 1
                    %break
                %endif
                %assign mdlBlkDWork = SLibGetModelBlockStructDWorkArg(mdlBlkDWork, ...
                    baseSystemIdx, block, sysFcnName, instIdx)
                %assign rtmField = rtmContainedInSelf ? ".blockIO" : ".rtb"
                %assign args = args + "&(%<mdlBlkDWork>%<rtmField>)"
                %assign skipLocalB = 1
                %break
              %case "LW" %% dwork
                %if blkSimpInterface
                    %assign skipLocalDW = 1
                    %break
                %endif
                %assign mdlBlkDWork = SLibGetModelBlockStructDWorkArg(mdlBlkDWork, ...
                    baseSystemIdx, block, sysFcnName, instIdx)
                %assign rtmField = rtmContainedInSelf ? ".dwork" : ".rtdw"
                %assign args = args + "&(%<mdlBlkDWork>%<rtmField>)"
                %assign skipLocalDW = 1
                %break
              %case "LX" %% continues states
                %assign arg = SLibModelBlockContinuousStateAddr(baseSystemIdx, ...
                    mSysIdx, block, sysFcnName, instIdx)
                %assign args = args + "%<arg>"
                %assign skipLocalX = 1
                %break
              %case "LDX" %% derivatives
                %assert (sysFcnName != "RegistrationFcn")
                %assign arg  = SLibContinuousStateDerivativeAddr(mSysIdx)
                %assign args = args + "%<arg>"
                %assign skipLocalXdot = 1
                %break
              %case "LXDI" %% continues state disabled
                %assert (sysFcnName != "RegistrationFcn")
                %assign arg = SLibContStateDisabledAddr(mSysIdx)
                %assign args = args + "%<arg>"
                %assign skipLocalXdis = 1
                %break
              %case "LXAT" %% continues state absolute tolerance
                %assert (sysFcnName != "RegistrationFcn")
                %assign arg = SLibContStateAbsoluteToleranceAddr(mSysIdx)
                %assign args = args + "%<arg>"
                %assign skipLocalXabstol = 1
                %break

              %case "LXPTMIN" %% continues state perturb  min
                %assert (sysFcnName != "RegistrationFcn")
                %assign arg = SLibContStatePerturbMinAddr(mSysIdx)
                %assign args = args + "%<arg>"
                %assign skipLocalXperturbmin = 1
                %break

              %case "LXPTMAX" %% continues state perturb  max
                %assert (sysFcnName != "RegistrationFcn")
                %assign arg = SLibContStatePerturbMaxAddr(mSysIdx)
                %assign args = args + "%<arg>"
                %assign skipLocalXperturbmax = 1
                %break

              %case "LZ" %% non-sampled zero crossings
                %assert (sysFcnName != "RegistrationFcn")
                %assign arg  = SLibNonsampledZCAddr()
                %assign args = args + "%<arg>"
                %assign skipLocalZCSV = 1
                %break
              %case "LZE" %% zero crossing events
                %assign mdlBlkDWork = SLibGetModelBlockStructDWorkArg(mdlBlkDWork, ...
                    baseSystemIdx, block, sysFcnName, instIdx)
                %assign args = args + "&(%<mdlBlkDWork>.rtzce)"
                %assign skipLocalZCE = 1
                %break
              %case "LCDG"
              %case "X" %% unknown agument type
                %break
              %case "LC" %% constat block IO
              %case "LP"  %% parameter
              %case "LCP" %% constant parameter
              %case "LPI" %% const parameter with init
              %default
                %%START_ASSERT
                %assign errTxt = "Unhandled argument type '%<argSrc>'."
                %<LibBlockReportError([],errTxt)>
                %break
                %%END_ASSERT
            %endswitch
        %endforeach
    %endif

    %foreach argIdx = NumArgs
        %if IsFPCIgnored(FPC)
            %if argIdx < NumInputs
                %assign portIdx = argIdx
                %assign SLObjectType = "Inport"
            %else
                %assign portIdx = argIdx - NumInputs
                %assign SLObjectType = "Outport"
            %endif
        %else
            %assign portIdx = CAST("Number", FPC.ArgSpecData[argIdx].PortNum)
            %assign SLObjectType = FPC.ArgSpecData[argIdx].SLObjectType
        %endif

        %if SLObjectType == "Inport"
            %% Consider adding the argument if it is not reusable.
            %if GetTheOtherReusableArgInFPC(FPC, argIdx) < 0
                %if !IsFPCIgnored(FPC) || ...
                    (!skipCanInput[portIdx] && canInputInfo[portIdx] > 0)
                    %assign arg = SLibGetModelBlockInput(mSysIdx, block, sysFcnName, mdlRefIdx, ...
                        portIdx, canInputInfo, FPC, argIdx)
                    %assert !ISEMPTY(arg)
                    %assign args = args + "%<arg>"
                %endif
            %endif
            %if !skipInputDims[portIdx]
                %assign arg = SLibGetInputCanDimSizeDWForFunctionStr(block, portIdx, ...
                    fcnInfo, sysFcnName)
                %if !ISEMPTY(arg)
                    %assign args = args + "%<arg>"
                %endif
            %endif
        %else
            %if !IsFPCIgnored(FPC) || ...
                (!skipCanOutput[portIdx] && canOutputInfo[portIdx] == 1)
                %assign arg = SLibGetModelBlockOutput(sysFcnName,  mdlRefIdx, ...
                    portIdx, FPC, argIdx)
                %if ISEMPTY(arg)
                    %%
                    %% If an output is not passed by pointer or ref, it is a return
                    %% argument, passed by value;
                    %% save the portIdx; assert that it is unassigned to this point
                    %%
                    %assert retArgPortIdx == -1
                    %assign retArgPortIdx = portIdx
                %else
                    %assign args = args + "%<arg>"
                %endif
            %endif
            %if !skipOutputDims[portIdx]
                %assign arg = SLibGetOutputCanDimSizeDWForFunctionStr(block, ...
                    portIdx, fcnInfo, sysFcnName)
                %if !ISEMPTY(arg)
                    %assign args = args + "%<arg>"
                %endif
            %endif
        %endif
    %endforeach

    %% If a model parameter argument is defined in the child model's model workspace
    %% then they will be part of canonical parameters when added to the model block
    %% interface in CreateModelReferenceFcnRec.
    %% The order in which we cached the input arguments is as follows:
    %%           Canonical inputs
    %%           Canonical outputs
    %%           Canonical Parameters
    %%              and so on

    %% SLibModelReferenceAppendInputsOutputs adds the canonical input, output and canonical
    %% parameters to the model reference initialize function for the child model.
    %% And this model reference registration function is called here along with the necessary
    %% input arguments.

    %% Also, please note that, in the function SLibCreateModelReferenceFunctionInterfaces, while
    %% creating function interfaces for codeinfo, for Registration function(mr_model_initialize),
    %% we call AddRegistrationFunction and that calls the AddRegistrationFunctionArguments
    %% where function arguments are added in the order: Canonical Input, Canonical
    %% Output, Canonical Parameter. So, this is in consistent with the order mentioned above.

    %% So follow the same order in the model block function's call site construction.
    %% TopTester: test/toolbox/simulink/variants/var-startup/tSTModelArgumentAsVCV.m
    %%
    %% Parameter Arguments
    %foreach argIdx=numPrmArgs
        %assign argInfo = canPrmArgInfo[argIdx]
        %if !skipCanParam[argIdx] && argInfo >= 1
            %assign prmType = prmTypes[argIdx]
            %assign isPointer = (1 == prmIsPointer[argIdx])
            %assign numBlockParamArgs = block.ParamSettings.NumBlockParamArgs
            %assign args = args + ...
                SLibGetModelBlockParameter(block, argIdx+numBlockParamArgs, argInfo, prmType, isPointer)
        %endif
    %endforeach

    %%
    %% SimStruct and noncontinuous output array
    %if sysFcnName == "RegistrationFcn" && IsSimstructBasedTarget()
        %if RTMMdlRefHasLocalSolver()
            %% Pass the local solver simstruct to child models. It is used instead of _mdlRefSfcnS
            %assign args = args + "%<RTMGet("MdlRefLocalSolverSPtr")>"
        %else
            %assign args = args + "%<tMdlRefSfcnS>"
        %endif
        %if blockInterface.HasNonContOutput
            %assign name = block.ParamSettings.ReferencedModelName
            %assign mangleName = FcnGetNoncontMangledName(name, BlockIdx[0], ...
                BlockIdx[2], instIdx)
            %assign args = args + "mr_%<mangleName>nonContOutputArray"
        %endif
    %endif

    %% Add child's global timer indices array (ptr) to initialize function's argument
    %% This array was created in FcnInitializeGlobalTimerIndices and the values are set
    %% in LibDumpERTAndModelrefRegExecution
    %if sysFcnName == "RegistrationFcn" && mdlRefIdx >= 0 && ...
        (::CompiledModel.ModelBlock[mdlRefIdx].NeedsGlobalTimerIndices == "yes")
        %assign args = args + "&mdlRef%<mdlRefIdx>_globalTimerIndices[0]"
    %endif

    %% Add child's global runtime event indices array (ptr) to initialize function's argument
    %% This array was created in FcnInitializeGlobalRuntimeEventIndices and the values are set
    %% in LibDumpERTAndModelrefRegExecution
    %if sysFcnName == "RegistrationFcn" && mdlRefIdx >= 0 && ...
        (::CompiledModel.ModelBlock[mdlRefIdx].NeedsGlobalRuntimeEventIndices == "yes")
        %assign args = args + "&mdlRef%<mdlRefIdx>_globalRuntimeEventIndices[0]"
    %endif

    %% calling the model intialize with right arguments from
    %% parent model initialize
    %if mdlRefIdx >= 0 && ISFIELD(::CompiledModel.ModelBlock[mdlRefIdx], "DataTransferIndexCount") && ::CompiledModel.ModelBlock[mdlRefIdx].DataTransferIndexCount > 0
        %assign startIdx = ...
            ::CompiledModel.ModelBlock[mdlRefIdx].DataTransferIndexStart
        %assign args = args + "&gblDataTransferIds[%<startIdx>]"
    %endif

    %% Pass the timing info to the registration function
    %% Note that we do not need to pass the timing bridge
    %% for any simstruct based targets.  In this case the rtm
    %% macros will automatically go through the parent
    %% simstruct to get the timing bridge.  Note that this is
    %% called for both model reference targets, and models
    %% that contain model blocks.
    %if sysFcnName == "RegistrationFcn" && ...
        !SLibIsCPPEncapMdlRefBuild()
        %if !IsModelReferenceForASimstructBasedTarget() && ...
            SLibIsERTCodeFormat()
            %if blockInterface.NeedsGlobalTimingEngine
                %if IsModelReferenceTarget()
                    %assign args = args + "timingBridge"
                %elseif LibIsDeploymentDiagram()
                    %assign args = args + "&%<timingBridgeName>"
                %else
                    %assign args = args + "&%<SLibGetGlobalTimingBridge()>"
                %endif
            %endif
            %if blockInterface.NeedCtrlRateMdlRefTiming
                %if IsModelReferenceTarget()
                    %assign args = args + "CtrlRateMdlRefTimingPtr"
                %else
                    %assign ctrlRateTiming = RTMGet("CtrlRateMdlRefTiming")
                    %assign args = args + "&(%<ctrlRateTiming>)"
                %endif
            %endif
        %endif
        %assign args = SLibAddMdlRefTIDArgs(blockInterface, block, args)
    %elseif sysFcnName == "RegistrationFcn" && SLibIsCPPEncapMdlRefBuild() && ...
        !block.MdlRefIsCPPClassGenMode
        %% This case is the parent model is CPP Encap.
        %% class, while the referenced
        %% model is CPP (Non-encap), and it is ModelReferenceRTWTarget.
        %% We need to directly pass the
        %% local global timing
        %% engine variable, which is already a pointer, to the
        %% submodel_initialize function. The case of both parent/child
        %% models being C++ encap. will be handled later by
        %% setupGlobalTimingEngine

        %assert IsModelReferenceRTWTarget()
        %assign args = SLibAttachTimingArgsForCPPEncap(block,blockInterface,args)

    %endif %% sysFcnName == "RegistrationFcn" && !SLibIsCPPEncapMdlRefBuild()

    %assign rtmContainedInSelf = ISFIELD(block, "ModelInstVarIndex") &&  block.ModelInstVarIndex > -1  || ...
        (blockInterface.rtmAllocateInParent && ::isRAccel)
    %%
    %% RTModel
    %if !skipRTM && fcnInfo.ArgInfo[RTModelIdx] == 1
        %if blkSimpInterface || (blockInterface.rtmAllocateInParent && !SLibIsSelfInSimTarget() && !isRAccel)
            %assign isRegFcn = sysFcnName == "RegistrationFcn"
            %assign rtmField = SLibGetModelInstVariableAddressForSimplifiedInterface(block,instIdx,isRegFcn)
            %if SIZE(args,1) > 0 && !isRegFcn
                %assign tmpArgs = []
                %assign tmpArgs = tmpArgs+rtmField
                %foreach idx = SIZE(args,1)
                    %assign tmpArgs = tmpArgs + args[idx]
                %endforeach
                %assign args = tmpArgs
            %else
                %assign args = args + rtmField
            %endif
        %elseif SLibModelBlockRTMAllocateInParent(block, blockInterface)
            %assign rtmArg = "&" + block.Identifier
            %assign args = args + rtmArg
        %else
            %assign mdlBlkDWork = SLibGetModelBlockStructDWorkArg(mdlBlkDWork, ...
                baseSystemIdx, block, sysFcnName, instIdx)
            %assign rtmField = rtmContainedInSelf ? "" : ".rtm"
            %assign args = args + "&(%<mdlBlkDWork>%<rtmField>)"
            %if ::isRAccel && blkPath != "" && sysFcnName == "RegistrationFcn"
                %assign rtmFieldsCache = "slsaCacheDWorkDataForSimTargetOP(%<tMdlRefSfcnS>, &(%<mdlBlkDWork>%<rtmField>), sizeof(%<mdlBlkDWork>%<rtmField>));"
            %endif
        %endif
    %endif
    %%
    %% BlockIO
    %if !skipLocalB && fcnInfo.ArgInfo[BlockIOIdx] == 1
        %assign mdlBlkDWork = SLibGetModelBlockStructDWorkArg(mdlBlkDWork, ...
            baseSystemIdx, block, sysFcnName, instIdx)
        %assign rtmField = rtmContainedInSelf ? ".blockIO" : ".rtb"
        %assign args = args + "&(%<mdlBlkDWork>%<rtmField>)"
    %endif
    %assign subsysRegFcnForCPPClassModelRefBlock = block.MdlRefIsCPPClassGenMode && ...
        !IsSystemReusableParentBaseSys(BlockIdx[0]) &&...
        (!IsModelRefScalableBuild() || GenerateClassInterface)

    %assign regFcn4MdlRefBlkCPPFromSubSys = subsysRegFcnForCPPClassModelRefBlock && ...
        sysFcnName == "RegistrationFcn" && ...
        ISFIELD(block,"CPPObjDWorkIdxInSubsys")

    %if regFcn4MdlRefBlkCPPFromSubSys
        %assert "RegistrationFcn" == sysFcnName
        %assign mdlRefInstCPPVar = ...
            SLibGetModelBlockVarGroupPath(baseSystemIdx, block, instIdx) ...
            + mdlRefInstCPPVar
    %elseif subsysRegFcnForCPPClassModelRefBlock && ...
        ISFIELD(block,"ModelInstVarGroupIndex") && ...
        block.ModelInstVarGroupIndex > -1
        %assign mdlRefInstCPPVar = ...
            SLibCGIRVarGroupPath(block.ModelInstVarGroupIndex,System[BlockIdx[0]].SystemIdx,sysFcnName != "RegistrationFcn") ...
            + mdlRefInstCPPVar
    %endif

    %%
    %% DWork
    %if !skipLocalDW && ...
        (fcnInfo.ArgInfo[DWorkIdx] == 1 || regFcn4MdlRefBlkCPPFromSubSys)
        %assign mdlBlkDWork = SLibGetModelBlockStructDWorkArg(mdlBlkDWork, ...
            baseSystemIdx, block, sysFcnName, instIdx)
        %assign rtmField = rtmContainedInSelf ? ".dwork" : ".rtdw"
        %assign args = args + "&(%<mdlBlkDWork>%<rtmField>)"
    %endif

    %if (sysFcnName == "RegistrationFcn") && ...
        GenerateClassInterface && block.MdlRefIsCPPClassGenMode
        %return SLibGetModelBlockRegistrationFunctionForCppClassGen(block,blkPath,blockInterface,instIdx,childIdx,mSysIdx)
    %endif %%  (sysFcnName == "RegistrationFcn") && GenerateClassInterface &&
    %%  block.MdlRefIsCPPClassGenMode


    %% All the rest will be supported when ERT supports continuous states/time, we
    %% must test them when that is online.
    %%
    %% ContStates
    %if !skipLocalX && fcnInfo.ArgInfo[ContStatesIdx] == 1
        %assign arg = SLibModelBlockContinuousStateAddr(baseSystemIdx, mSysIdx, ...
            block, sysFcnName, instIdx)
        %assign args = args + "%<arg>"
    %endif
    %%
    %% ContStatesDerivative
    %if !skipLocalXdot && fcnInfo.ArgInfo[ContStatesDerivativeIdx] == 1
        %assert (sysFcnName != "RegistrationFcn")
        %assign arg  = SLibContinuousStateDerivativeAddr(mSysIdx)
        %assign args = args + "%<arg>"
    %endif
    %%
    %% ContStatesDisabled
    %if !skipLocalXdis && fcnInfo.ArgInfo[ContStatesDisabledIdx] == 1
        %assign arg = SLibContStateDisabledAddr(mSysIdx)
        %assign args = args + "%<arg>"
    %endif
    %%
    %% Continuous States Absolute Tolerance
    %if !skipLocalXabstol && fcnInfo.ArgInfo[ContStatesAbsoluteToleranceIdx] == 1
        %assert (sysFcnName != "RegistrationFcn")
        %assign arg = SLibContStateAbsoluteToleranceAddr(mSysIdx)
        %assign args = args + "%<arg>"
    %endif
    %%

    %% Continuous States Perturb Min
    %if !skipLocalXperturbmin && fcnInfo.ArgInfo[ContStatesPerturbMinIdx] == 1
        %assert (sysFcnName != "RegistrationFcn")
        %assign arg = SLibContStatePerturbMinAddr(mSysIdx)
        %assign args = args + "%<arg>"
    %endif
    %%

    %% Continuous States Perturb Max
    %if !skipLocalXperturbmax && fcnInfo.ArgInfo[ContStatesPerturbMaxIdx] == 1
        %assert (sysFcnName != "RegistrationFcn")
        %assign arg = SLibContStatePerturbMaxAddr(mSysIdx)
        %assign args = args + "%<arg>"
    %endif
    %%


    %% NonsampledZC
    %if !skipLocalZCSV && fcnInfo.ArgInfo[NonsampledZCIdx] == 1
        %assert (sysFcnName != "RegistrationFcn")
        %assign arg  = SLibNonsampledZCAddr()
        %assign args = args + "%<arg>"
    %endif
    %%
    %% ZCEvent
    %if !skipLocalZCE && fcnInfo.ArgInfo[ZCEventIdx] == 1
        %assign mdlBlkDWork = SLibGetModelBlockStructDWorkArg(mdlBlkDWork, ...
            baseSystemIdx, block, sysFcnName, instIdx)
        %assign args = args + "&(%<mdlBlkDWork>.rtzce)"
    %endif
    %%
    %% MassMatrix (not needed if local solver is used. Local mass matrix is hidden from the top)
    %if blockInterface.ModelIsLinearlyImplicit && block.HasLocalSolver == "no"
        %assert (::CompiledModel.ModelIsLinearlyImplicit == "yes")
        %if (sysFcnName == "RegistrationFcn")
            %assign mmOffset = SLibBlockMassMatrixPrOffset("","",0)
            %if SLibIsMappedSystemInDeploymentDiagram(mSysIdx)
                %assign tIdx = SLibDeploymentGetTaskIndexForComponent(SLibGetPIDFromBlock(block, 0), 0)
                %assign args = args + ...
                    "&(%<SLibDeploymentGetTasksMassMatricesVarName(tIdx)>.pr[%<mmOffset>])"
            %else
                %assign args = args + "&(%<LibGetMassMatrixGlobalPr()>[%<mmOffset>])"
            %endif
        %endif
    %endif

    %% Arguments for Local Solver
    %% 1. MdlRefDWork argument. Note MdlRefDWork will not be exposed to the parent if the
    %% referenced model is single instance, in which case we don't need this argument.
    %% 2. Input compensation mode -- always needed if local solver is used
    %% 3. Output compensation mode -- always needed if local solver is used
    %% Input and output compensation mode arguments for local solver
    %if block.HasLocalSolver == "yes" && sysFcnName == "RegistrationFcn"
        %if ISFIELD(block, "DWork")
            %assign mdlBlkDWork = SLibGetModelBlockStructDWorkArg(mdlBlkDWork, ...
                baseSystemIdx, block, sysFcnName, instIdx)
            %assign mdlBlkDWorkAccess = "&(%<mdlBlkDWork>)"
            %assign args = args + mdlBlkDWorkAccess
        %endif
        %assign args = args + "%<block.LocalSolverInputCompensationMode>"
        %assign args = args + "%<block.LocalSolverOutputCompensationMode>"
    %endif

    %%
    %% In the ModelReference initialization code we need to pass in the systemRan
    %% dwork pointer and the corresponding tid.  All this is already hanging off
    %% the DataMapInfo, so simply index in to the correct array(s).
    %%
    %if (sysFcnName == "RegistrationFcn")
        %if IsModelReferenceSimTarget()
            %assign descIdx = ::CompiledModel.System[BlockIdx[0]].DescSysIdx[instIdx]
            %assign contIdx = ::CompiledModel.SubsystemRanBC.ContextSysIdx[descIdx]
            %assign arg1 = "%<RTMGet("DataMapInfo")>.systemRan[%<contIdx>]"
            %assign arg2 = "%<RTMGet("DataMapInfo")>.systemTid[%<contIdx>]"
            %assign args =  args + "%<arg1>" + "%<arg2>"
        %elseif ::isRAccel
            %assign args = args + "NULL" + "0"
        %endif
    %endif

    %% For every child model, when C-API is selected we need to pass the parent
    %% MMI structure to the child initialize function. The child MMI is cached
    %% inside the parent MMI. Also, the child model instance is assigned the
    %% corresponding block path in the parent model. Need to pass the block path
    %% and continous state start index (if states are logged).
    %if (sysFcnName == "RegistrationFcn")
        %assign blockInterface = GetModelrefInterface(block)
        %if ISFIELD(blockInterface, "RegFcnNeedsCAPIArgs") && ...
            blockInterface.RegFcnNeedsCAPIArgs
            %% Protected model blocks, and blocks inside foreach do not
            %% have any C-API information because they don't log.
            %if (RTWCAPI == 1) && !block.ParamSettings.InsideForEachSS && ...
                !block.ParamSettings.ProtectedModelBlock
                %% The top model has C-API turned on, i.e. it defines a MMI structure.
                %% Need to pass a pointer of the parent MMI to the child model
                %if GenRTModel
                    %assign arg1 = "&(%<RTMGet("DataMapInfo")>.mmi)"
                %else
                    %%RSim does not use rtModel with the C-API
                    %assign arg1 = "&(%<RSimRTWCAPIVarPtr>->mmi)"
                %endif

                %% For protected SIM targets, we don't want to use actual blockpaths
                %assign blockPath = blkPath
                %if SLibIsGeneratingSimTargetForProtectedModel()
                    %assign blockPath = SLibGetProtectedBlockPath()
                %endif
                %assign blockPath_escaped = FEVAL("coder.internal.getEscapedString", blockPath)

                %assign args = args + "%<arg1>" + "\"%<blockPath_escaped>\"" + "%<childIdx>"
                %if (block.ContStates[0] > 0)
                    %% Search through all the global ContinuousStates to find the one that is associated
                    %% with the Model block and instance to handle code reuse.
                    %assign modelBlockSigSrc = [%<block.BlockIdx[0]>, %<instIdx>, %<block.BlockIdx[2]>]
                    %with ::CompiledModel.ContStates
                        %foreach csIdx = NumContStates
                            %if ContState[csIdx].SigSrc == modelBlockSigSrc
                                %assign csvIdx = ContState[csIdx].StartIndex
                                %break
                            %endif
                        %endforeach
                    %endwith
                %else
                    %assign csvIdx = -1
                %endif
                %assign args = args + "%<csvIdx>"
            %else
                %% The top model has not defined a MMI pointer. Pass NULL pointers
                %% to the child model, if the child-model has a MMI structure
                %assign args = args + SLibGetNullDefinitionFromTfl() + SLibGetNullDefinitionFromTfl() + "0" + "-1"
            %endif %% RTWCAPI == 1
        %endif %% blockInterface.RegFcnNeedsCAPIArgs
    %endif %% Registration Functions

    %% Fill the return string fcnName(args, ...)
    %assign retStr = ""

    %if ISEMPTY(args)
        %% no input argument
        %if !GenerateClassInterface || !block.MdlRefIsCPPClassGenMode
            %assign retStr = "%<retStr>%<fcnName>" + "()"
        %else
            %assign dotOrArrow = SLibCPPDotOrArrowAccessOperator(block,blockInterface)
            %if (!IsSystemReusableParentBaseSys(BlockIdx[0]) || ...
                !(sysFcnName == "RegistrationFcn") || ...
                !IsModelRefScalableBuild()) && ...
                ISFIELD(block,"CPPObjDWorkIdxInSubsys")
                %assign subSysDWRec = SLibGetSubsysDWorkForCPPMdlRefBlk(block)
                %assign theObjArg = LibBlockDWork(subSysDWRec, "","","0")
                %assign retStr = "%<retStr>" + "(" + theObjArg +")%<dotOrArrow>%<fcnName>" + "()"
            %else
                %assign retStr = "%<retStr>" + mdlRefInstCPPVar +"%<dotOrArrow>%<fcnName>" + "()"
            %endif
        %endif
    %else
        %if !GenerateClassInterface || !block.MdlRefIsCPPClassGenMode
            %assign retStr = "%<retStr>%<fcnName>" + "("
        %else
            %assign dotOrArrow = SLibCPPDotOrArrowAccessOperator(block,blockInterface)

            %if (!IsSystemReusableParentBaseSys(BlockIdx[0])||...
                !(sysFcnName == "RegistrationFcn") ||...
                !IsModelRefScalableBuild()) && ...
                ISFIELD(block,"CPPObjDWorkIdxInSubsys")
                %assign subSysDWRec = SLibGetSubsysDWorkForCPPMdlRefBlk(block)
                %assign theObjArg = LibBlockDWork(subSysDWRec, "","","0")
                %assign retStr = "%<retStr>" + "(" + theObjArg +")%<dotOrArrow>%<fcnName>" + "("
            %else
                %assign retStr = "%<retStr>" + mdlRefInstCPPVar +"%<dotOrArrow>%<fcnName>" + "("
            %endif
        %endif

        %foreach idx = SIZE(args,1)
            %if idx == 0
                %% one input argument (no comma is needed)
                %assign retStr = retStr + args[idx]
            %else
                %assign retStr =  retStr + ", " + args[idx]
            %endif
        %endforeach
        %assign retStr = retStr +  ")"
    %endif

    %if retArgPortIdx >= 0
        %assign retStr = "%<LibBlockOutputSignal(retArgPortIdx, "", "", 0)> = %<retStr>;\n"
    %elseif !WHITE_SPACE(retStr)
        %assign retStr = retStr + ";"
    %endif

    %% Insert assignments between reusable inports and outports
    %if !ReuseMdlRefIO
        %assign retStr = GetReusableInoutAssignmentsFromFPC(...
            FPC, mSysIdx, block, sysFcnName, mdlRefIdx, canInputInfo) + retStr
    %endif

    %if ::isRAccel
        %assign retStr = retStr + rtmFieldsCache
    %endif


    %return retStr
%endfunction


%% Function: GetFunctionStr ========================================================================
%% Abstract:
%%     The following order is used in FcnGetAdditionalArgs and
%%     FcnAddParametersAndReturn. We must use the same order:
%%           TID
%%           outputIdx (VarDims only)
%%           ruleIdx (VarDims only)
%%           CanonicalInput
%%           CanonicalDWork for CanonicalInput
%%           CanonicalOutput
%%           CanonicalDWork for CanonicalOutput
%%           SimStruct
%%           rtModel
%%           BlockIO
%%           ConstBlockIO (?)
%%           DWork
%%           Prm (?)
%%           ContStates
%%           ContStatesDerivative
%%           ContStatesDisabled
%%           ContStatesAbsoluteTolerance
%%           ContStatesPerturbMin
%%           ContStatesPerturbMax
%%           NonsampledZC
%%           ZCEvent
%%           MassMatrix
%%           NumCanonicalPrm
%%           CanDWork (?)
%%           C-API required arguments (optional)
%%             o sysRan        (mdlrefsim target required)
%%             o sysTID        (mdlrefsim target required)
%%             o MMI           (mdlrefsim required, rtwtarget if RTWCAPI==true)
%%             o block Path    (mdlrefsim required, rtwtarget if RTWCAPI==true)
%%             o child Idx     (mdlrefsim required, rtwtarget if RTWCAPI==true)
%%             o Cont State Idx(mdlrefsim required, rtwtarget if RTWCAPIStates)
%%
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function GetFunctionStr(block, sysFcn, instIdx, tid, childIdx, blkPath)
    %assign sysFcnName = ISEQUAL(tid,"") ? ...
        "%<sysFcn>Fcn" :  "%<sysFcn>TID%<tid>Fcn"
    %assign blockInterface = GetModelrefInterface(block)
    %assign fcnInfo = blockInterface.%<sysFcnName>
    %if ISFIELD(fcnInfo, "FcnHeaderFile") && !ISEMPTY(fcnInfo.FcnHeaderFile)
        %<SLibUpdateGlobalSymbolTableForFile(fcnInfo.FcnHeaderFile, fcnInfo.FcnName)>\
    %endif
    %return SLibCallModelBlockFunction([], block, sysFcnName, blockInterface, ...
        fcnInfo, instIdx, tid, childIdx, blkPath)
%endfunction %%GetFunctionStr

%function GetSetDimsFunctionStr(outAndRuleIdx, block, sysFcn, instIdx, tid, childIdx, blkPath)
    %assign sysFcnName = ISEQUAL(tid,"") ? ...
        "%<sysFcn>Fcn" :  "%<sysFcn>TID%<tid>Fcn"
    %assign blockInterface = GetModelrefInterface(block)
    %assign fcnInfo = blockInterface.%<sysFcnName>

    %return SLibCallModelBlockFunction(outAndRuleIdx, block, sysFcnName, blockInterface, ...
        fcnInfo, instIdx, tid, childIdx, blkPath)
%endfunction %%GetFunctionStr

%function GetModelRefFcnCallTriggerTIDIsReq(block) void
    %assign blockInterface = GetModelrefInterface(block)
    %return blockInterface.FcnCallMdlRefTriggerTIDIsReq
%endfunction

%% Function: GetModelRefFcnNeedsTID ================================================================
%% Abstract:
%%     Returns whether this function uses TID in the argument list, we only
%% need to check this for the update and output functions.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function GetModelRefFcnNeedsTID(block, sysFcn)
    %assert (sysFcn == "UpdateFcn") || (sysFcn == "OutputFcn") || ...
        (sysFcn == "OutputUpdateFcn")
    %% Note that the TIDidx must match the index in GetFunctionStr above.
    %assign TIDIdx = 0
    %assign needsTID = 0

    %with block
        %assign blockInterface = GetModelrefInterface(block)
        %if ISFIELD(blockInterface, "%<sysFcn>")
            %assign needsTID = blockInterface.%<sysFcn>.ArgInfo[TIDIdx]
        %endif
    %endwith
    %return needsTID
%endfunction

%function FcnSpaces(numIndents) void
    %assign spaces = ""
    %foreach idx = numIndents
        %assign spaces = spaces + "  "
    %endforeach
    %return spaces
%endfunction

%function FcnEmitModelElement(modelElement) void
    %openfile buffer
    %assign numElems = SIZE(modelElement, 1)
    %foreach idx = numElems-2
        %assign elemIdx = numElems-1-idx
        * %<FcnSpaces(idx)>%<modelElement[elemIdx]>
    %endforeach
    * %<FcnSpaces(numElems - 2)>%<modelElement[1]>:%<modelElement[0]>
    %closefile buffer
    %return buffer
%endfunction

%function FcnEmitInitializerRegion(parent) void
    %openfile buffer
    {
        %assign numElements = SIZE(parent.Elements, 1)

        %%assume no elements are unconditional
        %assign hasUnconditionalElements = TLC_FALSE
        %assign hasElement = ""
        %foreach eIdx = numElements
            %assign comma = (eIdx < (numElements - 1)) ? "," : ""
            %assign element = parent.Elements[eIdx].Element
            %assign ppIf = ISFIELD(parent.Elements[eIdx],"NetVarCondFromChild") ? parent.Elements[eIdx].NetVarCondFromChild : ""
            %assign modelElement = ISFIELD(parent.Elements[eIdx],"ModelElement") ? parent.Elements[eIdx].ModelElement : ""
            %assign hasElement = ISFIELD(parent.Elements[eIdx],"HasElement") ? parent.Elements[eIdx].HasElement : ""

            %%If the hasElement exists, we know that the ppIf is not empty because it is populated only when ppIf is non empty
            %%Update the hasUnconditionalElements record
            %assign hasUnconditionalElements = hasUnconditionalElements || ISEMPTY(ppIf)
            %if TYPE(element) == "String"
                %assign idNum = IDNUM(element)
                %switch idNum[0]
                    %% Reference to coder data group from this model
                  %case "RCDG"
                    %assign group = ::CompiledModel.CoderGroup[idNum[1]]
                    &(%<SLibCoderDataGroupInstance(group)>)%<comma>
                    %break
                    %% Reference to propagated coder data group from descendent model
                  %case "RPCDG"
                    %assign group = ::CompiledModel.CoderDataGroups.CoderDataGroup[idNum[1]]
                    &(%<group.GroupPath>)%<comma>
                    %break
                  %case "RVG"
                    %assign vargroup = ::CompiledModel.VarGroups.VarGroup[idNum[1]]
                    %break
                  %case "PD"
                    %foreach pads = idNum[1]
                        %assign comma2 = (pads < (idNum[1] - 1)) ? "," : ""
                        'a'%<comma2>\
                    %endforeach
                    %<comma>
                    %break
                  %default
                    %<SLibIfVariantConditionForm(ppIf)>
                    %if !ISEMPTY(modelElement)
                        /*
                        %<FcnEmitModelElement(modelElement)>\
                        */
                    %endif
                    %<element>%<comma>
                    %if !ISEMPTY(hasElement)
                        %<SLibMakeSingleLine("#define " + hasElement)>
                    %endif
                    %<SLibEndIfVariantConditionForm(ppIf)>
                    %break
                %endswitch
            %else
                %% This is for nested modelref case when the InstP in moved to the top model
                %<SLibIfVariantConditionForm(ppIf)>
                %<FcnEmitInitializerRegion(element)>%<comma>
                %if !ISEMPTY(hasElement)
                    %<SLibMakeSingleLine("#define " + hasElement)>
                %endif
                %<SLibEndIfVariantConditionForm(ppIf)>
            %endif
        %endforeach

        %%If all elements are conditional, we need the #ifndef guard
        %if numElements > 0 && !hasUnconditionalElements
            %assert !ISEMPTY(hasElement)
            %<SLibWrapBody("#ifndef " + hasElement, "0", "#endif /* %<hasElement> undefined */")>
        %endif

    }\
    %closefile buffer
    %return buffer
%endfunction

%function FcnEmitInitializer(groupInitializer) void
    %if ISEMPTY(groupInitializer) || WHITE_SPACE(groupInitializer)
        %return ""
    %elseif TYPE(groupInitializer) == "String"
        %return groupInitializer
    %else
        %return FcnEmitInitializerRegion(groupInitializer)
    %endif
%endfunction

%% Function: FcnAdjustInitializer ==================================================================
%% Abstract:
%%   reformulate the static initializer of a propagated group to the context of this parent model
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function FcnAdjustInitializer(originalInitializer, mdlRefIdx) void
    %if ISEMPTY(originalInitializer) || (TYPE(originalInitializer) == "String")
        %return originalInitializer
    %endif
    %createrecord adjustedInitializer {}
    %assign numElements = SIZE(originalInitializer.Elements, 1)
    %foreach eIdx = numElements
        %assign element = originalInitializer.Elements[eIdx].Element
        %assign netVarCond = ISFIELD(originalInitializer.Elements[eIdx],"NetVarCondFromChild") ? originalInitializer.Elements[eIdx].NetVarCondFromChild : ""
        %assign modelElement = ISFIELD(originalInitializer.Elements[eIdx],"ModelElement") ? originalInitializer.Elements[eIdx].ModelElement : ""
        %assign hasElement = ISFIELD(originalInitializer.Elements[eIdx],"HasElement") ? originalInitializer.Elements[eIdx].HasElement : ""
        %if TYPE(element) == "String"
            %% In case element is a dataref, need to truly make a string to get element[0]
            %assign element0 = STRING(element)[0]
            %assign idNum = IDNUM(element)
            %switch idNum[0]
                %% Non-testpointed model parameter: just replace with the fornatted value
              %case "P"
                %assign blktpIdx = idNum[1]
                %assign mdlrefBlock = ::CompiledModel.ModelBlock[mdlRefIdx]
                %% The usage of the first instance block is OK here since all
                %% corresponding instances must have the same value or else
                %% reuse would not have been possible
                %assign prmIdx = mdlrefBlock.ParameterModelParameterIndices[blktpIdx]
                %assert prmIdx >= 0
                %assign mdlprm = ::CompiledModel.ModelParameters.Parameter[prmIdx]
                %assign mdltpIdx = mdlprm.TestpointIndex
                %assert mdltpIdx < 0
                %addtorecord adjustedInitializer Elements { Element "%<SLibGetFormattedPrmValue(mdlprm, "")>" }
                %break
                %% Testpointed parameter: adjust to this parent model, unless this parent model
                %% is a top model in which case replace with the formatted value
              %case "TP"
                %assign blktpIdx = idNum[1]
                %assign mdlrefBlock = ::CompiledModel.ModelBlock[mdlRefIdx]
                %assign mdlrefInfo = [ %<::CompiledModel.ModelReferenceBlocks[mdlRefIdx][3]>, %<::CompiledModel.ModelReferenceBlocks[mdlRefIdx][4]>]
                %assign modelElement = modelElement + SLibMangledGrBlockPath(mdlrefInfo)
                %% The usage of the first instance block is OK here since all
                %% corresponding instances must have the same value or else
                %% reuse would not have been possible
                %assign prmIdx = mdlrefBlock.ParameterModelParameterIndices[blktpIdx]
                %assert prmIdx >= 0
                %assign mdlprm = ::CompiledModel.ModelParameters.Parameter[prmIdx]
                %assign mdltpIdx = mdlprm.TestpointIndex
                %% We don't support testpointed parameters for top model
                %if mdltpIdx < 0 || !IsModelReferenceTarget()
                    %if mdlprm.StorageClass == "Custom"
                        %assign genType = SLibGetGenerateTypeForData(mdlprm)
                        %assign init = GENERATE_TYPE(mdlprm,"DataAccess",genType,"contents","","")
                        %addtorecord adjustedInitializer Elements { Element "%<init>" NetVarCondFromChild netVarCond HasElement hasElement ModelElement modelElement}
                    %else
                        %addtorecord adjustedInitializer Elements { Element "%<SLibGetFormattedPrmValue(mdlprm, "")>"  NetVarCondFromChild netVarCond HasElement hasElement ModelElement modelElement}
                    %endif
                %else
                    %addtorecord adjustedInitializer Elements { Element "TP%<mdltpIdx>" NetVarCondFromChild netVarCond HasElement hasElement ModelElement modelElement}
                %endif
                %break
                %% Padding: preserve as-is
              %case "PD"
                %addtorecord adjustedInitializer Elements { Element element }
                %break
                %% reference to coder data group: convert to reference to propagated group with the index adjusted
                %% to this parent model
              %case "RCDG"
                %assign mapKey = "Group" + STRING(idNum[1])
                %assign mapValue = FcnCoderGroupIndexMapValue(mdlRefIdx, mapKey)
                %assign groupIndex = mapValue.CoderDataGroupIndex
                %assign adjustedElement = "RPCDG" + STRING(groupIndex)
                %addtorecord adjustedInitializer Elements { Element adjustedElement }
                %break
                %% Reference to propagated coder data group from descendent model
              %case "RPCDG"
                %assign mapKey = "ChildGroup" + STRING(idNum[1])
                %assign mapValue = FcnCoderGroupIndexMapValue(mdlRefIdx, mapKey)
                %assign groupIndex = mapValue.CoderDataGroupIndex
                %assign adjustedElement = idNum[0] + STRING(groupIndex)
                %addtorecord adjustedInitializer Elements { Element adjustedElement }
                %break
                %% Embedded Propagated coder data group from descendent model: preserve as-is
              %case "PCDG"
                %addtorecord adjustedInitializer Elements { Element element }
                %break
                %% Reference to (non-codergroup) vargroup: preserve as-is
              %case "RVG"
                %addtorecord adjustedInitializer Elements { Element %<element> }
                %break
                %% Default for string: preserve as-is
              %default
                %addtorecord adjustedInitializer Elements { Element element }
                %break
            %endswitch
        %elseif TYPE(element) == "Scope"
            %% Recurse for scopes
            %% Initialize to dummy value since addrecord can't handle newlines thus we
            %% will directly set the value of the new element after adding the dummy value.
            %addtorecord adjustedInitializer Elements { Element 0 NetVarCondFromChild "" HasElement "" ModelElement ""}
            %assign init = FcnAdjustInitializer(element, mdlRefIdx)
            %assign numElements = SIZE(adjustedInitializer.Elements, 1)
            %assign adjustedInitializer.Elements[numElements - 1].Element = init
            %% This is needed for nested modelref case
            %assign adjustedInitializer.Elements[numElements - 1].NetVarCondFromChild = netVarCond
            %assign adjustedInitializer.Elements[numElements - 1].ModelElement = modelElement
            %assign adjustedInitializer.Elements[numElements - 1].HasElement = hasElement
        %else
            %assign errTxt = "Unhandled argument"
            %<LibReportError(errTxt)>
        %endif
    %endforeach
    %return adjustedInitializer
%endfunction

%% Function: FcnAdjustDynamicInitializer ===========================================================
%% Abstract:
%%   reformulate the dynamic initializer of a propagated group to the context of this parent model
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function FcnAdjustDynamicInitializer(childGroup, mdlRefIdx, blockInterface, dynamicInitPath, childGroupPath) void
    %assign originalInitializer = childGroup.DynamicInitializer
    %if ISEMPTY(originalInitializer)
        %return originalInitializer
    %endif
    %createrecord adjustedInitializer {}
    %assign fieldNames = FIELDNAMES(originalInitializer)
    %assign numElements = SIZE(fieldNames, 1)
    %foreach eIdx = numElements
        %assign fieldName = fieldNames[eIdx]
        %assign originalPath = originalInitializer.%<fieldName>
        %assign idNum = IDNUM(fieldName)
        %if idNum[0] == "TP"
            %assign blktpIdx = idNum[1]
            %assign mdlrefBlock = ::CompiledModel.ModelBlock[mdlRefIdx]
            %% The usage of the first instance block is OK here since all
            %% corresponding instances must have the same value or else
            %% reuse would not have been possible
            %assign prmIdx = mdlrefBlock.ParameterModelParameterIndices[blktpIdx]
            %assert prmIdx >= 0
            %assign mdlprm = ::CompiledModel.ModelParameters.Parameter[prmIdx]
            %assign mdltpIdx = mdlprm.TestpointIndex
            %if blockInterface.OkToMultiInstance
                %assign adjustedPath = dynamicInitPath + "." + originalPath
            %else
                %assign adjustedPath = originalPath
            %endif
            %if mdltpIdx >= 0 && !::isRAccel && !Accelerator
                %addtorecord adjustedInitializer TP%<mdltpIdx> adjustedPath
            %else
                %addtorecord adjustedInitializer P%<prmIdx> adjustedPath
            %endif
            %if IsModelReferenceSimTarget()
                %addtorecord mdlprm ChildGroupPath adjustedPath
            %endif
        %elseif idNum[0] == "P"
            %% Do nothing; swallow it up
        %else
            %assign errTxt = "Unhandled argument type '%<idNum[0]>'."
            %<LibReportError(errTxt)>
        %endif
    %endforeach
    %return adjustedInitializer
%endfunction

%% Function: FcnAssignChildGroupSIDs ===============================================================
%% Abstract:
%%   assign the child group SID to propagated model parameters
%%
%function FcnAssignChildGroupSID(childGroup, mdlRefIdx, childGroupSID) void
    %assign dynamicInitializer = childGroup.DynamicInitializer
    %if ISEMPTY(dynamicInitializer)
        %return dynamicInitializer
    %endif
    %assign fieldNames = FIELDNAMES(dynamicInitializer)
    %assign numElements = SIZE(fieldNames, 1)
    %foreach eIdx = numElements
        %assign fieldName = fieldNames[eIdx]
        %assign idNum = IDNUM(fieldName)
        %if idNum[0] == "TP"
            %assign blktpIdx = idNum[1]
            %assign mdlrefBlock = ::CompiledModel.ModelBlock[mdlRefIdx]
            %% The usage of the first instance block is OK here since all
            %% corresponding instances must have the same value or else
            %% reuse would not have been possible
            %assign prmIdx = mdlrefBlock.ParameterModelParameterIndices[blktpIdx]
            %assert prmIdx >= 0
            %assign mdlprm = ::CompiledModel.ModelParameters.Parameter[prmIdx]
            %addtorecord mdlprm ChildGroupSID childGroupSID
        %endif
    %endforeach
%endfunction

%% Function: CallModelrefBlockRegFcns ==============================================================
%% Abstract:
%%    Call all child model reference block registration functions.  Note
%% that the input mdlRefBlks can be empty.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants_crossfeature.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants4.m
%% TopTester: test/toolbox/simulink/variants/var-vss-general/tvss_sim_code_match_g984892.m
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tmg1317695_VC1.m
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tmg1331407_VC1.m
%% TopTester: test/toolbox/simulink/variants/var-inline-vsrc-systemtests/tVariantSource4.m
%%
%function CallModelrefBlockRegFcns(mdlRefBlks)
    %assign int32Type = LibGetDataTypeNameFromId(::CompiledModel.tSS_INT32)
    %assign uint32Type = LibGetDataTypeNameFromId(::CompiledModel.tSS_UINT32)
    %assign booleanType = LibGetDataTypeNameFromId(::CompiledModel.tSS_BOOLEAN)
    %assign charType = LibGetDataTypeNameFromId(::CompiledModel.tSS_CHAR)
    %assign realType = LibGetDataTypeNameFromId(::CompiledModel.tSS_DOUBLE)
    %assign baseSysIdx = GetBaseSystemIdx()
    %assign scalarTokens = LibGetScalarDataInitTokens()
    %openfile modelrefBuffer
    %if !ISEMPTY(mdlRefBlks)
        %assign needsTimingBridgeForDeploymentDiagram = TLC_FALSE
        %% First determine if any of the model blocks in this
        %% model need the global timing engine.
        %foreach rowIdx = SIZE(mdlRefBlks,0)
            %assign mdlRefInfo = mdlRefBlks[rowIdx]
            %assign mSysIdx = mdlRefInfo[0]
            %assign bIdx    = mdlRefInfo[1]
            %assign instIdx = mdlRefInfo[2]
            %with ::CompiledModel.System[mSysIdx].Block[bIdx]
                %assign blk = ::CompiledModel.System[mSysIdx].Block[bIdx]
                %% The usage of the first instance modelBlock is OK here because
                %% all corresponding instances across parent reusable subsystems
                %% must have a consistent state
                %assert 0 == blk.DeletedInIR
                %assign blockInterface = GetModelrefInterface(blk)
                %if blockInterface.NeedsGlobalTimingEngine
                    %assign ::tMdlRefTimingBridgeAccessed = TLC_TRUE
                    %if LibIsDeploymentDiagram() && ...
                        !SLibIsMappedSystemInDeploymentDiagram(mSysIdx)
                        %assign needsTimingBridgeForDeploymentDiagram = TLC_TRUE
                    %endif
                    %break
                %endif
            %endwith
        %endforeach

        %if !LibIsDeploymentDiagram() || needsTimingBridgeForDeploymentDiagram
            %% We only need to declare a local timing bridge
            %% for ERT based targets.  If the target is simstruct based
            %% (like RSIM), then the simstruct will already have a timing bridge.


            %if !IsModelReferenceTarget() && SLibIsERTCodeFormat() && ...
                ::tMdlRefTimingBridgeAccessed
                %if !MultiInstanceERTCode
                    %assign timingVarName = SLibGetGlobalTimingBridge()
                    %assign timingVar = "rtTimingBridge %<timingVarName>;"
                    %<SLibCacheCodeToFile("mdl_data_defn", timingVar)>
                    %<SLibCacheCodeToFile("mdl_priv_extern_data_decl", "extern " + timingVar)>

                    %assign declFile = SLibGetFullFileNameForCode("mdl_priv_extern_data_decl")
                    %assign defnFile = SLibGetFullFileNameForCode("mdl_dat_defn")
                    %% rtTimingBridge is defined in model_reference_types.h
                    %<SLibUpdateHeadersNeededByFile(declFile, SLibCoderModelReferenceTypesBaseName() + ".h")>
                    %<SLibUpdateGlobalSymbolTableForFile(declFile, timingVarName)>
                    %<SLibUpdateLocalSymbolTableForFile(defnFile, timingVarName)>
                %endif
                {
                    %% Determine if any clockticks are needed.  Note that if a long clock
                    %% tick is needed, then the normal clock tick is also needed since they
                    %% come in pairs.
                    %assign needClockTicks = TLC_FALSE
                    %assign needLongClockTicks = TLC_FALSE
                    %if SLibGetUsingTimerServiceLevel() < 3
                        %foreach idx = NumRuntimeExportedRates
                            %if ClockTickForTIDIsReqFcn(idx)
                                %assign needClockTicks = TLC_TRUE
                                %if LongClockTickForTIDIsReqFcn(idx)
                                    %assign needLongClockTicks = TLC_TRUE
                                    %break
                                %endif
                            %endif
                        %endforeach

                        %if needClockTicks
                            static %<uint32Type> *clockTickPtrs[%<NumSampleTimes>];
                            %if needLongClockTicks
                                static %<uint32Type> *clockTickHPtrs[%<NumSampleTimes>];
                            %endif
                        %endif
                        %if RTMTimePtrIsReqFcn() || RTMTaskTimeIsReqFcnForTID(0)
                            static %<realType> *taskTimePtrs[%<NumSampleTimes>];
                        %endif
                    %endif

                    %if ::CompiledModel.SingleRate != "yes"
                        %if RTMTaskCountersIsReqFcn()
                            static %<uint32Type> *taskCounterPtrs;
                        %endif
                        %if ERTPerTaskSampleHitsIsReqFcn()
                            %assign rateTransitionSize = ...
                                "(%<NumSampleTimes> * %<NumSampleTimes>)"
                            static %<booleanType> *rateTransitionPtrs[%<rateTransitionSize>];
                        %endif
                    %endif

                    %<SLibGetGlobalTimingBridge()>.nTasks = %<NumSampleTimes>;

                    %if SLibGetUsingTimerServiceLevel() < 3
                        %if needClockTicks
                            %foreach idx = NumSampleTimes
                                %if ClockTickForTIDIsReqFcn(idx)
                                    clockTickPtrs[%<idx>] = &(%<RTMGet("ClockTick%<idx>")>);
                                %else
                                    clockTickPtrs[%<idx>] = %<SLibGetNullDefinitionFromTfl()>;
                                %endif
                                %if needLongClockTicks
                                    %if LongClockTickForTIDIsReqFcn(idx)
                                        clockTickHPtrs[%<idx>] = &(%<RTMGet("ClockTickH%<idx>")>);
                                    %else
                                        clockTickHPtrs[%<idx>] = %<SLibGetNullDefinitionFromTfl()>;
                                    %endif
                                %endif
                            %endforeach
                            %<SLibGetGlobalTimingBridge()>.clockTick = clockTickPtrs;
                            %if needLongClockTicks
                                %<SLibGetGlobalTimingBridge()>.clockTickH = clockTickHPtrs;
                            %else
                                %<SLibGetGlobalTimingBridge()>.clockTickH = %<SLibGetNullDefinitionFromTfl()>;
                            %endif
                        %else
                            %<SLibGetGlobalTimingBridge()>.clockTick = %<SLibGetNullDefinitionFromTfl()>;
                            %<SLibGetGlobalTimingBridge()>.clockTickH = %<SLibGetNullDefinitionFromTfl()>;
                        %endif
                    %endif

                    %if ::CompiledModel.SingleRate != "yes"
                        %if RTMTaskCountersIsReqFcn()
                            %assign cTick = RTMGet("TaskCounters")
                            taskCounterPtrs = ...
                                &(%<cTick>.%<SLibERTMultiRateCounterField(0)>);
                            %<SLibGetGlobalTimingBridge()>.taskCounter = taskCounterPtrs;
                        %endif
                        %if ERTPerTaskSampleHitsIsReqFcn()
                            %assign shMat = RTMGet("PerTaskSampleHits")
                            %foreach i = NumRuntimeExportedRates
                                %foreach j = NumRuntimeExportedRates
                                    %if SLibGetNeedRateInteraction(i,j)
                                        %if SuppressMultiTaskScheduler || (UseTargetTaskScheduler() && !SLibSingleTasking())
                                            %assign val = "%<RTMGet("PerTaskSampleHits")>."...
                                                "b_%<SLibERTMultiRateTimingField(j,i)>"
                                        %else
                                            %assign val = "%<RTMGet("PerTaskSampleHits")>."...
                                                "%<SLibERTMultiRateTimingField(j,i)>"
                                        %endif
                                        rateTransitionPtrs[%<i>*%<NumSampleTimes> + %<j>] \
                                        = &(%<val>);
                                    %endif
                                %endforeach
                            %endforeach
                            %<SLibGetGlobalTimingBridge()>.rateTransition = rateTransitionPtrs;
                        %endif
                    %endif

                    %if SLibGetUsingTimerServiceLevel() < 3
                        %if RTMTimePtrIsReqFcn() || RTMTaskTimeIsReqFcnForTID(0)
                            %foreach idx = NumSampleTimes
                                %if SampleTime[idx].NeedFloatTime == "yes"
                                    taskTimePtrs[%<idx>] = &(%<LibGetTaskTime(idx)>);
                                %else
                                    taskTimePtrs[%<idx>] = %<SLibGetNullDefinitionFromTfl()>;
                                %endif
                            %endforeach
                            %<SLibGetGlobalTimingBridge()>.taskTime = taskTimePtrs;
                        %endif
                    %endif

                    %if RTMFirstInitCondFlagIsReqFcn()
                        %<SLibGetGlobalTimingBridge()>.firstInitCond = &%<RTMIs("FirstInitCond")>;
                    %endif
                }
            %endif %% !IsModelReferenceTarget() && SLibIsERTCodeFormat() && ...
        %endif %% !LibIsDeploymentDiagram() || needsTimingBridgeForDeploymentDiagram

        %% For the top model:
        %% copy the global timer indices from parent array (globalTimerIndices)
        %% to the child arrays (mdlRef<...>_globalTimerIndices)
        %% Note
        %% 1. Similar code for model ref targets exist in LibDumpERTAndModelrefRegExecution
        %% 2. We don't copy the global timer indices from parent (globalTimerIndices)
        %%    on to MdlRefGlobalTimerIndices field of RTM (as this does not exist)
        %if !IsModelReferenceTarget()
            %<initializeRTMAndChildGlobalTimerIndices()>
        %endif

        %% For the top model:
        %% copy the global runtime event indices from parent array (globalRuntimeEventIndices)
        %% to the child arrays (mdlRef<...>_globalRuntimeEventIndices)
        %% Note
        %% 1. Similar code for model ref targets exist in LibDumpERTAndModelrefRegExecution
        %% 2. We don't copy the global runtime event indices from parent (globalRuntimeEventIndices)
        %%    on to MdlRefGlobalRuntimeEventIndices field of RTM (as this does not exist)
        %if !IsModelReferenceTarget()
            %<initializeRTMAndChildGlobalRuntimeEventIndices()>
        %endif

        %% Add information to generate the top model's initialize to generate the
        %% data need to pass into the child model's initalize
        %if !IsModelReferenceTarget() && ISFIELD(::CompiledModel, "NumDataTransfers") && ::CompiledModel.NumDataTransfers > 0
            %assign rteBlkDWorkIndex = ::CompiledModel.RteBlockDWorkIndex
            %with System[NumSystems-1]
                const %<uint32Type> *gblDataTransferIds%<scalarTokens[0]>&%<LibBlockDWork(::CompiledModel.DWorks.DWork[rteBlkDWorkIndex],"", "", 0)>%<scalarTokens[1]>;
            %endwith
        %endif
    %endif %% !ISEMPTY(mdlRefBlks)

    %if LibIsDeploymentDiagram()
        %assign buf = SLibDeploymentCallModelrefBlockRegFcns(mdlRefBlks)
        %if !WHITE_SPACE(buf)
            %<buf>
        %endif
    %endif

    %with ::CompiledModel.System[baseSysIdx]
        %assign mdlBlkIdx = 0
        %foreach rowIdx = SIZE(mdlRefBlks,0)
            %assign mdlRefInfo = mdlRefBlks[rowIdx]
            %assign mSysIdx = mdlRefInfo[0]
            %assign bIdx    = mdlRefInfo[1]
            %assign instIdx = mdlRefInfo[2]
            %assign thisSystem = ::CompiledModel.System[mSysIdx]
            %assign thisBlock = thisSystem.Block[bIdx]
            %with thisBlock
                %% The usage of the first instance modelBlock is OK here because
                %% all corresponding instances across parent reusable subsystems
                %% must have a consistent state and interface
                %assert 0 == thisBlock.DeletedInIR
                %assign blockInterface = GetModelrefInterface(thisBlock)
                %assign doSSInitCacheClose = TLC_FALSE
                %if instIdx != -1
                    %assign standaloneSysIdx = thisSystem.StandaloneParentSysIdx[instIdx]
                    %if standaloneSysIdx != -1
                        %% cache registration fcn to parent standalone initialize fcn
                        %openfile stdSSBuffer
                        %assign doSSInitCacheClose = TLC_TRUE
                    %endif
                %endif

                %assign tmpVec = [%<mdlRefInfo[3]>, %<mdlRefInfo[4]>]
                %assign bpath  = STRING(SLibMangledGrBlockPath(tmpVec))
                %if EXISTS(slrt)
                    %%SPECIAL CASE FOR SLRT
                    %assign bpath  = STRING(SLibMangledGrBlockPath(tmpVec))
                    %assign bpath = FEVAL("xpcgate","htmlencode",bpath)
                %endif

                %if MdlRefIsCPPClassGenMode
                    %assign needsAuxilaryRegFcns = ...
                        blockInterface.RTMAccessed || ...
                        blockInterface.NeedsErrorStatus || ...
                        blockInterface.StopReqAccessed || ...
                        blockInterface.NeedsGlobalTimingEngine || ...
                        (ISFIELD(blockInterface, "RegFcnNeedsCAPIArgs") && ...
                        blockInterface.RegFcnNeedsCAPIArgs)
                %else
                    %assign needsAuxilaryRegFcns = TLC_FALSE
                %endif
                %if ISFIELD(blockInterface, "RegistrationFcn")
                    /* Model Initialize function for %<Type> Block: %<SLibGrBlockCommentName(thisBlock.GrSrc)> */
                    %% TopTester : test/toolbox/simulink/variants/var-inline-mdlref/tmdlref_basic.m -testspec:g1300511

                    %if SLibGetEnableFileControlForEntryPointFcns()
                        %assign modelInitializeFunctionSourceFile = GetEntryPointFcnMappedFile("InitFcn", "Source", 0)
                    %else
                        %assign modelInitializeFunctionSourceFile = SLibGetFullFileNameForCode("mdl_fcn_defn")
                    %endif

                    %<SLibUpdateLocalSymbolTableForFile(modelInitializeFunctionSourceFile, blockInterface.Name)>

                    %if ISFIELD(blockInterface.RegistrationFcn, "FcnName")
                        %<SLibUpdateLocalSymbolTableForFile(modelInitializeFunctionSourceFile, blockInterface.RegistrationFcn.FcnName)>
                    %endif

                    %assign sysIdxForMdlBlk = thisBlock.BlockIdx[0]
                    %assign blockSystem = ::CompiledModel.System[sysIdxForMdlBlk]
                    %assign vcRecord = SLibMdlRefNetInlineVariantPreprocessorCondition(mSysIdx, instIdx, bIdx)
                    %assign parentIfCond =  vcRecord.ifCond
                    %assign parentIfEndCond = vcRecord.endIfCond
                    %<parentIfCond>
                    %assign mdlBlk = ::CompiledModel.ModelBlock[rowIdx]
                    %if ISFIELD(mdlBlk, "ForEachSSLoopBnds")
                        %assign ::NeedForEachLoopInReg = TLC_TRUE
                        %assign ::NumForEachLoopHierarchyLevel = SIZE(mdlBlk.ForEachSSLoopBnds,1)
                        %% Calculate the total number of for-loop iterations
                        %assign numForLoops = 1
                        %foreach levelIdx = ::NumForEachLoopHierarchyLevel
                            %assign numForLoops = numForLoops * mdlBlk.ForEachSSLoopBnds[levelIdx]
                        %endforeach
                        %assign ::NeedLoopUnrolling = ((FEVAL("slsvTestingHook", "ForEachCodeGenLoopUnrolling") > 0) && (numForLoops < RollThreshold))
                        {
                            %if (::NeedLoopUnrolling)
                                %% Initialize counter vector for loop unrolling
                                %assign ::Counter4LoopUnrolling = []
                                %foreach levelIdx = ::NumForEachLoopHierarchyLevel
                                    %assign ::Counter4LoopUnrolling = ::Counter4LoopUnrolling + 0
                                %endforeach
                                %% Generate the unrolled loop
                                %foreach loopIdx = numForLoops
                                    %assign ::ForEachLoopHierarchyLevel = 1
                                    %<GetFunctionStr(thisBlock, "Registration", instIdx, "", mdlBlkIdx, bpath)>
                                    %% Update counter vector by adding 1 to the first level (the inner most ForEach)
                                    %foreach levelIdx = ::NumForEachLoopHierarchyLevel
                                        %assign ::Counter4LoopUnrolling[levelIdx] = ::Counter4LoopUnrolling[levelIdx] + 1
                                        %if (::Counter4LoopUnrolling[levelIdx] < mdlBlk.ForEachSSLoopBnds[levelIdx])
                                            %break
                                        %else
                                            %assign ::Counter4LoopUnrolling[levelIdx] = 0
                                        %endif
                                    %endforeach
                                %endforeach
                            %else
                                %assign ::ForEachLoopHierarchyLevel = ::NumForEachLoopHierarchyLevel
                                %foreach ssIdx = SIZE(mdlBlk.ForEachSSLoopBnds,1)
                                    %assign iterVar = "i_%<ForEachLoopHierarchyLevel>"
                                    %assign ::ForEachLoopHierarchyLevel = ::ForEachLoopHierarchyLevel - 1
                                    %<int32Type> %<iterVar>;
                                    for (%<iterVar> = 0; %<iterVar> < %<mdlBlk.ForEachSSLoopBnds[::ForEachLoopHierarchyLevel]>; %<iterVar>++) {
                                    %endforeach
                                    %assign ::ForEachLoopHierarchyLevel = 1

                                    %% Initialize child coder data groups when a model block is inside a ForEach SS
                                    %assign mdlrefKey = FcnCoderGroupIndexMapKey(rowIdx)
                                    %if ISFIELD(::CompiledModel.ChildGroupInitInForEachMap, mdlrefKey)
                                        %assign childGroupInits = GETFIELD(::CompiledModel.ChildGroupInitInForEachMap, mdlrefKey)
                                        %<childGroupInits>
                                    %endif

                                    %<GetFunctionStr(thisBlock, ...
                                        "Registration", instIdx, "", mdlBlkIdx, bpath)>
                                    %foreach ssIdx = SIZE(mdlBlk.ForEachSSLoopBnds,1)
                                    }
                                %endforeach
                            %endif
                        }
                        %assign ::NeedForEachLoopInReg = TLC_FALSE
                    %else
                        %<GetFunctionStr(thisBlock, ...
                            "Registration", instIdx, "", mdlBlkIdx, bpath)>
                    %endif

                    %<parentIfEndCond>
                %elseif needsAuxilaryRegFcns
                    /* Model Initialize function for %<Type> Block: '%<Name>' */
                    %assign sysIdxForMdlBlk = thisBlock.BlockIdx[0]
                    %% The usage of the first instance modelBlock is OK here because
                    %% all corresponding instances across parent reusable subsystems
                    %% must have consistent conditions
                    %assign blockSystem = ::CompiledModel.System[sysIdxForMdlBlk]
                    %assign vcRecord = SLibMdlRefNetInlineVariantPreprocessorCondition(mSysIdx, instIdx, bIdx)
                    %assign parentIfCond =  vcRecord.ifCond
                    %assign parentIfEndCond = vcRecord.endIfCond
                    %<parentIfCond>
                    %<SLibGetModelBlockRegistrationFunctionForCppClassGen(thisBlock,bpath,blockInterface,instIdx,mdlBlkIdx,mSysIdx)>
                    %<parentIfEndCond>
                %endif
                %if (::CompiledModel.RTWStatesLogging || (isRAccel&&(RTWCAPISignals==1))   ) && ...
                    !IsModelReferenceTarget() && !thisBlock.ParamSettings.InsideForEachSS && ...
                    !thisBlock.ParamSettings.ProtectedModelBlock
                    %if GenRTModel
                        %assign rtm_mmi = "&(%<RTMGet("DataMapInfo")>.mmi)"
                    %else
                        %assign rtm_mmi = "&(%<RSimRTWCAPIVarPtr>->mmi)"
                    %endif
                    %assign childMMI = "rtwCAPI_GetChildMMI(%<rtm_mmi>,%<mdlBlkIdx>)"
                    {
                        /* MAT-file logging: Update full-paths stored in the MMI */
                        %assign bpath_unmangled  = STRING(SLibGrBlockPath(tmpVec))
                        %assign bpath_escaped = FEVAL("coder.internal.getEscapedString", bpath_unmangled)
                        %<charType> *tempStr%<scalarTokens[0]>rtwCAPI_EncodePath("%<bpath_escaped>")%<scalarTokens[1]>;
                        rtwCAPI_UpdateFullPaths((%<childMMI>), tempStr, 1);
                        utFree(tempStr);
                    }
                %endif

                %if doSSInitCacheClose
                    %closefile stdSSBuffer
                    %<LibAddToSystemField(System[standaloneSysIdx],"CachedInitializeDataBody",...
                        "\n" + stdSSBuffer+ "\n")>
                %endif

                %<SLibDumpServiceInitForChildModel(thisBlock)>

            %endwith

            %% ChildMMI's are only created for unprotected models
            %if !thisBlock.ParamSettings.ProtectedModelBlock
                %assign mdlBlkIdx = mdlBlkIdx + 1
            %endif
        %endforeach
        %% We need to dump again ground declarations for model reference.
        %% This case happens when a scalar Ground signal is feeding a Reusable
        %% subsystem and the reusable subsystem contains a Model Reference
        %% Block
        %%            -------------------
        %%           |     ----------    |
        %%  Grnd sig |    |          |   |
        %%  -------->|--->|          |   |
        %%           |    |          |   |
        %%           |    |          |   |
        %%      ---->|--->|          |   |
        %%  Grnd Sig |    |          |   |
        %%           |     ----------    |
        %%           |     Model Block   |
        %%            -------------------
        %%             Reusable Subsystem

        %assign ::CurrentBufferFileName = SLibGetFullFileNameForCode("mdl_data_defn")
        %<SLibCacheCodeToFile("mdl_data_defn", LibDumpGroundDeclarations(0))>
        %assign ::CurrentBufferFileName = ""

    %endwith

    %if ((RTWCAPI == 1)  && IsModelReferenceTarget()) && !GenerateClassInterface
        %assign mmiStr = "%<RTMGetModelSS()>->DataMapInfo.mmi"
        /* Initialize Parent model MMI */
        if ((rt_ParentMMI != %<SLibGetNullDefinitionFromTfl()>) && (rt_ChildPath != %<SLibGetNullDefinitionFromTfl()>))
        {
            rtwCAPI_SetChildMMI(*rt_ParentMMI, rt_ChildMMIIdx, &(%<mmiStr>));
            rtwCAPI_SetPath(%<mmiStr>, rt_ChildPath);
            rtwCAPI_MMISetContStateStartIndex(%<mmiStr>, rt_CSTATEIdx);
        }
    %endif

    %if IsModelReferenceForASimstructBasedTarget()
        %if EXISTS(SolverResetInfo) && SolverResetInfo.NumNonContDerivSignals > 0
            %assign numNoncontDerivSigs = SIZE(SolverResetInfo.NonContDerivSignal,1)
            %assign arrayIdx = 0
            %foreach idx =  numNoncontDerivSigs
                %assign dU = SolverResetInfo.NonContDerivSignal[idx]
                %if ISFIELD(dU,"MdlRefInfo")
                    %assign mdlRefInfo = dU.MdlRefInfo
                    %assign mSysIdx = mdlRefInfo[0][0]
                    %assign bIdx    = mdlRefInfo[0][1]
                    %assign instIdx = mdlRefInfo[0][2]
                    %assign port    = mdlRefInfo[0][3]
                    %assign blk = System[mSysIdx].Block[bIdx]
                    %assign name = blk.ParamSettings.ReferencedModelName
                    %assign mangleName = FcnGetNoncontMangledName(name, mSysIdx, ...
                        bIdx, instIdx)
                    %foreach subIdx = dU.NumMdlRefNonContSigs
                        %<RTMSetNonContDerivSignal(arrayIdx,...
                            "mr_%<mangleName>nonContOutputArray[%<port>][%<subIdx>].sizeInBytes", ...
                            "mr_%<mangleName>nonContOutputArray[%<port>][%<subIdx>].currVal")>;
                        %assign arrayIdx = arrayIdx + 1
                    %endforeach
                %else
                    %if dU.ComplexSignal
                        %assign dtype = LibGetDataTypeComplexNameFromId(dU.DataTypeIdx)
                    %else
                        %assign dtype = LibGetDataTypeNameFromId(dU.DataTypeIdx)
                    %endif
                    %% For NonContDerivSignal inside For Each subsystem, we need to
                    %% index each For Each vargroup level by right index
                    %if ISFIELD(dU, "ForEachSSIterIndices")
                        %assign ::UseConstantForVarGroupIdx = TLC_TRUE
                        %assign ::VarGroupIndexVector = dU.ForEachSSIterIndices
                        %assign ::VarGroupIndexVectorSize = SIZE(::VarGroupIndexVector, 1)
                        %assign ::VarGroupIndexVectorIdx = ::VarGroupIndexVectorSize - 1
                    %endif
                    %<RTMSetNonContDerivSignal(arrayIdx,...
                        "%<dU.RegionLen>*sizeof(%<dtype>)", ...
                        "%<GetNonContAddress(dU, System[baseSysIdx])>")>;
                    %if ISFIELD(dU, "ForEachSSIterIndices")
                        %assign ::UseConstantForVarGroupIdx = TLC_FALSE
                        %assign ::VarGroupIndexVectorIdx = ::VarGroupIndexVectorSize - 1
                    %endif
                    %assign arrayIdx = arrayIdx + 1
                %endif
            %endforeach
        %endif
        %if EXISTS(SolverResetInfo) &&  ISFIELD(SolverResetInfo,"NonContOutputSignals")
            %foreach idx = ExternalOutputs.NumExternalOutputs
                %assign nonContOut = ...
                    SolverResetInfo.NonContOutputSignals.NonContOutput[idx]
                %assign numNonContSigs = ISFIELD(nonContOut,"NonContOutputSignal") ? ...
                    SIZE(nonContOut.NonContOutputSignal,1) : 0
                %assign arrayIdx = -1
                %foreach cIdx =  numNonContSigs
                    %assign nonContElem = nonContOut.NonContOutputSignal[cIdx]
                    %assign regLen = nonContElem.RegionLen
                    %if nonContElem.ComplexSignal
                        %assign dType = LibGetDataTypeComplexNameFromId(nonContElem.DataTypeIdx)
                    %else
                        %assign dType = LibGetDataTypeNameFromId(LibGetDataTypeIdAliasedThruToFromId(nonContElem.DataTypeIdx))
                    %endif
                    %% If this signal is coming from a submodel, then we
                    %% can't initialize it here.  We will initialize the
                    %% information after we call the submodels registration function
                    if (mr_nonContOutputArray[%<idx>] != %<SLibGetNullDefinitionFromTfl()>) {
                        %if ISFIELD(nonContElem,"MdlRefInfo")
                            %assign mdlRefInfo = nonContElem.MdlRefInfo
                            %assign mSysIdx = mdlRefInfo[0][0]
                            %assign bIdx    = mdlRefInfo[0][1]
                            %assign instIdx = mdlRefInfo[0][2]
                            %assign port    = mdlRefInfo[0][3]
                            %assign blk = System[mSysIdx].Block[bIdx]
                            %assign name = blk.ParamSettings.ReferencedModelName
                            %assign mangleName = FcnGetNoncontMangledName(name, mSysIdx, ...
                                bIdx, instIdx)
                            %foreach mIdx = nonContElem.NumMdlRefNonContSigs
                                %assign arrayIdx = arrayIdx + 1
                                mr_nonContOutputArray[%<idx>][%<arrayIdx>].sizeInBytes = ...
                                    mr_%<mangleName>nonContOutputArray[%<port>][%<mIdx>].sizeInBytes;
                                mr_nonContOutputArray[%<idx>][%<arrayIdx>].currVal = ...
                                    mr_%<mangleName>nonContOutputArray[%<port>][%<mIdx>].currVal;
                                %% If this is the last array, set the next pointer to NULL
                                %if cIdx == numNonContSigs - 1 && ...
                                    mIdx == nonContElem.NumMdlRefNonContSigs -1
                                    mr_nonContOutputArray[%<idx>][%<arrayIdx>].next = %<SLibGetNullDefinitionFromTfl()>;
                                %else
                                    %assign nextIdx = arrayIdx + 1
                                    mr_nonContOutputArray[%<idx>][%<arrayIdx>].next = ...
                                        &(mr_nonContOutputArray[%<idx>][%<nextIdx>]);
                                %endif
                            %endforeach
                        %else
                            %% For NonContDerivSignal inside For Each subsystem, we need to
                            %% index each For Each vargroup level by right index
                            %if ISFIELD(nonContElem, "ForEachSSIterIndices")
                                %assign ::UseConstantForVarGroupIdx = TLC_TRUE
                                %assign ::VarGroupIndexVector = nonContElem.ForEachSSIterIndices
                                %assign ::VarGroupIndexVectorSize = SIZE(::VarGroupIndexVector, 1)
                                %assign ::VarGroupIndexVectorIdx = ::VarGroupIndexVectorSize - 1
                            %endif
                            %assign address = GetNonContAddress(nonContElem, ...
                                ::CompiledModel.System[GetBaseSystemIdx()])
                            %if ISFIELD(nonContElem, "ForEachSSIterIndices")
                                %assign ::UseConstantForVarGroupIdx = TLC_FALSE
                                %assign ::VarGroupIndexVectorIdx = ::VarGroupIndexVectorSize - 1
                            %endif
                            %assign arrayIdx = arrayIdx + 1
                            mr_nonContOutputArray[%<idx>][%<arrayIdx>].sizeInBytes = ...
                                %<regLen>*sizeof(%<dType>);
                            mr_nonContOutputArray[%<idx>][%<arrayIdx>].currVal = (%<charType> *)%<address>;
                            %if cIdx ==  numNonContSigs - 1
                                mr_nonContOutputArray[%<idx>][%<arrayIdx>].next = %<SLibGetNullDefinitionFromTfl()>;
                            %else
                                %assign nextIdx = arrayIdx + 1
                                mr_nonContOutputArray[%<idx>][%<arrayIdx>].next = ...
                                    &(mr_nonContOutputArray[%<idx>][%<nextIdx>]);
                            %endif
                        %endif
                    }
                %endforeach
            %endforeach
        %endif
    %endif

    %with ::CompiledModel.System[baseSysIdx]
        %<SLibDumpServicePortProvidersInit()>
    %endwith

    %closefile modelrefBuffer
    %return modelrefBuffer
%endfunction %%CallModelrefBlockRegFcns

%% Function: FcnGetChildCoderGroupDWorkPathFromSys
%%
%function FcnGetChildCoderGroupDWorkPathFromSys(modelBlock, blockInterface, instIdx, accSysIdx)
    %if !blockInterface.OkToMultiInstance
        %assign dworkPath = ""
    %elseif blockInterface.rtmAllocateInParent && ISFIELD(modelBlock, "ModelInstVarIndex") && modelBlock.ModelInstVarIndex > -1
        %assign selfVarGroupIdx = SLibGetSelfVarGroupIndexForModelBlock(modelBlock, instIdx)
        %assert selfVarGroupIdx > -1
        %assign selfCGTypeIdx = ::CompiledModel.VarGroups.VarGroup[selfVarGroupIdx].CGTypeIdx
        %if LibCGTypeIsMatrix(selfCGTypeIdx)
            %assign selfCGTypeIdx = LibCGTypeBaseIndex(selfCGTypeIdx)
        %endif
        %assign fldName = LibCGTypeMemberName(selfCGTypeIdx, modelBlock.ModelInstVarIndex)
        %assign vgPath = SLibCGIRVarGroupPath(selfVarGroupIdx, accSysIdx, TLC_FALSE)
        %assign dworkPath = vgPath + fldName
    %else
        %assign dworkCategory = FcnGetModelBlockDWorkCategory(modelBlock)
        %assign accSys = ::CompiledModel.System[accSysIdx]
        %assign varGroupIdx = FcnSysVarGroupIndex(accSys, dworkCategory, instIdx)
        %assert varGroupIdx > -1
        %assign varGroupPath = SLibCGIRVarGroupPath(varGroupIdx, accSysIdx, accSys.CrossNoArgFcnBound)
        %assign dworkIdx = SLibGetStructDWorkIdxForModelRefBlk(modelBlock)
        %assign dwRec = ::CompiledModel.DWorks.DWork[modelBlock.DWork[dworkIdx].FirstRootIdx]
        %assign dworkPath = varGroupPath + LibGetRecordIdentifier(dwRec)
    %endif
    %return dworkPath
%endfunction

%% Function: FcnGetChildCoderGroupDWorkPath ========================================================
%% Abstract:
%%    Get dwork path to use with child codergroup
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function FcnGetChildCoderGroupDWorkPath(modelBlock, blockInterface, instIdx, isMdlblkInForEach) void
    %if !blockInterface.OkToMultiInstance
        %assign dworkPath = ""
    %elseif blockInterface.rtmAllocateInParent
        %if isMdlblkInForEach && ...
            ISFIELD(modelBlock, "ModelInstVarIndex") && (modelBlock.ModelInstVarIndex > -1)
            %assign selfVarGroupIdx = SLibGetSelfVarGroupIndexForModelBlock(modelBlock, instIdx)
            %assert selfVarGroupIdx > -1
            %assign selfCGTypeIdx = ::CompiledModel.VarGroups.VarGroup[selfVarGroupIdx].CGTypeIdx
            %if LibCGTypeIsMatrix(selfCGTypeIdx)
                %assign selfCGTypeIdx = LibCGTypeBaseIndex(selfCGTypeIdx)
            %endif
            %assign fldName = LibCGTypeMemberName(selfCGTypeIdx, modelBlock.ModelInstVarIndex)
            %assign vgPath = SLibCGIRVarGroupPath(selfVarGroupIdx, NumSystems-1, TLC_FALSE)
            %assign dworkPath = vgPath + fldName
        %elseif IsModelReferenceTarget() && ::CompiledModel.OkToMultiInstanceModelref
            %% The usage of the first instance modelBlock is OK here because
            %% all corresponding instances across parent reusable subsystems
            %% must have the same identifier
            %assign dworkPath = modelBlock.Identifier
        %else
            %assign dworkPath = SLibGetModelBlockStructDWorkArg( ...
                "", NumSystems-1, modelBlock, "RegistrationFcn", instIdx)
        %endif
    %else
        %assign dworkPath = SLibGetModelBlockStructDWorkArg( ...
            "", NumSystems-1, modelBlock, "RegistrationFcn", instIdx)
    %endif
    %return dworkPath
%endfunction

%% Function: FcnCoderGroupIndexMapKey ==============================================================
%% Abstract:
%%    compute the key to the coder group index map
%function FcnCoderGroupIndexMapKey(mdlRefIdx) void
    %assign mdlRefBlks = ::CompiledModel.ModelReferenceBlocks
    %assign mdlRefInfo = mdlRefBlks[mdlRefIdx]
    %assign sysIdx = mdlRefInfo[0]
    %assign blkIdx = mdlRefInfo[1]
    %assign instIdx = mdlRefInfo[2]
    %if instIdx < 0
        %assign instIdx = 0
    %endif
    %return "B%<sysIdx>_%<blkIdx>_%<instIdx>"
%endfunction

%% Function: FcnAddToCoderGroupIndexMap ============================================================
%% Abstract:
%%    add an entry to the CoderDataGroupIndexMap for a model block
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function FcnAddToCoderGroupIndexMap(mdlRefIdx, childGroup, childGroupIndex, mappedCoderDataGroupIndex) void
    %assign mapKey1 = FcnCoderGroupIndexMapKey(mdlRefIdx)
    %if !ISFIELD(::CompiledModel.CoderDataGroupIndexMap, mapKey1)
        %addtorecord ::CompiledModel.CoderDataGroupIndexMap %<mapKey1> {}
    %endif
    %assign indexMapEntry = ::CompiledModel.CoderDataGroupIndexMap.%<mapKey1>
    %% If a group originating in this child model, the secondary key is Group#.
    %% Otherwise, it is ChildGroup#
    %if childGroup.Depth == 0
        %assign mapKey2 = "Group" + childGroupIndex
    %else
        %assign mapKey2 = "ChildGroup" + childGroupIndex
    %endif
    %createrecord mapValue {}
    %addtorecord mapValue CoderDataGroupIndex mappedCoderDataGroupIndex
    %addtorecord indexMapEntry %<mapKey2> %<mapValue>
    %undef mapValue
%endfunction

%% Function: FcnCoderGroupIndexMapValue ============================================================
%% Abstract:
%%    return a value from the coder group index map
%function FcnCoderGroupIndexMapValue(mdlRefIdx, key) void
    %assign key1 = FcnCoderGroupIndexMapKey(mdlRefIdx)
    %assign value1 = ::CompiledModel.CoderDataGroupIndexMap.%<key1>
    %return value1.%<key>
%endfunction


%% Function: FcnGetCoderGroupSelfPath ==============================================================
%% Abstract:
%%    Compute the pointer path for a child coder group
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function FcnGetCoderGroupSelfPath(childGroup, blockInterface, dworkPath) void
    %if !blockInterface.OkToMultiInstance
        %assign pointerPath = childGroup.SelfPath
    %else
        %if blockInterface.rtmAllocateInParent
            %% self group has empty pointer path
            %if ISEMPTY(childGroup.SelfPath)
                %assign pointerPath = dworkPath
            %else
                %assign pointerPath = dworkPath + "." + childGroup.SelfPath
            %endif
        %else
            %if childGroup.Depth == 0
                %assign pointerPath = dworkPath + "." + childGroup.SelfPath
            %else
                %if ::isRAccel || ::isRSim
                    %assign pointerPath = dworkPath + "." + childGroup.SelfPath
                %else
                    %assign pointerPath = dworkPath + ".rtdw." + childGroup.SelfPath
                %endif
            %endif
        %endif
    %endif
    %return pointerPath
%endfunction

%% Function: FcnGetDynamicInitPath =================================================================
%% Abstract:
%%    Compute the dynamic init path
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function FcnGetDynamicInitPath(selfPath, modelBlock, blockInterface, dworkPath) void
    %if !blockInterface.OkToMultiInstance
        %assign dynamicInitPath = selfPath
    %else
        %if blockInterface.rtmAllocateInParent
            %% The usage of the first instance modelBlock is OK here because
            %% all corresponding instances across parent reusable subsystems
            %% must have the same identifier
            %assign dynamicInitPath = modelBlock.Identifier
        %else
            %if ::isRAccel || !SLibMultiInstance()
                %assign dynamicInitPath = dworkPath
            %else
                %assign dynamicInitPath = "rtdw." + dworkPath
            %endif
        %endif
    %endif
    %return dynamicInitPath
%endfunction

%% Function FcnGetNameOfVarGroupElementForPCGD =============================
%% Abstract:
%%   Compute the name of an element in a vargroup for a submodel
%%
%function FcnGetNameOfVarGroupElementForPCGD(varGroupIdx, modelBlockIndex) void
    %assign numElement = SLibVarGroupNumElements(varGroupIdx)
    %foreach elemIdx = numElement
        %assign idnum  = ...
            IDNUM(SLibVarGroupElementSource(varGroupIdx, elemIdx))
        %assign recType = idnum[0]
        %assign recIdx  = idnum[1]
        %if recType == "PCDG" && ...
            (modelBlockIndex == recIdx)
            %return SLibVarGroupElementName(varGroupIdx, elemIdx)
        %endif
    %endforeach
    %% We can get here for self for encapsulated C++, which doesn't nest hierarchically
    %return ""
%endfunction

%% Function FcnGetCoderGroupPath ===========================================
%% Abstract:
%%   Compute the GroupPath for a child coder group
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function FcnGetCoderGroupPath(childGroup, modelBlock, modelBlockIndex, mdlblkInstIdx, isMdlBlkInForEach) void

    %% Multi-instance, InParent child group adds element name as determined
    %% by this model, who is its parent
    %if !childGroup.SingleInstancePropagator
        %if childGroup.AsStructure == "InParent"
            %assign isModelSingleInstance = !SLibMultiInstance()
            %assign actualGroup = childGroup
            %if isModelSingleInstance && ...
                childGroup.IsPolymorphic && ...
                childGroup.ImplementationType == "MultiInstance"
                %assign singleGroupIdx = SLibGetSingleInstanceGroupIdx(childGroup)
                %assign actualGroup = ::CompiledModel.CoderDataGroup[singleGroupIdx]
            %endif
            %if !isMdlBlkInForEach
                %assign varGroupIdx = SLibGetRootVarGroupIdxForCoderGroup(actualGroup)
            %else
                %assign blkSystem = ::CompiledModel.System[modelBlock.BlockIdx[0]]
                %assign varGroupIdx = FcnSysVarGroupIndex(blkSystem, "CoderDataGroup" + actualGroup.Name, mdlblkInstIdx)
                %assert varGroupIdx > -1
            %endif

            %% self can fail to be present in this model even though in child model
            %% in which case varGroupIdx = -1
            %if varGroupIdx < 0
                %% The usage of the first instance modelBlock is OK here because
                %% all corresponding instances across parent reusable subsystems
                %% must have the same identifier
                %assign groupPath = modelBlock.Identifier
                %if !ISEMPTY(childGroup.GroupPath)
                    %assign groupPath = groupPath + "_" + childGroup.GroupPath
                %endif

                %% Otherwise we have a parent vargroup in this model at the root level
            %else
                %assign groupPath = FcnGetNameOfVarGroupElementForPCGD(varGroupIdx, modelBlockIndex)
                %if !ISEMPTY(childGroup.GroupPath)
                    %assign groupPath = groupPath + "." + childGroup.GroupPath
                %endif
                %% If the current model is single instance, and the child group is
                %% propagated from a multi-instance model so that we are now
                %% transitioning from a multi-instance portion of a model hierarchy
                %% to single instance, add the varGroups's root instance because its
                %% a lot easier to find it here than from the context of a parent model
                %% Exception: skip if InParent is implemented as unstructured in top model.
                %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
                %if isModelSingleInstance && varGroup.PackageAsStruct && !isMdlBlkInForEach
                    %assign structInstance = ISFIELD(varGroup, "StructureInstanceName") ? ...
                        varGroup.StructureInstanceName : varGroup.SelfStructureInstanceName
                    %assign groupPath = structInstance + "." + groupPath
                %endif
            %endif

        %else

            %% The usage of the first instance modelBlock is OK here because
            %% all corresponding instances across parent reusable subsystems
            %% must have the same identifier
            %if childGroup.IsSelf
                %assign groupPath = modelBlock.Identifier
                %% Now, multi-instance Standalone or InSelf
            %else
                %if SLibIsAutosarPIMCoderGroup(childGroup) || SLibIsAutosarInstPCoderGroup(childGroup)
                    %assign identifier = CGMODEL_ACCESS("String.rstrip", modelBlock.Identifier, "_")
                    %assign groupPath = identifier + "_" + childGroup.GroupPath
                %else
                    %assign groupPath = modelBlock.Identifier + "_" + childGroup.GroupPath
                %endif
            %endif
        %endif

        %% Single-instance propagator - remains unchanged
    %else
        %assign groupPath = childGroup.GroupPath
    %endif

    %return groupPath
%endfunction

%function FcnAdjustChildGroupPathForForEach(childGroupPath, parentGroup, mdlBlk, mdlblkInstIdx, internalPath)
    %assign blkSys = ::CompiledModel.System[mdlBlk.BlockIdx[0]]
    %assign groupVGName = "CoderDataGroup" + parentGroup.Name
    %assign parentVGIdx = FcnSysVarGroupIndex(blkSys, groupVGName, mdlblkInstIdx)
    %if parentVGIdx > -1
        %if internalPath
            %assign childGroupPath = ...
                SLibCGIRVarGroupPath(parentVGIdx, GetBaseSystemIdx(), blkSys.CrossNoArgFcnBound) + childGroupPath
        %else
            %assign childGroupPath = ...
                SLibCGIRVarGroupPath(parentVGIdx, NumSystems-1, blkSys.CrossNoArgFcnBound) + childGroupPath
        %endif
    %endif
    %return childGroupPath
%endfunction

%function FcnAdjustChildGroupPathForMultiInst(childGroupPath, parentGroup, mdlBlk)
    %if GenerateClassInterface
        %if parentGroup.AsStructure == "InParent"
            %assign delimiter = "->"
        %else
            %assign delimiter = "."
        %endif
        %assign childGroupPath = ...
            SLibCoderDataGroupRTMFieldName(parentGroup) + delimiter + childGroupPath
    %else
        %assign childGroupPath = ...
            SLibGetCoderDataGroupPointerFromRTM(parentGroup, 0) + "->" + childGroupPath
    %endif
    %return childGroupPath
%endfunction

%% Function FcnGenerateGroupInstance ============================================
%% Abstract:
%%    Do we generate an instance for the group?
%function FcnGenerateGroupInstance(childGroup) void
    %assign generateGroupInstance = TLC_FALSE

    %if !childGroup.IsImportedFromFile
        %if childGroup.AsStructure == "InParent"
            %assign isSelfGroup = SLibGetSelfCoderDataGroupIndex() > -1 && ...
                childGroup.Name == ::CompiledModel.CoderDataGroup[SLibGetSelfCoderDataGroupIndex()].Name
            %if childGroup.ContainsInstanceSpecificParameter
                %assign generateGroupInstance = !IsModelReferenceTarget()
            %elseif !isSelfGroup
                %assign generateGroupInstance = childGroup.Depth == 0
            %endif
        %elseif childGroup.AsStructure == "InSelf"
            %% InstP in order to provide initialization from the top
            %if childGroup.ContainsInstanceSpecificParameter
                %if Accelerator
                    %assign generateGroupInstance = (childGroup.Depth == 0)
                %elseif ::isRAccel || ::isRSim
                    %assign generateGroupInstance = childGroup.SingleInstanceDefiner
                %else
                    %assign generateGroupInstance = TLC_TRUE
                %endif
            %endif
        %else
            %assign generateGroupInstance = TLC_TRUE
        %endif
    %endif
    %return generateGroupInstance
%endfunction

%% Function: FcnCopyInstPForSimTargets =============================================================
%% Abstract:
%%   Copy instance-specific parameter values for sim targets
%function FcnCopyInstPForSimTargets(dynamicInitializer, childGroup) void
    %assign fieldNames = FIELDNAMES(dynamicInitializer)
    %assign numElements = SIZE(fieldNames, 1)
    %foreach eIdx = numElements
        %assign fieldName = fieldNames[eIdx]
        %assign idNum = IDNUM(fieldName)
        %if idNum[0] == "P"
            %assign dst = dynamicInitializer.%<fieldName>
            %assign mdlParam = ::CompiledModel.ModelParameters.Parameter[idNum[1]]
            %assign src = LibModelParameterAddr(mdlParam, "", "", 0)
            %assign sizeof = "sizeof(" + dst + ")"
            %assign memcpy = "(void) " + ...
                LibGenMemFcnCall("memcpy", "&(" + dst + ")", src, sizeof) + ";\n"
            %if ::isRAccel || Accelerator
                %% SLCOMPILER-4387 : Generate code for assignment of coder data group,
                %% before code for modelref initialize is generated. Child model initialize
                %% will memset() rtm. All the memcpy statements which are called before
                %% child model initialize will be useless. So, moving model parameter initialization
                %% memcpy statements after the child model initialization code.
                %assign ::CompiledModel.ChildCoderDataGroupDynamicInitializer  = ...
                    ::CompiledModel.ChildCoderDataGroupDynamicInitializer + memcpy
                %if !mdlParam.HasDescendantParamWrite
                    %assign ::CompiledModel.ChildCoderDataGroupAssignmentForParamTs = ...
                        ::CompiledModel.ChildCoderDataGroupAssignmentForParamTs + memcpy
                %endif
                %if ::isRAccel && !ISEMPTY(childGroup.SingleInstanceHeaderFile)
                    %<SLibUpdateHeadersNeededByFile(SLibGetFullFileNameForCode("mdl_src_incl"), childGroup.SingleInstanceHeaderFile)>
                %endif
            %else
                %assert ::isRSim
                %<LibMdlStartCustomCode(memcpy, "execution")>
            %endif
        %endif
    %endforeach
%endfunction

%function FcnLocalStructAccess(modelBlock, blockInterface, instIdx, isMdlblkInForEach)
    %assign localStructAccess = ""
    %if IsModelReferenceTarget()
        %if !::CompiledModel.OkToMultiInstanceModelref
            %assign localStructAccess = ""
        %elseif blockInterface.rtmAllocateInParent
            %if isMdlblkInForEach
                %% In this case, selfPath starts from root, so local access starts with ::tSimStruct
                %assign localStructAccess = ::tSimStruct + "->"
            %else
                %% When using self vargroup (rtmAllocateInParent), model block may be nested to subsystem self,
                %% whereas selfPath only contains the model block's path.
                %% In this case, local access needs to build up the path from root to model block.
                %assign localStructAccess = SLibGetPathToSimplifiedInterfaceModelBlock(modelBlock, instIdx)
            %endif
        %else
            %% The usage of the first instance modelBlock is OK here because
            %% all corresponding instances across parent reusable subsystems
            %% must have the same root
            %assign localStructAccess = SLibGetModelBlockVarGroupRoot(modelBlock)
        %endif
    %endif
    %return localStructAccess
%endfunction

%% Function: FcnAssignChildCoderGroupsInNonAllocators ==============================================
%% Abstract:
%%   Assign self pointers for coder groups in middle models with AsStructure=InParent
%function FcnAssignChildCoderGroupsInNonAllocators(childGroup, modelBlock, instIdx, blockInterface, isMdlblkInForEach, groupPath, selfPath) void
    %assign localStructAccess = FcnLocalStructAccess(modelBlock, blockInterface, instIdx, isMdlblkInForEach)
    %% The usage of the first instance modelBlock is OK here because
    %% all corresponding instances across parent reusable subsystems
    %% must have the same name and condition
    %assign comment = "/* Assign pointer for %<childGroup.Identification>, Block: '%<modelBlock.Name>' */\n"
    %assign condition = SLibMdlRefSystemPreprocessorCondition(modelBlock)
    %assign ppIf = ""
    %assign ppEndif = ""
    %if !ISEMPTY(condition)
        %assign ppIf = "#if " + condition + "\n"
        %assign ppEndif = "#endif\n"
    %endif
    %assign guardedInitStmt = ppIf + comment + ...
        "%<localStructAccess>%<selfPath> = &%<groupPath>;\n" + ppEndif
    %assign ::CompiledModel.ChildCoderDataGroupAssignmentForParamTs = ...
        ::CompiledModel.ChildCoderDataGroupAssignmentForParamTs + guardedInitStmt
    %if !isMdlblkInForEach
        %assign ::CompiledModel.ChildCoderDataGroupAssignmentForRegistration = ...
            ::CompiledModel.ChildCoderDataGroupAssignmentForRegistration + guardedInitStmt
    %else
        %assign ::childGroupInitsInForEach = ::childGroupInitsInForEach + guardedInitStmt
    %endif
%endfunction

%% Function: FcnFormDeclaration ====================================================================
%% Abstract:
%%   form data declaration
%function FcnFormDeclaration(childGroup, groupPath, ppCondition, initializer, comment, decl)
    %assign ppIf = ""
    %assign ppEndif = ""
    %if !ISEMPTY(ppCondition)
        %assign ppIf = "#if " + ppCondition
        %assign ppEndif = "#endif"
    %endif
    %assign declaration = "%<childGroup.Type> %<groupPath>%<initializer>;\n"
    %assign declaration = LibGetCppBracedInitStr(declaration)
    %if decl
        %assign declaration = SLibApplyMemSecToDataDeclForGroup(declaration, childGroup, groupPath, ::CompiledModel.ConfigSet, TLC_TRUE)
    %else
        %assign declaration = SLibApplyMemSecToDataDefnForGroup(declaration, childGroup, groupPath, ::CompiledModel.ConfigSet, TLC_TRUE)
    %endif
    %openfile declarationBuf
    %<ppIf>
    %<comment>
    %<declaration>
    %<ppEndif>
    %closefile declarationBuf
    %return declarationBuf
%endfunction

%% Function: FcnDeclareChildCoderGroups ============================================================
%% Abstract:
%%   declare and define child coder groups
%function FcnDeclareChildCoderGroups(childGroup, blockInterface, groupPath, ppCondition, initializer) void
    %if !WHITE_SPACE(initializer)
        %assign initializer = " = " + initializer
    %endif
    %if !ISEMPTY(childGroup.Type) && !ISEMPTY(groupPath)
        %assign comment = "/* Define buffer for %<childGroup.Identification>, Block: '%<Name>' */\n"
        %assign definition = FcnFormDeclaration(childGroup, groupPath, ppCondition, initializer, comment, TLC_FALSE)
        %assign defnFileFullName = ""
        %if ISEMPTY(childGroup.SingleInstanceDefinitionFileRule)
            %<SLibCacheCodeToFile("mdldata_data_defn", definition)>
            %assign defnFileFullName = SLibGetFullFileNameForCode("mdldata_data_defn")
        %else
            %assign defnFileNameRule = SLibGetFileNameWithoutExtension(childGroup.SingleInstanceDefinitionFileRule)
            %assign defnFileName = FEVAL("slInternal", "getCodePreviewUsingNamingService", ::CompiledModel.Name, defnFileNameRule, ::CompiledModel.Name, childGroup.UserProvidedName, ::CompiledModel.ConfigSet.CustomUserTokenString)
            %assign defnFile = SLibAddModelFile("SystemBody", "Simulink", defnFileName)
            %<SLibSetModelFileAttribute(defnFile, "Group", "data")>
            %assign declHdr = childGroup.SingleInstanceHeaderFile
            %if !ISEMPTY(declHdr)
                %<LibSetIncludesSection(defnFile, "RequiredIncludes", declHdr + ".h")>
            %endif
            %<SLibSetModelFileAttribute(defnFile, "Definitions", definition)>
            %assign defnFileFullName = defnFileName + "." + ::LangFileExt
        %endif
        %assign comment = "/* Declare buffer for %<childGroup.Identification>, Block: '%<Name>' */\n"
        %assign declaration = FcnFormDeclaration(childGroup, groupPath, ppCondition, "", comment, TLC_TRUE)
        %<SLibCacheCodeToFile("mdl_priv_data_define", declaration)>
        %assign fileName = SLibGetFullFileNameForCode("mdl_priv_data_define")
        %<SLibUpdateLocalSymbolTableForFile(fileName, childGroup.Type)>
        %<SLibUpdateGlobalSymbolTableForFile(fileName, groupPath)>
        %<SLibUpdateLocalSymbolTableForFile(defnFileFullName, groupPath)>
    %endif
%endfunction

%% Function: FcnAssignChildCoderGroupsInAllocators =================================================
%% Abstract:
%%   Assign self pointers for coder groups in allocating models with AsStructure=InParent
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function FcnAssignChildCoderGroupsInAllocators(childGroup, modelBlock, isMdlblkInForEach, groupPath, selfPath) void
    %% The usage of the first instance modelBlock is OK here because
    %% all corresponding instances across parent reusable subsystems
    %% must have the same name and condition
    %assign comment = "/* Assign pointer for %<childGroup.Identification>, Block: '%<modelBlock.Name>' */\n"
    %assign condition = SLibMdlRefSystemPreprocessorCondition(modelBlock)
    %assign ppIf = ""
    %assign ppEndif = ""
    %assign groupIdentifier = FcnGetIdentifierFromFullPath(groupPath)
    %assign fileName = SLibGetFullFileNameForCode("mdl_src")
    %if !ISEMPTY(condition)
        %assign ppIf = "#if " + condition + "\n"
        %assign ppEndif = "#endif\n"
    %endif
    %if childGroup.AsStructure == "InSelf"
        %assign sizeof = "sizeof(" + childGroup.Type + ")"
        %assign memcpy = "(void) " + ...
            LibGenMemFcnCall("memcpy", "&(" + selfPath + ")", "&(" + groupPath + ")", sizeof) + ";\n"
        %assign ::CompiledModel.ChildCoderDataGroupMemcpy = ...
            ::CompiledModel.ChildCoderDataGroupMemcpy + ppIf + comment + memcpy + ppEndif
        %<SLibUpdateLocalSymbolTableForFile(fileName, groupIdentifier)>
        %% Self is directly embededed instead of via reference
    %elseif ((childGroup.Depth == 0) && (childGroup.AsStructure == "InParent")) || ...
        (childGroup.AsStructure == "Standalone")
        %assign guardedInitStmt = ppIf + comment + ...
            "%<selfPath> = &%<groupPath>;\n" + ppEndif
        %assign ::CompiledModel.ChildCoderDataGroupAssignmentForParamTs = ...
            ::CompiledModel.ChildCoderDataGroupAssignmentForParamTs + guardedInitStmt
        %if !isMdlblkInForEach
            %assign ::CompiledModel.ChildCoderDataGroupAssignmentForRegistration = ...
                ::CompiledModel.ChildCoderDataGroupAssignmentForRegistration + guardedInitStmt
        %else
            %assign ::childGroupInitsInForEach = ::childGroupInitsInForEach + guardedInitStmt
        %endif
        %<SLibUpdateLocalSymbolTableForFile(fileName, groupIdentifier)>
    %endif
%endfunction

%% Function: FcnAssignHSAutosarCoderGroupsInAllocators =============================================
%% Abstract:
%%   Assign self pointers for coder groups for Autosar PerInstanceMemory and PerInstanceParameter in allocation
%function FcnAssignHSAutosarCoderGroupsInAllocators(childGroup, modelBlock, groupPath, selfPath) void
    %% The usage of the first instance modelBlock is OK here because
    %% all corresponding instances across parent reusable subsystems
    %% must have the same name
    %assign comment = "/* Assign pointer for %<childGroup.Identification>, Block: '%<modelBlock.Name>' */\n"
    %assign arg = ""
    %if MultiInstanceERTCode
        %assign arg = FcnGetMultiInstanceRunnableArgs(TLC_TRUE)
    %endif
    %assign rteCall = "Rte_"
    %if SLibIsAutosarPIMCoderGroup(childGroup)
        %assign rteCall = "Rte_Pim_"
    %elseif SLibIsAutosarInstPCoderGroup(childGroup)
        %assign rteCall = "Rte_CData_"
    %endif
    %assign ::CompiledModel.ChildCoderDataGroupAssignmentForRegistration = ...
        ::CompiledModel.ChildCoderDataGroupAssignmentForRegistration + comment + ...
        "%<selfPath> = %<rteCall>%<groupPath>(%<arg>);\n"
    %assign ::CompiledModel.ChildCoderDataGroupAssignmentForParamTs = ...
        ::CompiledModel.ChildCoderDataGroupAssignmentForParamTs + comment + ...
        "%<selfPath> = %<rteCall>%<groupPath>(%<arg>);\n"
%endfunction

%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortFcnCall3.m
%%
%function FcnGetCoderGroupSelfPointerInit(group)
    %% Promote to static if inparent or inself and self is static
    %if SLibAccessGroupThroughSelf(group)
        %if SLibHasSelfWithStaticInit()
            %return "Static"
        %else
            %return "Dynamic"
        %endif
    %else
        %return group.DataInit
    %endif
%endfunction

%% Do we need to dynamically assign this codergroup pointer in the self?
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function FcnAssignChildCoderGroup(childGroup, mdlrefBlock) void
    %assign childModelIsClass = mdlrefBlock.MdlRefIsCPPClassGenMode
    %assign isDLGroup = SLibIsDeepLearningCoderGroup(childGroup)
    %return !(::isRAccel && !isDLGroup) && ...
        !Accelerator && ...
        !childModelIsClass && ...
        !childGroup.SingleInstanceDefiner && ...
        (!SLibIsSelfImported() ||...
        SLibIsAutosarInstPCoderGroup(childGroup))&& ...
        (childGroup.AsStructure != "None") && ...
        (childGroup.SelfPointerInit == "Dynamic") && ...
        !childGroup.IsSelf
%endfunction

%function FcnGetSingleInstanceType(childGroup, singleInstancePropagator) void
    %if singleInstancePropagator && !childGroup.SingleInstancePropagator
        %assign groupIndex = SLibCoderDataGroupIndex(childGroup.Name)
        %% groupIndex can be negative if child group is _self and this model
        %% has no _self
        %if groupIndex >= 0
            %return SLibCoderDataGroupType(::CompiledModel.CoderDataGroup[groupIndex])
        %else
            %return ""
        %endif
    %else
        %return childGroup.SingleInstanceType
    %endif
%endfunction

%% Get index of parent group in this model
%function FcnGetParentGroupIndex(childGroup) void
    %assign switchToSingleInstGroup = ...
        !SLibMultiInstance() && ...
        childGroup.IsPolymorphic && ...
        childGroup.ImplementationType == "MultiInstance"
    %if switchToSingleInstGroup
        %return SLibGetSingleInstanceGroupIdx(childGroup)
    %else
        %return SLibCoderDataGroupIndex(childGroup.Name)
    %endif
%endfunction

%function SetupForEachLoopVariablesForChildGroupInit(mdlBlk) void
    %assign int32Type = LibGetDataTypeNameFromId(::CompiledModel.tSS_INT32)
    %assert ISFIELD(mdlBlk, "ForEachSSLoopBnds")
    %<CacheForEachLoopVariablesForChildGroupInit()>
    %assign ::NeedForEachLoopInReg = TLC_TRUE
    %assign ::NumForEachLoopHierarchyLevel = SIZE(mdlBlk.ForEachSSLoopBnds, 1)
    %assign ::ForEachLoopHierarchyLevel = 1 %% Init code is always inside the innermost loop
    %assign ::childGroupInitsInForEach = ""

    %openfile ::loopStartBuf
    %assign iterVar = "i_%<ForEachLoopHierarchyLevel>"
    %<int32Type> %<iterVar>;
    for (%<iterVar> = 0; %<iterVar> < %<mdlBlk.ForEachSSLoopBnds[::ForEachLoopHierarchyLevel-1]>; %<iterVar>++) {
        %closefile ::loopStartBuf
        %openfile ::loopEndBuf
    }
    %closefile ::loopEndBuf
%endfunction

%function CacheForEachLoopVariablesForChildGroupInit() void
    %assert !EXISTS(::NeedForEachLoopInReg)
    %assert !EXISTS(::NumForEachLoopHierarchyLevel)
    %assert !EXISTS(::ForEachLoopHierarchyLevel)
    %% %assign ::NeedForEachLoopInRegPrev = ::NeedForEachLoopInReg
    %% %assign ::NumForEachLoopHierarchyLevelPrev = ::NumForEachLoopHierarchyLevel
    %% %assign ::ForEachLoopHierarchyLevelPrev = ::ForEachLoopHierarchyLevel
%endfunction

%function RestoreForEachLoopVariablesForChildGroupInit() void
    %undef ::NeedForEachLoopInReg
    %undef ::NumForEachLoopHierarchyLevel
    %undef ::ForEachLoopHierarchyLevel
    %undef ::childGroupInitsInForEach
    %undef ::loopStartBuf
    %undef ::loopEndBuf
    %% %assign ::NeedForEachLoopInReg = ::NeedForEachLoopInRegPrev
    %% %assign ::NumForEachLoopHierarchyLevel = ::NumForEachLoopHierarchyLevelPrev
    %% %assign ::ForEachLoopHierarchyLevel = ::ForEachLoopHierarchyLevelPrev
%endfunction

%function FcnAdjustPPCondition(blk, childGroup) void
    %assign condition = SLibMdlRefSystemPreprocessorCondition(blk)
    %if ISEMPTY(childGroup.PPCondition)
        %return condition
    %else
        %if ISEMPTY(condition)
            %return childGroup.PPCondition
        %else
            %return "(" + condition + ") && (" + childGroup.PPCondition + ")"
        %endif
    %endif
%endfunction

%function FcnGetResolvedScopedDSMForModelBlock(mdlBlkRec) void
    %createrecord resolvedScopedDSM {}
    %if ISFIELD(mdlBlkRec, "ResolvedScopedDSMDworkIndices")
        %foreach idx = SIZE(mdlBlkRec.ResolvedScopedDSMDworkIndices,1)
            %assign dwRecIdx = mdlBlkRec.ResolvedScopedDSMDworkIndices[idx]
            %assign dwRec = ::CompiledModel.DWorks.DWork[dwRecIdx]
            %addtorecord resolvedScopedDSM %<dwRec.DataStoreMemoryName> dwRecIdx
        %endforeach
    %endif
    %return resolvedScopedDSM
%endfunction

%% Function: SLibRefDSMNetVariantCondition =========================================================
%% Abstract:
%%    it return the net variant condiiton on ref DSM block which is inside a referenced model
%%    net VC on Ref DSM blk = VC on Ref DSM blk + VC on ref model (in which ref dsm blk recides)
%%
%%
%% TopTester: test/toolbox/simulink/variants/var-dsm-scoped/tScopedDSMBasic.m -testspec:TestPoint_mTopScopedDSM_ThreeLayer
%%
%function SLibRefDSMNetVariantCondition(record, dsmBlkId, modelBlock) void
    %if(ISFIELD(record.ScopedDSMs[dsmBlkId], "VariantCondition"))
        %assign condOnRefDSM = record.ScopedDSMs[dsmBlkId].VariantCondition
        %assign condOnModelRefBlk = SLibMdlRefSystemPreprocessorCondition(modelBlock)
        %return SLibGetVariantConditionCombineByAND(condOnRefDSM, condOnModelRefBlk)
    %else
        %return ""
    %endif
%endfunction

%% TopTester: test/toolbox/simulink/variants/var-dsm-scoped/tScopedDSMBasic.m -testspec:TestPoint_mTopScopedDSM_MI_NoPointerAssin
%function FcnProcessPropagatedScopedDSMInMultiInstanceRecord(record, resolvedScopedDSMForModelBlock, resolvedPath, unresolvedPath, modelBlock, blockInterface, instIdx, isModelblkInForEach) void
    %createrecord unresolvedScopedDSMs {}
    %if !ISEMPTY(record) && ISFIELD(record, "ScopedDSMs")
        %if !ISEMPTY(resolvedPath)
            %assign resolvedPath = resolvedPath + "."
        %endif
        %if !GenerateClassInterface
            %assign resolvedPath = FcnLocalStructAccess(modelBlock, blockInterface, instIdx, isModelblkInForEach) + resolvedPath
        %endif
        %foreach idx = SIZE(record.ScopedDSMs, 1)
            %assign dsmName = record.ScopedDSMs[idx].Name
            %assign originalPath = record.ScopedDSMs[idx].Path
            %assign netCondOnRefDSM = SLibRefDSMNetVariantCondition(record, idx, modelBlock)
            %% Resolves in this model; adjust AssignmentForResolvedScopedDSM
            %if ISFIELD(resolvedScopedDSMForModelBlock, dsmName)
                %assign scopedDSMMemoryInit = ""
                %assign ppIf = ""
                %assign ppEndif = ""
                %% if net condition on ref DSM block is always false, which means there is no need to ref dsm pointer assignment in generated code.
                %if STRING(netCondOnRefDSM) != STRING(TLC_FALSE)
                    %assign dwRecIdx = resolvedScopedDSMForModelBlock.%<dsmName>
                    %% final argument below is false because we are not accessing the dwork from a nonreusable subsytem inside a reusable subsystem
                    %assign dwAddr = SLibGetGlobalDWorkAddr(dwRecIdx, TLC_FALSE)
                    %assign scopedDSMMemoryInit = ...
                        resolvedPath + originalPath + " = " + dwAddr + ";\n"

                    %if !ISEMPTY(netCondOnRefDSM)
                        %assign ppIf = "#if " + netCondOnRefDSM + "\n"
                        %assign ppEndif = "#endif\n"
                    %endif
                %endif

                %if CGMODEL_ACCESS("CGModel.IsVariantSupportForScopedDSMOn") != 0
                    %assign ::CompiledModel.AssignmentForResolvedScopedDSM = ...
                        ::CompiledModel.AssignmentForResolvedScopedDSM +  ppIf + ...
                        scopedDSMMemoryInit + ppEndif
                %else
                    %assign ::CompiledModel.AssignmentForResolvedScopedDSM = ...
                        ::CompiledModel.AssignmentForResolvedScopedDSM + ...
                        scopedDSMMemoryInit
                %endif
                %if !ISEMPTY(record.ScopedDSMs[idx].HeaderFile)
                    %<SLibUpdateHeadersNeededByFile(SLibGetFullFileNameForCode("mdl_src_incl"), record.ScopedDSMs[idx].HeaderFile)>
                %endif
            %else
                %assign dsmPath = originalPath
                %if !ISEMPTY(unresolvedPath)
                    %assign dsmPath = unresolvedPath + "." + dsmPath
                %endif
                %if CGMODEL_ACCESS("CGModel.IsVariantSupportForScopedDSMOn") != 0
                    %addtorecord unresolvedScopedDSMs ScopedDSMs { Name dsmName Path dsmPath VariantCondition netCondOnRefDSM HeaderFile record.ScopedDSMs[idx].HeaderFile}
                %else
                    %addtorecord unresolvedScopedDSMs ScopedDSMs { Name dsmName Path dsmPath HeaderFile record.ScopedDSMs[idx].HeaderFile}
                %endif
            %endif
        %endforeach
    %endif
    %return unresolvedScopedDSMs
%endfunction

%function FcnProcessPropagatedScopedDSMInMultiInstanceDWorkForModelBlock(mdlRefBlks, rowIdx) void
    %assign mSysIdx = mdlRefBlks[rowIdx][0]
    %assign bIdx    = mdlRefBlks[rowIdx][1]
    %assign blk = ::CompiledModel.System[mSysIdx].Block[bIdx]
    %% The usage of the first instance modelBlock is OK here because
    %% all corresponding instances across parent reusable subsystems
    %% must have a consistent interface
    %assign blockInterface = GetModelrefInterface(blk)

    %% Process scoped DSM's
    %if ISFIELD(blockInterface, "ScopedDSMInMultiInstanceDWork") && ...
        !ISEMPTY(blockInterface.ScopedDSMInMultiInstanceDWork)
        %assign ::CompiledModel.AncestorHasDataStoreReferenceInDWork = TLC_TRUE
        %assign instIdx = mdlRefBlks[rowIdx][2]
        %assign mdlBlkRec = ::CompiledModel.ModelBlock[rowIdx]
        %assign resolvedScopedDSMForModelBlock = FcnGetResolvedScopedDSMForModelBlock(mdlBlkRec)
        %assign isMdlblkInForEach = ISFIELD(mdlBlkRec, "ForEachSSLoopBnds")


        %% The usage of the first instance modelBlock is OK here because
        %% we pass in the parent subsystem instance index
        %if GenerateClassInterface
            %assign dworkPath = SLibGetMdlRefInstCPPVar(blk, instIdx, mSysIdx)
            %assign dynamicInitPath = dworkPath
        %else
            %assign dworkPath = FcnGetChildCoderGroupDWorkPath(blk, blockInterface, instIdx, isMdlblkInForEach)
            %assign dynamicInitPath = FcnGetDynamicInitPath(dworkPath, blk, blockInterface, dworkPath)
        %endif
        %assign unresolvedScopedDSMs = FcnProcessPropagatedScopedDSMInMultiInstanceRecord(blockInterface.ScopedDSMInMultiInstanceDWork, resolvedScopedDSMForModelBlock, dworkPath, dynamicInitPath, blk, blockInterface, instIdx, isMdlblkInForEach)
        %if !ISEMPTY(unresolvedScopedDSMs)
            %foreach idx = SIZE(unresolvedScopedDSMs.ScopedDSMs, 1)
                %assign ::CompiledModel.ScopedDSMInMultiInstanceDWork = ::CompiledModel.ScopedDSMInMultiInstanceDWork + unresolvedScopedDSMs.ScopedDSMs[idx]
            %endforeach
        %endif
    %endif
%endfunction

%function FcnProcessPropagatedScopedDSMInMultiInstanceDWork() void
    %assign mdlRefBlks = ISFIELD(::CompiledModel,"ModelReferenceBlocks") ? ...
        ::CompiledModel.ModelReferenceBlocks : []
    %if ISEMPTY(mdlRefBlks)
        %return
    %endif
    %foreach rowIdx = SIZE(mdlRefBlks,0)
        %<FcnProcessPropagatedScopedDSMInMultiInstanceDWorkForModelBlock(mdlRefBlks, rowIdx)>
    %endforeach
%endfunction

%% TopTester: test/toolbox/simulink/variants/var-dsm-scoped/tScopedDSMBasic.m -testspec:TestPoint_mTopScopedDSM_SingleInstance
%% TopTester: test/toolbox/simulink/variants/var-dsm-scoped/tScopedDSMBasic.m -testspec:TestPoint_mTopScopedDSM_SI_NoPointerAssin_1
%function FcnProcessPropagatedScopedDSMInSingleInstanceRecord(record, resolvedScopedDSMForModelBlock, modelBlock) void
    %createrecord unresolvedScopedDSMs {}
    %if !ISEMPTY(record) && ISFIELD(record, "ScopedDSMs")
        %foreach idx = SIZE(record.ScopedDSMs, 1)
            %assign dsmName = record.ScopedDSMs[idx].Name
            %assign originalPath = record.ScopedDSMs[idx].Path
            %assign netCondOnRefDSM = SLibRefDSMNetVariantCondition(record, idx, modelBlock)
            %% Resolves in this model; add to AssignmentForResolvedScopedDSM
            %if ISFIELD(resolvedScopedDSMForModelBlock, dsmName)
                %assign scopedDSMMemoryInit = ""
                %assign ppIf = ""
                %assign ppEndif = ""
                %% if net condition on ref DSM block is always false, whihc means there is no need to ref dsm pointer assignment in generated code.
                %if STRING(netCondOnRefDSM) != STRING(TLC_FALSE)
                    %assign dwRecIdx = resolvedScopedDSMForModelBlock.%<dsmName>
                    %% final argument below is false because we are not accessing the dwork from a nonreusable subsytem inside a reusable subsystem
                    %assign dwAddr = SLibGetGlobalDWorkAddr(dwRecIdx, TLC_FALSE)
                    %assign scopedDSMMemoryInit = ...
                        originalPath + " = " + dwAddr + ";\n"

                    %if !ISEMPTY(netCondOnRefDSM)
                        %assign ppIf = "#if " + netCondOnRefDSM + "\n"
                        %assign ppEndif = "#endif\n"
                    %endif
                %endif
                %if CGMODEL_ACCESS("CGModel.IsVariantSupportForScopedDSMOn") != 0
                    %assign ::CompiledModel.AssignmentForResolvedScopedDSM = ...
                        ::CompiledModel.AssignmentForResolvedScopedDSM + ppIf + ...
                        scopedDSMMemoryInit + ppEndif
                %else
                    %assign ::CompiledModel.AssignmentForResolvedScopedDSM = ...
                        ::CompiledModel.AssignmentForResolvedScopedDSM + ...
                        scopedDSMMemoryInit
                %endif
                %if !ISEMPTY(record.ScopedDSMs[idx].HeaderFile)
                    %<SLibUpdateHeadersNeededByFile(SLibGetFullFileNameForCode("mdl_src_incl"), record.ScopedDSMs[idx].HeaderFile)>
                %endif
            %else
                %if CGMODEL_ACCESS("CGModel.IsVariantSupportForScopedDSMOn") != 0
                    %addtorecord unresolvedScopedDSMs ScopedDSMs { Name dsmName Path originalPath VariantCondition netCondOnRefDSM HeaderFile record.ScopedDSMs[idx].HeaderFile }
                %else
                    %addtorecord unresolvedScopedDSMs ScopedDSMs { Name dsmName Path originalPath HeaderFile record.ScopedDSMs[idx].HeaderFile }
                %endif
            %endif
        %endforeach
    %endif
    %return unresolvedScopedDSMs
%endfunction

%function FcnProcessPropagatedScopedDSMInSingleInstanceForModelBlock(mdlRefBlks, rowIdx) void
    %assign mSysIdx = mdlRefBlks[rowIdx][0]
    %assign bIdx    = mdlRefBlks[rowIdx][1]
    %assign blk = ::CompiledModel.System[mSysIdx].Block[bIdx]
    %% The usage of the first instance modelBlock is OK here because
    %% all corresponding instances across parent reusable subsystems
    %% must have a consistent interface
    %assign blockInterface = GetModelrefInterface(blk)

    %% Process scoped DSM's
    %if ISFIELD(blockInterface, "ScopedDSMInSingleInstance") && ...
        !ISEMPTY(blockInterface.ScopedDSMInSingleInstance)
        %assign ::CompiledModel.AncestorHasDataStoreReferenceInDWork = TLC_TRUE
        %assign instIdx = mdlRefBlks[rowIdx][2]
        %assign mdlBlkRec = ::CompiledModel.ModelBlock[rowIdx]
        %assign resolvedScopedDSMForModelBlock = FcnGetResolvedScopedDSMForModelBlock(mdlBlkRec)
        %assign unresolvedScopedDSMs = FcnProcessPropagatedScopedDSMInSingleInstanceRecord(blockInterface.ScopedDSMInSingleInstance, resolvedScopedDSMForModelBlock, blk)
        %if !ISEMPTY(unresolvedScopedDSMs)
            %foreach idx = SIZE(unresolvedScopedDSMs.ScopedDSMs, 1)
                %assign ::CompiledModel.ScopedDSMInSingleInstance = ::CompiledModel.ScopedDSMInSingleInstance + unresolvedScopedDSMs.ScopedDSMs[idx]
            %endforeach
        %endif
    %endif
%endfunction

%function FcnProcessPropagatedScopedDSMInSingleInstance() void
    %assign mdlRefBlks = ISFIELD(::CompiledModel,"ModelReferenceBlocks") ? ...
        ::CompiledModel.ModelReferenceBlocks : []
    %if ISEMPTY(mdlRefBlks)
        %return
    %endif
    %foreach rowIdx = SIZE(mdlRefBlks,0)
        %<FcnProcessPropagatedScopedDSMInSingleInstanceForModelBlock(mdlRefBlks, rowIdx)>
    %endforeach
%endfunction

%function FcnGetScopedDSMPath(childGroup, blockInterface, dworkPath)
    %assign scopedDSMPath = dworkPath
    %if blockInterface.OkToMultiInstance && ...
        !blockInterface.rtmAllocateInParent && ...
        childGroup.Depth > 0
        %assign scopedDSMPath = scopedDSMPath + ".rtdw"
    %endif
    %return scopedDSMPath
%endfunction


%function FcnGetEmptyRecord() void
    %createrecord record {}
    %return record
%endfunction

%% Function: FcnProcessChildCoderGroups ============================================================
%% Abstract:
%%    Process child coder groups
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function FcnProcessChildCoderGroups() void
    %assign mdlRefBlks = ISFIELD(::CompiledModel,"ModelReferenceBlocks") ? ...
        ::CompiledModel.ModelReferenceBlocks : []
    %if ISEMPTY(mdlRefBlks)
        %return
    %endif
    %assign baseSysIdx = GetBaseSystemIdx()

    %assign childCoderDataGroupIndex = 0
    %assign ::CompiledModel.AssignmentForResolvedScopedDSM = ""
    %assign ::CompiledModel.ChildCoderDataGroupAssignmentForRegistration = ""
    %assign ::CompiledModel.ChildCoderDataGroupAssignmentForParamTs = ""
    %assign ::CompiledModel.ChildCoderDataGroupMemcpy = ""
    %assign ::CompiledModel.ChildCoderDataGroupDynamicInitializer = ""
    %assign ancestorAllocatesCoderDataGroups = ::CompiledModel.AncestorAllocatesCoderDataGroups
    %addtorecord ::CompiledModel CoderDataGroupIndexMap {}

    %if IsModelReferenceTarget()
        %% For ModelReferenceTarget, AncestorAllocatesCoderDataGroups is already computed in C++
        :: CompiledModel.AncestorAllocatesCoderDataGroups = ...
            CGMODEL_ACCESS("CGModel.ancestorAllocatesCoderDataGroupsModelRefTarget")
    %endif

    %with System[baseSysIdx]
        %% Loop over all the model blocks ...
        %foreach rowIdx = SIZE(mdlRefBlks,0)
        %assign mSysIdx = mdlRefBlks[rowIdx][0]
        %assign bIdx    = mdlRefBlks[rowIdx][1]
        %assign instIdx = mdlRefBlks[rowIdx][2]
        %with ::CompiledModel.System[mSysIdx].Block[bIdx]
            %assign blk = ::CompiledModel.System[mSysIdx].Block[bIdx]

            %% If the model block is in SIL mode, we don't propagate its
            %% coder groups up for accelerator or model ref sim target
            %if ParamSettings.XILCodeInterface != "None" && ...
                (Accelerator || isRAccel || IsModelReferenceSimTarget())
                %continue
            %endif

            %% The usage of the first instance modelBlock is OK here because
            %% all corresponding instances across parent reusable subsystems
            %% must have a consistent state
            %assert 0 == blk.DeletedInIR
            %% The usage of the first instance modelBlock is OK here because
            %% all corresponding instances across parent reusable subsystems
            %% must have a consistent interface
            %assign blockInterface = GetModelrefInterface(blk)

            %% If the model block propagates child code groups ...
            %if ISFIELD(blockInterface, "CoderDataGroups") && ...
                !ISEMPTY(blockInterface.CoderDataGroups)
            %assign childGroups = blockInterface.CoderDataGroups.CoderDataGroup
            %assign numChildGroups = SIZE(childGroups, 1)

            %assign mdlBlkRec = ::CompiledModel.ModelBlock[rowIdx]
            %assign resolvedScopedDSMForModelBlock= FcnGetResolvedScopedDSMForModelBlock(mdlBlkRec)
            %assign isMdlblkInForEach = ISFIELD(mdlBlkRec, "ForEachSSLoopBnds")
            %if isMdlblkInForEach
                %<SetupForEachLoopVariablesForChildGroupInit(mdlBlkRec)>
            %endif

            %% The usage of the first instance modelBlock is OK here because
            %% we pass in the parent subsystem instance index
            %assign dworkPath = FcnGetChildCoderGroupDWorkPath(blk, blockInterface, instIdx, isMdlblkInForEach)

            %% Establish codergroup mapping from index in child model to index in this model
            %assign mappedCoderDataGroupIndex = childCoderDataGroupIndex


            %% Loop over each child group
            %foreach gIdx = numChildGroups
                %assign childGroup = blockInterface.CoderDataGroups.CoderDataGroup[gIdx]
                %assign previousChildGroupIndex = STRING(CAST("Number", childGroup.CoderDataGroupIndex))
                %<FcnAddToCoderGroupIndexMap(rowIdx, childGroup, previousChildGroupIndex, mappedCoderDataGroupIndex)>

                %assign typeHeaderFile = ""
                %if SLibAutosarActive() && ...
                    (SLibIsAutosarPIMCoderGroup(childGroup) || SLibIsAutosarInstPCoderGroup(childGroup))
                    %assign typeHeaderFile = MainAutosarInterfaceName() + ".h"
                %elseif ISFIELD(childGroup, "TypeHeaderFile")
                    %assign typeHeaderFile = childGroup.TypeHeaderFile
                %endif
                %if !ISEMPTY(childGroup.Type) && !ISEMPTY(typeHeaderFile)
                    %<SLibUpdateGlobalSymbolTableForFile(typeHeaderFile, childGroup.Type)>
                    %if childGroup.ContainsInstanceSpecificParameter
                        %% include header file for referenced model InstP in model.h
                        %<SLibUpdateLocalSymbolTableForFile(SLibGetFullFileNameForCode("mdl_hdr_incl"), childGroup.Type)>
                    %endif
                %endif

                %% Keep track of whether an ancestor allocates coder groups for this model,
                %% since that breaks incremental build.
                %% If IsModelReferenceTarget() is true, it's already handled at the beginning of function.
                %if !IsModelReferenceTarget() && !SLibAllocatesCoderDataGroup(childGroup)
                    %assign ::CompiledModel.AncestorAllocatesCoderDataGroups = TLC_TRUE
                %endif

                %% This can be empty for coder groups coming from protected models created in older releases
                %% We unpack the codegen artifacts and build for protected models
                %assign hasElement = ISFIELD(childGroup,"HasElement") ? childGroup.HasElement : ""
                %assign IsHiddenFromParent = ISFIELD(childGroup, "IsHiddenFromParent")? childGroup.IsHiddenFromParent: ""

                %% Assign paths since we'll need them in the second loop below where we
                %% adjust initializers
                %assign selfPath = ...
                    FcnGetCoderGroupSelfPath(childGroup, blockInterface, dworkPath)
                %assign ppCondition = FcnAdjustPPCondition(blk, childGroup)
                %% The usage of the first instance modelBlock is OK here because
                %% we pass in the rowIdx which is instance-specific
                %assign childGroupPath = FcnGetCoderGroupPath(childGroup, blk, rowIdx, instIdx, isMdlblkInForEach)
                %assign selfPointerInit = FcnGetCoderGroupSelfPointerInit(childGroup)
                %assign grBlkIndex = [ %<mdlRefBlks[rowIdx][3]>, %<mdlRefBlks[rowIdx][4]> ]
                %assign graphicalPath = ISEMPTY(childGroup.GraphicalPath) ? ...
                    SLibGrBlockCommentName(grBlkIndex) : ...
                    SLibGrBlockCommentName(grBlkIndex) + "/" + childGroup.GraphicalPath
                %assign singleInstancePropagator = !SLibMultiInstance()
                %assign singleInstanceHeaderFile = childGroup.SingleInstanceHeaderFile
                %if IsModelReferenceSimTarget() && ...
                    singleInstancePropagator && !childGroup.SingleInstancePropagator && ...
                    childGroup.ContainsInstanceSpecificParameter
                    %assign singleInstanceHeaderFile = SLibGetFileNameForCode("mdl_hdr") + ".h"
                %endif
                %assign singleInstanceType = FcnGetSingleInstanceType(childGroup, singleInstancePropagator)
                %assign sid = STRING(rowIdx) + "_" + STRING(gIdx) + "_" + childGroup.SID
                %assign vcOnMdlBlk = SLibMdlRefSystemPreprocessorCondition(blk)
                %% Create the child data group records
                %addtorecord ::CompiledModel.CoderDataGroups CoderDataGroup { \
                    Name childGroup.Name \
                    UserProvidedName childGroup.UserProvidedName \
                    Description childGroup.Description \
                    Identification childGroup.Identification \
                    Type childGroup.Type \
                    Depth childGroup.Depth+1 \
                    SelfPath selfPath \
                    PPCondition ppCondition \
                    GroupPath childGroupPath \
                    GraphicalPath graphicalPath \
                    SID sid \
                    DataInit childGroup.DataInit \
                    SelfPointerInit selfPointerInit \
                    SingleInstanceDefiner childGroup.SingleInstanceDefiner \
                    SingleInstancePropagator singleInstancePropagator \
                    SingleInstanceType singleInstanceType \
                    IsInstanceSpecific childGroup.IsInstanceSpecific \
                    IsSelf childGroup.IsSelf \
                    IsSynthesized childGroup.IsSynthesized \
                    IsHiddenFromParent IsHiddenFromParent \
                    SynthesizedNamePrefix childGroup.SynthesizedNamePrefix \
                    SingleInstanceHeaderFile singleInstanceHeaderFile \
                    SingleInstanceDefinitionFileRule childGroup.SingleInstanceDefinitionFileRule \
                    IsOpaque childGroup.IsOpaque \
                    IsPolymorphic childGroup.IsPolymorphic \
                    ImplementationType childGroup.ImplementationType \
                    IsMemorySectionConst childGroup.IsMemorySectionConst \
                    IsMemorySectionVolatile childGroup.IsMemorySectionVolatile \
                    MemorySectionQualifier childGroup.MemorySectionQualifier \
                    MemorySection childGroup.MemorySection \
                    MemorySectionIsLegacy childGroup.MemorySectionIsLegacy \
                    IsImportedFromFile childGroup.IsImportedFromFile \
                    AsStructure childGroup.AsStructure \
                    CompiledModelBlockIndex rowIdx \
                    IndexInBlockInterface gIdx \
                    NetVariantCondition vcOnMdlBlk \
                    HasElement hasElement \
                    CoderDataGroupIndex mappedCoderDataGroupIndex \
                    ContainsInstanceSpecificParameter childGroup.ContainsInstanceSpecificParameter \
                    HasAccessMethod childGroup.HasAccessMethod \
                    IsDataTransferGroup childGroup.IsDataTransferGroup \
                    GroupContains childGroup.GroupContains \
                    TypeHeaderFile typeHeaderFile \
                }

                %if isMdlblkInForEach
                    %addtorecord ::CompiledModel.CoderGroupInitLoop CoderDataGroupInitLoop { \
                        LoopStart ::loopStartBuf \
                        LoopEnd ::loopEndBuf \
                    }
                %else
                    %addtorecord ::CompiledModel.CoderGroupInitLoop CoderDataGroupInitLoop { \
                        LoopStart "" \
                        LoopEnd "" \
                    }
                %endif

                %% Add to the child group map
                %assign key = "CG" + sid
                %if ISFIELD(::CompiledModel.ChildGroupMap, key)
                    %<LibReportFatalError("duplicate map entries")>
                %endif
                %addtorecord ::CompiledModel.ChildGroupMap %<key> ::CompiledModel.CoderDataGroups.CoderDataGroup[mappedCoderDataGroupIndex]
                %assign mappedCoderDataGroupIndex = mappedCoderDataGroupIndex + 1
            %endforeach

            %% Now set up all static and dynamic initializers, which can cross reference
            %% other groups - that's why we had to do this in two separate loops
            %assign mappedCoderDataGroupIndex = childCoderDataGroupIndex

            %% Loop over each group
            %foreach gIdx = numChildGroups

                %assign childGroup = blockInterface.CoderDataGroups.CoderDataGroup[gIdx]
                %assign childGroupPath = ::CompiledModel.CoderDataGroups.CoderDataGroup[mappedCoderDataGroupIndex].GroupPath
                %assign childSelfPath = ::CompiledModel.CoderDataGroups.CoderDataGroup[mappedCoderDataGroupIndex].SelfPath
                %assign ppCondition = ::CompiledModel.CoderDataGroups.CoderDataGroup[mappedCoderDataGroupIndex].PPCondition
                %assign childGroupSID = ::CompiledModel.CoderDataGroups.CoderDataGroup[mappedCoderDataGroupIndex].SID
                %% The usage of the first instance modelBlock is OK here because
                %% we pass in the dworkPath which is instance-specific
                %assign dynamicInitPath = ...
                    FcnGetDynamicInitPath(childGroup.SelfPath, blk, blockInterface, dworkPath)
                %% If we're allocating the group, or if a top-model multi-instance build,
                %% create group allocation and definition buffers
                %if SLibAllocatesCoderDataGroup(childGroup) || ...
                    (!IsModelReferenceTarget() && MultiInstanceERTCode)

                    %% Adjust the initializers to the context of this parent model
                    %assign adjustedInitializer = FcnAdjustInitializer(childGroup.Initializer, rowIdx)
                    %assign dynamicInitializer = FcnAdjustDynamicInitializer(childGroup, rowIdx, blockInterface, dynamicInitPath, childGroupPath)
                    %<FcnAssignChildGroupSID(childGroup, rowIdx, childGroupSID)>
                    %% Emit the initializer since we're allocating groups
                    %assign initializer = FcnEmitInitializer(adjustedInitializer)

                    %% Declare child groups that are in-self, or single instance
                    %if childGroup.AsStructure != "InParent" || childGroup.SingleInstanceDefiner
                        %% We only allocate and declare data in some cases
                        %if FcnGenerateGroupInstance(childGroup)
                            %<FcnDeclareChildCoderGroups(childGroup, blockInterface, childGroupPath, ppCondition, initializer)>
                        %endif
                        %% Otherwise, put finishing touches on childGroupPath
                    %else
                        %% Parent group may not be present if child creates _self but
                        %% parent does not.  In that case, leave childGroupPath alone.
                        %assign parentGroupIndex = FcnGetParentGroupIndex(childGroup)
                        %if parentGroupIndex >= 0
                            %assign parentGroup = ::CompiledModel.CoderDataGroup[parentGroupIndex]
                            %if SLibCoderGroupPackageAsStruct(parentGroup)
                                %if isMdlblkInForEach
                                    %assign childGroupPath = ...
                                        FcnAdjustChildGroupPathForForEach(childGroupPath, parentGroup, blk, instIdx, TLC_TRUE)
                                    %if childGroup.ContainsInstanceSpecificParameter
                                        %assign ::CompiledModel.CoderDataGroups.CoderDataGroup[mappedCoderDataGroupIndex].GroupPath = ...
                                            FcnAdjustChildGroupPathForForEach(::CompiledModel.CoderDataGroups.CoderDataGroup[mappedCoderDataGroupIndex].GroupPath, parentGroup, blk, instIdx, TLC_FALSE)
                                    %endif
                                %elseif MultiInstanceERTCode
                                    %assign childGroupPath = ...
                                        FcnAdjustChildGroupPathForMultiInst(childGroupPath, parentGroup, blk)
                                %endif
                            %endif
                        %endif
                    %endif

                    %% Create coder group assignment buffers
                    %if FcnAssignChildCoderGroup(childGroup, blk)
                        %if (SLibIsAutosarPIMCoderGroup(childGroup) || SLibIsAutosarInstPCoderGroup(childGroup))
                            %% The usage of the first instance modelBlock is OK here
                            %% because the routine doesn't need instance-specific info
                            %<FcnAssignHSAutosarCoderGroupsInAllocators(childGroup, blk, childGroupPath, childSelfPath)>
                        %else
                            %% The usage of the first instance modelBlock is OK here
                            %% because the routine doesn't need instance-specific info
                            %<FcnAssignChildCoderGroupsInAllocators(childGroup, blk, isMdlblkInForEach, childGroupPath, childSelfPath)>
                        %endif
                    %endif

                    %% Copy instance-specific parameter values for sim targets
                    %if ::isRAccel || Accelerator || ::isRSim
                        %<FcnCopyInstPForSimTargets(dynamicInitializer, childGroup)>
                    %endif

                    %% if we don't allocate or declare the childGroup, we still need to
                    %% adjust the initializer to the context of this parent model
                    %% as well as initialize pointers for submodel's InParent groups
                %else
                    %assign initializer = FcnAdjustInitializer(childGroup.Initializer, rowIdx)
                    %assign dynamicInitializer = FcnAdjustDynamicInitializer(childGroup, rowIdx, blockInterface, dynamicInitPath, childGroupPath)
                    %<FcnAssignChildGroupSID(childGroup, rowIdx, childGroupSID)>
                    %% Create coder group assignment buffers
                    %if FcnAssignChildCoderGroup(childGroup, blk) && ...
                        (childGroup.AsStructure == "InParent") && ...
                        (childGroup.Depth == 0)
                        %assign parentGroupIndex = FcnGetParentGroupIndex(childGroup)
                        %assign parentGroup = ::CompiledModel.CoderDataGroup[parentGroupIndex]
                        %if isMdlblkInForEach
                            %assign childGroupPath = ...
                                FcnAdjustChildGroupPathForForEach(childGroupPath, parentGroup, blk, instIdx, TLC_TRUE)
                            %if childGroup.ContainsInstanceSpecificParameter
                                %assign ::CompiledModel.CoderDataGroups.CoderDataGroup[mappedCoderDataGroupIndex].GroupPath = ...
                                    FcnAdjustChildGroupPathForForEach(::CompiledModel.CoderDataGroups.CoderDataGroup[mappedCoderDataGroupIndex].GroupPath, parentGroup, blk, instIdx, TLC_FALSE)
                            %endif
                        %elseif SLibMultiInstance()
                            %assign childGroupPath = ...
                                FcnAdjustChildGroupPathForMultiInst(childGroupPath, parentGroup, blk)
                        %endif
                        %<FcnAssignChildCoderGroupsInNonAllocators(childGroup, blk, instIdx, blockInterface, isMdlblkInForEach, childGroupPath, childSelfPath)>
                    %endif
                %endif

                %% Process scoped DSM's
                %assign scopedDSMPath = FcnGetScopedDSMPath(childGroup, blockInterface, dworkPath)
                %assign unresolvedScopedDSMs = FcnProcessPropagatedScopedDSMInMultiInstanceRecord(childGroup.ScopedDSMs, resolvedScopedDSMForModelBlock, scopedDSMPath, scopedDSMPath, blk, blockInterface, instIdx, isMdlblkInForEach)

                %% Add the static and dynamic initializers to the child coder group record.
                %addtorecord ::CompiledModel.CoderDataGroups.CoderDataGroup[mappedCoderDataGroupIndex] Initializer initializer
                %addtorecord ::CompiledModel.CoderDataGroups.CoderDataGroup[mappedCoderDataGroupIndex] DynamicInitializer dynamicInitializer
                %addtorecord ::CompiledModel.CoderDataGroups.CoderDataGroup[mappedCoderDataGroupIndex] ScopedDSMs unresolvedScopedDSMs

                %assign mappedCoderDataGroupIndex = mappedCoderDataGroupIndex + 1
            %endforeach
            %assign childCoderDataGroupIndex = childCoderDataGroupIndex + numChildGroups
            %if isMdlblkInForEach
                %if !ISEMPTY(::childGroupInitsInForEach)
                    %assign mdlrefKey = FcnCoderGroupIndexMapKey(rowIdx)
                    %addtorecord ::CompiledModel.ChildGroupInitInForEachMap %<mdlrefKey> ::childGroupInitsInForEach
                %endif
                %<RestoreForEachLoopVariablesForChildGroupInit()>
            %endif
            %endif
        %endwith
    %endforeach
%endwith

%endfunction %%FcnProcessChildCoderGroups

%% Function: GetNonContAddress =====================================================================
%% Abstract:
%%  Returns the address of the signal which is used to track a noncontinuous
%% signal feeding an integrator.
%function GetNonContAddress(du, ss)
    %assign sigSrc  = du.SigSrc
    %assign startEl = du.StartEl
    %assign regLen  = du.RegionLen
    %assign idNum = IDNUM(sigSrc)
    %%
    %switch idNum[0]
        %% Note: no need for "u" because the top model will
        %% check for the reset in this case.
      %case "y"
        %assign opIdx        = idNum[1]
        %assign interface    = ss.Interface
        %assign canOutputArg = interface.CanonicalOutputArgDef[opIdx]
        %assign name  = LibGetRecordIdentifier(canOutputArg)
        %assign addr  = "&%<name>[%<startEl>]"
        %<SLibAccessArgHelper(canOutputArg,"",ss.CurrentTID)>
        %break
      %default
        %assign bo = BlockOutputs.GlobalBlockOutput[idNum[1]]
        %assert (bo.Invariant == "no")
        %assert (LibGetRecordWidth(bo) >= regLen + startEl)
        %assign cross = System[bo.SigSrc[0]].CrossNoArgFcnBound
        %assign name  = SLibCG_GetVarGroupElementPath(bo.VarGroupIdx, ...
            ss.SystemIdx, cross)
        %assign opW   = (LibGetRecordWidth(bo) == 1) ? "" : "[%<startEl>]"
        %assign addr  = "&%<name>%<opW>"
        %break
    %endswitch
    %return addr
%endfunction


%% Function: CallModelrefBlockFreeFullPaths ========================================================
%% Abstract:
%%    Call rtwCAPI_SetFreeFullPaths
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function CallModelrefBlockFreeFullPaths(mdlRefBlks)
    %openfile modelrefBuffer
    %if ::CompiledModel.RTWStatesLogging && !IsModelReferenceTarget() && ...
        HasModelReferenceBlocks()
        %assign baseSysIdx = GetBaseSystemIdx()
        %with System[baseSysIdx]
            %if ::NumModelBlocksWithCAPI > 0
                %assign mdlBlkIdx = 0
                %foreach rowIdx = SIZE(mdlRefBlks,0)
                    %% This does a deep dive so we only want to do it
                    %% for the top (note: the engine takes care of this in sim)
                    %assign mdlRefInfo = mdlRefBlks[rowIdx]
                    %assign mSysIdx = mdlRefInfo[0]
                    %assign bIdx    = mdlRefInfo[1]
                    %assign instIdx = mdlRefInfo[2]
                    %assign blk = ::CompiledModel.System[mSysIdx].Block[bIdx]
                    %% The usage of the first instance modelBlock is OK here because
                    %% all corresponding instances across parent reusable subsystems
                    %% must have a consistent state
                    %assert 0 == blk.DeletedInIR
                    %if !blk.ParamSettings.SupportsCAPI
                        %continue
                    %endif

                    %if GenRTModel
                        %assign rtm_mmi = "&(%<RTMGet("DataMapInfo")>.mmi)"
                    %else
                        %assign rtm_mmi = "&(%<RSimRTWCAPIVarPtr>->mmi)"
                    %endif
                    %assign childMMI = "rtwCAPI_GetChildMMI(%<rtm_mmi>,%<mdlBlkIdx>)"
                    rtwCAPI_FreeFullPaths((%<childMMI>));
                    %assign mdlBlkIdx = mdlBlkIdx + 1
                %endforeach
            %endif
        %endwith
    %endif
    %closefile modelrefBuffer
    %return modelrefBuffer
%endfunction %%CallModelrefBlockFreePath


%% =============================================================================
%%
%function ModelrefCacheSolverResetCode(ss) void
    %openfile tmpbuf
    %assign nDU = SolverResetInfo.NumNonContDerivSignals
    %if nDU > 0
        if (%<RTMIs("MajorTimeStep")>) {
            %foreach idx = nDU
                %assign dulocal = RTMGetIdxed("NonContDerivSignal", %<idx>)
                if (%<LibGenMemFcnCall("memcmp", "%<dulocal>.pCurrVal", ...
                    "%<dulocal>.pPrevVal", "%<dulocal>.sizeInBytes")> != 0) {
                    (void) %<LibGenMemFcnCall("memcpy", "%<dulocal>.pPrevVal", ...
                        "%<dulocal>.pCurrVal", "%<dulocal>.sizeInBytes")>;
                    %<RTMSetSolverNeedsReset()>;
                }
            %endforeach
        }
    %endif
    %closefile tmpbuf
    %return tmpbuf
%endfunction


%% The following functions have similar formats for exported identifiers.
%% SLibWriteMdlRefExportedMdlInfo is used in model reference sim target and
%% CacheMdlRefExportedMdlInfoInBinfo is used in ModelReferenceRTWTarget.
%% If you change the exported signal format in one function, you should modify another one.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants6.m
%%
%function CacheMdlRefExportedMdlInfoInBinfo() void
    %with ::CompiledModel
        %createrecord mdlInfoRecords {}

        %foreach idIdx = ExportedMdlInfo.NumExportedMdlInfo
            %assign id = ExportedMdlInfo.ExportedMdlInfo[idIdx]
            %assign path = ""
            %if !ISEMPTY(id.BPath) && !WHITE_SPACE(id.BPath)
                %assign path =  id.BPath
            %endif

            %addtorecord mdlInfoRecords mdlInfo  { \
                Id     id.Id;    \
                Class  id.Class; \
                Alias  id.Alias; \
                Port   id.Port;  \
                Path   path      \
            }
        %endforeach
        %<CacheModelrefInterfaceInMatInfoFile(::CompiledModel.Name, ...
            "addMdlInfos", mdlInfoRecords)>
    %endwith
%endfunction

%% The following functions have similar formats for exported identifiers.
%% SLibWriteMdlRefExportedMdlInfo is used in model reference sim target and
%% CacheMdlRefExportedMdlInfoInBinfo is used in ModelReferenceRTWTarget.
%% If you change the exported signal format in one function, you should modify another one.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants6.m
%%
%function SLibWriteMdlRefExportedMdlInfo() void
    %with ::CompiledModel
        %openfile tmpBuffer
        static RegMdlInfo rtMdlInfo_%<Name>[%<ExportedMdlInfo.NumExportedMdlInfo>]%<LibGetDataInitEqualSign()>{
            %foreach idIdx = ExportedMdlInfo.NumExportedMdlInfo
                %assign id = ExportedMdlInfo.ExportedMdlInfo[idIdx]
                %if ISEMPTY(id.BPath) || WHITE_SPACE(id.BPath)
                    {"%<id.Id>", %<id.Class>, %<id.Alias>, %<id.Port>, %<SLibGetNullDefinitionFromTfl()>}\
                %else
                    {"%<id.Id>", %<id.Class>, %<id.Alias>, %<id.Port>, (void *) "%<STRING(id.BPath)>"}\
                %endif
                %if idIdx < (ExportedMdlInfo.NumExportedMdlInfo-1)
                    ,
                %endif
            %endforeach
        };
        %assign numSharedDSM = ::CompiledModel.NumDataStoresPushedToTopModel
        %if numSharedDSM > 0

            void *%<::CompiledModel.Name>_DSM[%<numSharedDSM>];
            int  %<::CompiledModel.Name>_DSMIdx[%<numSharedDSM>];
        %endif
        %closefile tmpBuffer
        %<SLibCacheCodeToFile("mdl_data_defn", tmpBuffer)>

        %openfile tmpBuffer
        %if numSharedDSM > 0
            extern void *%<::CompiledModel.Name>_DSM[%<numSharedDSM>];
            extern int  %<::CompiledModel.Name>_DSMIdx[%<numSharedDSM>];
        %endif
        %closefile tmpBuffer
        %<SLibCacheCodeToFile("mdl_fcn_decl", tmpBuffer)>

        %<SLibWriteMdlRefMdlInfoRegFcn()>

        %% These might be better off in the SIM target boilerplate?
        %<SLibWriteMdlRefSuppressUnreferencedLocalFcn()>

        %<SLibWriteMdlRefCacheDataAsMxArrayFcn()>
        %<SLibWriteMdlRefRestoreDataFromMxArrayFcn()>
        %<SLibWriteMdlRefCacheBitFieldToMxArrayFcn()>
        %<SLibWriteMdlRefExtractBitFieldFromMxArrayFcn()>

        %<SLibWriteMdlRefCacheDataToMxArrayWithOffsetFcn()>
        %<SLibWriteMdlRefRestoreDataFromMxArrayWithOffsetFcn()>
        %<SLibWriteMdlRefCacheBitFieldToCellArrayWithOffsetFcn()>
        %<SLibWriteMdlRefExtractBitFieldFromCellArrayWithOffsetFcn()>

        %<SLibWriteMdlRefGetSetDWorkFcns()>
        %<SLibWriteRegisterSimStateChecksumFcn()>
        %<SLibWriteGetSimStateDisallowedBlocksFcn()>
        %<SLibWriteReusedSubSystemBlockPathFcn()>

        %<SLibWriteMdlRefInitRestoreDataFcns()>
    %endwith
%endfunction

%% =========================================================================== |
%% Function: SLibWriteMdlRefMdlInfoRegFcn
%% Abstract: Writes model_MdlInfoRegFcn in model.c.
%%           Extracted from SLibWriteMdlRefExportedMdlInfo.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants4.m
%%
%function SLibWriteMdlRefMdlInfoRegFcn() void
    %assign booleanType = LibGetDataTypeNameFromId(::CompiledModel.tSS_BOOLEAN)
    %assign charType = LibGetDataTypeNameFromId(::CompiledModel.tSS_CHAR)
    %assign intType = LibGetDataTypeNameFromId(::CompiledModel.tSS_INTEGER)
    %assign regFcnName = SLibCreateMdlInfoRegFcnName()
    %createrecord ReferencedModelHash {}
    %openfile mdlInfoRegFcnBuffer
    void %<regFcnName>(SimStruct* mdlRefSfcnS, %<charType> *modelName, %<intType> *retVal)
    {
        *retVal = 0;
        %if ISFIELD(::CompiledModel, "NumModelReferenceBlocks")
            %assign scalarTokens = LibGetScalarDataInitTokens()
            {
                %<booleanType> regSubmodelsMdlinfo%<scalarTokens[0]>%<GET_TYPE_ID_REPLACEMENT("false")>%<scalarTokens[1]>;
                ssGetRegSubmodelsMdlinfo(mdlRefSfcnS, &regSubmodelsMdlinfo);
                if (regSubmodelsMdlinfo) {
                    %foreach idIdx = NumModelReferenceBlocks
                        %assign blkIdx    = ModelReferenceBlocks[idIdx]
                        %assign mdlBlock  = System[blkIdx[0]].Block[blkIdx[1]]
                        %assign modelName = mdlBlock.ParamSettings.ReferencedModelName
                        %if !ISFIELD(ReferencedModelHash, modelName)
                            mr_%<modelName>_MdlInfoRegFcn(mdlRefSfcnS, %<WriteStringLiteralModelRefSimTarget(modelName)>, retVal);
                            if (*retVal == 0) return;
                            *retVal = 0;
                            %addtorecord ReferencedModelHash %<modelName> 1
                        %endif
                    %endforeach
                }
            }
        %endif

        %<RegisterMdlRefSFcnToWksDataTypes()>

        %assign modelName = Name
        *retVal = 0;
        ssRegModelRefMdlInfo(...
            mdlRefSfcnS, modelName, rtMdlInfo_%<modelName>, ...
            %<ExportedMdlInfo.NumExportedMdlInfo>);

        *retVal = 1;
    }

    %closefile mdlInfoRegFcnBuffer
    %<SLibCacheCodeToFile("mdl_fcn_defn", mdlInfoRegFcnBuffer)>

    %openfile mdlInfoRegFcnBuffer
    %<LibExternInFcnDecls()>void %<regFcnName>(SimStruct* mdlRefSfcnS, %<charType> *modelName, %<intType> *retVal);
    %closefile mdlInfoRegFcnBuffer
    %<SLibCacheCodeToFile("mdl_fcn_prototype", mdlInfoRegFcnBuffer)>
%endfunction

%% =========================================================================== |
%% BEGIN ModelRefAccelModeSimState support
%% =========================================================================== |

%% =========================================================================== |
%% Function: SLibWriteGetSimStateDisallowedBlocksFcn
%% Abstract: Recursively packages the information about blocks that prevent
%%           the SimState from being safely stored, and returns it in an
%%           mxArray.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants4.m
%%
%function SLibWriteGetSimStateDisallowedBlocksFcn() void
    %assign scalarTokens = LibGetScalarDataInitTokens()
    %assign currentSystem = System[GetBaseSystemIdx()]
    %with currentSystem.Interface
        %assign fcnSig = SLibCreateGetSimStateDisallowedBlocksFcnSigForModel(Name)

        %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
        %% Code generation for header prototype.
        %%
        %openfile fcnBuffer
        %<LibExternInFcnDecls()>%<fcnSig>;
        %closefile fcnBuffer
        %<SLibCacheCodeToFile("mdl_fcn_prototype", fcnBuffer)>

        %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
        %% Code generation for function implementation.
        %%
        %openfile fcnBuffer

        %selectfile fcnBuffer
        %<fcnSig>
        {
            %with SimStateDisallowedBlocks

                %assign modelNames  = LibGetReferencedModelNames()
                %assign numChildren = modelNames.NumReferencedModels

                %if (0 == NumSimStateDisallowedBlocks) && (0 == numChildren)
                    %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
                    %% This model is a leaf node with no disallowed block data.
                    %%
                    return %<SLibGetNullDefinitionFromTfl()>;

                %elseif (0 == NumSimStateDisallowedBlocks) && (1 == numChildren)
                    %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
                    %% This is an internal node with no disallowed block data of its own.
                    %% Just return the singleton child's result to the caller.
                    %%
                    return %<SLibCreateGetSimStateDisallowedBlocksFcnNameForModel(...
                        modelNames.ReferencedModel[0].Name)>();

                %elseif (0 == NumSimStateDisallowedBlocks)
                    %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
                    %% This is a multi-child internal node with no disallowed block data of
                    %% its own. We must fetch data from each unique child in turn.
                    %% If only one child returns non-NULL, simply return its data.
                    %% Otherwise, concatenate the results into a new cell matrix, destroy
                    %% the individual arrays, and return the consolidated data instead.
                    %%
                    mxArray * data%<scalarTokens[0]>NULL%<scalarTokens[1]>;
                    size_t numChildrenWithDisallowedBlocks%<scalarTokens[0]>0%<scalarTokens[1]>;
                    size_t numBlocks%<scalarTokens[0]>0%<scalarTokens[1]>;

                    %<SLibWriteFetchChildSimStateDisallowedBlockData(modelNames, fcnBuffer)>

                    if (numChildrenWithDisallowedBlocks > 1) {
                        mwIndex subs[2], offset;

                        data = mxCreateCellMatrix(numBlocks, 3);

                        subs[0] = 0;

                        %<SLibWriteCacheChildSimStateDisallowedBlockData(...
                            modelNames, fcnBuffer)>
                    }

                    return data;

                %elseif (0 == numChildren)
                    %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
                    %% This is a leaf node with disallowed block data. Pack the data into
                    %% a new cell matrix and return it.
                    %%
                    mxArray * data%<scalarTokens[0]>mxCreateCellMatrix(%<NumSimStateDisallowedBlocks>, 3)%<scalarTokens[1]>;
                    mwIndex subs[2], offset;

                    %<SLibWriteCacheLocalSimStateDisallowedBlockData(numChildren, fcnBuffer)>

                    return data;

                %else
                    %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
                    %% This is the general case of an internal node with disallowed block
                    %% data of its own. Generate an array of mxArrays along with a running
                    %% total of  non-null results and a total block count, then concatenate
                    %% the contents
                    %%
                    mxArray * data%<scalarTokens[0]>NULL%<scalarTokens[1]>;
                    mwIndex subs[2], offset;
                    size_t numChildrenWithDisallowedBlocks%<scalarTokens[0]>0%<scalarTokens[1]>;
                    size_t numBlocks%<scalarTokens[0]>0%<scalarTokens[1]>;

                    %<SLibWriteFetchChildSimStateDisallowedBlockData(...
                        modelNames, fcnBuffer)>

                    %assign allocM = "numBlocks + %<NumSimStateDisallowedBlocks>"

                    data = mxCreateCellMatrix(%<allocM>, 3);

                    %<SLibWriteCacheLocalSimStateDisallowedBlockData(...
                        numChildren, fcnBuffer)>

                    %<SLibWriteCacheChildSimStateDisallowedBlockData(...
                        modelNames, fcnBuffer)>

                    return data;

                %endif

            %endwith

        }

        %closefile fcnBuffer
        %<SLibCacheCodeToFile("mdl_fcn_defn", fcnBuffer)>

    %endwith

%endfunction

%% =========================================================================== |
%% Function: SLibWriteCacheChildSimStateDisallowedBlockData
%% Abstract: Emit code to cache the disallowed block lists returned by
%%           recursive calls into child models.
%%
%function SLibWriteCacheChildSimStateDisallowedBlockData(...
    modelNames, fcnBuffer) void
    %assign scalarTokens = LibGetScalarDataInitTokens()

    %selectfile fcnBuffer

    {
        size_t i;
        for (i = 0; i < %<modelNames.NumReferencedModels>; ++i) {
            mxArray * data_i%<scalarTokens[0]>disallowedBlocksInChild[i]%<scalarTokens[1]>;

            if (%<SLibGetNullDefinitionFromTfl()> != data_i) {
                mwIndex subs_i[2], offset_i;
                const mwIndex numRows_i%<scalarTokens[0]>(mwIndex) mxGetM(data_i)%<scalarTokens[1]>;

                for (subs_i[0] = 0; subs_i[0] < numRows_i; ++(subs_i[0])) {
                    mwIndex j;
                    for (j = 0; j < 3; ++j) {
                        mxArray* data_ij;

                        subs_i[1] = j;

                        offset_i = mxCalcSingleSubscript(data_i, 2, subs_i);

                        data_ij = mxGetCell(data_i, offset_i);
                        data_ij = mxDuplicateArray(data_ij);

                        subs[1] = j;
                        offset  = mxCalcSingleSubscript(data,   2, subs  );

                        mxSetCell(data, offset, data_ij);
                    }

                    ++(subs[0]);
                }

                mxDestroyArray(data_i);
            }
        }
    }

%endfunction

%% =========================================================================== |
%% Function: SLibWriteFetchChildSimStateDisallowedBlockData
%% Abstract: Emit code to ask each child model for an mxArray of disallowed
%%           blocks, then perform some bookkeeping to ensure that all of the
%%           block data gets passed up correctly.
%%
%function SLibWriteFetchChildSimStateDisallowedBlockData(...
    modelNames, fcnBuffer) void
    %assign scalarTokens = LibGetScalarDataInitTokens()

    %selectfile fcnBuffer

    %with modelNames

        mxArray * disallowedBlocksInChild[%<NumReferencedModels>];

        %foreach idx = NumReferencedModels

            disallowedBlocksInChild[%<idx>] =
            %<SLibCreateGetSimStateDisallowedBlocksFcnNameForModel(...
                ReferencedModel[idx].Name)>();

        %endforeach
        {
            size_t i;
            for (i = 0; i < %<NumReferencedModels>; ++i) {
                mxArray * data_i%<scalarTokens[0]>disallowedBlocksInChild[i]%<scalarTokens[1]>;
                if (%<SLibGetNullDefinitionFromTfl()> != data_i) {
                    if (0 == numChildrenWithDisallowedBlocks++) {
                        data = data_i;
                    }
                    numBlocks += mxGetM(data_i);
                }
            }
        }
    %endwith

%endfunction

%% =========================================================================== |
%% Function: SLibWriteCacheLocalSimStateDisallowedBlockData
%% Abstract: Emit code to cache the disallowed block data contained in the
%%           model.rtw file being processed.
%%
%function SLibWriteCacheLocalSimStateDisallowedBlockData(...
    numChildren, fcnBuffer) void
    %assign charType = LibGetDataTypeNameFromId(::CompiledModel.tSS_CHAR)
    %assign realType = LibGetDataTypeNameFromId(::CompiledModel.tSS_DOUBLE)

    %assign equalSign = LibGetDataInitEqualSign()

    %selectfile fcnBuffer

    %with SimStateDisallowedBlocks

        {
            static const %<charType> * blockType[%<NumSimStateDisallowedBlocks>]%<equalSign>{
                %foreach idx = NumSimStateDisallowedBlocks
                    "%<SimStateDisallowedBlock[idx].BlockType>",
                %endforeach
            };

            static const %<charType> * blockPath[%<NumSimStateDisallowedBlocks>]%<equalSign>{
                %foreach idx = NumSimStateDisallowedBlocks
                    %assign blockPath_escaped = FEVAL("coder.internal.getEscapedString", STRING(SimStateDisallowedBlock[idx].BlockPath))
                    "%<blockPath_escaped>",
                %endforeach
            };

            static const int reason[%<NumSimStateDisallowedBlocks>]%<equalSign>{
                %foreach idx = NumSimStateDisallowedBlocks
                    %<SimStateDisallowedBlock[idx].Reason>,
                %endforeach
            };

            %% There is a bit of a hack-fu that uses the side effect of incrementing
            %% subs[0] to the correct value prior to the start of appending child data.
            for (subs[0] = 0; subs[0] < %<NumSimStateDisallowedBlocks>; ++(subs[0])) {
                subs[1] = 0;
                offset  = mxCalcSingleSubscript(data, 2, subs);

                mxSetCell(data, offset, mxCreateString(blockType[subs[0]]));

                subs[1] = 1;
                offset  = mxCalcSingleSubscript(data, 2, subs);

                mxSetCell(data, offset, mxCreateString(blockPath[subs[0]]));

                subs[1] = 2;
                offset  = mxCalcSingleSubscript(data, 2, subs);

                mxSetCell(data, offset, mxCreateDoubleScalar((%<realType>)reason[subs[0]]));
            }
        }

    %endwith

%endfunction

%% =========================================================================== |
%% Function SLibLogStatesAfterStateWrite
%% Abstract: call into simulink to log states after stateWriter block's output
%%
%function SLibLogStatesAfterStateWrite(stateWriteBlockSID) void
    %return "slmrLogStatesAfterStateWrite(%<RTMGet("MdlRefSfcnS")>, \"%<stateWriteBlockSID>\")"
%endfunction

%% =========================================================================== |
%% Function SLibIsRapidAccelSimulating
%% Abstract: return if it is Rapid Accelerator simulation
%%
%function SLibIsRapidAccelSimulating() void
    %return "slIsRapidAcceleratorSimulating()"
%endfunction


%% =========================================================================== |
%% Function: SLibWriteRegisterSimStateChecksumFcn
%% Abstract: Construct the model_RegisterSimStateChecksum function.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants4.m
%%
%function SLibWriteRegisterSimStateChecksumFcn() void
    %assign uint32Type = LibGetDataTypeNameFromId(::CompiledModel.tSS_UINT32)
    %assign currentSystem = System[GetBaseSystemIdx()]
    %with currentSystem.Interface
        %assign fcnSig = SLibCreateRegisterSimStateChecksumFcnSigForModel(Name)

        %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
        %% Code generation for function definition.
        %%
        %openfile fcnBuffer
        %<fcnSig>
        {
            %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
            %% Initialize with value computed during the build procedure
            %%
            const %<uint32Type> chksum[4]%<LibGetDataInitEqualSign()>{
                %foreach idx = 4
                    %<SimStateChecksum[idx]>,
                %endforeach
            };

            slmrModelRefRegisterSimStateChecksum(S, "%<Name>", &chksum[0]);

            %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
            %% Ask all child models to register their checksums.
            %%
            %assign modelNames = LibGetReferencedModelNames() %% from mdlrefutil.tlc

            %with modelNames
                %foreach idx = NumReferencedModels
                    %<SLibCreateRegisterSimStateChecksumFcnNameForModel ...
                        (ReferencedModel[idx].Name)>(S);
                %endforeach
            %endwith
        }
        %closefile fcnBuffer
        %<SLibCacheCodeToFile("mdl_fcn_defn", fcnBuffer)>

        %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
        %% Code generation for header prototype.
        %%
        %openfile fcnBuffer
        %<LibExternInFcnDecls()>%<fcnSig>;
        %closefile fcnBuffer
        %<SLibCacheCodeToFile("mdl_fcn_prototype", fcnBuffer)>
    %endwith
%endfunction

%% =========================================================================== |
%% Function: SLibCreateRegisterSimStateChecksumFcnSigForModel
%% Abstract: Construct the model_RegisterSimStateChecksum function signature.
%%
%function SLibCreateRegisterSimStateChecksumFcnSigForModel(thisModelName)
    %assign regFcnName = SLibCreateRegisterSimStateChecksumFcnNameForModel(Name)
    %return "void %<regFcnName>(SimStruct* S)"
%endfunction

%% =========================================================================== |
%% Function: SLibCreateRegisterSimStateChecksumFcnNameForModel
%% Abstract: Creates the model_RegisterSimStateChecksum function name.
%%
%function SLibCreateRegisterSimStateChecksumFcnNameForModel(thisModelName)
    %return "mr_%<thisModelName>_RegisterSimStateChecksum"
%endfunction

%% =========================================================================== |
%% Function: SLibWriteMdlRefGetSetDWorkFcns
%% Abstract: Write a getter and setter for a model's DWork items.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function SLibWriteMdlRefGetSetDWorkFcns() void
    %assign currentSystem = System[GetBaseSystemIdx()]
    %with currentSystem.Interface
        %assign getterFcnSig = SLibCreateGetDWorkFcnSigForModel(Name)
        %assign setterFcnSig = SLibCreateSetDWorkFcnSigForModel(Name)

        %assign isSingleInstance = !::CompiledModel.OkToMultiInstanceModelref
        %assign dwMembers ...
            = SLibGetDWorkMemberNamesForSystem(currentSystem, isSingleInstance)

        %with dwMembers %% rtbName->"mdlrefDW->rtb", hasRTB etc

            %assign needsToCacheDWorkState ...
                =  hasRTB ...
                || hasRTDW ...
                || hasRTZCE ...
                || HasModelReferenceBlocks()

            %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
            %% Code generation for function bodies begins here.
            %%
            %openfile getDWorkBuffer
            %<getterFcnSig> {

                %openfile setDWorkBuffer
                %<setterFcnSig> {

                    %assign ssMxName = "ssDW"

                    %if needsToCacheDWorkState

                        (void) %<ssMxName>;
                        %if !isSingleInstance
                            (void) %<SLibGetMdlrefDWPtrName()>;
                        %endif

                        %<SLibWriteGetDWorkPreamble(...
                            rtbMxName, rtdwMxName, rtzceMxName, ssMxName, getDWorkBuffer)>

                        %if hasRTB
                            %<SLibWriteCacheRestoreVariableToFromMxArray(...
                                rtbName, ssMxName, 0, getDWorkBuffer, setDWorkBuffer)>
                        %endif

                        %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
                        %% Traverse the RTDW tree and list of referenced models, make lists
                        %% of variables to stash, emit code to stash them if necessary.
                        %%

                        %assign rtdwTree = SLibCreateEmptyRTDWTreeObject(rtdwName)

                        %if hasRTDW
                            %% This picks up state for this model, s-functions in models
                            %% referenced from this model, and MdlrefDW structs for multi-instance
                            %% models referenced from this model.
                            %%
                            %assign varGroupIdx = FcnSysVarGroupIndex(currentSystem, "DWork", 0)
                            %<SLibGetDWorkStateItemsForVarGroup(rtdwTree, varGroupIdx)>
                        %endif

                        %if SLibSimTargetUsesModelSelf()
                            %% When using RTM as model self, dwork is contained by RTM, so child model's dwork
                            %% is contained in child model's RTM, which is then contained by the parent model.
                            %% Therefore, to get child model dwork hierarchically, the RTM needs to be passed down.
                            %assign varGroupIdx = FcnSysVarGroupIndex(currentSystem, "CoderDataGroup_self", 0)
                            %<SLibGetDWorkStateItemsForVarGroup(rtdwTree, varGroupIdx)>
                        %endif

                        %if HasModelReferenceBlocks() && isSingleInstance
                            %% Iterate over the list, picking out the single-instance models
                            %% and noting their name. These need to be stashed even if no
                            %% RTDW struct exists.
                            %%
                            %<SLibGetDWorkPairsForSingleInstanceModelBlocks(rtdwTree)>
                        %endif

                        %if SLibRTDWTreeContainsPersistentState(rtdwTree)
                            %% If this model or its children own persistent state, emit code
                            %% to cache it.
                            %%
                            %<SLibWriteGetSetRTDWContents(...
                                rtdwTree, ssMxName, 1, getDWorkBuffer, setDWorkBuffer)>
                        %endif

                        %if hasRTZCE
                            %<SLibWriteCacheRestoreVariableToFromMxArray(...
                                rtzceName, ssMxName, 2, getDWorkBuffer, setDWorkBuffer)>
                        %endif

                        %selectfile getDWorkBuffer
                        %if !isSingleInstance
                            (void) %<SLibGetMdlrefDWPtrName()>;
                        %endif
                        return %<ssMxName>;
                    %else %% doesn't need to cache DWork state
                        %selectfile getDWorkBuffer
                        %if !isSingleInstance
                            (void) %<SLibGetMdlrefDWPtrName()>;
                        %endif
                        return %<SLibGetNullDefinitionFromTfl()>;

                        %selectfile setDWorkBuffer
                        (void) %<ssMxName>;
                        %if !isSingleInstance
                            (void) %<SLibGetMdlrefDWPtrName()>;
                        %endif
                    %endif

                    %selectfile getDWorkBuffer
                }
                %selectfile setDWorkBuffer
            }

            %closefile getDWorkBuffer
            %closefile setDWorkBuffer

            %<SLibCacheCodeToFile("mdl_fcn_defn", getDWorkBuffer)>
            %<SLibCacheCodeToFile("mdl_fcn_defn", setDWorkBuffer)>

            %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
            %% Code generation for header declarations.
            %%
            %openfile getDWorkBuffer
            %<LibExternInFcnDecls()>%<getterFcnSig>;
            %closefile getDWorkBuffer

            %openfile setDWorkBuffer
            %<LibExternInFcnDecls()>%<setterFcnSig>;
            %closefile setDWorkBuffer

            %<SLibCacheCodeToFile("mdl_fcn_prototype", getDWorkBuffer)>
            %<SLibCacheCodeToFile("mdl_fcn_prototype", setDWorkBuffer)>
        %endwith %% dwMembers
    %endwith  %% currentSystem.Interface
%endfunction

%% =========================================================================== |
%% Function: SLibCreateEmptyRTDWTreeObject
%% Abstract: Create an initialized empty instance of the record used to cache
%%           the results of traversing the RTDW tree.
%%
%% Members of the returned struct:
%%
%%    prefixName          : Name of this node in path to DWORK items.
%%
%%    numStateItems       : The number of POD items to store at this level.
%%
%%    numModelBlocks      : The number of Model blocks at this level.
%%
%%    numberOfIterations  : The number of times this level is iterated.
%%                          (> 0 == For Each SS)
%%
%%    numForEachSSs       : The number of For Each Subsystems at this level.
%%
%function SLibCreateEmptyRTDWTreeObject(newPrefixName)
    %createrecord rtdwTree { ...
        prefixName    newPrefixName; ...
        numStateItems       0; ...
        numModelBlocks      0; ...
        numberOfIterations  0; ...
        numForEachSSs       0  ...
    }

    %return rtdwTree
%endfunction

%% =========================================================================== |
%% Function: SLibRTDWTreeContainsPersistentState
%% Abstract: Returns true if there is something that needs to be cached.
%%
%function SLibRTDWTreeContainsPersistentState(rtdwTree)
    %return ...
        rtdwTree.numStateItems  > 0 || ...
        rtdwTree.numModelBlocks > 0 || ...
        rtdwTree.numForEachSSs  > 0
%endfunction

%% =========================================================================== |
%% Function: SLibEnumerateAndIndexRTDWTree
%% Abstract: Make a flat list of DWORK paths to be used in various places, and
%%           insert the corresponding indices to the flat list into each leaf
%%           node. For single-instance Model blocks, the model name is used
%%           as a placeholder since the paths are used as the field names for
%%           the container struct.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants4.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%%
%function SLibEnumerateAndIndexRTDWTree(...
    rtdwTree, prefix, rtdwList, loopDepth) void

    %foreach modelIdx = rtdwTree.numModelBlocks

        %assign thisBlock = rtdwTree.modelBlock[modelIdx]

        %addtorecord thisBlock index rtdwList.numItems

        %if WHITE_SPACE(thisBlock.dwName)
            %addtorecord rtdwList item { value thisBlock.modelName }
        %else
            %if ISFIELD(thisBlock, "modelBlockPrefix")
                %assign prefixToBlock = thisBlock.modelBlockPrefix
            %else
                %assign prefixToBlock = prefix
            %endif
            %addtorecord rtdwList item { value prefixToBlock + "." + thisBlock.dwName }
        %endif

        %assign rtdwList.numItems = rtdwList.numItems + 1
    %endforeach

    %foreach stateIdx = rtdwTree.numStateItems
        %assign thisState = rtdwTree.stateItem[stateIdx]

        %addtorecord thisState index rtdwList.numItems

        %addtorecord rtdwList item { value prefix + "." + thisState.name }

        %assign rtdwList.numItems = rtdwList.numItems + 1
    %endforeach

    %if rtdwTree.numForEachSSs > 0
        %assign maxLoopDepth = %<loopDepth> + 1

        %foreach ssIdx = rtdwTree.numForEachSSs
            %assign thisSS = rtdwTree.forEachSS[ssIdx]
            %assign subPrefix = prefix + "." + thisSS.prefixName + "[0]"
            %assign subLoopDepth = ...
                %<SLibEnumerateAndIndexRTDWTree(thisSS, subPrefix, rtdwList, loopDepth+1)>
            %if subLoopDepth > maxLoopDepth
                %assign maxLoopDepth = subLoopDepth
            %endif
        %endforeach

        %assign loopDepth = maxLoopDepth
    %endif

    %return loopDepth
%endfunction

%% =========================================================================== |
%% Function: SLibGetDWorkMemberNamesForSystem
%% Abstract: Construct the fully-qualified variable names for the members
%%           of the MdlrefDW_model_checksum_T struct and return them as
%%           a record.
%% TopTester: test/toolbox/simulink/variants/var-vss-condexecuted/tContPortGecks.m
%%
%function SLibGetDWorkMemberNamesForSystem(currentSystem, isSingleInstance)
    %assign hasRTB   = currentSystem.HasBlockIOArg
    %assign hasRTDW  = currentSystem.HasDWorkArg
    %assign hasRTZCE = currentSystem.HasZCEventArg
    %if ::isRAccel
        %assign rtbName   = LibGetBlockIOStruct()
        %assign rtdwName  = LibGetDWorkStruct()
        %assign rtzceName = LibGetPreviousZCStruct()
        %assign rtbMxName   = hasRTB   ? rtbName   : "NULL_B"
        %assign rtdwMxName  = hasRTDW  ? rtdwName  : "NULL_DW"
        %assign rtzceMxName = hasRTZCE ? rtzceName : "NULL_PrevZCX"
    %else
        %if isSingleInstance
            %assign rtbName   = FcnSysVarGroupNonreusedName(currentSystem, "BlockIO")
            %assign rtdwName  = FcnSysVarGroupNonreusedName(currentSystem, "DWork"  )
            %assign rtzceName = FcnSysVarGroupNonreusedName(currentSystem, "ZCEvent")

            %assign rtbMxName   = hasRTB   ? rtbName   : "NULL_B"
            %assign rtdwMxName  = hasRTDW  ? rtdwName  : "NULL_DW"
            %assign rtzceMxName = hasRTZCE ? rtzceName : "NULL_PrevZCX"
        %else
            %assign rtbName = !SLibGetUseRTMcgType() ? "rtb" : "rtm.blockIO"
            %assign dwName  = !SLibGetUseRTMcgType() ? "rtdw" : "rtm.dwork"
            %assign zceName = !SLibGetUseRTMcgType() ? "rtzce" : "rtm.prevZCSigState"
            %assign rtbMxName   = hasRTB   ? "%<rtbName>"   : "NULL->rtb"
            %assign rtdwMxName  = hasRTDW  ? "%<dwName>"  : "NULL->rtdw"
            %assign rtzceMxName = hasRTZCE ? "%<zceName>" : "NULL->rtzce"

            %assign mdlrefDWPtrName = SLibGetMdlrefDWPtrName()

            %assign rtbName   = hasRTB   ? "%<mdlrefDWPtrName>->%<rtbMxName>"   : ""
            %assign rtdwName  = hasRTDW  ? "%<mdlrefDWPtrName>->%<rtdwMxName>"  : ""
            %assign rtzceName = hasRTZCE ? "%<mdlrefDWPtrName>->%<rtzceMxName>" : ""

            %if SLibSimTargetUsesModelSelf()
                %if !hasRTDW && IsBaseSystem(currentSystem.SystemIdx)
                    %% At the root level, rtm acts like dwork. So use rtm to populate names.
                    %assign rtdwMxName = "rtm"
                    %assign rtdwName = "%<mdlrefDWPtrName>->%<rtdwMxName>"
                %endif
            %endif
        %endif
    %endif

    %createrecord dwMembers { ...
        rtbName   "%<rtbName>"   ;  rtbMxName   "%<rtbMxName>"   ; ...
        rtdwName  "%<rtdwName>"  ;  rtdwMxName  "%<rtdwMxName>"  ; ...
        rtzceName "%<rtzceName>" ;  rtzceMxName "%<rtzceMxName>" ; ...
        hasRTB %<hasRTB> ; hasRTDW %<hasRTDW> ; hasRTZCE %<hasRTZCE> ...
    }

    %return dwMembers
%endfunction

%% =========================================================================== |
%% Function: SLibWriteGetDWorkPreamble
%% Abstract: Write the variable declarations needed at the beginning of the
%%           top-level scope of mr_model_{Get,Set}DWork.
%%
%function SLibWriteGetDWorkPreamble(...
    rtbMxName, rtdwMxName, rtzceMxName, ssMxName, getDWorkBuffer) void
    %assign charType = LibGetDataTypeNameFromId(::CompiledModel.tSS_CHAR)
    %assign equalSign = LibGetDataInitEqualSign()
    %assign tokens = LibGetScalarDataInitTokens()
    %selectfile getDWorkBuffer
    static const %<charType> * %<ssMxName>FieldNames[3]%<equalSign>{
        "%<rtbMxName>",
        "%<rtdwMxName>",
        "%<rtzceMxName>",
    };
    mxArray * %<ssMxName>%<tokens[0]>mxCreateStructMatrix(1, 1, 3, %<ssMxName>FieldNames)%<tokens[1]>;
%endfunction

%% =========================================================================== |
%% Function: SLibGetCreateInitRestoreDataFcnNameForModel
%% Abstract: Creates the mr_model_CreateInitRestoreData function name.
%%
%function SLibGetCreateInitRestoreDataFcnNameForModel(modelName)
    %return "mr_%<modelName>_CreateInitRestoreData"
%endfunction

%% =========================================================================== |
%% Function: SLibGetCopyFromInitRestoreDataFcnNameForModel
%% Abstract: Creates the mr_model_CopyFromInitRestoreData function name.
%%
%function SLibGetCopyFromInitRestoreDataFcnNameForModel(modelName)
    %return "mr_%<modelName>_CopyFromInitRestoreData"
%endfunction

%% =========================================================================== |
%% Function: SLibGetDestroyInitRestoreDataFcnNameForModel
%% Abstract: Creates the mr_model_DestroyInitRestoreData function name.
%%
%function SLibGetDestroyInitRestoreDataFcnNameForModel(modelName)
    %return "mr_%<modelName>_DestroyInitRestoreData"
%endfunction

%% =========================================================================== |
%% Function: SLibWriteMdlRefInitRestoreDataFcns
%% Abstract: Write the functions to handle saving and restoring data in the
%%           DWork structure of the referenced model after initialization.
%%           These functions are
%%              mr_model_CreateInitRestoreData()
%%              mr_model_CopyFromInitRestoreData()
%%              mr_model_DestroyInitRestoreData()
%%
%function SLibWriteMdlRefInitRestoreDataFcns() void
    %if ModelRefBlockHasPrivateDWork()
        %assign modelName = ::CompiledModel.Name
        %assign initRestoreData = "%<modelName>_InitRestoreDataPtr"
        %assign createDataFcnSignature = ...
            "void %<SLibGetCreateInitRestoreDataFcnNameForModel(modelName)>()"
        %assign copyDataFcnSignature = ...
            "void %<SLibGetCopyFromInitRestoreDataFcnNameForModel(modelName)>()"
        %assign destroyDataFcnSignature = ...
            "void %<SLibGetDestroyInitRestoreDataFcnNameForModel(modelName)>()"
        %openfile tmpBuffer
        static void *%<initRestoreData> = %<SLibGetNullDefinitionFromTfl()>;

        %<createDataFcnSignature>
        {
            %<initRestoreData> = utMalloc(sizeof(%<LibGetDWorkStruct()>));
            memcpy(%<initRestoreData>, (void *) &(%<LibGetDWorkStruct()>), sizeof(%<LibGetDWorkStruct()>));
        }

        %<copyDataFcnSignature>
        {
            memcpy((void *) &(%<LibGetDWorkStruct()>), %<initRestoreData>, sizeof(%<LibGetDWorkStruct()>));
        }

        %<destroyDataFcnSignature>
        {
            utFree(%<initRestoreData>);
        }
        %closefile tmpBuffer
        %<SLibCacheCodeToFile("mdl_fcn_defn", tmpBuffer)>

        %openfile tmpBuffer
        %<createDataFcnSignature>;
        %<copyDataFcnSignature>;
        %<destroyDataFcnSignature>;
        %closefile tmpBuffer
        %<SLibCacheCodeToFile("mdl_fcn_decl", tmpBuffer)>
    %endif
%endfunction

%% =========================================================================== |
%% Function: SLibIgnoreThisDWorkForOP
%% Abstract: Returns true if the argument DWORK is declared to be a PWORK or
%%           pointer type, or is not state and the block declares HAS_NO_SIM_STATE.
%% TopTester: test/toolbox/simulink/modelref/SimState/tHasNoSimState_G2330827.m
%%
%function SLibIgnoreThisDWorkForOP(thisDWork)
    %if thisDWork.Origin == "PWORK"
        %return TLC_TRUE
    %endif

    %if thisDWork.IgnoreThisDWorkForOP != 0
        %return TLC_TRUE
    %endif

    %if LibCGTypeIsPointer(thisDWork.CGTypeIdx)
        %return TLC_TRUE
    %endif

    %if LibCGTypeIsMatrix(thisDWork.CGTypeIdx) && ...
        LibCGTypeIsPointer(LibCGTypeBaseIndex(thisDWork.CGTypeIdx))
        %return TLC_TRUE
    %endif

    %return TLC_FALSE
%endfunction

%% =========================================================================== |
%% Function: SLibGetDWorkStateItemsForVarGroup
%% Abstract: Recursively make a flat list of members of the DW to cache for
%%           the current model. Includes MdlrefDW structs for multi-instance
%%           models.
%% TopTester: test/toolbox/simulink/blocks/sb2sl/tsb2slmdlref2.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants4.m
%%
%function SLibGetDWorkStateItemsForVarGroup(rtdwTree, varGroupIdx) void

    %if varGroupIdx >= 0

        %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
        %assign isSelfVarGroup = varGroup.IsModelSelfCoderGroupVarGroup
        %assign cgTypeIdx = varGroup.CGTypeIdx

        %if LibCGTypeIsMatrix(cgTypeIdx) %% this is a ForEach SS

            %% grab the number of iterations of this SS
            %assign rtdwTree.numberOfIterations = LibCGTypeWidth(varGroup.CGTypeIdx)

            %% proceed using the base type of the SS
            %assign cgTypeIdx = LibCGTypeBaseIndex(varGroup.CGTypeIdx)

        %endif

        %foreach mIdx = LibCGTypeNumMembers(cgTypeIdx)

            %assign memberName = LibCGTypeMemberName(cgTypeIdx, mIdx)

            %assign idnum = IDNUM(varGroup.VarGroupElements[mIdx])

            %assign recType = idnum[0]
            %assign recIdx  = idnum[1]

            %switch recType
              %case "W"
              %case "LDW" %% local scratch dwork converted to global
                %if isSelfVarGroup
                    %continue
                %endif
                %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
                %% Most DWORKs fall under this case.
                %%
                %assign dataRec = SLibGetDataRecForVarGroupMember(recType, recIdx)
                %assign sysIdx  = dataRec.SigSrc[0]
                %assign blkIdx  = dataRec.SigSrc[2]

                %if !(sysIdx >= 0 && blkIdx >= 0) %% is virtual
                    %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
                    %% If we ever encounter this combination, abort the compilation.
                    %%
                    %<SLibReportErrorWithIdAndArgs(...
                        "Simulink:modelReference:InternalCodeGenerationError", ...
                        Name + ": Virtual DWORK")>
                    %exit
                %endif

                %assign ownerBlk = ::CompiledModel.System[sysIdx].Block[blkIdx]

                %if "ModelReference" == ownerBlk.Type && "DWORK" == dataRec.Origin
                    %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
                    %% Multi-instance Model blocks will have an entry in the DWORK
                    %% tree. The MdlrefDW items for single-instance Models are picked
                    %% up in SLibGetDWorkPairsForSingleInstanceModelBlocks.
                    %%

                    %assign isInitStatusDWork = TLC_FALSE
                    %if ISFIELD(dataRec, "DWorkForInitStatus")
                        %assign isInitStatusDWork = (dataRec.DWorkForInitStatus == 1)
                    %endif

                    %if GetModelrefInterface(ownerBlk).IsScalableBuild || isInitStatusDWork
                        %% This is an S-Function DWork owned by a single-instance model
                        %% referenced from ownerBlk. Add it to the list of states
                        %%
                        %if !SLibIgnoreThisDWorkForOP(dataRec)
                            %<SLibAppendStateItem(...
                                varGroup, mIdx, rtdwTree, memberName, dataRec)>
                        %endif
                    %else
                        %% This is a MdlrefDW struct that belongs to the model
                        %% referenced by this block.
                        %%
                        %addtorecord rtdwTree ...
                            modelBlock { ...
                            modelName ownerBlk.ParamSettings.ReferencedModelName; ...
                            dwName memberName ...
                        }
                        %assign rtdwTree.numModelBlocks = rtdwTree.numModelBlocks + 1
                    %endif
                %elseif !SLibIgnoreThisDWorkForOP(dataRec) %% all non-ModelReference blocks
                    %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
                    %% Most POD DWORKs will be picked up here.
                    %%
                    %<SLibAppendStateItem(...
                        varGroup, mIdx, rtdwTree, memberName, dataRec)>
                %endif

                %break %% case "W" "LDW"

              %case "VG"
                %if isSelfVarGroup
                    %continue
                %endif
                %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
                %% Recursively descend into non-virtual subsystems.
                %%
                %assign newRtdwTree = SLibCreateEmptyRTDWTreeObject(memberName)

                %<SLibGetDWorkStateItemsForVarGroup(newRtdwTree, recIdx)>

                %if newRtdwTree.numberOfIterations > 0
                    %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
                    %% If we parsed a ForEach SS DWORK structure, we need to add an
                    %% entry for each instance with the proper index appended the
                    %% member name prefix prior to the dot operator.
                    %%
                    %addtorecord rtdwTree forEachSS %<newRtdwTree>
                    %assign rtdwTree.numForEachSSs = rtdwTree.numForEachSSs + 1
                %else
                    %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
                    %% This is a normal sub-structure in the DWORK, all we need is
                    %% the dot operator. Fold the new sub-tree into the existing tree.
                    %%
                    %<SLibAppendNewRtdwTree(rtdwTree, newRtdwTree)>
                %endif

                %break %% case "VG"

              %case "S"
                %if isSelfVarGroup
                    %continue
                %endif
                %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
                %%
                %addtorecord rtdwTree ...
                    stateItem { name memberName; bitFieldWidth 0 }

                %assign rtdwTree.numStateItems = rtdwTree.numStateItems + 1

                %break %% case "S"

              %case "PCDG"
                %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
                %% When child model's DWork is contained in RTM (child model's
                %% self coder data group vargroup)
                %%
                %assign prefixName = "%<SLibGetMdlrefDWPtrName()>->rtm"
                %assign group = FcnGetCoderGroupForVarGroup(varGroup)
                %assign childDataGroup = FcnGetChildDataGroup(group, recIdx)
                %assert childDataGroup.AsStructure == "InParent"
                %assign mdlrefBlock = ::CompiledModel.ModelReferenceBlocks[childDataGroup.CompiledModelBlockIndex]
                %assign ownerBlk = ::CompiledModel.System[mdlrefBlock[0]].Block[mdlrefBlock[1]]

                %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
                %% Multi-instance Model blocks will have an entry in the DWORK
                %% tree. The MdlrefDW items for single-instance Models are picked
                %% up in SLibGetDWorkPairsForSingleInstanceModelBlocks.
                %%
                %assign mdlrefInterface = GetModelrefInterface(ownerBlk)
                %if mdlrefInterface.IsScalableBuild
                    %% This is an S-Function DWork owned by a single-instance model
                    %% referenced from ownerBlk. Add it to the list of states
                    %%
                    %if !SLibIgnoreThisDWorkForOP(dataRec)
                        %<SLibAppendStateItem(...
                            varGroup, mIdx, rtdwTree, memberName, dataRec)>
                    %endif
                %else
                    %% This is a DWork struct that belongs to the model
                    %% referenced by this block.
                    %%
                    %addtorecord rtdwTree ...
                        modelBlock { ...
                        modelName ownerBlk.ParamSettings.ReferencedModelName; ...
                        modelBlockPrefix prefixName ...
                        mdlrefDWorkType "%<mdlrefInterface.DWorkType>" ...
                        dwName memberName ...
                    }
                    %assign rtdwTree.numModelBlocks = rtdwTree.numModelBlocks + 1
                %endif

                %break %% case "PCDG"

              %default
                %if SLibSimTargetUsesModelSelf()
                    %% In this case, RTM is passed in to build up the rtdwTree. RTM
                    %% can contain other types of vargroups. DWork vargroup and child
                    %% RTMs are handled above, and other vargroups will be skipped.
                    %break %% skip unhandled vargroups
                %endif
                %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
                %% If there other states that we haven't handled, abort compilation.
                %%
                %<SLibReportErrorWithIdAndArgs(...
                    "Simulink:modelReference:InternalCodeGenerationError", ...
                    Name + ": Unexpected recType")>
                %exit
            %endswitch
        %endforeach
    %endif

%endfunction

%% =========================================================================== |
%% Function: SLibAppendStateItem
%% Abstract: Append the current struct data member to the list of new state
%%           items for the system of interest.
%%
%function SLibAppendStateItem(...
    varGroup, mIdx, rtdwTree, memberName, dataRec) void

    %assign subStructIdx = varGroup.NumSubStructs > 0 ? ...
        varGroup.SubStructIndex[mIdx] : -1

    %assign subStructPath = -1 != subStructIdx ? ...
        varGroup.SubStuctNames[subStructIdx] + "." : ""

    %addtorecord rtdwTree ...
        stateItem { ...
        name subStructPath + memberName; ...
        bitFieldWidth dataRec.BitFieldWidth ...
    }

    %assign rtdwTree.numStateItems = rtdwTree.numStateItems + 1

%endfunction

%% =========================================================================== |
%% Function: SLibAppendNewRtdwTree
%% Abstract: Append the given tree of DWORK items to the current tree,
%%           prepending the new tree's prefix path.
%% TopTester: test/toolbox/simulink/variants/var-export-fcns/tExportFcnsWithInlineVariants.m
%function SLibAppendNewRtdwTree(rtdwTree, newRtdwTree) void

    %assign prefix = newRtdwTree.prefixName + "."

    %foreach stateIdx = newRtdwTree.numStateItems

        %addtorecord rtdwTree ...
            stateItem { ...
            name prefix + newRtdwTree.stateItem[stateIdx].name; ...
            bitFieldWidth newRtdwTree.stateItem[stateIdx].bitFieldWidth ...
        }

    %endforeach

    %assign rtdwTree.numStateItems = ...
        rtdwTree.numStateItems + newRtdwTree.numStateItems

    %foreach blockIdx = newRtdwTree.numModelBlocks

        %assign thisDwName = newRtdwTree.modelBlock[blockIdx].dwName

        %addtorecord rtdwTree ...
            modelBlock { ...
            modelName newRtdwTree.modelBlock[blockIdx].modelName; ...
            dwName "" == thisDwName ? "" : prefix + thisDwName ...
        }

    %endforeach

    %assign rtdwTree.numModelBlocks = ...
        rtdwTree.numModelBlocks + newRtdwTree.numModelBlocks

    %foreach ssIdx = newRtdwTree.numForEachSSs

        %assign thisForEachSS = newRtdwTree.forEachSS[ssIdx]
        %assign thisForEachSS.prefixName = prefix + thisForEachSS.prefixName
        %addtorecord rtdwTree forEachSS %<thisForEachSS>

    %endforeach

    %assign rtdwTree.numForEachSSs = ...
        rtdwTree.numForEachSSs + newRtdwTree.numForEachSSs

%endfunction

%% =========================================================================== |
%% Function: SLibGetDWorkPairsForSingleInstanceModelBlocks
%% Abstract: Appends entries for the single-instance referenced models to
%%           the provided list of { model ; path.to.model_DWORK1 } pairs.
%%
%%         > Single-instance referenced models own their state, so an empty
%%           string is returned for the path. This signifies that the
%%           getter/setter does not require a pointer to be passed from the
%%           parent model.
%%
%%         > Multi-instance referenced models place their state in the RTDW
%%           heirarchy, so the data needed to generate calls to their
%%           respective mr_model_{get,set}DWork functions is picked up in
%%           SLibGetDWorkStateItemsForVarGroup.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%%
%function SLibGetDWorkPairsForSingleInstanceModelBlocks(rtdwTree) void

    %foreach idIdx = NumModelReferenceBlocks

        %assign blkIdx  = ModelReferenceBlocks[idIdx]
        %assign mdlBlk  = System[blkIdx[0]].Block[blkIdx[1]]
        %assign blkIntf = GetModelrefInterface(mdlBlk)

        %if blkIntf.IsScalableBuild %% single-instance mode

            %addtorecord rtdwTree ...
                modelBlock { ...
                modelName mdlBlk.ParamSettings.ReferencedModelName; ...
                dwName "" ...
            }

            %assign rtdwTree.numModelBlocks = rtdwTree.numModelBlocks + 1

        %endif
    %endforeach
%endfunction

%% =========================================================================== |
%% Function: SLibWriteGetSetRTDWContents
%% Abstract: Writes code to cache/restore the contents of dw->rtdw/model_DW.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%%
%function SLibWriteGetSetRTDWContents(...
    rtdwTree, ...
    ssMxName, ssMxIndex, ...
    getDWorkBuffer, setDWorkBuffer) void

    %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
    %% Prepare to generate code.
    %%
    %createrecord rtdwList { numItems 0 }
    %assign maxLoopDepth = ...
        SLibEnumerateAndIndexRTDWTree(rtdwTree, rtdwTree.prefixName, rtdwList, 0)

    %% for variable and constant declarations at the beginning of the rtdw scope
    %openfile getDWorkDeclarationsBuffer
    %openfile setDWorkDeclarationsBuffer

    %% for memory allocation statements and other things that must happen between
    %% the definition statements and the main body
    %openfile getDWorkPreambleBuffer
    %openfile setDWorkPreambleBuffer

    %% for the actual load/save operation statements
    %openfile getDWorkBodyBuffer
    %openfile setDWorkBodyBuffer

    %% for anything that must be done after all of the state load/save operations
    %% are complete
    %openfile getDWorkEpilogueBuffer
    %openfile setDWorkEpilogueBuffer

    %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
    %% Generate code.
    %%
    %assign rtdwMxName = "rtdwData"

    %<SLibWriteGetSetRTDWDeclarations(...
        rtdwList, rtdwMxName, ...
        ssMxName, ssMxIndex, ...
        getDWorkDeclarationsBuffer, setDWorkDeclarationsBuffer)>

    %<SLibWriteGetSetRTDWItems(...
        rtdwTree, rtdwList, maxLoopDepth, ...
        rtdwMxName, ...
        getDWorkDeclarationsBuffer, setDWorkDeclarationsBuffer, ...
        getDWorkPreambleBuffer, setDWorkPreambleBuffer, ...
        getDWorkBodyBuffer, setDWorkBodyBuffer)>

    %<SLibWriteGetSetRTDWEpilogue(...
        rtdwMxName, ssMxName, ssMxIndex, ...
        getDWorkEpilogueBuffer, setDWorkEpilogueBuffer)>

    %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
    %% Consolidate generated code.
    %%
    %closefile getDWorkDeclarationsBuffer
    %closefile setDWorkDeclarationsBuffer

    %closefile getDWorkPreambleBuffer
    %closefile setDWorkPreambleBuffer

    %closefile getDWorkBodyBuffer
    %closefile setDWorkBodyBuffer

    %closefile getDWorkEpilogueBuffer
    %closefile setDWorkEpilogueBuffer

    %selectfile getDWorkBuffer

    %<getDWorkDeclarationsBuffer>
    %<getDWorkPreambleBuffer>
    %<getDWorkBodyBuffer>
    %<getDWorkEpilogueBuffer>

    %selectfile setDWorkBuffer

    %<setDWorkDeclarationsBuffer>
    %<setDWorkPreambleBuffer>
    %<setDWorkBodyBuffer>
    %<setDWorkEpilogueBuffer>

%endfunction

%% =========================================================================== |
%% Function: SLibWriteGetSetRTDWDeclarations
%% Abstract: Open a new scope and declare local variables needed to cache the
%%           contents of dw->rtdw/model_DW.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%%
%function SLibWriteGetSetRTDWDeclarations(...
    rtdwList, ...
    rtdwMxName, ssMxName, ssMxIndex, ...
    getDWorkDeclarationsBuffer, setDWorkDeclarationsBuffer) void
    %assign charType = LibGetDataTypeNameFromId(::CompiledModel.tSS_CHAR)

    %assign equalSign = LibGetDataInitEqualSign()
    %assign tokens = LibGetScalarDataInitTokens()

    %selectfile getDWorkDeclarationsBuffer

    {
        %assign createStructMatrixArgument = "%<rtdwMxName>FieldNames"
        %if rtdwList.numItems > 0
            static const %<charType> * %<rtdwMxName>FieldNames[%<rtdwList.numItems>]%<equalSign>{
                %foreach itemIdx = rtdwList.numItems
                    "%<rtdwList.item[itemIdx].value>",
                %endforeach
            };
        %else
            static const %<charType> * %<rtdwMxName>FieldNames%<tokens[0]>NULL%<tokens[1]>;
            %assign createStructMatrixArgument = "&" + createStructMatrixArgument
        %endif
        mxArray * %<rtdwMxName>%<tokens[0]>
        mxCreateStructMatrix(1, 1, %<rtdwList.numItems>, %<createStructMatrixArgument>)%<tokens[1]>;

        %selectfile setDWorkDeclarationsBuffer

        {
            const mxArray * %<rtdwMxName>%<tokens[0]>
            mxGetFieldByNumber(%<ssMxName>, 0, %<ssMxIndex>)%<tokens[1]>;
    %%}}

%endfunction

%% =========================================================================== |
%% Function: SLibWriteGetSetRTDWEpilogue
%% Abstract: Terminate the block scope that caches/restores the rtdw struct.
%%
%function SLibWriteGetSetRTDWEpilogue(...
    rtdwMxName, ssMxName, ssMxIndex, ...
    getDWorkBodyBuffer, setDWorkBodyBuffer) void

    %selectfile getDWorkBodyBuffer

    mxSetFieldByNumber(%<ssMxName>, 0, %<ssMxIndex>, %<rtdwMxName>);
}

%selectfile setDWorkBodyBuffer

}

%endfunction

%% =========================================================================== |
%% Function: SLibWriteGetSetRTDWItems
%% Abstract: Writes the code that caches/restores the MdlrefDW contents.
%%
%% This creates a record of commonly-used items such as loop variable names,
%% along with the workspace used to compute offsets when marshalling DWORKS
%% contained within a For Each SS. After this record is created, recurse the
%% tree and populate the loop bodies.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%%
%function SLibWriteGetSetRTDWItems(...
    rtdwTree, rtdwList, maxLoopDepth, rtdwMxName, ...
    getDWorkDeclarationsBuffer, setDWorkDeclarationsBuffer, ...
    getDWorkPreambleBuffer, setDWorkPreambleBuffer, ...
    getDWorkBodyBuffer, setDWorkBodyBuffer) void

    %createrecord forEachDims { numDims 0; maxDims %<maxLoopDepth> }

    %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
    %% If we are generating loop bodies, pre-generate the variable names and
    %% emit code declaring the loop counter variables. Since we may have multiple
    %% loop scopes, we emit the offsetN variable at the start of each loop body
    %% instead of declaring them with the loop counter. Loop counts are written
    %% as numeric literals.
    %%
    %foreach loopIdx = maxLoopDepth

        %addtorecord forEachDims dim { size 0 }

        %assign loopVarName = "k" + "%<loopIdx>"

        %addtorecord forEachDims loopVar { name loopVarName }
        %addtorecord forEachDims offsetVar { name "offset%<loopIdx>" }

        %selectfile getDWorkDeclarationsBuffer

        int %<loopVarName>;

        %selectfile setDWorkDeclarationsBuffer

        int %<loopVarName>;

    %endforeach

    %<SLibTraverseAndGenerateGetSetRTDWItems(...
        rtdwTree, rtdwList, forEachDims, "", rtdwMxName, ...
        getDWorkPreambleBuffer, setDWorkPreambleBuffer, ...
        getDWorkBodyBuffer, setDWorkBodyBuffer)>

%endfunction

%% =========================================================================== |
%% Function: SLibTraverseAndGenerateGetSetRTDWItems
%% Abstract: Recursively descend the intermediate tree of DWORK items.
%%
%% DWORKs contained inside atomic SSs within a For Each SS are folded into their
%% enclosing For Each SS. On entry, we write out all DWORK items that are not
%% contained within a For Each SS, then traverse the tree of each For Each SS.
%% At each level, we open a new loop body on entry and close it on exit.
%%
%% Within a given loop body, then number of copies of all DWORKS at that level
%% of the tree are fixed. This number is stored in the variable "offset{0,...}"
%% and used where appropriate.
%%
%% Memory allocation for each DWORK happens in the preamble. For MdlrefDW and
%% bitfield types, a cell matrix is created. All other items are marshalled
%% into an appropriately-sized uint8_T array.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%% TopTester: test/toolbox/simulink/variants/modelVariants/tInactiveVariants.m
%%
%function SLibTraverseAndGenerateGetSetRTDWItems(...
    rtdwTree, rtdwList, forEachDims, prefixName, rtdwMxName, ...
    getDWorkPreambleBuffer, setDWorkPreambleBuffer, ...
    getDWorkBodyBuffer, setDWorkBodyBuffer) void

    %assert 0 == rtdwTree.numberOfIterations
    %assert WHITE_SPACE(prefixName)

    %assign scalarTokens = LibGetScalarDataInitTokens()

    %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
    %% Emit code for Model blocks
    %%
    %foreach modelIdx = rtdwTree.numModelBlocks
        %assign thisBlock = rtdwTree.modelBlock[modelIdx]
        %assign modelName = thisBlock.modelName
        %assign dwIndex = thisBlock.index
        %assign dwName = rtdwList.item[dwIndex].value
        %assign dwCast = ISFIELD(thisBlock, "mdlrefDWorkType") ? ...
            "(%<thisBlock.mdlrefDWorkType>*)" : ""
        %assign isSingleInstanceModelBlock = WHITE_SPACE(thisBlock.dwName)

        %selectfile getDWorkBodyBuffer
        {

            %if isSingleInstanceModelBlock
                mxArray* varData%<scalarTokens[0]>%<SLibCreateGetDWorkFcnNameForModel(modelName)>()%<scalarTokens[1]>;
            %else
                mxArray* varData%<scalarTokens[0]>%<SLibCreateGetDWorkFcnNameForModel(modelName)>(\
                %<dwCast> &(%<dwName>))%<scalarTokens[1]>;
            %endif
            mxSetFieldByNumber(%<rtdwMxName>, 0, %<dwIndex>, varData);
        }

        %selectfile setDWorkBodyBuffer

        %if isSingleInstanceModelBlock
            %<SLibCreateSetDWorkFcnNameForModel(modelName)>(\
            mxGetFieldByNumber(%<rtdwMxName>, 0, %<dwIndex>));
        %else
            %<SLibCreateSetDWorkFcnNameForModel(modelName)>(
            %<dwCast> &(%<dwName>),
            mxGetFieldByNumber(%<rtdwMxName>, 0, %<dwIndex>));
        %endif

    %endforeach

    %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
    %% Emit code for this model's DWORKs
    %%
    %foreach stateIdx = rtdwTree.numStateItems
        %assign thisState = rtdwTree.stateItem[stateIdx]
        %assign numBits   = thisState.bitFieldWidth

        %assign dwIndex = thisState.index
        %assign dwName  = rtdwList.item[dwIndex].value

        %if 0 != numBits
            %<SLibWriteCacheRestoreBitFieldToFromMxArray(...
                dwName, rtdwMxName, dwIndex, ...
                numBits, getDWorkBodyBuffer, setDWorkBodyBuffer)>
        %else
            %if ::GenCPP && ::isRAccel
                %<SLibWriteCacheRestoreVariableToFromMxArrayCPPGen(...
                    dwName, rtdwMxName, dwIndex, ...
                    getDWorkBodyBuffer, setDWorkBodyBuffer)>
            %else
                %<SLibWriteCacheRestoreVariableToFromMxArray(...
                    dwName, rtdwMxName, dwIndex, ...
                    getDWorkBodyBuffer, setDWorkBodyBuffer)>
            %endif
        %endif

    %endforeach

    %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
    %% Recursively emit code for For Each SS blocks
    %%
    %foreach ssIdx = rtdwTree.numForEachSSs

        %<SLibGenerateForEachGetSetRTDWItems(...
            rtdwTree.forEachSS[ssIdx], rtdwList, forEachDims, ...
            rtdwTree.prefixName, rtdwMxName, ...
            getDWorkPreambleBuffer, setDWorkPreambleBuffer, ...
            getDWorkBodyBuffer, setDWorkBodyBuffer)>

    %endforeach

%endfunction

%% =========================================================================== |
%% Function: SLibGenerateForEachGetSetRTDWItems
%% Abstract: Emit code to cache/restore DWORK items that are inside a
%%           For Each SS hierarchy.
%%
%% Recurses on every For Each SS it contains.
%%
%function SLibGenerateForEachGetSetRTDWItems(...
    rtdwTree, rtdwList, forEachDims, prefixName, rtdwMxName, ...
    getDWorkPreambleBuffer, setDWorkPreambleBuffer, ...
    getDWorkBodyBuffer, setDWorkBodyBuffer) void

    %assert 0 < rtdwTree.numberOfIterations
    %assert !WHITE_SPACE(prefixName)

    %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
    %% Setup up dimensions and loop variables
    %%
    %assign loopVarName = forEachDims.loopVar[forEachDims.numDims].name
    %assign fullPrefix  = "%<prefixName>.%<rtdwTree.prefixName>[%<loopVarName>]"

    %assign forLoopStatement = ...
        "for(" + loopVarName + " = 0; " ...
        +  loopVarName + " < " + "%<rtdwTree.numberOfIterations>" + "; " ...
        + "++" + loopVarName + ")"

    %assign forEachDims.dim[forEachDims.numDims].size = rtdwTree.numberOfIterations
    %assign offsetVarName = forEachDims.offsetVar[forEachDims.numDims].name
    %assign forEachDims.numDims = forEachDims.numDims + 1
    %assign loopOffsetStatement = SLibGetOffsetDefinitionForLoop(forEachDims)
    %assign matrixSize = SLibGetMatrixSizeForLoop(forEachDims)

    %assign scalarTokens = LibGetScalarDataInitTokens()

    %selectfile getDWorkBodyBuffer

    %<forLoopStatement>
    {
        %<loopOffsetStatement>

        %selectfile setDWorkBodyBuffer

        %<forLoopStatement>
        {
            %<loopOffsetStatement>

            %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
            %% Emit code for Model blocks
            %%
            %foreach modelIdx = rtdwTree.numModelBlocks
                %assign thisBlock = rtdwTree.modelBlock[modelIdx]
                %assign modelName = thisBlock.modelName
                %assign dwIndex = thisBlock.index
                %assign dwName = fullPrefix  + "." + thisBlock.dwName

                %if WHITE_SPACE(thisBlock.dwName)
                    %<SLibReportErrorWithIdAndArgs(...
                        "Simulink:modelReference:InternalCodeGenerationError", ...
                        Name + ": Single-instance Model block within For Each Subsystem")>
                %endif

                %selectfile getDWorkPreambleBuffer

                mxSetFieldByNumber(%<rtdwMxName>, 0, %<dwIndex>, \
                mxCreateCellMatrix(1, %<matrixSize>));

                %selectfile getDWorkBodyBuffer
                {

                    mxArray* varData%<scalarTokens[0]>%<SLibCreateGetDWorkFcnNameForModel(modelName)>( \
                    &(%<dwName>))%<scalarTokens[1]>;

                    mxSetCell(mxGetFieldByNumber(%<rtdwMxName>, 0, %<dwIndex>), \
                    %<offsetVarName>, varData);
                }

                %selectfile setDWorkBodyBuffer

                %<SLibCreateSetDWorkFcnNameForModel(modelName)>(\
                &(%<dwName>), \
                mxGetCell(mxGetFieldByNumber(%<rtdwMxName>,0, %<dwIndex>), \
                %<offsetVarName>));

            %endforeach

            %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
            %% Emit code for DWORK items at this level
            %%
            %foreach stateIdx = rtdwTree.numStateItems
                %assign thisState = rtdwTree.stateItem[stateIdx]
                %assign numBits   = thisState.bitFieldWidth

                %assign dwIndex = thisState.index
                %assign dwName  = fullPrefix + "." + thisState.name

                %if 0 != numBits

                    %selectfile getDWorkPreambleBuffer

                    mxSetFieldByNumber(%<rtdwMxName>, 0, %<dwIndex>, \
                    mxCreateCellMatrix(1, %<matrixSize>));

                    %selectfile getDWorkBodyBuffer

                    %<SLibGetCacheBitFieldToCellArrayWithOffsetFcnName()>(\
                    %<rtdwMxName>, 0, %<dwIndex>, %<offsetVarName>, %<dwName>);

                    %selectfile setDWorkBodyBuffer

                    %<dwName> = %<SLibGetExtractBitFieldFromCellArrayWithOffsetFcnName()>(\
                    %<rtdwMxName>, 0, %<dwIndex>, %<offsetVarName>, %<numBits>);

                %else

                    %selectfile getDWorkPreambleBuffer

                    mxSetFieldByNumber(%<rtdwMxName>, 0, %<dwIndex>, \
                    mxCreateUninitNumericMatrix( \
                    1, \
                    %<matrixSize>*sizeof(%<rtdwList.item[dwIndex].value>), \
                    mxUINT8_CLASS, mxREAL));

                    %selectfile getDWorkBodyBuffer

                    %<SLibGetCacheDataToMxArrayWithOffsetFcnName()>( \
                    %<rtdwMxName>, 0, %<dwIndex>, %<offsetVarName>, \
                    &(%<dwName>), sizeof(%<rtdwList.item[dwIndex].value>));

                    %selectfile setDWorkBodyBuffer

                    %<SLibGetRestoreDataFromMxArrayWithOffsetFcnName()>( \
                    &(%<dwName>), \
                    %<rtdwMxName>, 0, %<dwIndex>, %<offsetVarName>, \
                    sizeof(%<rtdwList.item[dwIndex].value>));

                %endif

            %endforeach

            %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
            %% Recursively emit code for For Each SSs at this level
            %%
            %foreach ssIdx = rtdwTree.numForEachSSs

                %<SLibGenerateForEachGetSetRTDWItems(...
                    rtdwTree.forEachSS[ssIdx], rtdwList, forEachDims, ...
                    fullPrefix, rtdwMxName, ...
                    getDWorkPreambleBuffer, setDWorkPreambleBuffer, ...
                    getDWorkBodyBuffer, setDWorkBodyBuffer)>

            %endforeach

            %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
            %% Close this loop body and decrement the dimensions vector counter
            %%
            %selectfile getDWorkBodyBuffer
        }

        %selectfile setDWorkBodyBuffer
    }

    %assign forEachDims.numDims = forEachDims.numDims - 1

%endfunction

%% =========================================================================== |
%% Function: SLibGetOffsetDefinitionForLoop
%% Abstract: Compute and define the offsetN variable for the innermost loop body
%%           with the specified dimensions. Returns the variable definition
%%           statement.
%%
%% This is the offset into the array used to store the instances of a DWORK
%% contained within a For Each SS. The value is
%%
%%   offset_(N_d-1) = Sum_(i=0)_(N_d-1) { k_i * Prod_(j=i+1)_(j=N_d-1){ l_j } }
%%
%%   , where
%%
%%   N_d = depth of the loop nest
%%   k_i = loop variable of the i'th dimension
%%   l_j = number of loops over the j'th dimension
%%
%% (We use the convention that Prod_n_n {} = 1)
%%
%function SLibGetOffsetDefinitionForLoop(forEachDims)
    %assign offsetVal = ""

    %foreach i = forEachDims.numDims

        %if i > 0
            %assign offsetVal = offsetVal + " + "
        %endif

        %assign offsetVal = offsetVal + forEachDims.loopVar[i].name

        %foreach j = forEachDims.numDims
            %if j > i
                %assign offsetVal = offsetVal + "*%<forEachDims.dim[j].size>"
            %endif
        %endforeach

    %endforeach

    %assign scalarTokens = LibGetScalarDataInitTokens()

    %return "const mwIndex %<forEachDims.offsetVar[forEachDims.numDims-1].name>" ...
        + "%<scalarTokens[0]>%<offsetVal>%<scalarTokens[1]>;"

%endfunction

%% =========================================================================== |
%% Function: SLibGetMatrixSizeForLoop
%% Abstract: For a given loop nesting level, compute the number of times its
%%           body will be executed and return it.
%%
%function SLibGetMatrixSizeForLoop(forEachDims)
    %assign matrixSize = 1
    %foreach i = forEachDims.numDims
        %assign matrixSize = matrixSize * forEachDims.dim[i].size
    %endforeach
    %return matrixSize
%endfunction

%% =========================================================================== |
%% Function: SLibCreateGetDWorkFcnSigForModel
%% Abstract: Construct the model_GetDWork function signature.
%%
%function SLibCreateGetDWorkFcnSigForModel(thisModelName)
    %assign getFcnName = SLibCreateGetDWorkFcnNameForModel(Name)
    %assign getFcnArgs = SLibCreateGetDWorkFcnArgs()
    %return "mxArray * %<getFcnName>%<getFcnArgs>"
%endfunction

%% =========================================================================== |
%% Function: SLibCreateSetDWorkFcnSigForModel
%% Abstract: Construct the model_SetDWork function signature.
%%
%function SLibCreateSetDWorkFcnSigForModel(thisModelName)
    %assign setFcnName = SLibCreateSetDWorkFcnNameForModel(Name)
    %assign setFcnArgs = SLibCreateSetDWorkFcnArgs()
    %return "void %<setFcnName>%<setFcnArgs>"
%endfunction

%% =========================================================================== |
%% Function: SLibCreateGetDWorkFcnNameForModel
%% Abstract: Creates the model_GetDWork function name.
%%
%function SLibCreateGetDWorkFcnNameForModel(thisModelName)
    %return "mr_%<thisModelName>_GetDWork"
%endfunction

%% =========================================================================== |
%% Function: SLibGetMdlrefDWPtrName
%% Abstract: Single point of definition for the pointer to the MdlrefDW struct.
%%
%function SLibGetMdlrefDWPtrName()
    %return "mdlrefDW"
%endfunction

%% =========================================================================== |
%% Function: SLibCreateGetDWorkFcnArgs
%% Abstract: Get the argument signature for the mr_model_GetDWork function.
%%           If the model is single-instance, then it owns its DWork and
%%           takes no arguments.
%%
%function SLibCreateGetDWorkFcnArgs()
    %if ::CompiledModel.OkToMultiInstanceModelref
        %return "(const %<tsysMdlrefDWorkType> * %<SLibGetMdlrefDWPtrName()>)"
    %endif
    %return "()"
%endfunction

%% =========================================================================== |
%% Function: SLibCreateSetDWorkFcnNameForModel
%% Abstract: Creates the model_SetDWork function name.
%%
%function SLibCreateSetDWorkFcnNameForModel(thisModelName)
    %return "mr_%<thisModelName>_SetDWork"
%endfunction

%% =========================================================================== |
%% Function: SLibCreateSetDWorkFcnArgs
%% Abstract: Get the argument signature for the model_SetDWork function.
%%           If the model is single-instance, then it owns its DWork and
%%           only needs a pointer to the data it cached in the getter.
%%
%function SLibCreateSetDWorkFcnArgs()
    %if ::CompiledModel.OkToMultiInstanceModelref
        %assign mdlrefDW = SLibGetMdlrefDWPtrName()
        %return "(%<tsysMdlrefDWorkType> * %<mdlrefDW>, const mxArray* ssDW)"
    %endif
    %return "(const mxArray* ssDW)"
%endfunction

%% =========================================================================== |
%% Function: SLibCreateGetSimStateDisallowedBlocksFcnSigForModel
%% Abstract: Create the function signature for the function
%%           mr_model_GetSimStateDisallowedBlocks.
%%
%function SLibCreateGetSimStateDisallowedBlocksFcnSigForModel(thisModelName)
    %assign fcnName = ...
        SLibCreateGetSimStateDisallowedBlocksFcnNameForModel(thisModelName)

    %assign fcnArgs = SLibCreateGetSimStateDisallowedBlocksFcnArgs()

    %return "mxArray * %<fcnName>%<fcnArgs>"
%endfunction

%% =========================================================================== |
%% Function: SLibCreateGetSimStateDisallowedBlocksFcnArgs
%% Abstract: Get the argument signature for the function
%%           mr_model_GetSimStateDisallowedBlocks.
%%
%function SLibCreateGetSimStateDisallowedBlocksFcnArgs()
    %return "()"
%endfunction

%% =========================================================================== |
%% Function: SLibCreateGetSimStateDisallowedBlocksFcnNameForModel
%% Abstract: Create the mr_model__GetSimStateDisallowedBlocks function name.
%%
%function SLibCreateGetSimStateDisallowedBlocksFcnNameForModel(thisModelName)
    %return "mr_%<thisModelName>_GetSimStateDisallowedBlocks"
%endfunction

%% =========================================================================== |
%% Function: SLibWriteCacheRestoreBitFieldToFromMxArray
%% Abstract: Add code to cache/restore the specified variable
%%           to the appropriate buffers.
%%
%function SLibWriteCacheRestoreBitFieldToFromMxArray(...
    varName, mxName, mxIndex, numBits, getBuffer, setBuffer) void
    %assign uintType = LibGetDataTypeNameFromId(::CompiledModel.tSS_UINTEGER)

    %selectfile getBuffer
    %<SLibGetCacheBitFieldToMxArrayFcnName()>(
    %<mxName>, 0, %<mxIndex>, (%<uintType>) %<varName>);

    %selectfile setBuffer
    %<varName> = %<SLibGetExtractBitFieldFromMxArrayFcnName()>(
    %<mxName>, 0, %<mxIndex>, %<numBits>);

%endfunction

%% =========================================================================== |
%% Function: SLibWriteCacheRestoreVariableToFromMxArray
%% Abstract: Add code to cache/restore the specified variable
%%           to the appropriate buffers.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function SLibWriteCacheRestoreVariableToFromMxArray(...
    varName, mxName, mxIndex, getBuffer, setBuffer) void
    %selectfile getBuffer
    %<SLibGetCacheDataAsMxArrayFcnName()>(
    %<mxName>, 0, %<mxIndex>, (const void*)&(%<varName>), sizeof(%<varName>));

    %selectfile setBuffer
    %<SLibGetRestoreDataFromMxArrayFcnName()>(
    (void*)&(%<varName>), %<mxName>, 0, %<mxIndex>, sizeof(%<varName>));

%endfunction

%% =========================================================================== |
%% Function: SLibWriteMdlRefSuppressUnreferencedLocalFcn
%% Abstract: Add code to suppress compiler warning about
%%           removing unreferenced local functions(MSVC: C4505)
%%
%function SLibWriteMdlRefSuppressUnreferencedLocalFcn() void
    %openfile supWarningBuf
    #if defined(_MSC_VER)
    #pragma warning(disable: 4505) //unreferenced local function has been removed
    #endif
    %closefile supWarningBuf

    %<SLibCacheCodeToFile("mdl_src_compilerWarnings", supWarningBuf)>
%endfunction

%% =========================================================================== |
%% Function: SLibWriteCacheRestoreVariableToFromMxArray
%% Abstract: Add code to cache/restore the specified variable
%%           to the appropriate buffers. To be called when
%%           'TargetLang' is set to 'c++' and mode is rapid
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function SLibWriteCacheRestoreVariableToFromMxArrayCPPGen(...
    varName, mxName, mxIndex, getBuffer, setBuffer) void
    %selectfile getBuffer
    %assign rtwFieldName = "dwork_" + "%<mxIndex>"
    volatile void* %<rtwFieldName> = reinterpret_cast<volatile void*>(&(%<varName>));
    %<SLibGetCacheDataAsMxArrayFcnName()>(
    %<mxName>, 0, %<mxIndex>, (const_cast<void*>(%<rtwFieldName>)), sizeof(%<varName>));

    %selectfile setBuffer
    volatile void* %<rtwFieldName> = reinterpret_cast<volatile void*>(&(%<varName>));
    %<SLibGetRestoreDataFromMxArrayFcnName()>(
    (const_cast<void*>(%<rtwFieldName>)), %<mxName>, 0, %<mxIndex>, sizeof(%<varName>));
%endfunction

%% =========================================================================== |
%% Function: SLibWriteMdlRefCacheBitFieldToMxArrayFcn
%% Abstract: Construct the mr_cacheBitFieldToMxArray function.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function SLibWriteMdlRefCacheBitFieldToMxArrayFcn() void
    %assign realType = LibGetDataTypeNameFromId(::CompiledModel.tSS_DOUBLE)
    %assign uintType = LibGetDataTypeNameFromId(::CompiledModel.tSS_UINTEGER)
    %assign fcnArgs = "(mxArray * destArray, mwIndex i, int j, %<uintType> bitVal)"
    %assign fcnSig  = ...
        "static void %<SLibGetCacheBitFieldToMxArrayFcnName()>%<fcnArgs>"
    %openfile fcnBuffer
    %<fcnSig>;
    %<fcnSig>
    {
        %% This seems brittle to me: What if someone creates a 64-bit wide field?
        %% A double can only encode 51 bits. Hopefully a compiler warning will
        %% tip the user off.
        %%
        mxSetFieldByNumber(destArray, i, j, mxCreateDoubleScalar((%<realType>) bitVal));
    }
    %closefile fcnBuffer

    %<SLibCacheCodeToFile("mdl_fcn_defn", fcnBuffer)>
%endfunction

%% =========================================================================== |
%% Function: SLibWriteMdlRefExtractBitFieldFromMxArrayFcn
%% Abstract: Construct the mr_extractBitFieldFromMxArray function.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function SLibWriteMdlRefExtractBitFieldFromMxArrayFcn() void
    %assign uintType = LibGetDataTypeNameFromId(::CompiledModel.tSS_UINTEGER)
    %assign fcnArgs = ...
        "(const mxArray * srcArray, mwIndex i, int j, %<uintType> numBits)"
    %assign fcnSig = ...
        "static %<uintType> %<SLibGetExtractBitFieldFromMxArrayFcnName()>%<fcnArgs>"

    %assign scalarTokens = LibGetScalarDataInitTokens()
    %openfile fcnBuffer
    %<fcnSig>;
    %<fcnSig>
    {
        const %<uintType> varVal%<scalarTokens[0]>(%<uintType>) mxGetScalar(mxGetFieldByNumber(srcArray, i, j))%<scalarTokens[1]>;
        return varVal & ((1u<<numBits)-1u);
    }
    %closefile fcnBuffer

    %<SLibCacheCodeToFile("mdl_fcn_defn", fcnBuffer)>
%endfunction

%% =========================================================================== |
%% Function: SLibWriteMdlRefCacheDataAsMxArrayFcn
%% Abstract: Construct the mr_cacheDataAsMxArray function.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function SLibWriteMdlRefCacheDataAsMxArrayFcn() void
    %assign uint8Type = LibGetDataTypeNameFromId(::CompiledModel.tSS_UINT8)
    %assign fcnArgs = ...
        "(mxArray * destArray, mwIndex i, int j, const void * srcData, size_t numBytes)"
    %assign fcnSig  = ...
        "static void %<SLibGetCacheDataAsMxArrayFcnName()>%<fcnArgs>"

    %assign scalarTokens = LibGetScalarDataInitTokens()
    %openfile fcnBuffer
    %<fcnSig>;
    %<fcnSig>
    {
        mxArray * newArray%<scalarTokens[0]>
        mxCreateUninitNumericMatrix((size_t) 1, numBytes, mxUINT8_CLASS, mxREAL)%<scalarTokens[1]>;
        memcpy((%<uint8Type> *) mxGetData(newArray), (const %<uint8Type> *) srcData, numBytes);
        mxSetFieldByNumber(destArray, i, j, newArray);
    }
    %closefile fcnBuffer

    %<SLibCacheCodeToFile("mdl_fcn_defn", fcnBuffer)>
%endfunction

%% =========================================================================== |
%% Function: SLibWriteMdlRefRestoreDataFromMxArrayFcn
%% Abstract: Construct the mr_restoreDataFromMxArray function.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function SLibWriteMdlRefRestoreDataFromMxArrayFcn() void
    %assign uint8Type = LibGetDataTypeNameFromId(::CompiledModel.tSS_UINT8)
    %assign fcnArgs = ...
        "(void * destData, const mxArray * srcArray, mwIndex i, int j, size_t numBytes)"
    %assign fcnSig  = ...
        "static void %<SLibGetRestoreDataFromMxArrayFcnName()>%<fcnArgs>"
    %openfile fcnBuffer
    %<fcnSig>;
    %<fcnSig>
    {
        memcpy((%<uint8Type> *) destData,
        (const %<uint8Type> *) mxGetData(mxGetFieldByNumber(srcArray, i, j)),
        numBytes);
    }
    %closefile fcnBuffer

    %<SLibCacheCodeToFile("mdl_fcn_defn", fcnBuffer)>
%endfunction

%% =========================================================================== |
%% Function: SLibGetCacheBitFieldToMxArrayFcnName
%% Abstract: Canonical getter for the name of this static utility function.
%%
%function SLibGetCacheBitFieldToMxArrayFcnName()
    %return "mr_%<::CompiledModel.Name>_cacheBitFieldToMxArray"
%endfunction

%% =========================================================================== |
%% Function: SLibGetExtractBitFieldFromMxArrayFcnName
%% Abstract: Canonical getter for the name of this static utility function.
%%
%function SLibGetExtractBitFieldFromMxArrayFcnName()
    %return "mr_%<::CompiledModel.Name>_extractBitFieldFromMxArray"
%endfunction

%% =========================================================================== |
%% Function: SLibGetCacheDataAsMxArrayFcnName
%% Abstract: Canonical getter for the name of this static utility function.
%%
%function SLibGetCacheDataAsMxArrayFcnName()
    %return "mr_%<::CompiledModel.Name>_cacheDataAsMxArray"
%endfunction

%% =========================================================================== |
%% Function: SLibGetRestoreDataFromMxArrayFcnName
%% Abstract: Canonical getter for the name of this static utility function.
%%
%function SLibGetRestoreDataFromMxArrayFcnName()
    %return "mr_%<::CompiledModel.Name>_restoreDataFromMxArray"
%endfunction

%% =========================================================================== |
%% Function: SLibWriteMdlRefCacheDataToMxArrayWithOffsetFcn
%% Abstract: Construct the mr_cacheDataToMxArrayWithOffset function.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function SLibWriteMdlRefCacheDataToMxArrayWithOffsetFcn() void
    %assign uint8Type = LibGetDataTypeNameFromId(::CompiledModel.tSS_UINT8)
    %assign fcnArgs = ...
        "(mxArray * destArray, mwIndex i, int j, mwIndex offset, const void * srcData, size_t numBytes)"
    %assign fcnSig  = "static void %<SLibGetCacheDataToMxArrayWithOffsetFcnName()>%<fcnArgs>"

    %assign scalarTokens = LibGetScalarDataInitTokens()
    %openfile fcnBuffer
    %<fcnSig>;
    %<fcnSig>
    {
        %<uint8Type> * varData%<scalarTokens[0]>\
        (%<uint8Type> *) mxGetData(mxGetFieldByNumber(destArray, i, j))%<scalarTokens[1]>;

        memcpy( \
        (%<uint8Type> *) &varData[offset*numBytes], \
        (const %<uint8Type> *) srcData, \
        numBytes);
    }
    %closefile fcnBuffer

    %<SLibCacheCodeToFile("mdl_fcn_defn", fcnBuffer)>
%endfunction

%% =========================================================================== |
%% Function: SLibWriteMdlRefRestoreDataFromMxArrayWithOffsetFcn
%% Abstract: Construct the mr_restoreDataFromMxArrayWithOffset function.
%%
%function SLibWriteMdlRefRestoreDataFromMxArrayWithOffsetFcn() void
    %assign uint8Type = LibGetDataTypeNameFromId(::CompiledModel.tSS_UINT8)
    %assign fcnArgs = ...
        "(void * destData, const mxArray * srcArray, mwIndex i, int j, mwIndex offset, size_t numBytes)"
    %assign fcnSig  = ...
        "static void %<SLibGetRestoreDataFromMxArrayWithOffsetFcnName()>%<fcnArgs>"
    %assign scalarTokens = LibGetScalarDataInitTokens()
    %openfile fcnBuffer
    %<fcnSig>;
    %<fcnSig>
    {
        const %<uint8Type> * varData%<scalarTokens[0]>\
        (const %<uint8Type> *) mxGetData(mxGetFieldByNumber(srcArray, i, j))%<scalarTokens[1]>;

        memcpy( \
        (%<uint8Type> *) destData, \
        (const %<uint8Type> *) &varData[offset*numBytes], \
        numBytes);
    }
    %closefile fcnBuffer

    %<SLibCacheCodeToFile("mdl_fcn_defn", fcnBuffer)>
%endfunction

%% =========================================================================== |
%% Function: SLibGetCacheDataToMxArrayWithOffsetFcnName
%% Abstract: Canonical getter for the name of this static utility function.
%%
%function SLibGetCacheDataToMxArrayWithOffsetFcnName()
    %return "mr_%<::CompiledModel.Name>_cacheDataToMxArrayWithOffset"
%endfunction

%% =========================================================================== |
%% Function: SLibGetRestoreDataFromMxArrayWithOffsetFcnName
%% Abstract: Canonical getter for the name of this static utility function.
%%
%function SLibGetRestoreDataFromMxArrayWithOffsetFcnName()
    %return "mr_%<::CompiledModel.Name>_restoreDataFromMxArrayWithOffset"
%endfunction

%% =========================================================================== |
%% Function: SLibWriteMdlRefCacheBitFieldToCellArrayWithOffsetFcn
%% Abstract: Construct the mr_cacheBitFieldToCellArrayWithOffset function.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function SLibWriteMdlRefCacheBitFieldToCellArrayWithOffsetFcn() void
    %assign realType = LibGetDataTypeNameFromId(::CompiledModel.tSS_DOUBLE)
    %assign uintType = LibGetDataTypeNameFromId(::CompiledModel.tSS_UINTEGER)
    %assign fcnArgs = ...
        "(mxArray * destArray, mwIndex i, int j, mwIndex offset, %<uintType> fieldVal)"
    %assign fcnSig  = ...
        "static void %<SLibGetCacheBitFieldToCellArrayWithOffsetFcnName()>%<fcnArgs>"
    %openfile fcnBuffer
    %<fcnSig>;
    %<fcnSig>
    {
        mxSetCell(mxGetFieldByNumber(destArray, i, j), offset, \
        mxCreateDoubleScalar((%<realType>) fieldVal));
    }
    %closefile fcnBuffer

    %<SLibCacheCodeToFile("mdl_fcn_defn", fcnBuffer)>
%endfunction

%% =========================================================================== |
%% Function: SLibWriteMdlRefExtractBitFieldFromCellArrayWithOffsetFcn
%% Abstract: Construct the mr_extractBitFieldFromCellArrayWithOffset function.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function SLibWriteMdlRefExtractBitFieldFromCellArrayWithOffsetFcn() void
    %assign uintType = LibGetDataTypeNameFromId(::CompiledModel.tSS_UINTEGER)
    %assign fcnArgs = ...
        "(const mxArray * srcArray, mwIndex i, int j, mwIndex offset, %<uintType> numBits)"
    %assign fcnSig  = ...
        "static %<uintType> %<SLibGetExtractBitFieldFromCellArrayWithOffsetFcnName()>%<fcnArgs>"
    %assign scalarTokens = LibGetScalarDataInitTokens()
    %openfile fcnBuffer
    %<fcnSig>;
    %<fcnSig>
    {
        const %<uintType> fieldVal%<scalarTokens[0]>\
        (%<uintType>) mxGetScalar(mxGetCell(mxGetFieldByNumber(srcArray, i, j), offset))%<scalarTokens[1]>;

        return fieldVal & ((1u << numBits) - 1u);
    }
    %closefile fcnBuffer

    %<SLibCacheCodeToFile("mdl_fcn_defn", fcnBuffer)>
%endfunction

%% =========================================================================== |
%% Function: SLibGetCacheBitFieldToCellArrayWithOffsetFcnName
%% Abstract: Canonical getter for the name of this static utility function.
%%
%function SLibGetCacheBitFieldToCellArrayWithOffsetFcnName()
    %return "mr_%<::CompiledModel.Name>_cacheBitFieldToCellArrayWithOffset"
%endfunction

%% =========================================================================== |
%% Function: SLibGetExtractBitfieldFromCellArrayWithOffsetFcnName
%% Abstract: Canonical getter for the name of this static utility function.
%%
%function SLibGetExtractBitFieldFromCellArrayWithOffsetFcnName()
    %return "mr_%<::CompiledModel.Name>_extractBitFieldFromCellArrayWithOffset"
%endfunction

%% =========================================================================== |
%% END ModelRefAccelModeSimState support
%% =========================================================================== |

%% Write exported model information to the model_msf.c.
%function SLibWriteMdlRefExportedMdlInfoForModelRef() void
    %assign intType = LibGetDataTypeNameFromId(::CompiledModel.tSS_INTEGER)
    %with ::CompiledModel
        %assign scalarTokens = LibGetScalarDataInitTokens()
        %openfile tmpBuffer
        %<intType> retVal%<scalarTokens[0]>1%<scalarTokens[1]>;
        %assign regFcnName = SLibCreateMdlInfoRegFcnName()
        %<regFcnName>(S, "%<Name>", &retVal);
        if (!retVal) return;
        %closefile tmpBuffer
    %endwith
    %return tmpBuffer
%endfunction

%function SLibCreateMdlInfoRegFcnName() void
    %return "mr_%<Name>_MdlInfoRegFcn"
%endfunction

%% Function: FcnInitializeGlobalTimerIndices =======================================================
%% Abstract:
%%   Write out the declaration and initialization of the data structures for
%%   handling global timer indices. We create an array for each referenced model that
%%   has timers
%%
%function FcnInitializeGlobalTimerIndices() Output
    %assign uintType = LibGetDataTypeNameFromId(::CompiledModel.tSS_UINTEGER)
    %if ::CompiledModel.NeedsGlobalTimerIndices != "yes"
        %return
    %endif
    %% Declare all the arrays

    %assign equalSign = LibGetDataInitEqualSign()

    %% For the top model
    %openfile declbuf
    %if !IsModelReferenceTarget()
        %assign numTimers = ::CompiledModel.NumTimers
        %selectfile declbuf
        %assign comma = ""
        %<uintType> globalTimerIndices[%<numTimers>]%<equalSign>{\
            %foreach eIdx =numTimers
                %<comma> %<eIdx>\
                %assign comma = ", "
            %endforeach
        };
    %endif

    %if !HasModelReferenceBlocks()
        %closefile declbuf
        %<declbuf>\
        %return
    %endif
    %assign mdlRefBlks = ::CompiledModel.ModelReferenceBlocks
    %foreach rowIdx = SIZE(mdlRefBlks,0)
        %assign needsTimerIndices = ...
            (::CompiledModel.ModelBlock[rowIdx].NeedsGlobalTimerIndices == "yes")
        %assign topTimerIndices = ::CompiledModel.ModelBlock[rowIdx].TopTimerIndices
        %if needsTimerIndices
            %assign numTopTimerIndices = SIZE(topTimerIndices, 1)
            %selectfile declbuf
            %assign comma = ""
            %<uintType> mdlRef%<rowIdx>_globalTimerIndices[%<numTopTimerIndices>]%<equalSign>{\
                %foreach eIdx =numTopTimerIndices
                    %<comma> %<eIdx>\
                    %assign comma = ", "
                %endforeach
            };
        %endif
    %endforeach
    %closefile declbuf
    %<declbuf>\
%endfunction

%% Function: FcnInitializeGlobalRuntimeEventIndices ================================================
%% Abstract:
%%   Write out the declaration and initialization of the data structures for
%%   handling global runtime event indices. We create an array for each referenced model that
%%   has runtime events
%%
%function FcnInitializeGlobalRuntimeEventIndices() Output
    %assign uintType = LibGetDataTypeNameFromId(::CompiledModel.tSS_UINTEGER)
    %if ::CompiledModel.NeedsGlobalRuntimeEventIndices != "yes"
        %return
    %endif
    %% Declare all the arrays

    %assign equalSign = LibGetDataInitEqualSign()

    %% For the top model
    %openfile declbuf
    %if !IsModelReferenceTarget()
        %assign numEvents = ::CompiledModel.NumExternalRuntimeEvents
        %selectfile declbuf
        %assign comma = ""
        %<uintType> globalRuntimeEventIndices[%<numEvents>]%<equalSign>{\
            %foreach eIdx =numEvents
                %<comma> %<eIdx>\
                %assign comma = ", "
            %endforeach
        };
    %endif

    %if !HasModelReferenceBlocks()
        %closefile declbuf
        %<declbuf>\
        %return
    %endif
    %assign mdlRefBlks = ::CompiledModel.ModelReferenceBlocks
    %foreach rowIdx = SIZE(mdlRefBlks,0)
        %assign needsEventIndices = ...
            (::CompiledModel.ModelBlock[rowIdx].NeedsGlobalRuntimeEventIndices == "yes")
        %assign topEventIndices = ::CompiledModel.ModelBlock[rowIdx].TopExternalRuntimeEventsIndices
        %if needsEventIndices
            %assign numTopEventIndices = SIZE(topEventIndices, 1)
            %selectfile declbuf
            %assign comma = ""
            %<uintType> mdlRef%<rowIdx>_globalRuntimeEventIndices[%<numTopEventIndices>]%<equalSign>{\
                %foreach eIdx =numTopEventIndices
                    %<comma> %<eIdx>\
                    %assign comma = ", "
                %endforeach
            };
        %endif
    %endforeach
    %closefile declbuf
    %<declbuf>\
%endfunction

%% Function: FcnInitializeModelRefGlobalTimingEngine ===============================================
%% Abstract:
%%    Declare all the global variables necessary for the global timing engine
%% and initialize these variables in the registration function
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%% TopTester: test/toolbox/simulink/variants/var-general/tVariantGecks.m
%% TopTester: test/toolbox/simulink/variants/var-general/tVariantGecks6.m
%%
%function FcnInitializeModelRefGlobalTimingEngine() Output
    %assign intType = LibGetDataTypeNameFromId(::CompiledModel.tSS_INTEGER)
    %assert IsModelReferenceTarget()

    %% Write out the declaration of the global TID map.  Note that for inherited
    %% submodels, we will put the map into the rtModel.  This is because each
    %% instance the submodel could get a different TID and we need the TID
    %% for logging.
    %assign numTIDs = SLibGetNumTIDsForGlobalTIDMap()

    %openfile cbuffer
    %if ::tMdlRefGlobalTIDMapAccessed
        %if MdlRefIsConstSampleBlock() && !MdlRefHasParameterRate()
            %<intType> %<::tMdlRefGlobalTID>[1];
        %elseif !RTMMdlRefGlobalTIDIsInstanceBased()
            %<intType> %<::tMdlRefGlobalTID>[%<numTIDs>];
        %endif
    %endif
    %if !IsModelReferenceForASimstructBasedTarget() && ...
        ::tMdlRefTimingBridgeAccessed && !RTMTimingBridgeIsReqFcn()
        %assert SLibIsERTCodeFormat()
        %assign timingVar = SLibGetGlobalTimingBridge()
        const rtTimingBridge *%<timingVar>;
        %<SLibUpdateLocalSymbolTableForFile(SLibGetFullFileNameForCode("mdl_data_defn"), timingVar)>
    %endif
    %closefile cbuffer
    %<SLibCacheCodeToFile("mdl_data_defn", cbuffer)>

    %openfile hpbuffer
    %if ::tMdlRefGlobalTIDMapAccessed
        %if MdlRefIsConstSampleBlock() && !MdlRefHasParameterRate()
            extern %<intType> %<::tMdlRefGlobalTID>[1];
        %elseif !RTMMdlRefGlobalTIDIsInstanceBased()
            extern %<intType> %<::tMdlRefGlobalTID>[%<numTIDs>];
        %endif
    %endif
    %if !IsModelReferenceForASimstructBasedTarget() && ...
        ::tMdlRefTimingBridgeAccessed && !RTMTimingBridgeIsReqFcn()
        %assert SLibIsERTCodeFormat()
        %assign timingVar = SLibGetGlobalTimingBridge()
        extern const rtTimingBridge *%<timingVar>;
        %assign declFile = SLibGetFullFileNameForCode("mdl_priv_extern_data_decl")
        %% rtTimingBridge is defined in model_reference_types.h
        %<SLibUpdateHeadersNeededByFile(declFile, SLibCoderModelReferenceTypesBaseName() + ".h")>
        %<SLibUpdateGlobalSymbolTableForFile(declFile, timingVar)>
    %endif
    %closefile hpbuffer
    %<SLibCacheCodeToFile("mdl_priv_extern_data_decl", hpbuffer)>

    %if !GenerateClassInterface
        %if ::tMdlRefGlobalTIDMapAccessed
            /* setup the global timing engine */
            %if !MdlRefIsConstSampleBlock() || MdlRefHasParameterRate()
                %foreach idx = numTIDs
                    %% skip service task tid which is
                    %% used for service infrastructure only
                    %if SLibIsServiceTaskTID(idx) || SLibSimEventTID(idx)
                        %continue
                    %endif

                    %% We do not access union rate without task TIDs in referenced models.
                    %if SLibIsUnionSampleTimeTIDWithoutTask(idx)
                        %continue
                    %endif

                    %<FcnGetMdlRefGlobalTIDMap("")>[%<idx>] = mdlref_TID%<idx>;
                %endforeach
            %else
                %<::tMdlRefGlobalTID>[0] = mdlref_TID0;
            %endif

            %if RTMMdlRefTriggerTIDIsReqFcn()
                %<FcnGetMdlRefTriggerTIDMap("")> = mdlref_TriggerTID;
            %endif
        %endif

        %if !IsModelReferenceForASimstructBasedTarget() && ...
            ::tMdlRefTimingBridgeAccessed
            %assert SLibIsERTCodeFormat()
            %if RTMTimingBridgeIsReqFcn()
                %% Set timing bridge of rtm
                %<RTMSet("timingBridge", "timingBridge")>;
            %else
                %<SLibGetGlobalTimingBridge()> = timingBridge;
            %endif
        %endif
    %endif
%endfunction

%% Function: FcnInitializeNoncontSignals ===========================================================
%% Abstract:
%%   Write out the declaration and initialization of the data structures for
%% handling information on noncontinous signals coming from model reference
%% blocks.  We create an array of type ssNonContDerivSig for each model
%% reference block, and initialize the outports that we need information for.
%% TopTester: test/toolbox/simulink/variants/modelVariants/tVariantsBasic_g724566.m
%%
%function FcnInitializeNoncontSignals() Output
    %if !HasModelReferenceBlocks()
        %return
    %endif
    %% Declare all the arrays
    %assign mdlRefBlks = ::CompiledModel.ModelReferenceBlocks
    %openfile declbuf
    %openfile codebuf
    %foreach rowIdx = SIZE(mdlRefBlks,0)
        %assign mdlRefInfo = mdlRefBlks[rowIdx]
        %assign mSysIdx = mdlRefInfo[0]
        %assign bIdx    = mdlRefInfo[1]
        %assign instIdx = mdlRefInfo[2]
        %assign blk = ::CompiledModel.System[mSysIdx].Block[bIdx]
        %% The usage of the first instance modelBlock is OK here because
        %% all corresponding instances across parent reusable subsystems
        %% must have a consistent state
        %assert 0 == blk.DeletedInIR
        %assign name = blk.ParamSettings.ReferencedModelName
        %assign blockInterface = GetModelrefInterface(blk)
        %if blockInterface.HasNonContOutput
            %assign mangleName = FcnGetNoncontMangledName(name, mSysIdx, bIdx, instIdx)
            %selectfile declbuf
            %assign comma = ""
            %assign equalSign = LibGetDataInitEqualSign()
            %% This is an array of pointers  of size nOutputPorts.  If an
            %% output port has any noncontinuous signals, we'll create
            %% another array to hold all those signals below
            ssNonContDerivSigFeedingOutports *mr_%<mangleName>nonContOutputArray[%<LibBlockNumOutputPorts(blk)>]%<equalSign>{\
                %foreach nullIdx = LibBlockNumOutputPorts(blk)
                    %<comma>%<SLibGetNullDefinitionFromTfl()>\
                    %assign comma = ", "
                %endforeach
            };
            %assign nonContPorts = blockInterface.NonContOutports
            %foreach pIdx = SIZE(nonContPorts,1)
                %if nonContPorts[pIdx] > 0
                    %assign intNumSigs = CAST("Number", nonContPorts[pIdx])
                    %selectfile declbuf
                    %% Create an array of noncont signals for this port
                    ssNonContDerivSigFeedingOutports mr_%<mangleName>nonContDerivSig%<pIdx>[%<intNumSigs>];
                    %selectfile codebuf
                    mr_%<mangleName>nonContOutputArray[%<pIdx>] = mr_%<mangleName>nonContDerivSig%<pIdx>;
                %endif
            %endforeach
        %endif
    %endforeach
    %closefile declbuf
    %closefile codebuf
    %<declbuf>\

    %<codebuf>\
%endfunction

%% Function: SLibGenNoncontDerivSigStruct ==========================================================
%% Abstract:
%%   Write out the structure which holds the memory needed when looking
%% at noncontinuous signals feeding deriv ports.  This is for modelref
%% only, and it helps avoid using malloc.
%function SLibGenNoncontDerivSigStruct() void
    %assign uint8Type = LibGetDataTypeNameFromId(::CompiledModel.tSS_UINT8)
    %openfile declBuf

    /*
    * The following structure contains memory needed to
    * track noncontinuous signals feeding derivative ports.
    */
    struct {
        %assign numNoncontDerivSigs = SIZE(SolverResetInfo.NonContDerivSignal,1)
        %assign arrayIdx = 0
        %foreach idx = numNoncontDerivSigs
            %assign dU = SolverResetInfo.NonContDerivSignal[idx]
            %if ISFIELD(dU,"MdlRefInfo")
                %foreach subIdx = dU.NumMdlRefNonContSigs
                    %assign numBytes = dU.NonContSigSizeInBytes[subIdx]
                    %<uint8Type> mr_nonContSig%<arrayIdx>[%<numBytes>];
                    %assign arrayIdx = arrayIdx + 1
                %endforeach
            %else
                %if dU.ComplexSignal
                    %assign dtype = LibGetDataTypeComplexNameFromId(dU.DataTypeIdx)
                %else
                    %assign dtype = LibGetDataTypeNameFromId(dU.DataTypeIdx)
                %endif
                %<dtype> mr_nonContSig%<arrayIdx>[%<dU.RegionLen>];
                %assign arrayIdx = arrayIdx + 1
            %endif
        %endforeach
    } \
    %closefile declBuf
    %return declBuf
%endfunction


%% Function: CPPEncapNeedsLocalVars ================================================================
%% Abstract:
%%  Does C++ encapsulation interface needs to introduce local variables to
%%  model regestration function?
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function CPPEncapNeedsLocalVars(genERTSfcn) void
    %assign hasDWork = ! SLibModelDWorkStructIsEmpty()
    %assign dworkZeroed = TLC_FALSE

    %if hasDWork && (!(ForceBlockIOInitOptimize && IsModelReferenceTarget()))
        %assign dworkZeroed = SLibZeroMemory("DWork")
    %endif

    %if hasDWork && genERTSfcn
        %% SIL requires DWork (if existing) to be Zeroed regardless user setting.
        %% See the callsite to SLibDumpERTAndModelrefInitMemoryCode in ertsfcnbody.tlc
        %assign dworkZeroed = TLC_TRUE
    %endif

    %return GenerateClassInterface && ...
        CGMODEL_ACCESS("CGModel.getUseOperatorNewForModelRefRegistration") && ...
        dworkZeroed
%endfunction %% CPPEncapNeedsLocalVars


%% Function: SLibGetCPPEncapInitLocalVars ==========================================================
%% Abstract:
%%  Determine what local variables will be needed for cpp encapsulation
%%  in the model initialization function; must be guarded by
%%  CPPEncapNeedsLocalVars

%function SLibGetCPPEncapInitLocalVars(genERTSFcn) void
    %assert CPPEncapNeedsLocalVars(genERTSFcn)

    %assign localVars = ""

    %assign mdlRefBlks = ISFIELD(::CompiledModel,"ModelReferenceBlocks") ? ...
        ::CompiledModel.ModelReferenceBlocks : []


    %if !ISEMPTY(mdlRefBlks)
        %assign NO_PARENT        = ""
        %assign NO_QUALIFIER     = ""
        %assign ERT_MACRO_NONE   = [0, 0, 0, 0]

        %foreach rowIdx = SIZE(mdlRefBlks,0)
            %assign mdlRefInfo = mdlRefBlks[rowIdx]
            %assign mSysIdx = mdlRefInfo[0]
            %assign bIdx    = mdlRefInfo[1]
            %assign instIdx = mdlRefInfo[2]
            %% The usage of the first instance modelBlock is OK here because
            %% all corresponding instances across parent reusable subsystems
            %% must have a consistent state
            %assign blk     = ::CompiledModel.System[mSysIdx].Block[bIdx]
            %assert 0 == blk.DeletedInIR

            %if !blk.MdlRefIsCPPClassGenMode
                %continue
            %endif

            %assign blkInterface = GetModelrefInterface(blk)

            %if blkInterface.IsScalableBuild || IsSystemReusableParentBaseSys(mSysIdx)
                %continue
            %endif

            %assign locVarName = "local_" + ::CompiledModel.ModelBlock[rowIdx].MdlRefInstanceVarName
            %assign mdlBlkCompiledModel = ::CompiledModel.ModelBlock[rowIdx]
            %assign optDim = ""
            %if ISFIELD(mdlBlkCompiledModel, "ForEachSSLoopBnds")
                %assign tmpLevel = SIZE(mdlBlkCompiledModel.ForEachSSLoopBnds,1)
                %foreach ssIdx = SIZE(mdlBlkCompiledModel.ForEachSSLoopBnds,1)
                    %assign tmpLevel = tmpLevel - 1
                    %assign optDim = optDim + "[%<mdlBlkCompiledModel.ForEachSSLoopBnds[tmpLevel]>]"
                %endforeach
            %endif

            %openfile tmpBuf
            %assign namespaceStr = ""
            %if EXISTS(blkInterface.FPC.ClassNamespace) && (!ISEMPTY(blkInterface.FPC.ClassNamespace))
                %assign namespaceStr = "%<blkInterface.FPC.ClassNamespace>::"
            %endif

            %if ISEMPTY(optDim)
                %<namespaceStr>%<blkInterface.FPC.ModelClassName>_ptr %<locVarName>;
            %else
                %<namespaceStr>%<blkInterface.FPC.ModelClassName>_ptr %<locVarName>%<optDim>;
            %endif
            %closefile tmpBuf

            %assign localVars = localVars + tmpBuf
        %endforeach
    %endif

    %return localVars

%endfunction %% SLibGetCPPEncapInitLocalVars


%% Function:  SLibGetCPPEncapInitCopyCode================================
%% Abstract:
%%  Determine the code needed to copy the referenced model object pointers so that
%%  later we can restore them after the DWork has been Zeroed, in the model initialization function;
%%  It must be guarded by CPPEncapNeedsLocalVars. The argument is a boolean flag to indicate that it
%%  is a back up operation or a restore operation.
%function SLibGetCPPEncapInitCopyCode(isBackup, genERTSfcn) void
    %assign int32Type = LibGetDataTypeNameFromId(::CompiledModel.tSS_INT32)
    %assert CPPEncapNeedsLocalVars(genERTSfcn)

    %assign copyCode = ""

    %assign mdlRefBlks = ISFIELD(::CompiledModel,"ModelReferenceBlocks") ? ...
        ::CompiledModel.ModelReferenceBlocks : []


    %if !ISEMPTY(mdlRefBlks)
        %assign NO_PARENT        = ""
        %assign NO_QUALIFIER     = ""
        %assign ERT_MACRO_NONE   = [0, 0, 0, 0]

        %foreach rowIdx = SIZE(mdlRefBlks,0)
            %assign mdlRefInfo = mdlRefBlks[rowIdx]
            %assign mSysIdx = mdlRefInfo[0]
            %assign bIdx    = mdlRefInfo[1]
            %assign instIdx = mdlRefInfo[2]
            %% The usage of the first instance modelBlock is OK here because
            %% all corresponding instances across parent reusable subsystems
            %% must have a consistent state
            %assign blk     = ::CompiledModel.System[mSysIdx].Block[bIdx]
            %assert 0 == blk.DeletedInIR

            %if !blk.MdlRefIsCPPClassGenMode
                %continue
            %endif

            %assign blkInterface = GetModelrefInterface(blk)

            %if blkInterface.IsScalableBuild || IsSystemReusableParentBaseSys(mSysIdx)
                %continue
            %endif

            %assign locVarName = "local_" + ::CompiledModel.ModelBlock[rowIdx].MdlRefInstanceVarName

            %assign mdlBlkCompiledModel = ::CompiledModel.ModelBlock[rowIdx]


            %openfile tmpBuf
            %if !ISFIELD(mdlBlkCompiledModel, "ForEachSSLoopBnds")
                %assign cppVarPath = SLibCalcMdlRefObjSubsysAccessPath(mSysIdx,...
                    bIdx,instIdx,"Registration")
                %if isBackup
                    %<locVarName> = %<cppVarPath>;
                %else
                    %<cppVarPath> = %<locVarName>;
                %endif
            %else
                %assign ::NeedForEachLoopInReg = TLC_TRUE
                %assign ::NumForEachLoopHierarchyLevel = SIZE(mdlBlkCompiledModel.ForEachSSLoopBnds,1)
                %assign ::ForEachLoopHierarchyLevel = ::NumForEachLoopHierarchyLevel
                %assign copySrcVarForEachSS = locVarName

                {
                    %foreach ssIdx = SIZE(mdlBlkCompiledModel.ForEachSSLoopBnds,1)
                        %assign iterVar = "i_%<ForEachLoopHierarchyLevel>"
                        %assign ::ForEachLoopHierarchyLevel = ::ForEachLoopHierarchyLevel - 1
                        %assign copySrcVarForEachSS = copySrcVarForEachSS + "[%<iterVar>]"
                        %<int32Type> %<iterVar>;
                        for (%<iterVar> = 0; %<iterVar> < %<mdlBlkCompiledModel.ForEachSSLoopBnds[::ForEachLoopHierarchyLevel]>; %<iterVar>++) {
                        %endforeach
                        %assign ::ForEachLoopHierarchyLevel = 1
                        %assign cppVarPath = SLibCalcMdlRefObjSubsysAccessPath(mSysIdx,...
                            bIdx,instIdx,"Registration")
                        %if isBackup
                            %<copySrcVarForEachSS> = %<cppVarPath>;
                        %else
                            %<cppVarPath> = %<copySrcVarForEachSS>;
                        %endif
                        %assign ::ForEachLoopHierarchyLevel = 1

                        %foreach ssIdx = SIZE(mdlBlkCompiledModel.ForEachSSLoopBnds,1)
                        }
                    %endforeach
                }
                %assign ::NeedForEachLoopInReg = TLC_FALSE
            %endif
            %closefile tmpBuf

            %assign copyCode = copyCode + tmpBuf
        %endforeach
    %endif

    %return copyCode

%endfunction %% SLibGetCPPEncapInitCopyCode

%% Function: SLibCPPDotOrArrowAccessOperator =======================================================
%% Abstract:
%%  Which access operator, "." or "->", to use when calling member functions on
%%  encapsulated model reference C++ objects.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants9.m
%%
%function SLibCPPDotOrArrowAccessOperator(blk, blkInterface) void
    %assert GenerateClassInterface
    %assert blk.MdlRefIsCPPClassGenMode

    %assign accOperator = ((!blkInterface.IsScalableBuild) && ...
        CGMODEL_ACCESS("CGModel.getUseOperatorNewForModelRefRegistration")) ? ...
        "->" : "."

    %return accOperator
%endfunction %% SLibCPPDotOrArrowAccessOperator


%% Function RegisterMdlRefSFcnToWksDataTypes ======================================
%% Abstract:
%%   Generate the S-Function code to register enum and fixed point data types used
%%   by workspace logging in the mdlInitializeSizes function.
%% TopTester: test/toolbox/simulink/variants/var-vss-codevariants/tcodevariants1.m
%%
%function RegisterMdlRefSFcnToWksDataTypes() Output
    %assign realType = LibGetDataTypeNameFromId(::CompiledModel.tSS_DOUBLE)

    %% ToWks logging in Dataset format is only supported currently for modelref sim
    %% targets.
    %if (!IsModelReferenceSimTarget())
        %return
    %endif

    %% See if there are any logged non-builtin types to register
    %if !EXISTS(::CompiledModel.DataTypes.NonBuiltinLoggingTypes) || ...
        SIZE(::CompiledModel.DataTypes.NonBuiltinLoggingTypes, 1) < 1
        %return
    %endif

    /* Workspace Logging Data Type Registration */
    %foreach idx = SIZE(::CompiledModel.DataTypes.NonBuiltinLoggingTypes, 1)
        {
            DTypeId dtId = INVALID_DTYPE_ID;
            %assign dID = ::CompiledModel.DataTypes.NonBuiltinLoggingTypes[idx]

            %% ENUM data types
            %if LibIsEnumDataType(dID)
                %assign dtName = LibGetDataTypeNameFromId(dID)
                ssRegisterTypeFromNamedObject(mdlRefSfcnS, "%<dtName>", &dtId);
                %% Half Precision type
            %elseif LibIsHalfDataType(dID)
                dtId = ssRegisterDataTypeHalfPrecision(mdlRefSfcnS, 0);
                %% FIXED POINT data types
            %elseif LibIsDataTypeFixpt(dID)
                %assign curDT = FixPt_GetDataTypeFromIndex(dID)

                %if FixPt_DataTypeIsFloat(curDT)
                    dtId = ssRegisterDataTypeFxpScaledDouble( \
                    mdlRefSfcnS, \
                    %<curDT.IsSigned>, \
                    %<curDT.RequiredBits>, \
                    (%<realType>)%<curDT.FracSlope>, \
                    %<curDT.FixedExp>, \
                    (%<realType>)%<curDT.Bias>, \
                    0);
                %else
                    dtId = ssRegisterDataTypeFxpFSlopeFixExpBias( \
                    mdlRefSfcnS, \
                    %<curDT.IsSigned>, \
                    %<curDT.RequiredBits>, \
                    (%<realType>)%<curDT.FracSlope>, \
                    %<curDT.FixedExp>, \
                    (%<realType>)%<curDT.Bias>, \
                    0);
                %endif

                %% BUS data types
            %elseif LibDataTypeIsBus(dID)
                %assign dtName = LibGetDataTypeNameFromId(dID)
                ssRegisterTypeFromNamedObject(mdlRefSfcnS, "%<dtName>", &dtId);

                %% UNKNOWN types
            %else
                %assign errTxt = ...
                    "User-defined data types not supported for model reference simulation logging."
                %<LibReportFatalError(errTxt)>
            %endif

            if(dtId == INVALID_DTYPE_ID) {
                return;
            }
        }
    %endforeach
%endfunction %% RegisterMdlRefSFcnToWksDataTypes


%function SLibUsePortBasedSampleTime() void
    %return (::CompiledModel.UsePortBasedSampleTime == "yes")
%endfunction

%function SLibSimTargetUsesModelSelf() void
    %return SLibIsSelfInSimTarget() && SLibIsSelfStructured()
%endfunction

%% Function: SLibGetInstancePath ===================================================================
%%
%% Get the full path to top model from DataMapInfo
%%
%function SLibGetInstancePath() void
    %if ::isRAccel
        %return "%<RSimRTWCAPIVar>.mmi.InstanceMap.fullPath"
    %else
        %return "%<RTMGet("DataMapInfo")>.mmi.InstanceMap.fullPath"
    %endif
%endfunction

%% Function: SLibWriteReusedSubSystemBlockPathFcn ==================================================
%%
%% Write reused subsystem sysId, blkId, and blk path arrays and function
%% to return blk path
%%
%function SLibWriteReusedSubSystemBlockPathFcn() void
    %assign uint32Type = LibGetDataTypeNameFromId(::CompiledModel.tSS_UINT32)
    %assign charType = LibGetDataTypeNameFromId(::CompiledModel.tSS_CHAR)
    %assign intType = LibGetDataTypeNameFromId(::CompiledModel.tSS_INTEGER)

    %if IsModelReferenceSimTarget() && ISFIELD(::CompiledModel, "ReusedSubSystemBlockData")
        %assign numBlks = SIZE(::CompiledModel.ReusedSubSystemBlockData.BlockPath,1)
        %openfile fcnBuffer
        %assign fcnSig = "void %<Name>_rt_ssGetBlockPath(SimStruct* S, %<intType> sysIdx, %<intType> blkIdx, %<charType>** blkPath)"
        %assign equalSign = LibGetDataInitEqualSign()
        %<fcnSig>
        {
            static %<intType> systemIdx[%<numBlks>]%<equalSign>{ \
                %foreach idx = numBlks
                    %<::CompiledModel.ReusedSubSystemBlockData.SystemIndex[idx]>,\
                %endforeach
            };
            static %<intType> blockIdx[%<numBlks>]%<equalSign>{ \
                %foreach idx = numBlks
                    %<::CompiledModel.ReusedSubSystemBlockData.BlockIndex[idx]>,\
                %endforeach
            };
            static %<charType>* blockPath[%<numBlks>]%<equalSign>{ \
                %foreach idx = numBlks
                    "%<::CompiledModel.ReusedSubSystemBlockData.BlockPath[idx]>",\
                %endforeach
            };
            %<uint32Type> idx;
            *blkPath = %<SLibGetNullDefinitionFromTfl()>;
            for(idx = 0; idx < %<numBlks>; ++idx)
            {
                if(sysIdx == systemIdx[idx] && blkIdx == blockIdx[idx] )
                {
                    *blkPath = blockPath[idx];
                    return;
                }
            }
        }

        %closefile fcnBuffer
        %<SLibCacheCodeToFile("mdl_fcn_defn", fcnBuffer)>

        %openfile fcnBuffer
        %<LibExternInFcnDecls()>%<fcnSig>;
        %closefile fcnBuffer
        %<SLibCacheCodeToFile("mdl_fcn_prototype", fcnBuffer)>
    %endif
%endfunction

%function isCanonicalParamRetained(canPrmDef)
    %return (canPrmDef.OriginalDataTypeIdx != -1)
%endfunction

%function FcnIncludeCoderDataGroupHeaderFile(header) void
    %assign sfcnFile = SLibGetFullFileNameForCode("mdlsfcn_src_custom_incl")
    %if !(CGMODEL_ACCESS("FileRepository.getIsFileAlreadyIncluded", header, sfcnFile))
        %openfile buf
        #include "%<header>"
        %closefile buf
        %<SLibCacheCodeToFile("mdlsfcn_src_custom_incl", buf)>
    %endif
%endfunction

%function FcnUpdateMdlRefCoderDataGroupInfo() void
    %% see InstPWriter.m
    %if !LibUseOldFilePackagingInfrastructure() && !ISEMPTY(::CompiledModel.CoderDataGroups)
        %assign coderDataGroups = ::CompiledModel.CoderDataGroups.CoderDataGroup
        %assign numCoderDataGroups = SIZE(coderDataGroups, 1)
        %assign incHeaders = []
        %foreach groupIdx = numCoderDataGroups
            %assign group = ::CompiledModel.CoderDataGroups.CoderDataGroup[groupIdx]
            %if group.IsInstanceSpecific && group.DataInit == "Static"
                %if group.SingleInstanceDefiner && !ISEMPTY(group.TypeHeaderFile)
                    %<FcnIncludeCoderDataGroupHeaderFile(group.TypeHeaderFile)>
                %endif
                %if !ISEMPTY(group.SingleInstanceHeaderFile)
                    %<FcnIncludeCoderDataGroupHeaderFile(group.SingleInstanceHeaderFile)>
                %endif
            %endif
        %endforeach
    %endif
%endfunction

%function FcnUpdateMdlRefMessageServiceInfo() void
    %% see MessageServiceWriter.m
    %if !EXISTS(NumServicePorts) || ...
        ModelrefBlockNeedsDwork() || ...
        SLibGetSelfCoderDataGroupVarGroupIndex() >= 0
        %return
    %endif

    %assign fileName = SLibGetFileNameForCode("mdlsfcn_src_custom_incl") + "." + ::LangFileExt
    %assign incHeaders = []

    %with ServicePortInfoMap
        %foreach portIdx = NumServicePorts
            %assign thisPort = ServicePort[portIdx]
            %assign providingServices = thisPort.ProvidingServices
            %if !ISEMPTY(providingServices)
                %assign numProvidingSvc = SIZE(providingServices.ProvidingService)[1]
                %foreach i = numProvidingSvc
                    %assign svc = providingServices.ProvidingService[i]
                    %if svc.DelegatedDworkIdx != -2 || ...
                        (svc.Name != "SendData" && svc.Name != "RecvData" && ...
                        svc.Name != "TakeData" && svc.Name != "NotifyAvail")
                        %continue
                    %endif
                    %assign paired = SLibGetPairedServiceAndPort(thisPort, svc)
                    %if ISEMPTY(paired.port)
                        %continue
                    %endif
                    %assign aSID = paired.port.SID
                    %assign mdlBlk = SLibGetMdlBlockFromSID(aSID)
                    %if !ISEMPTY(mdlBlk)
                        %assign pairedServiceInChildMdl = SLibGetPairedServiceAtMdlBoundary(paired.port, paired.service, mdlBlk)
                        %if !ISEMPTY(pairedServiceInChildMdl)
                            %assign blkInterface = GetModelrefInterface(mdlBlk)
                            %assign incFileName = blkInterface.FileName
                            %assign duplicate = TLC_FALSE
                            %foreach idx = SIZE(incHeaders, 1)
                                %if incHeaders[idx] == incFileName
                                    %assign duplicate = TLC_TRUE
                                    %break
                                %endif
                            %endforeach
                            %if !duplicate
                                %assign incHeaders = incHeaders + incFileName
                            %endif
                        %endif
                    %endif
                %endforeach
            %endif
        %endforeach
    %endwith

    %openfile incBuf
    %foreach idx = SIZE(incHeaders, 1)
        %assign incFileName = incHeaders[idx]
        #include "%<incFileName>.h"
    %endforeach
    %closefile incBuf
    %<SLibCacheCodeToFile("mdlsfcn_src_custom_incl", incBuf)>
%endfunction

%function FcnOutportsHaveStringDataType()
    %assign isString = TLC_FALSE
    %foreach idx = ExternalOutputs.NumExternalOutputs
        %assign outport = ExternalOutputs.ExternalOutput[idx]
        %assign sysIdx = outport.Block[0]
        %assign blkIdx = outport.Block[1]
        %assign outportBlock = System[sysIdx].Block[blkIdx]
        %with System[sysIdx]
            %with outportBlock
                %assign dataTypeIdx = LibBlockInputSignalDataTypeId(0)
                %if LibIsStringDataType(dataTypeIdx)
                    %assign isString = TLC_TRUE
                    %break
                %endif
            %endwith
        %endwith
    %endforeach

    %return isString
%endfunction

%function FcnNeedToIncludeBlkInterfaceHeader(block)
    %assign blockInterface = GetModelrefInterface(block)
    %return (blockInterface.AncestorAllocatesCoderDataGroups || ...
        !(block.MdlRefIsCPPClassGenMode && ...
        (blockInterface.IsScalableBuild || CGMODEL_ACCESS("CGModel.getUseOperatorNewForModelRefRegistration"))))
%endfunction

%function FcnIncludeRefBlksHeader() Output
    %if LibUseOldFilePackagingInfrastructure()
        %return
    %endif

    %assign headers = []
    %assign thisSystem = System[GetBaseSystemIdx()]
    %assign numMdlRefBlks = thisSystem.NumIncludedModelReference
    %foreach rowIdx = numMdlRefBlks
        %assign mdlRefInfo = thisSystem.IncludedModelReference[rowIdx]
        %assign mSysIdx = mdlRefInfo.SysIdx
        %assign bIdx    = mdlRefInfo.BlockIdx
        %assign blk     = ::CompiledModel.System[mSysIdx].Block[bIdx]
        %assert 0 == blk.DeletedInIR
        %assign blockInterface = GetModelrefInterface(blk)
        %assign name           = blockInterface.FileName + ".h"
        %if FcnNeedToIncludeBlkInterfaceHeader(blk)
            %assign headers = headers + name
        %endif
    %endforeach

    %% g2976014:
    %% mdlref SIM target might need header files of indirect referenced models
    %assign headers = loc_FcnIncludeRefsHeaderForScopedDSM(...
        ::CompiledModel.ScopedDSMInSingleInstance, headers)
    %assign headers = loc_FcnIncludeRefsHeaderForScopedDSM(...
        ::CompiledModel.ScopedDSMInMultiInstanceDWork, headers)

    %assign sfcnFile = SLibGetFullFileNameForCode("mdlsfcn_src_custom_incl")

    %% %% Print the #includes
    %foreach headerIdx = SIZE(headers, 1)
        %assign header = headers[headerIdx]
        %if !(CGMODEL_ACCESS("FileRepository.getIsFileAlreadyIncluded", header, sfcnFile))
            %openfile buf
            #include "%<header>"
            %closefile buf
            %<SLibCacheCodeToFile("mdlsfcn_src_custom_incl", buf)>
        %endif
    %endforeach
%endfunction

%function loc_FcnIncludeRefsHeaderForScopedDSM(scopedDSMList, headerList)
    %if !ISEMPTY(scopedDSMList)
        %foreach dsmIdx = SIZE(scopedDSMList.ScopedDSMs, 1)
            %assign dsm = scopedDSMList.ScopedDSMs[dsmIdx]
            %if !ISEMPTY(dsm.HeaderFile)
                %assign headerList = headerList + dsm.HeaderFile
            %endif
        %endforeach
    %endif
    %return headerList
%endfunction

%function FcnReinitGlobalVars() Output
    %assign booleanType = LibGetDataTypeNameFromId(::CompiledModel.tSS_BOOLEAN)
    %openfile tmpbuf
    %if ISFIELD(::CompiledModel.ModelParameters, "HasParameterWriterBlockInModel") && ...
        !SLibPrmBufferIsEmpty("SimulinkGlobal", "Instance")
        %assign paramsType = SLibGetModelTypesNamespacePrefix() + ::tParametersType
        %if !GenerateClassInterface
            %assign baseSystem = ::CompiledModel.System[GetBaseSystemIdx()]
            %assign paramsStaticName = ...
                FcnSysVarGroupNonreusedName(baseSystem,"Parameter")
        %else
            %assign oldStrNames = SLibGetOldStrNames()
            %assign paramsStaticName = ...
                SLibGetPrmsName(oldStrNames)
        %endif

        static %<booleanType> isParamReinitNeeded = %<GET_TYPE_ID_REPLACEMENT("false")>;
        static %<paramsType> %<paramsStaticName>_temp;
        if (!isParamReinitNeeded) {
            isParamReinitNeeded = %<GET_TYPE_ID_REPLACEMENT("true")>;
            (void) %<LibGenMemFcnCall("memcpy", "&%<paramsStaticName>_temp", ...
                "&%<paramsStaticName>", "sizeof(%<paramsType>)")>;
        } else {
            (void) %<LibGenMemFcnCall("memcpy", "&%<paramsStaticName>", ...
                "&%<paramsStaticName>_temp", "sizeof(%<paramsType>)")>;
        }
    %endif
    %closefile tmpbuf
    %return tmpbuf
%endfunction

%% EOF modelrefsfcnlib.tlc
