
%%
%%
%%
%% Copyright 1994-2022 The MathWorks, Inc.
%%
%% Abstract:
%%      To Workspace block target file. For use with standard .mat file
%%      logging.
%%

%% In order to use this file to generate code for both
%% ToWorkspace and SignalToWorkspace, the wildcard must be used.
%%
%implements * "C"

%include "logging_sup.tlc"

%% Function: BlockInstanceSetup ====================================================================
%% Abstract:
%%   Set expression folding compliance
%%
%function BlockInstanceSetup(block, system) void
    %<LibBlockSetIsExpressionCompliant(block)>
%endfunction %% BlockInstanceSetup

%% Function: CreateAobHierarchy ====================================================================
%% Abstract:
%%   Generate code that creates a full AoB hierarchy tree.
%%
%function CreateAobHierarchy(block, system) Output
    %assign nulldef = SLibGetNullDefinitionFromTfl()
    %assign scalarTokens = LibGetScalarDataInitTokens()
    %assign port0DTypeId = LibBlockInputSignalDataTypeId(0)
    %if ParamSettings.NumDims > 0
        %assign nDims = ParamSettings.NumDims
        %assign dims = ParamSettings.Dims
    %else
        %assign nDims = LibBlockInputSignalNumDimensions(0)
        %assign dims = LibBlockInputSignalDimensions(0)
    %endif
    %assign hierInfoIdx = ParamSettings.HierInfoIndex[0]
    %assign nodeIdx = 0
    %assign pAobHierarchy = "pAobHierarchyNode0"
    void *%<pAobHierarchy>%<scalarTokens[0]>%<nulldef>%<scalarTokens[1]>;
    %openfile statements
    rtwAobHierarchyCreateRootNode(&%<pAobHierarchy>);
    %closefile statements
    %assign statementsBuffer = statements
    %createrecord retValsLowerLevel %<CreateAobHierarchyRecursion( ...
        port0DTypeId, ...
        pAobHierarchy, ...
        nDims, ...
        dims, ...
        hierInfoIdx, ...
        nodeIdx ...
        )>
    %assign nNodes = retValsLowerLevel.val
    %assign statementsBuffer = statementsBuffer + retValsLowerLevel.statements
    %undef retValsLowerLevel
    %assign nNodes = %<nNodes> + 1
    %openfile statements
    rtwAobHierarchyVerifyNNodes(%<pAobHierarchy>, %<nNodes>);
    %closefile statements
    %assign statementsBuffer = statementsBuffer + statements
    %assign statementsBuffer = STRING(statementsBuffer)
    %createrecord retVals { val pAobHierarchy; statements statementsBuffer }
    %return retVals
%endfunction %% CreateAobHierarchy

%% Function: CreateAobHierarchyRecursion ===========================================================
%% Abstract:
%%   The recursive part of CreateAobHierarchy.
%%
%function CreateAobHierarchyRecursion( ...
    dTypeId, ...
    parentNodeName, ...
    nDims, ...
    dims, ...
    hierInfoIdx, ...
    nodeIdx ...
    ) Output
    %assign statementsBuffer = " "
    %assign nulldef = SLibGetNullDefinitionFromTfl()
    %assign scalarTokens = LibGetScalarDataInitTokens()
    %assign isNvBus = LibDataTypeIsBus(dTypeId)
    %if isNvBus
        %assign dimsArrayPrefix = "aobDimensions"
        %assign dimsArrayName = ...
            "%<CreateDimsArray(nDims, dims, dimsArrayPrefix, nodeIdx)>"
        %openfile statements
        rtwAobHierarchySetDim(%<parentNodeName>, %<nDims>, %<dimsArrayName>);
        %closefile statements
        %assign statementsBuffer = statementsBuffer + statements
        %assign nChildren = LibDataTypeNumElements(dTypeId)
        %foreach childNo = nChildren
            %assign childDTypeId = LibDataTypeElementDataTypeId(dTypeId, childNo)
            %with ::CompiledModel.BlockHierarchyMap
                %assign childHierInfoIdx = ...
                    SignalHierLoggingInfo[hierInfoIdx].Children[childNo]
                %assign childSignalLabel = ...
                    SignalHierLoggingInfo[childHierInfoIdx].SignalName
            %endwith
            %assign childNDims = LibDataTypeElementNumDimensions(dTypeId, childNo)
            %assign childDims = LibDataTypeElementDimensions(dTypeId, childNo)
            %assign nodeIdx = %<nodeIdx> + 1
            %assign nodeName = "pAobHierarchyNode" + "%<nodeIdx>"
            void *%<nodeName>%<scalarTokens[0]>%<nulldef>%<scalarTokens[1]>;
            %openfile statements
            rtwAobHierarchyCreateNode(...
                "%<childSignalLabel>", ...
                &%<nodeName>...
                );
            %closefile statements
            %assign statementsBuffer = statementsBuffer + statements
            %createrecord retValsLowerLevel  ...
                %<CreateAobHierarchyRecursion( ...
                childDTypeId, ...
                nodeName, ...
                childNDims, ...
                childDims, ...
                childHierInfoIdx, ...
                nodeIdx ...
                )>
            %assign nodeIdx = retValsLowerLevel.val
            %assign statementsBuffer = statementsBuffer + retValsLowerLevel.statements
            %undef retValsLowerLevel
            %openfile statements
            rtwAobHierarchyAddChild(%<parentNodeName>, %<nodeName>);
            %closefile statements
            %assign statementsBuffer = statementsBuffer + statements
        %endforeach
    %endif
    %assign statementsBuffer = STRING(statementsBuffer)
    %createrecord retVals {val nodeIdx; statements statementsBuffer}
    %return retVals
%endfunction %% CreateAobHierarchyRecursion

%% Function: CreateDimsArray =======================================================================
%% Abstract:
%%   Generate code that defines a dimensions array.
%%
%function CreateDimsArray(nDims, dims, prefix, idx) Output
    %assign dimsArrayName = prefix + "%<idx>"
    %<CreateDims(nDims, dims, dimsArrayName)>
    %return dimsArrayName
%endfunction %% CreateDimsArray

%% Function: CreateOffsets =========================================================================
%% Abstract:
%%   The main part of CreateDimsArray processing.
%%
%function CreateOffsets(parentDatatypeId, numChildren) Output
    %assign uintType = LibGetDataTypeNameFromId(::CompiledModel.tSS_UINTEGER)
    %assign offsets = "%<uintType> offsets[%<numChildren>]%<LibGetDataInitEqualSign()>{"
    %foreach childNo = numChildren
        %assign offVal = LibDataTypeElementOffset(parentDatatypeId, childNo)
        %assign offsets = offsets + "%<offVal>"
        %if childNo != numChildren-1
            %assign offsets = offsets + ", "
        %endif
    %endforeach
    %assign offsets = offsets + "};"
    %<offsets>
%endfunction %% CreateDims

%% Function: CreateDims ============================================================================
%% Abstract:
%%   The main part of CreateDimsArray processing.
%%
%function CreateDims(nDims, dims, dimsArrayName) Output
    %assign uintType = LibGetDataTypeNameFromId(::CompiledModel.tSS_UINTEGER)
    %assign equalSign = LibGetDataInitEqualSign()
    %if nDims == 1
        %<uintType> %<dimsArrayName>[1]%<equalSign>{%<dims[0]>};
    %else
        %assign dimsInit = "%<uintType> %<dimsArrayName>[%<nDims>]%<equalSign>{"
        %foreach dimsIdx = nDims
            %assign dimsInit = dimsInit + "%<dims[dimsIdx]>"
            %if dimsIdx != nDims-1
                %assign dimsInit = dimsInit + ", "
            %endif
        %endforeach
        %assign dimsInit = dimsInit + "};"
        %<dimsInit>
    %endif
%endfunction %% CreateDims

%% Function: CreateSignalProbe =====================================================================
%% Abstract:
%%   Generates code that crates a signal probe object.
%%
%function CreateSignalProbe( ...
    pSignalProbeCollectionName, ...
    dTypeId, ...
    nDims, ...
    dims, ...
    complexity, ...
    signalName, ...
    interpMethod, ...
    decimation, ...
    maxDataPoints, ...
    units, ...
    leadIdx ...
    ) Output
    %assign nulldef = SLibGetNullDefinitionFromTfl()
    %% Process dims
    %assign dimsArrayPrefix = "signalDimensions"
    %assign dimsArrayName = ...
        "%<CreateDimsArray(nDims, dims, dimsArrayPrefix, leadIdx)>"

    %% Process datatype
    %% built-in class name
    %if LibIsBuiltInDataType(dTypeId)
        %assign typeName = SLibGetMLDataTypeFromId(dTypeId)
        %if typeName == "boolean"
            %assign typeName = "logical"
        %endif
        %assign isFxp = TLC_FALSE
        %% fixpt parameters
    %elseif LibIsDataTypeFixpt(dTypeId)
        %assign curDT = FixPt_GetDataTypeFromIndex(dTypeId)
        %if fxpIsDataTypeFixPt(curDT)
            %assign typeName = "fixed-point"
            %assign isFxp    = TLC_TRUE
        %elseif fxpIsDataTypeScaledDouble(curDT)
            %assign typeName = "scaled-double"
            %assign isFxp    = TLC_TRUE
        %elseif FixPt_DataTypeIsDouble(curDT)
            %assign typeName = "double"
            %assign isFxp = TLC_FALSE
        %elseif FixPt_DatatTypeIsSingle(curDT)
            %assign typeName = "single"
            %assign isFxp = TLC_FALSE
        %elseif FixPt_DatatTypeIsBoolean(curDT)
            %assign typeName = "logical"
            %assign isFxp = TLC_FALSE
        %else
            %assert TLC_FALSE
        %endif
        %assign fxp_isSigned = curDT.IsSigned
        %assign fxp_wordLen = curDT.RequiredBits
        %assign fxp_slope = curDT.FracSlope
        %assign fxp_fixedExp = curDT.FixedExp
        %assign fxp_bias = curDT.Bias
        %% enum parameters
    %elseif LibIsEnumDataType(dTypeId)
        %assign typeName = LibGetDataTypeNameFromId(dTypeId)
        %assign isFxp = TLC_FALSE
        %% UNKNOWN types
    %else
        %assert TLC_FALSE
    %endif

    %% Create SignalProbe call
    %if isFxp
        %openfile statementsBuffer
        rtwSignalProbeCollectionAddElementFxp(...
            %<pSignalProbeCollectionName>, ...
            "%<signalName>", ...
            "%<interpMethod>", ...
            %<decimation>, ...
            %<maxDataPoints>, ...
            %<nDims>, ...
            %<dimsArrayName>, ...
            %<complexity>, ...
            "%<units>", ...
            "%<typeName>", ...
            %<fxp_isSigned>, ...
            %<fxp_wordLen>, ...
            %<fxp_slope>, ...
            %<fxp_fixedExp>, ...
            %<fxp_bias> ...
            );
        %closefile statementsBuffer
    %else
        %assign storedBuiltInTypeName = ""
        %if LibIsEnumDataType(dTypeId)
            %assign storageID = -1
            %if LibIsEnumTypeStoredAsInt(dTypeId)
                %assign storageID = 6 %% int32
            %else
                %assign storageID = LibGetEnumTypeStorageType(dTypeId)
            %endif
            %assign storedBuiltInTypeName = SLibGetMLDataTypeFromId(storageID)
        %endif
        %openfile statementsBuffer
        rtwSignalProbeCollectionAddElement(...
            %<pSignalProbeCollectionName>, ...
            "%<signalName>", ...
            "%<interpMethod>", ...
            %<decimation>, ...
            %<maxDataPoints>, ...
            %<nDims>, ...
            %<dimsArrayName>, ...
            %<complexity>, ...
            "%<units>", ...
            "%<typeName>",...
            "%<storedBuiltInTypeName>"
        );
        %closefile statementsBuffer
    %endif
    %assign statementsBuffer = STRING(statementsBuffer)
    %return statementsBuffer
%endfunction %% CreateSignalProbe

%function getParamSettingsDatasetName() Output
    %assign datasetName = "tmp_raccel_logsout"
    %return datasetName
%endfunction

%% Function: CreateSignalProbeCollectionAob ========================================================
%% Abstract:
%%   Generates code that creates SignalProbeCollection object including all
%%   SignalProbe elements.
%%
%function CreateSignalProbeCollectionAob(block, system) Output
    %assign statementsBuffer = " "
    %assign nulldef = SLibGetNullDefinitionFromTfl()
    %assign scalarTokens = LibGetScalarDataInitTokens()
    %assign datasetMetadataKey = STRING(ParamSettings.DatasetMetadataKey)
    %assign datasetName = getParamSettingsDatasetName()
    %assign elementName = STRING(ParamSettings.ElementNames[0])
    %assign blockPath = STRING(ParamSettings.LogBlockPath)
    %% Logged port index
    %assert(ParamSettings.ConnectedPortIdx[0] > 0)
    %assign logPortIdx = ParamSettings.ConnectedPortIdx[0]
    %% For outport logging dataset, use logPortIdx for element order
    %if datasetMetadataKey == "DATASET_OUTPORT_LOGGING"
        %assign logPortIdx = ParamSettings.ElementOrder[0]
    %endif
    %if IsModelReferenceTarget()
        %assign mapInfo = RTMsGet(system, "DataMapInfo")
        char* pathToTopModel%<scalarTokens[0]>%<mapInfo>.mmi.InstanceMap.fullPath%<scalarTokens[1]>;
    %else
        char* pathToTopModel%<scalarTokens[0]>""%<scalarTokens[1]>;
    %endif

    %assign propName = STRING(ParamSettings.PropagatedName)
    %assign pSignalProbeCollectionName = "pSignalProbeCollection"
    %assign pOSigstreamManagerName = "pOSigstreamManager"
    void *%<pSignalProbeCollectionName>%<scalarTokens[0]>%<nulldef>%<scalarTokens[1]>;
    void *%<pOSigstreamManagerName>%<scalarTokens[0]>%<nulldef>%<scalarTokens[1]>;
    %openfile statements
    %<pOSigstreamManagerName> = rt_GetOSigstreamManager();
    rtwSignalProbeCollectionCreateInstance(...
        "%<datasetMetadataKey>", ...
        "%<datasetName>", ...
        "%<elementName>", ...
        "%<propName>", ...
        pathToTopModel, ...
        "%<blockPath>", ...
        %<logPortIdx>, ...
        %<pOSigstreamManagerName>, ...
        &%<pSignalProbeCollectionName>
    );
    %closefile statements
    %assign statementsBuffer = statementsBuffer + statements
    %assign port0DTypeId = LibBlockInputSignalDataTypeId(0)
    %assign complexity = LibBlockInputSignalIsComplex(0)
    %assign width = LibBlockInputSignalWidth(0)
    %if ParamSettings.NumDims > 0
        %assign nDims = ParamSettings.NumDims
        %assign dims = ParamSettings.Dims
    %else
        %assign nDims = LibBlockInputSignalNumDimensions(0)
        %assign dims = LibBlockInputSignalDimensions(0)
    %endif
    %if !ISEMPTY(ParamSettings.SignalNames)
        %assign signalName = STRING(ParamSettings.SignalNames[0])
    %else
        %assign signalName = ""
    %endif
    %assign isLinearInterp = ParamSettings.LinearInterpolation[0]
    %assign interpMethod = ""
    %if isLinearInterp
        %assign interpMethod = "linear"
    %else
        %assign interpMethod = "zoh"
    %endif
    %assign decimation    = ParamSettings.Decimation[0]
    %assign maxDataPoints = ParamSettings.MaxDataPoints[0]
    %assign hierInfoIdx = ParamSettings.HierInfoIndex[0]
    %assign leafIdx = 0
    %assign units = getASCIIEscapedUnitsToLog(0)

    %createrecord retValsLowerLevel ...
        %<CreateSignalProbeCollectionRecursionAob( ...
        block, ...
        system, ...
        pSignalProbeCollectionName, ...
        port0DTypeId, ...
        width, ...
        nDims, ...
        dims, ...
        complexity, ...
        signalName, ...
        interpMethod, ...
        decimation, ...
        maxDataPoints, ...
        units, ...
        hierInfoIdx, ...
        leafIdx ...
        )>
    %assign nLeaves = retValsLowerLevel.val
    %assign statementsBuffer = statementsBuffer + retValsLowerLevel.statements
    %undef retValsLowerLevel
    %openfile statements
    rtwSignalProbeCollectionVerifyNLeaves(...
        %<pSignalProbeCollectionName>, ...
        %<nLeaves>...
        );
    %closefile statements
    %assign statementsBuffer = statementsBuffer + statements
    %assign statementsBuffer = STRING(statementsBuffer)
    %createrecord retVals {val pSignalProbeCollectionName; statements statementsBuffer}
    %return retVals
%endfunction %% CreateSignalProbeCollectionAob

%% Function: CreateSignalProbeCollectionRecursionAob ===============================================
%% Abstract:
%%   The recursive part of create SignalProbeCollection, where the code adding
%%   SignalProbe elements is generated.
%%
%function CreateSignalProbeCollectionRecursionAob( ...
    block, ...
    system, ...
    pSignalProbeCollectionName, ...
    dTypeId, ...
    width, ...
    nDims, ...
    dims, ...
    complexity, ...
    signalName, ...
    interpMethod, ...
    decimation, ...
    maxDataPoints, ...
    units, ...
    hierInfoIdx, ...
    leafIdx ...
    ) Output
    %assign statementsBuffer = " "
    %assign isNvBus = LibDataTypeIsBus(dTypeId)
    %if !isNvBus
        %if hierInfoIdx >= 0
            %with ::CompiledModel.BlockHierarchyMap
                %assign signalLabel = SignalHierLoggingInfo[hierInfoIdx].SignalName
            %endwith
        %else
            %assign signalLabel = signalName
        %endif
        %assign statements = ...
            "%<CreateSignalProbe( ...
            pSignalProbeCollectionName, ...
            dTypeId, ...
            nDims, ...
            dims, ...
            complexity, ...
            signalLabel, ...
            interpMethod, ...
            decimation, ...
            maxDataPoints, ...
            units, ...
            leafIdx ...
            )>"
        %assign statementsBuffer = statementsBuffer + statements
        %assign leafIdx = leafIdx + 1
    %else
        %assign nChildren = LibDataTypeNumElements(dTypeId)
        %foreach dimIdx = %<width>
            %foreach childNo = nChildren
                %assign childDTypeId = LibDataTypeElementDataTypeId(dTypeId, childNo)
                %assign childWidth = LibDataTypeElementWidth(dTypeId, childNo)
                %assign childNDims = LibDataTypeElementNumDimensions(dTypeId, childNo)
                %assign childDims = LibDataTypeElementDimensions(dTypeId, childNo)
                %assign childComplexity = LibDataTypeElementIsComplex(dTypeId, childNo)
                %assign childSignalName = LibDataTypeElementName(dTypeId, childNo)
                %assign childUnits = getASCIIEscapedUnitsToLogFromBusObject(dTypeId, childNo)
                %with ::CompiledModel.BlockHierarchyMap
                    %assign childHierInfoIdx = ...
                        SignalHierLoggingInfo[hierInfoIdx].Children[childNo]
                %endwith
                %assign signalName = ""
                %createrecord retValsLowerLevel ...
                    %<CreateSignalProbeCollectionRecursionAob( ...
                    block, ...
                    system, ...
                    pSignalProbeCollectionName, ...
                    childDTypeId, ...
                    childWidth, ...
                    childNDims, ...
                    childDims, ...
                    childComplexity, ...
                    signalName, ...
                    interpMethod, ...
                    decimation, ...
                    maxDataPoints, ...
                    childUnits, ...
                    childHierInfoIdx, ...
                    leafIdx ...
                    )>
                %assign leafIdx = retValsLowerLevel.val
                %assign statementsBuffer = statementsBuffer + retValsLowerLevel.statements
                %undef retValsLowerLevel
            %endforeach
        %endforeach
    %endif
    %assign statementsBuffer = STRING(statementsBuffer)
    %createrecord retVals { val leafIdx; statements statementsBuffer }
    %return retVals
%endfunction %% CreateSignalProbeCollectionRecursionAob

%% Function: CreateVirtualBusHierarchyAndSignalProbeCollection =====================================
%% Abstract:
%%   Generate code that creates a full hierarchy tree and the
%%   SignalProbeCollection for virtual bus logging.
%%
%function CreateVirtualBusHierarchyAndSignalProbeCollection(block, system) Output
    %assign uintType = LibGetDataTypeNameFromId(::CompiledModel.tSS_UINTEGER)
    %assign nulldef = SLibGetNullDefinitionFromTfl()
    %assign statementsBuffer = " "
    %% AobHierarchy settings
    %assign dimsArrayName = "aobDimensions"
    %<uintType> %<dimsArrayName>[1]%<LibGetDataInitEqualSign()>{ 1 };
    %assign pAobHierarchyName = "pAobHierarchyNode0"

    %% SignalProbeCollection settings
    %assign datasetMetadataKey = STRING(ParamSettings.DatasetMetadataKey)
    %assign datasetName = getParamSettingsDatasetName()
    %assign elementName = STRING(ParamSettings.ElementNames[0])
    %assign blockPath = STRING(ParamSettings.LogBlockPath)
    %% Logged port index
    %assert(ParamSettings.ConnectedPortIdx[0] > 0)
    %assign logPortIdx = ParamSettings.ConnectedPortIdx[0]
    %% For outport logging dataset, use logPortIdx for element order
    %if datasetMetadataKey == "DATASET_OUTPORT_LOGGING"
        %assign logPortIdx = ParamSettings.ElementOrder[0]
    %endif
    %assign scalarTokens = LibGetScalarDataInitTokens()
    %if IsModelReferenceTarget()
        %assign mapInfo = RTMsGet(system, "DataMapInfo")
        char* pathToTopModel%<scalarTokens[0]>%<mapInfo>.mmi.InstanceMap.fullPath%<scalarTokens[1]>;
    %else
        char* pathToTopModel%<scalarTokens[0]>""%<scalarTokens[1]>;
    %endif
    %assign propName = STRING(ParamSettings.PropagatedName)
    %assign pSignalProbeCollectionName = "pSignalProbeCollection"
    %assign pOSigstreamManagerName = "pOSigstreamManager"
    void *%<pAobHierarchyName>%<scalarTokens[0]>%<nulldef>%<scalarTokens[1]>;
    void *%<pSignalProbeCollectionName>%<scalarTokens[0]>%<nulldef>%<scalarTokens[1]>;
    void *%<pOSigstreamManagerName>%<scalarTokens[0]>%<nulldef>%<scalarTokens[1]>;
    %openfile statements
    rtwAobHierarchyCreateRootNode(&%<pAobHierarchyName>);
    %<pOSigstreamManagerName> = rt_GetOSigstreamManager();
    rtwSignalProbeCollectionCreateInstance(...
        "%<datasetMetadataKey>", ...
        "%<datasetName>", ...
        "%<elementName>", ...
        "%<propName>", ...
        pathToTopModel, ...
        "%<blockPath>", ...
        %<logPortIdx>, ...
        %<pOSigstreamManagerName>, ...
        &%<pSignalProbeCollectionName>
    );
    %closefile statements
    %assign statementsBuffer = statementsBuffer + statements
    %if !ISEMPTY(ParamSettings.SignalNames)
        %assign signalName = STRING(ParamSettings.SignalNames[0])
    %else
        %assign signalName = ""
    %endif
    %assign decimation    = ParamSettings.Decimation[0]
    %assign maxDataPoints = ParamSettings.MaxDataPoints[0]

    %assign hierInfoIdx = ParamSettings.HierInfoIndex[0]
    %assign nodeIdx = 0
    %assign leafIdx = 0
    %createrecord retValsLowerLevel ...
        %<CreateVirtualBusHierarchyAndSignalProbeCollectionRecursion( ...
        block, ...
        system, ...
        pAobHierarchyName, ...
        pSignalProbeCollectionName, ...
        hierInfoIdx, ...
        dimsArrayName, ...
        signalName, ...
        decimation, ...
        maxDataPoints, ...
        nodeIdx, ...
        leafIdx ...
        )>
    %assign nodeLeafIdx = retValsLowerLevel.val
    %assign statementsBuffer = statementsBuffer + retValsLowerLevel.statements
    %undef retValsLowerLevel
    %assign nNodes = %<nodeLeafIdx[0]> + 1
    %assign nLeaves = %<nodeLeafIdx[1]>
    %openfile statements
    rtwAobHierarchyVerifyNNodes(%<pAobHierarchyName>, %<nNodes>);
    rtwSignalProbeCollectionVerifyNLeaves(...
        %<pSignalProbeCollectionName>, ...
        %<nLeaves>...
        );
    rtwSignalProbeCollectionSetAobHierarchy( ...
        %<pSignalProbeCollectionName>, ...
        %<pAobHierarchyName>...
        );
    %closefile statements
    %assign statementsBuffer = statementsBuffer + statements
    %assign statementsBuffer = STRING(statementsBuffer)
    %createrecord retVals {val pSignalProbeCollectionName; statements statementsBuffer}
    %return retVals
%endfunction %% CreateVirtualBusHierarchyAndSignalProbeCollection

%% Function: CreateVirtualBusHierarchyAndSignalProbeCollectionRecursion ============================
%% Abstract:
%%   The recursive part of CreateVirtualBusHierarchyAndSignalProbeCollection.
%%
%function CreateVirtualBusHierarchyAndSignalProbeCollectionRecursion( ...
    block, ...
    system, ...
    parentNodeName, ...
    pSignalProbeCollectionName, ...
    hierInfoIdx, ...
    dimsArrayName, ...
    signalName, ...
    decimation, ...
    maxDataPoints, ...
    nodeIdx, ...
    leafIdx ...
    ) Output
    %assign statementsBuffer = " "
    %assign nulldef = SLibGetNullDefinitionFromTfl()
    %with ::CompiledModel.BlockHierarchyMap
        %if EXISTS(SignalHierLoggingInfo[hierInfoIdx].NumChildren)
            %assign nChildren = SignalHierLoggingInfo[hierInfoIdx].NumChildren
        %else
            %assign nChildren = 0
        %endif
    %endwith
    %if nChildren == 0
        %if hierInfoIdx >= 0
            %with ::CompiledModel.BlockHierarchyMap
                %assign signalLabel = SignalHierLoggingInfo[hierInfoIdx].SignalName
            %endwith
        %else
            %assign signalLabel = signalName
        %endif
        %assign nDims = LibBlockInputSignalNumDimensions(leafIdx)
        %assign dims = LibBlockInputSignalDimensions(leafIdx)
        %assign dTypeId = LibBlockInputSignalDataTypeId(leafIdx)
        %assign complexity = LibBlockInputSignalIsComplex(leafIdx)
        %assign isLinearInterp = ParamSettings.LinearInterpolation[leafIdx]
        %assign interpMethod = ""
        %assign units = getASCIIEscapedUnitsToLog(leafIdx)

        %if isLinearInterp
            %assign interpMethod = "linear"
        %else
            %assign interpMethod = "zoh"
        %endif
        %assign statements = ...
            "%<CreateSignalProbe( ...
            pSignalProbeCollectionName, ...
            dTypeId, ...
            nDims, ...
            dims, ...
            complexity, ...
            signalLabel, ...
            interpMethod, ...
            decimation, ...
            maxDataPoints, ...
            units, ...
            leafIdx ...
            )>"
        %assign statementsBuffer = statementsBuffer + statements
        %assign leafIdx = leafIdx + 1
        %assign nodeLeafIdx = [%<nodeIdx>; %<leafIdx>]
    %else
        %openfile statements
        rtwAobHierarchySetDim(%<parentNodeName>, 1, %<dimsArrayName>);
        %closefile statements
        %assign statementsBuffer = statementsBuffer + statements
        %assign nodeLeafIdx = [%<nodeIdx>; %<leafIdx>]
        %foreach childNo = nChildren
            %with ::CompiledModel.BlockHierarchyMap
                %assign childHierInfoIdx = ...
                    SignalHierLoggingInfo[hierInfoIdx].Children[childNo]
                %assign childSignalLabel = ...
                    SignalHierLoggingInfo[childHierInfoIdx].SignalName
            %endwith
            %assign nodeIdx = nodeLeafIdx[0]
            %assign leafIdx = nodeLeafIdx[1]
            %assign nodeIdx = %<nodeIdx> + 1
            %assign nodeName = "pAobHierarchyNode" + "%<nodeIdx>"
            void *%<nodeName> = %<nulldef>;
            %openfile statements
            rtwAobHierarchyCreateNode(...
                "%<childSignalLabel>", ...
                &%<nodeName>...
                );
            rtwAobHierarchyAddChild(%<parentNodeName>, %<nodeName>);
            %closefile statements
            %assign statementsBuffer = statementsBuffer + statements
            %assign signalName = ""
            %createrecord retValsLowerLevel  ...
                %<CreateVirtualBusHierarchyAndSignalProbeCollectionRecursion( ...
                block, ...
                system, ...
                nodeName, ...
                pSignalProbeCollectionName, ...
                childHierInfoIdx, ...
                dimsArrayName, ...
                signalName, ...
                decimation, ...
                maxDataPoints, ...
                nodeIdx, ...
                leafIdx ...
                )>
            %assign nodeLeafIdx = retValsLowerLevel.val
            %assign statementsBuffer = statementsBuffer + retValsLowerLevel.statements
            %undef retValsLowerLevel
        %endforeach
    %endif
    %assign statementsBuffer = STRING(statementsBuffer)
    %createrecord retVals {val nodeLeafIdx; statements statementsBuffer}
    %return retVals
%endfunction %% CreateVirtualBusHierarchyAndSignalProbeCollectionRecursion

%% Function: FixPt_Fix2DblConvParams ===============================================================
%% Abstract:
%%   A fixpoint to double conversion is completely characterized by three
%%   parameters according to the formula:
%%     ValueAsDouble = Slope * 2^Exp * ValueAsFixedPoint + Bias
%%   Given a fixed point data type, this function returns the three parameters
%%   Slope, Exp and Bias in a string array.
%%
%function FixPt_Fix2DblConvParams(outDT,inDT) void
    %if !FixPt_DataTypeIsDouble(outDT)
        %%START_ASSERT
        %assign errTxt = "Error: The argument outDT must be a double"
        %<LibReportFatalError(errTxt)>
        %%END_ASSERT
    %endif
    %%
    %if !FixPt_DataTypeIsFloat(inDT)
        %assign bitsPerChunk     = LargestIntegerNumBits
        %assign numOfChunk       = FixPt_NumChunks(inDT.RequiredBits)
        %assign isSigned         = inDT.IsSigned
    %else
        %% floating point and scaled double
        %% These next three members are not used in this case
        %assign bitsPerChunk     = 0
        %assign numOfChunk       = 0
        %assign isSigned         = 0
    %endif
    %assign fExp   = inDT.FixedExp - outDT.FixedExp
    %assign fSlope = CAST("Real",inDT.FracSlope) / CAST("Real",outDT.FracSlope)
    %assign bias   = ( CAST("Real",inDT.Bias) - CAST("Real",outDT.Bias) ) / CAST("Real",outDT.FracSlope)
    %assign retVectStr = ["%<bitsPerChunk>", "%<numOfChunk>", "%<isSigned>", "%<fSlope>", "%<fExp>", "%<bias>"]
    %return retVectStr
    %%
%endfunction  %% FixPt_Fix2DblConvParams

%% Function: Start =================================================================================
%% Abstract:
%%      If we are using the standard .mat file logging then write out
%%      call to create the data logging variable. In addition, if the scope
%%      is constant then we need to log the data once here.
%%
%function SetupRuntimeResources(block, system) Output
    %assign booleanType = LibGetDataTypeNameFromId(::CompiledModel.tSS_BOOLEAN)
    %assign charType = LibGetDataTypeNameFromId(::CompiledModel.tSS_CHAR)
    %assign intType = LibGetDataTypeNameFromId(::CompiledModel.tSS_INTEGER)
    %assign sigLogRapidAccel = ParamSettings.SigLogRapidAccel
    %if block.Type == "ToWorkspace" && ...
        (sigLogRapidAccel == 1 || sigLogRapidAccel == 2)
        %if sigLogRapidAccel == 1
            %return
        %elseif sigLogRapidAccel == 2
            %<StartSignalStreaming(block, system)>
            %return
        %endif
    %endif
    %if CodeFormat == "S-Function"
        %assign warnTxt = "ToWorkspace blocks not currently supported " ...
            "for S-Function code format.  Block disabled."
        %<LibBlockReportWarning(block, warnTxt)>
        %return
    %endif
    %%
    %if MatFileLogging != 0 && (TargetType == "RT" || isRSim)
        %assign name          = STRING(ParamSettings.VariableName)
        %if name == ""
            %return
        %endif
        %assign maxDataPoints = ParamSettings.MaxDataPoints[0]
        %assign decimation    = ParamSettings.Decimation[0]
        %assign symWidth      = LibBlockInputSignalSymbolicWidth(0)
        %assign nDims         = LibBlockInputSignalNumDimensions(0)
        %assign symDims       = LibBlockInputSignalSymbolicDimensions(0)
        %assign isVarDims     = LibGetIsInputPortVarDims(0) %%is dimension mode VarDims
        %assign sigDTypeId    = LibBlockInputSignalDataTypeId(0)
        %%
        %if (LibIsDataTypeLogSupported(sigDTypeId, TLC_TRUE) == TLC_FALSE)
            %assign warnTxt = "Unable to log data for this block " ...
                "because MAT-File logging is not supported for " ...
                "data type '%<LibGetDataTypeNameFromId(sigDTypeId)>'."
            %<LibBlockReportWarning(block, warnTxt)>
            %return
        %endif
        %%
        %assign sigDTypeEnum  = LibGetDataTypeEnumFromId(sigDTypeId)
        %assign logDTypeId    = SLibSigToLogDataType(sigDTypeId, tSS_DOUBLE)
        %assign logDTypeEnum  = LibGetDataTypeEnumFromId(logDTypeId)
        %assign cmplx         = LibBlockInputSignalIsComplex(0)
        %assign frameData     = ParamSettings.FrameData
        %assign logVar        = LibBlockPWork(LoggedData, "", "", 0)
        %assign ts            = LibBlockSampleTime(block)
        %assign nulldef       = SLibGetNullDefinitionFromTfl()
        %assign currSigDimsInitStr   = ""
        %assign currSigDimsSetStr    = ""
        %assign currSigDimsSizeStr   = ""
        %assign currSigDimsSize      = ConfigSet.TargetBitPerInt/8
        %assign currSigDimsSizeComma = ""

        %assign equalSign = LibGetDataInitEqualSign()
        %assign scalarTokens = LibGetScalarDataInitTokens()

        %%
        %if ParamSettings.SaveFormat == "Array"
            {
                %if nDims == 1
                    %<intType>  dimensions[1]%<equalSign>{%<symDims[0]>};
                %else
                    %assign dimsInit = "%<intType>  dimensions[%<nDims>]%<equalSign>{"
                    %foreach dimsIdx = nDims
                        %assign dimsInit = dimsInit + "%<symDims[dimsIdx]>"
                        %if dimsIdx != nDims-1
                            %assign dimsInit = dimsInit + ", "
                        %endif
                    %endforeach
                    %assign dimsInit = dimsInit + "};"
                    %<dimsInit>
                %endif
                %%
                %% For continguous, fixed-point datatype use an RTWLogDataTypeConvert
                %% object for converting from fixed-point to double before logging.
                %% The alternative is to create a local variable large enough to hold
                %% the converted data.  For some video signals, this variable becomes
                %% so large that the generated code seg-faults when attempting to
                %% allocate it.
                %%
                %if LibIsDataTypeFixpt(sigDTypeId) && ParamSettings.InputContiguous == "yes"
                    %assign typeQ              = "static "
                    %assign sigFixPtDType      = FixPt_GetDataTypeFromIndex(sigDTypeId)
                    %assign logFixPtDtype      = FixPt_GetDataTypeFromIndex(logDTypeId)
                    %assign sigDTypeConvParams = FixPt_Fix2DblConvParams(logFixPtDtype,sigFixPtDType)
                    %<typeQ> RTWLogDataTypeConvert rt_ToWksDataTypeConvert[]%<equalSign>{
                        {1, %<logDTypeEnum>, %<sigDTypeEnum>, %<sigDTypeConvParams[0]>, %<sigDTypeConvParams[1]>, ...
                            %<sigDTypeConvParams[2]>, %<sigDTypeConvParams[3]>, %<sigDTypeConvParams[4]>, %<sigDTypeConvParams[5]>}
                    };

                    %% "Array" format logging only supports fixed-size signal logging,
                    %% so set currSigDims and currSigDimsSize to NULL, and set logValDims
                    %% to NO_LOGVALDIMS
                    %<SLibGenLogVarCreateWithConvert(logVar, name, logDTypeEnum, ...
                        "rt_ToWksDataTypeConvert", 0, cmplx, ...
                        frameData, symWidth, nDims, "dimensions", "NO_LOGVALDIMS",...
                        nulldef, nulldef, maxDataPoints, decimation, ts, 1)>
                    if (%<logVar> == %<nulldef>) return;
                }
                %else
                    %% "Array" format logging only supports fixed-size signal logging,
                    %% so set currSigDims and currSigDimsSize to NULL, and set logValDims
                    %% to NO_LOGVALDIMS
                    %<SLibGenLogVarCreate(logVar, name, logDTypeEnum, 0, cmplx, ...
                        frameData, symWidth, nDims, "dimensions", "NO_LOGVALDIMS", ...
                        nulldef, nulldef, maxDataPoints, decimation, ts, 1)>

                    if (%<logVar> == %<nulldef>) return;
                }
                %endif
        %else %% Structure
            {
                %assign typeQ    = "static "
                %assign label    = ParamSettings.Label
                %%
                %<typeQ> %<intType>            rt_ToWksWidths[]        %<equalSign>{%<symWidth>};
                %<typeQ> %<intType>            rt_ToWksNumDimensions[] %<equalSign>{%<nDims>};
                %if nDims == 1
                    %<typeQ> %<intType>            rt_ToWksDimensions[]  %<equalSign>{%<symDims[0]>};

                    %if isVarDims
                        %% current signal dimensions
                        %assign currSigDims = SLibGetCurrentInputPortDimensions(0, 0)
                    %else
                        %% actually we don't care if the signal is fixed-size signal
                        %assign currSigDims = "rt_ToWksWidths[0]"
                    %endif
                    %assign currSigDimsInitStr = "%<typeQ> void *rt_ToWksCurrSigDims[]%<equalSign>{%<nulldef>};"
                    %assign currSigDimsSetStr = "rt_ToWksCurrSigDims[0] = &%<currSigDims>; \n"
                    %assign currSigDimsSizeStr = %<currSigDimsSize>
                %else
                    %assign dimsInit = "%<typeQ> %<intType>  rt_ToWksDimensions[]%<equalSign>{"
                    %assign currSigDimsInitStr = "%<typeQ> void *rt_ToWksCurrSigDims[]%<equalSign>{"
                    %foreach dimsIdx = nDims
                        %assign currSigDimsSizeStr = currSigDimsSizeStr + currSigDimsSizeComma + "%<currSigDimsSize>"
                        %assign currSigDimsSizeComma = ", "

                        %assign dimsInit = dimsInit + "%<symDims[dimsIdx]>"
                        %assign currSigDimsInitStr = currSigDimsInitStr + nulldef
                        %if isVarDims
                            %assign currSigDims = SLibGetCurrentInputPortDimensions(0, dimsIdx)
                        %else
                            %assign currSigDims = "rt_ToWksWidths[0]"
                        %endif
                        %assign currSigDimsSetStr = currSigDimsSetStr + ...
                            "rt_ToWksCurrSigDims[%<dimsIdx>] = &%<currSigDims>; \n"

                        %if dimsIdx != nDims-1
                            %assign dimsInit = dimsInit + ", "
                            %assign currSigDimsInitStr = currSigDimsInitStr + ", "
                        %endif
                    %endforeach
                    %assign dimsInit = dimsInit + "};"
                    %assign currSigDimsInitStr = currSigDimsInitStr + "};"
                    %<dimsInit>
                %endif
                %assign preprocessingFcnPtrsStr = nulldef
                %assign preprocessingFcnPtrsComma = ""
                %<typeQ> %<booleanType>        rt_ToWksIsVarDims[]     %<equalSign>{%<isVarDims>};
                %<currSigDimsInitStr>
                %<typeQ> %<intType>            rt_ToWksCurrSigDimsSize[]%<equalSign>{%<currSigDimsSizeStr>};
                %<typeQ> BuiltInDTypeId   rt_ToWksDataTypeIds[]   %<equalSign>{%<logDTypeEnum>};
                %<typeQ> %<intType>            rt_ToWksComplexSignals[]%<equalSign>{%<cmplx>};
                %<typeQ> %<intType>            rt_ToWksFrameData[]     %<equalSign>{%<frameData>};
                %<typeQ> RTWPreprocessingFcnPtr rt_ToWksLoggingPreprocessingFcnPtrs[]%<equalSign>\
                {
                    %<preprocessingFcnPtrsStr>
                };
                %assign label_escaped = FEVAL("coder.internal.getEscapedString", label)
                %<typeQ> const %<charType>     *rt_ToWksLabels[]       = {"%<STRING(label_escaped)>"};
                %if LibIsDataTypeFixpt(sigDTypeId) && ParamSettings.InputContiguous == "yes"
                    %assign sigFixPtDType = FixPt_GetDataTypeFromIndex(sigDTypeId)
                    %assign logFixPtDtype = FixPt_GetDataTypeFromIndex(logDTypeId)
                    %assign sigDTypeConvParams = FixPt_Fix2DblConvParams(logFixPtDtype,sigFixPtDType)
                    %<typeQ> RTWLogDataTypeConvert rt_ToWksDataTypeConvert[]%<equalSign>{
                        {1, %<logDTypeEnum>, %<sigDTypeEnum>, %<sigDTypeConvParams[0]>, %<sigDTypeConvParams[1]>, ...
                            %<sigDTypeConvParams[2]>, %<sigDTypeConvParams[3]>, %<sigDTypeConvParams[4]>, %<sigDTypeConvParams[5]>}
                    };

                    %<typeQ> RTWLogSignalInfo rt_ToWksSignalInfo      %<equalSign>{
                        1,
                        rt_ToWksWidths,
                        rt_ToWksNumDimensions,
                        rt_ToWksDimensions,
                        rt_ToWksIsVarDims,
                        rt_ToWksCurrSigDims,
                        rt_ToWksCurrSigDimsSize,
                        rt_ToWksDataTypeIds,
                        rt_ToWksComplexSignals,
                        rt_ToWksFrameData,
                        rt_ToWksLoggingPreprocessingFcnPtrs,
                        {rt_ToWksLabels},
                        %<nulldef>,
                        %<nulldef>,
                        %<nulldef>,
                        {%<nulldef>},
                        {%<nulldef>},
                        %<nulldef>,
                        rt_ToWksDataTypeConvert
                    };
                %else
                    %<typeQ> RTWLogSignalInfo rt_ToWksSignalInfo      %<equalSign>{
                        1,
                        rt_ToWksWidths,
                        rt_ToWksNumDimensions,
                        rt_ToWksDimensions,
                        rt_ToWksIsVarDims,
                        rt_ToWksCurrSigDims,
                        rt_ToWksCurrSigDimsSize,
                        rt_ToWksDataTypeIds,
                        rt_ToWksComplexSignals,
                        rt_ToWksFrameData,
                        rt_ToWksLoggingPreprocessingFcnPtrs,
                        {rt_ToWksLabels},
                        %<nulldef>,
                        %<nulldef>,
                        %<nulldef>,
                        {%<nulldef>},
                        {%<nulldef>},
                        %<nulldef>,
                        %<nulldef>
                    };
                %endif

                %assign blockPath = STRING(LibGetBlockPath(block))
                %assign blockPath_escaped = FEVAL("coder.internal.getEscapedString", blockPath)
                %<typeQ> const %<charType> rt_ToWksBlockName[]         %<scalarTokens[0]>"%<blockPath_escaped>"%<scalarTokens[1]>;

                %if isVarDims
                    /* set currSigDims field */
                    %<currSigDimsSetStr>
                %endif

                %assign logTime  = (ParamSettings.SaveFormat == "StructureWithTime")
                %<SLibGenStructLogVarCreate(logVar, name, logTime, maxDataPoints, ...
                    decimation, ts, "&rt_ToWksSignalInfo", "rt_ToWksBlockName")>
                if (%<logVar> == %<nulldef>) return;
            }
        %endif

    %elseif (IsModelReferenceSimTarget() && ParamSettings.SaveFormat == "Dataset" )
        %% Model Reference Simulation Target: Dataset Format
        if (!slIsRapidAcceleratorSimulating()) {

            %% Create dataset elements
            %<CreateDatasetVariable(block,system)>

            %% Constant-Time Output processed in Start
            %<logSample(block, system, -2)>

            %if (ParamSettings.SignalStreamingCapable == "off")
                %assign simS = RTMsGet(system, "MdlRefSfcnS")
                %assign blockPath = STRING(ParamSettings.LogBlockPath)
                %assign blockPath_escaped = FEVAL("coder.internal.getEscapedString", blockPath)
                if (ssIsRapidAcceleratorActive(%<simS>))
                {
                    slReportToWksNoRTWSupportForDataset(%<simS>,"%<blockPath_escaped>","Timeseries" );
                }
            %endif

        }

        %if (block.Type == "ToWorkspace" && ...
            ParamSettings.SignalStreamingCapable == "on")
            else {
                %<StartSignalStreaming(block, system)>
            }
        %endif
    %endif
%endfunction %% Start

%% Function: StartSignalStreaming ==================================================================
%% Abstract:
%%      Start callback using Signal Streamig infrastructure.
%function StartSignalStreaming(block, system)  Output
    %assign uintType = LibGetDataTypeNameFromId(::CompiledModel.tSS_UINTEGER)
    %assign nulldef = SLibGetNullDefinitionFromTfl()
    if (rt_GetOSigstreamManager() != %<nulldef>) {
        %if 0 < block.NumForEachLevels
            %assign scalarTokens = LibGetScalarDataInitTokens()
            %<uintType> numForEachLevels%<scalarTokens[0]>%<block.NumForEachLevels>%<scalarTokens[1]>;
            %<CreateDims(block.NumForEachLevels,block.ForEachDims,"forEachDims")>
        %endif
        %assign nInputPorts = block.NumDataInputPorts
        %if nInputPorts > 1
            %<StartSignalStreamingVirtualBus(block, system)>
        %else %% nInputPorts == 1
            %assign dTypeId = LibBlockInputSignalDataTypeId(0)
            %assign isNvBus = LibDataTypeIsBus(dTypeId)
            %assign hierInfoIdx = ParamSettings.HierInfoIndex[0]
            %if isNvBus || hierInfoIdx == -1
                %% hierInfoIdx == -1 means this is a non-bus signal
                %<StartSignalStreamingNonVirtualAob(block, system)>
            %else
                %<StartSignalStreamingVirtualBus(block, system)>
            %endif
        %endif
        %% Constant-Time Output processed in Start
        %<logSample(block, system, -2)>
    }
%endfunction %% StartSignalStreaming

%% Function: StartSignalStreamingNonVirtualAob =====================================================
%% Abstract:
%%      Start callback using Signal Streaming infrastructure for non-virtual AoB
%%      logging.
%function StartSignalStreamingNonVirtualAob(block, system)  Output
    {
        %createrecord retValsLowerLevel %<CreateAobHierarchy(block, system)>
        %assign pAobHierarchy = retValsLowerLevel.val
        %assign statementsBuffer = retValsLowerLevel.statements
        %undef retValsLowerLevel
        {
            %createrecord retValsLowerLevel %<CreateSignalProbeCollectionAob(block, system)>
            %assign pSignalProbeCollection = retValsLowerLevel.val
            %assign statementsBuffer = statementsBuffer + retValsLowerLevel.statements
            %undef retValsLowerLevel
            %openfile statements
            rtwSignalProbeCollectionSetAobHierarchy(...
                %<pSignalProbeCollection>, ...
                %<pAobHierarchy>...
                );
            %if 0 == block.NumForEachLevels
                rtwSignalProbeCollectionFinalizeMetaData(%<pSignalProbeCollection>);
            %else
                rtwSignalProbeCollectionFinalizeMetaDataForeach(%<pSignalProbeCollection>, numForEachLevels, forEachDims);
            %endif
            %<LibBlockPWork(SignalProbe, "", "", 0)> = %<pSignalProbeCollection>;

            %closefile statements
            %assign statementsBuffer = statementsBuffer + statements
            %<statementsBuffer>
        }
    }
%endfunction %% StartSignalStreamingNonVirtualAob


%% Prepare Signal descriptor, the root node, and calls function to
%% construct the node tree.
%function StartSlioNonVirtualBus(block, system, treeVector) Output
    {
        %assign dTypeId = LibBlockInputSignalDataTypeId(0)
        %if block.ParamSettings.BusDatatypeIdSpecifiedAtOutport > 0
            %assign dTypeId = block.ParamSettings.BusDatatypeIdSpecifiedAtOutport
        %endif

        %assign signalName = STRING(ParamSettings.ElementNames[0])
        %assign nChildren = LibDataTypeNumElements(dTypeId)
        %if ParamSettings.NumDims > 0
            %assign nDims = ParamSettings.NumDims
            %assign dims = ParamSettings.Dims
        %else
            %assign nDims = LibBlockInputSignalNumDimensions(0)
            %assign dims = LibBlockInputSignalDimensions(0)
        %endif
        %assign dimsArrayName = "aobDims"
        %<CreateDims(nDims, dims, dimsArrayName)>
        %assign hierInfoIdx = ParamSettings.HierInfoIndex[0]
        %with ::CompiledModel.BlockHierarchyMap
            %assign nChildren = SignalHierLoggingInfo[hierInfoIdx].NumChildren
        %endwith
        %assign root = "root"

        %assign isLinearInterp = ParamSettings.LinearInterpolation[0]

        %% Interpolation
        %assign interpMethod = ""
        %if isLinearInterp
            %assign interpolationMethod = "linear"
        %else
            %assign interpolationMethod = "zoh"
        %endif

        %% Sample Time
        %assign sampleTime = ParamSettings.SampleTimeLabels[0]
        %if IsModelReferenceSimTarget() && !MdlRefDisallowSampleTimeInheritance()
            %assign discreteInterval = 0
        %else
            %assign discreteInterval = ParamSettings.DiscreteInterval[0]
        %endif
        %assign stopTime = RTMGet("TFinal")

        %assign parentSignalName =  ...
            STRING(ParamSettings.ElementNames[0])

        %assign busSize = LibGetDataTypeSLSizeFromId(dTypeId)
        {
            %<CreateOffsets(dTypeId, nChildren)>
            rtwAddTopNVBusNode(...
                %<dTypeId>, ...
                "%<parentSignalName>", ...
                %<nChildren>, ...
                %<dimsArrayName>, ...
                %<nDims>, ...
                %<busSize>, ...
                offsets, ...
                "%<sampleTime>", ...
                %<discreteInterval>, ...
                %<stopTime>, ...
                treeVector);
        }
        %<getNVBusNodeLeaves(block, system, dTypeId, ...
            hierInfoIdx, interpolationMethod, sampleTime, ...
            discreteInterval, stopTime, treeVector)>
    }
%endfunction

%function addEnumLeafNode(...
    dTypeId, ...
    signalLabel, ...
    interpolationMethod, ...
    dimsArrayName, ...
    nDims, ...
    datatypeName, ...
    units, ...
    resolvedDatatypeName, ...
    sampleTime, ...
    discreteInterval, ...
    stopTime, ...
    treeVector) Output
    %assign charType = LibGetDataTypeNameFromId(::CompiledModel.tSS_CHAR)
    %assign intType = LibGetDataTypeNameFromId(::CompiledModel.tSS_INTEGER)

    %assign nEnums = FcnGetEnumTypeNumEnums(dTypeId)
    %assign allEnumValues = Vector(%<nEnums>) [0@%<nEnums>]
    %assign allEnumLabels = Vector(%<nEnums>) [""@%<nEnums>]

    %foreach enumIdx = nEnums
        %assign allEnumValues[enumIdx] = SLibGetEnumTypeValueFromIndex(dTypeId, enumIdx)
        %assign allEnumLabels[enumIdx] = SLibGetEnumTypeStringFromIndex(dTypeId, enumIdx)
    %endforeach

    %<OutputTypedVectorForDatasetVariable(nEnums, allEnumValues, intType, "enumValues")>
    %<OutputTypedVectorForDatasetVariable(nEnums, allEnumLabels, "%<charType>*",  "enumLabels")>

    rtwAddEnumLeafNode(...
        %<dTypeId>, ...
        "%<signalLabel>", ...
        "%<interpolationMethod>", ...
        %<dimsArrayName>, ...
        %<nDims>, ...
        "%<datatypeName>", ...
        "%<units>", ...
        "%<resolvedDatatypeName>", ...
        "%<sampleTime>", ...
        %<discreteInterval>, ...
        %<stopTime>, ...
        (const unsigned int*)enumValues, ...
        (const char**)enumLabels, ...
        %<nEnums>, ...
        %<treeVector>);
%endfunction  %%addEnumLeafNode

%% Adds nodes until gets to the leaves.
%function getNVBusNodeLeaves(...
    block, system, parentDatatypeId, ...
    parentHierinfoidx, ...
    interpolationMethod, sampleTime, discreteInterval, ...
    stopTime, treeVector) Output

    %assign dsMetadataKey = STRING(ParamSettings.DatasetMetadataKey)
    %assign nChildren = LibDataTypeNumElements(parentDatatypeId)
    %foreach childNo = nChildren

        %% Child datatype id
        %assign childDTypeId = LibDataTypeElementDataTypeId(...
            parentDatatypeId, childNo)

        %% Child signal/label name
        %with ::CompiledModel.BlockHierarchyMap
            %assign childHierInfoIdx = ...
                SignalHierLoggingInfo[parentHierinfoidx].Children[childNo]
            %assign childSignalLabel = ...
                SignalHierLoggingInfo[childHierInfoIdx].SignalName
        %endwith
        %% Child dimensions
        %assign childNDims = LibDataTypeElementNumDimensions(...
            parentDatatypeId, childNo)
        %assign childDims = LibDataTypeElementDimensions(...
            parentDatatypeId, childNo)
        %assign childDimsArrayName = "dims"
        %assign isChildNvBus = LibDataTypeIsBus(childDTypeId)

        %if isChildNvBus
            %% Child number of children
            %assign childNumberOfChildren = ...
                LibDataTypeNumElements(childDTypeId)
            {
                %<CreateDims(childNDims, childDims, childDimsArrayName)>
                %<CreateOffsets(childDTypeId, childNumberOfChildren)>
                %assign busSize = LibGetDataTypeSLSizeFromId(childDTypeId)
                rtwAddNVBusNode(...
                    %<childDTypeId>, ...
                    "%<childSignalLabel>", ...
                    %<childNumberOfChildren>, ...
                    %<childDimsArrayName>, ...
                    %<childNDims>, ...
                    %<busSize>, ...
                    offsets, ...
                    %<treeVector>);
            }
            %<getNVBusNodeLeaves(block, system, childDTypeId, ...
                childHierInfoIdx, interpolationMethod, sampleTime, ...
                discreteInterval, stopTime, treeVector)>

        %else
            %% Is the signal complex number
            %assign childComplex = LibDataTypeElementIsComplex(...
                parentDatatypeId, childNo)

            %% Datatype Name
            %assign datatypeName = getDatatypeNameFromId(childDTypeId)

            %% Signal unit
            %if dsMetadataKey == "DATASET_SIGNAL_LOGGING"
                %assign childUnits = LibDataTypeElementASCIIEscapedUnits(parentDatatypeId, childNo)
            %elseif block.ParamSettings.BusDatatypeIdSpecifiedAtOutport == -1 && ...
                block.ParamSettings.InheritSourceUnit == "no"
                %assign childUnits = ""
            %else
                %assign childUnits = getASCIIEscapedUnitsToLogFromBusObject(...
                    parentDatatypeId, childNo)
            %endif

            {
                %<CreateDims(childNDims, childDims, childDimsArrayName)>
                %if LibIsBuiltInDataType(childDTypeId)
                    rtwAddLeafNode(...
                        %<childDTypeId>, ...
                        "%<childSignalLabel>", ...
                        "%<interpolationMethod>", ...
                        %<childComplex>, ...
                        %<childDimsArrayName>, ...
                        %<childNDims>, ...
                        "%<datatypeName>", ...
                        "%<childUnits>", ...
                        "%<sampleTime>", ...
                        %<discreteInterval>, ...
                        %<stopTime>, ...
                        %<treeVector>);

                %elseif LibIsDataTypeFixpt(childDTypeId)
                    %assign curDT = FixPt_GetDataTypeFromIndex(childDTypeId)
                    %assign fxp_isSigned = curDT.IsSigned
                    %assign fxp_wordLen = curDT.RequiredBits
                    %assign fxp_slope = curDT.FracSlope
                    %assign fxp_fixedExp = curDT.FixedExp
                    %assign fxp_bias = curDT.Bias
                    rtwAddFixedPointLeafNode(...
                        %<childDTypeId>, ...
                        "%<childSignalLabel>", ...
                        "%<interpolationMethod>", ...
                        %<childComplex>, ...
                        %<childDimsArrayName>, ...
                        %<childNDims>, ...
                        "%<datatypeName>", ...
                        "%<childUnits>", ...
                        %<fxp_isSigned>, ...
                        %<fxp_wordLen>, ...
                        %<fxp_slope>, ...
                        %<fxp_fixedExp>, ...
                        %<fxp_bias>, ...
                        "%<sampleTime>", ...
                        %<discreteInterval>, ...
                        %<stopTime>, ...
                        %<treeVector>);

                    %% enum parameters
                %elseif LibIsEnumDataType(childDTypeId)
                    %assign storageID = -1
                    %if LibIsEnumTypeStoredAsInt(childDTypeId)
                        %assign storageID = 6 %% int32
                    %else
                        %assign storageID = LibGetEnumTypeStorageType(childDTypeId)
                    %endif
                    %assign resolvedDatatypeName = SLibGetMLDataTypeFromId(storageID)
                    %assign nEnums = FcnGetEnumTypeNumEnums(childDTypeId)
                    %assign allEnumValues = Vector(%<nEnums>) [0@%<nEnums>]
                    %assign allEnumLabels = Vector(%<nEnums>) [""@%<nEnums>]

                    %<addEnumLeafNode(...
                        childDTypeId, ...
                        childSignalLabel, ...
                        interpolationMethod, ...
                        childDimsArrayName, ...
                        childNDims, ...
                        datatypeName, ...
                        childUnits, ...
                        resolvedDatatypeName, ...
                        sampleTime, ...
                        discreteInterval, ...
                        stopTime, ...
                        treeVector)>

                    %% UNKNOWN types
                %else
                    %assert TLC_FALSE
                %endif
            }
        %endif
    %endforeach
    rtwPopNVBusNode(%<treeVector>);
%endfunction



%function StartSlioNVBusSignalDef(block, system, pworkAddress) Output
    %assign intType = LibGetDataTypeNameFromId(::CompiledModel.tSS_INTEGER)
    %assign uintType = LibGetDataTypeNameFromId(::CompiledModel.tSS_UINTEGER)
    %% Port type
    %assign dsMetadataKey = STRING(ParamSettings.DatasetMetadataKey)
    %assign porttype = 3 %% Noport
    %assign clientType = 10 %% Undefined
    %assign portOrder = 0
    %if dsMetadataKey ==  "DATASET_SIGNAL_LOGGING"
        %assign porttype = 1 %% Outport
        %assign clientType = 1 %% Antenna
        %assign datasetName = "tmp_raccel_logsout"
    %endif
    %if dsMetadataKey ==  "DATASET_OUTPORT_LOGGING"
        %assign porttype = 2   %% Import
        %assign clientType = 3  %% Outport
        %assign datasetName = "tmp_raccel_yout"
        %assign portOrder = ParamSettings.ElementOrder[0]
        if (rtwLogRootOutport(rtwGetPointerFromUniquePtr(rt_slioCatalogue())))
    %endif
    {
        %assign nulldef = SLibGetNullDefinitionFromTfl()
        %assign scalarTokens = LibGetScalarDataInitTokens()
        %% root
        %assign treeVector = "treeVector"
        void * treeVector%<scalarTokens[0]>rtwGetTreeVector()%<scalarTokens[1]>;

        %% ForEach dimensions
        %if 0 < block.NumForEachLevels
            %<uintType> numForEachLevels%<scalarTokens[0]>%<block.NumForEachLevels>%<scalarTokens[1]>;
            %<CreateDims(block.NumForEachLevels,block.ForEachDims,"forEachDims")>
            %assign foreachSubDims = "forEachDims, " + STRING(block.NumForEachLevels)
        %else
            %assign foreachSubDims = nulldef + ", 0"
        %endif
        %if IsModelReferenceSimTarget()
            %<intType> forEachMdlRefDimsArray[32];
            %<intType> forEachMdlRefDimsArraySize%<scalarTokens[0]>0%<scalarTokens[1]>;
            %% Get the dimensions of the foreach subsystem which contains the model block
            if(!slIsRapidAcceleratorSimulating()) {
                forEachMdlRefDimsArraySize = slSigLogGetForEachDimsForRefModel(...
                    %<RTMsGet(system, "MdlRefSfcnS")>, ...
                    forEachMdlRefDimsArray);
            }
            %assign foreachTopDims = "forEachMdlRefDimsArraySize ? (const %<uintType>*)forEachMdlRefDimsArray : " + nulldef + ", forEachMdlRefDimsArraySize"
        %else
            %assign foreachTopDims = nulldef + ", 0"
        %endif

        %<StartSlioNonVirtualBus(block, system, treeVector)>

        %% number of inport ports
        %assign numberOfInputPorts = 1

        %% Max points
        %assign maxpoints = ParamSettings.MaxDataPoints[0]

        %% Decimation
        %assign decimation = ParamSettings.Decimation[0]

        %% Propagated name
        %assign propagatedName = STRING(ParamSettings.PropagatedName)

        %% Logged name
        %assign loggedName = STRING(ParamSettings.ElementNames[0])

        {
            %% Block path
            %assign blockPath = STRING(ParamSettings.LogBlockPath)
            %if IsModelReferenceTarget()
                %assign mapInfo = RTMsGet(system, "DataMapInfo")
                char* pathToTopModel%<scalarTokens[0]>%<mapInfo>.mmi.InstanceMap.fullPath%<scalarTokens[1]>;
            %else
                char* pathToTopModel%<scalarTokens[0]>""%<scalarTokens[1]>;
            %endif

            %% Port index
            %assign logPortIdx = ParamSettings.ConnectedPortIdx[0]

            const void * signalDescriptor%<scalarTokens[0]>rtwGetSignalDescriptor (...
                treeVector, ...
                %<numberOfInputPorts>, ...
                %<porttype>,
            %<maxpoints>, ...
                %<decimation>, ...
                "%<loggedName>", ...
                "%<propagatedName>", ...
                pathToTopModel, ...
                "%<blockPath>", ...
                %<logPortIdx>, ...
                %<portOrder>, ...
                rtwGetPointerFromUniquePtr(rt_slioCatalogue()), ...
                %<foreachTopDims>, ...
                %<foreachSubDims>)%<scalarTokens[1]>;

            %if IsModelReferenceTarget()
                void * loggingInterval%<scalarTokens[0]>...
                    rtliGetLoggingInterval(%<RTMGet("MdlRefSfcnS")>->mdlInfo->rtwLogInfo)%<scalarTokens[1]>;
            %else
                void * loggingInterval%<scalarTokens[0]>...
                    rtliGetLoggingInterval(%<RTMsGet(system, "RootSS")>->mdlInfo->rtwLogInfo)%<scalarTokens[1]>;
            %endif
            void * accessor%<scalarTokens[0]>%<nulldef>%<scalarTokens[1]>;

            %<pworkAddress> = accessor;
        }
    %%}
    %if dsMetadataKey ==  "DATASET_OUTPORT_LOGGING"
    } else {
        %<pworkAddress> = %<nulldef>;
    }
    %else
    }
    %endif

%endfunction

%function StartSlioVirtualBusSignalDef(block, system, pworkAddress) Output
    %assign intType = LibGetDataTypeNameFromId(::CompiledModel.tSS_INTEGER)
    %assign uintType = LibGetDataTypeNameFromId(::CompiledModel.tSS_UINTEGER)

    %% Port type
    %assign dsMetadataKey = STRING(ParamSettings.DatasetMetadataKey)
    %assign porttype = 3 %% Noport
    %assign clientType = 10 %% Undefined
    %assign portOrder = 0
    %if dsMetadataKey ==  "DATASET_SIGNAL_LOGGING"
        %assign porttype = 1 %% Outport
        %assign clientType = 1 %% Antenna
        %assign datasetName = "tmp_raccel_logsout"
    %endif
    %if dsMetadataKey ==  "DATASET_OUTPORT_LOGGING"
        %assign porttype = 2   %% Import
        %assign clientType = 3  %% Outport
        %assign datasetName = "tmp_raccel_yout"
        %assign portOrder = ParamSettings.ElementOrder[0]
        if (rtwLogRootOutport(rtwGetPointerFromUniquePtr(rt_slioCatalogue())))
    %endif
    {
        %assign nulldef = SLibGetNullDefinitionFromTfl()
        %assign scalarTokens = LibGetScalarDataInitTokens()
        %% root
        %assign treeVector = "treeVector"
        %assign dTypeId = block.ParamSettings.BusDatatypeIdSpecifiedAtOutport

        void * treeVector%<scalarTokens[0]>rtwGetTreeVector()%<scalarTokens[1]>;

        %% ForEach dimensions
        %if 0 < block.NumForEachLevels
            %<uintType> numForEachLevels%<scalarTokens[0]>%<block.NumForEachLevels>%<scalarTokens[1]>;
            %<CreateDims(block.NumForEachLevels,block.ForEachDims,"forEachDims")>
            %assign foreachSubDims = "forEachDims, " + STRING(block.NumForEachLevels)
        %else
            %assign foreachSubDims = nulldef + ", 0"
        %endif
        %if IsModelReferenceSimTarget()
            %<intType> forEachMdlRefDimsArray[32];
            %<intType> forEachMdlRefDimsArraySize%<scalarTokens[0]>0%<scalarTokens[1]>;
            %% Get the dimensions of the foreach subsystem which contains the model block
            if(!slIsRapidAcceleratorSimulating()) {
                forEachMdlRefDimsArraySize = slSigLogGetForEachDimsForRefModel(...
                    %<RTMsGet(system, "MdlRefSfcnS")>, ...
                    forEachMdlRefDimsArray);
            }
            %assign foreachTopDims = "forEachMdlRefDimsArraySize ? (const %<uintType>*)forEachMdlRefDimsArray : " + nulldef + ", forEachMdlRefDimsArraySize"
        %else
            %assign foreachTopDims = nulldef + ", 0"
        %endif

        %<StartSlioVirtualBus(block, system, dTypeId, treeVector)>

        %% number of inport ports
        %assign numberOfInputPorts = block.NumDataInputPorts

        %% Max points
        %assign maxpoints = ParamSettings.MaxDataPoints[0]

        %% Decimation
        %assign decimation = ParamSettings.Decimation[0]

        %% Propagated name
        %assign propagatedName = STRING(ParamSettings.PropagatedName)

        %% Logged name
        %assign loggedName = STRING(ParamSettings.ElementNames[0])

        {
            %% Block path
            %assign blockPath = STRING(ParamSettings.LogBlockPath)
            %if IsModelReferenceTarget()
                %assign mapInfo = RTMsGet(system, "DataMapInfo")
                char* pathToTopModel%<scalarTokens[0]>%<mapInfo>.mmi.InstanceMap.fullPath%<scalarTokens[1]>;
            %else
                char* pathToTopModel%<scalarTokens[0]>""%<scalarTokens[1]>;
            %endif

            %% Port index
            %assign logPortIdx = ParamSettings.ConnectedPortIdx[0]

            const void * signalDescriptor%<scalarTokens[0]>rtwGetSignalDescriptor(...
                treeVector, ...
                %<numberOfInputPorts>, ...
                %<porttype>,
            %<maxpoints>, ...
                %<decimation>, ...
                "%<loggedName>", ...
                "%<propagatedName>", ...
                pathToTopModel, ...
                "%<blockPath>", ...
                %<logPortIdx>, ...
                %<portOrder>, ...
                rtwGetPointerFromUniquePtr(rt_slioCatalogue()), ...
                %<foreachTopDims>, ...
                %<foreachSubDims>)%<scalarTokens[1]>;

            %if IsModelReferenceTarget()
                void * loggingInterval%<scalarTokens[0]>...
                    rtliGetLoggingInterval(%<RTMGet("MdlRefSfcnS")>->mdlInfo->rtwLogInfo)%<scalarTokens[1]>;
            %else
                void * loggingInterval%<scalarTokens[0]>...
                    rtliGetLoggingInterval(%<RTMsGet(system, "RootSS")>->mdlInfo->rtwLogInfo)%<scalarTokens[1]>;
            %endif
            void * accessor%<scalarTokens[0]>%<nulldef>%<scalarTokens[1]>;

            %<pworkAddress> = accessor;
        }
    %%}
    %if dsMetadataKey ==  "DATASET_OUTPORT_LOGGING"
    } else {
        %<pworkAddress> = %<nulldef>;
    }
    %else
    }
    %endif

%endfunction



%% Prepare Signal descriptor, the root node, and calls function to
%% construct the node tree.
%function StartSlioVirtualBus(block, system, parentDatatypeId, treeVector) Output
    {
        %assign signalName = STRING(ParamSettings.ElementNames[0])
        %assign hierInfoIdx = ParamSettings.HierInfoIndex[0]
        %with ::CompiledModel.BlockHierarchyMap
            %assign nChildren = SignalHierLoggingInfo[hierInfoIdx].NumChildren
        %endwith
        %assign isLinearInterp = ParamSettings.LinearInterpolation[0]

        %% Interpolation
        %assign interpMethod = ""
        %if isLinearInterp
            %assign interpolationMethod = "linear"
        %else
            %assign interpolationMethod = "zoh"
        %endif

        rtwAddTopBusNode(...
            "%<signalName>", ...
            %<nChildren>, ...
            treeVector);
        %assign portIdx = 0
        %with ::CompiledModel.BlockHierarchyMap
            %foreach childNo = nChildren
                %assign childHierInfoIdx = SignalHierLoggingInfo[hierInfoIdx].Children[childNo]
                %assign portIdx = getBusNodeLeaves(block, system, childHierInfoIdx, ...
                    portIdx, parentDatatypeId, childNo, treeVector)
            %endforeach
        %endwith
        rtwPopNVBusNode(%<treeVector>);
    }
%endfunction

%% Adds nodes until gets to the leaves.
%function getBusNodeLeaves(...
    block, system, hierInfoIdx, ...
    portIdx, parentDatatypeId, currentChildNo, treeVector) Output

    %with ::CompiledModel.BlockHierarchyMap
        %assign sigName = SignalHierLoggingInfo[hierInfoIdx].SignalName
        %assign nChildren = SignalHierLoggingInfo[hierInfoIdx].NumChildren
        %assign dsMetadataKey = STRING(ParamSettings.DatasetMetadataKey)
        %if nChildren > 0
            rtwAddBusNode(...
                "%<sigName>", ...
                %<nChildren>, ...
                treeVector);

            %if parentDatatypeId != -1
                %assign currentDatatypeId = LibDataTypeElementDataTypeId(...
                    parentDatatypeId, currentChildNo)
            %else
                %assign currentDatatypeId = -1
            %endif

            %foreach childNo = nChildren
                %assign childHierInfoIdx = SignalHierLoggingInfo[hierInfoIdx].Children[childNo]
                %assign portIdx = getBusNodeLeaves(block, system, childHierInfoIdx, ...
                    portIdx, currentDatatypeId, childNo, treeVector)
            %endforeach
            rtwPopNVBusNode(%<treeVector>);
            %return portIdx
        %else
            %% Signal unit
            %if parentDatatypeId != -1
                %% Bus is specifed at the outport
                %if dsMetadataKey == "DATASET_SIGNAL_LOGGING"
                    %assign units = LibDataTypeElementASCIIEscapedUnits(parentDatatypeId, currentChildNo)
                %else
                    %assign units = getASCIIEscapedUnitsToLogFromBusObject(...
                        parentDatatypeId, currentChildNo)
                %endif
            %else
                %if dsMetadataKey == "DATASET_SIGNAL_LOGGING"
                    %assign units = LibBlockInputSignalASCIIEscapedUnitExpr(portIdx)
                %elseif block.ParamSettings.InheritSourceUnit == "yes"
                    %assign units = getASCIIEscapedUnitsToLog(portIdx)
                %else
                    %assign units = ""
                %endif
            %endif
            %<getLeafNode(block, system, portIdx, sigName, units, treeVector)>
            %return portIdx + 1
        %endif
    %endwith
%endfunction


%function getLeafNode(block, system, portIdx, sigName, units, treeVector) Output
    {
        %% Data type registration
        %assign portDT = LibBlockInputSignalDataTypeId(portIdx)
        %assign dtID = LibGetDataTypeIdAliasedThruToFromId(portDT)

        %% Complexity
        %assign complexity = LibBlockInputSignalIsComplex(portIdx)

        %% Interpolation
        %assign isLinearInterp = ParamSettings.LinearInterpolation[portIdx]
        %% Interpolation
        %assign interpMethod = ""
        %if isLinearInterp
            %assign interpMethod = "linear"
        %else
            %assign interpMethod = "zoh"
        %endif

        %% Dimensions
        %assign nDims = LibBlockInputSignalNumDimensions(portIdx)
        %assign dims = LibBlockInputSignalDimensions(portIdx)

        %% Sample Time
        %assign sampleTime = ParamSettings.SampleTimeLabels[portIdx]
        %if IsModelReferenceSimTarget() && !MdlRefDisallowSampleTimeInheritance()
            %assign discreteInterval = 0
        %else
            %assign discreteInterval = ParamSettings.DiscreteInterval[portIdx]
        %endif
        %assign stopTime = RTMGet("TFinal")

        %<addLeafNode(...
            dtID,...
            dims, ...
            nDims, ...
            complexity, ...
            interpMethod, ...
            sigName, ...
            units, ...
            sampleTime, ...
            discreteInterval, ...
            stopTime, ...
            treeVector)>
    }
%endfunction


%function addLeafNode(...
    dtID, dims, nDims, complexity, ...
    interpMethod, sigName, sigUnits, ...
    sampleTime, discreteInterval, stopTime, treeVector) Output
    %assign datatypeName = getDatatypeNameFromId(dtID)

    %assign arrayName = "dims"
    %<CreateDims(nDims, dims, arrayName)>

    %if LibIsBuiltInDataType(dtID)
        rtwAddLeafNode(...
            %<dtID>, ...
            "%<sigName>", ...
            "%<interpMethod>", ...
            %<complexity>, ...
            (unsigned int*)dims,  ...
            %<nDims>, ...
            "%<datatypeName>", ...
            "%<sigUnits>", ...
            "%<sampleTime>", ...
            %<discreteInterval>, ...
            %<stopTime>, ...
            %<treeVector>);

    %elseif LibIsDataTypeFixpt(dtID)
        %assign curDT = FixPt_GetDataTypeFromIndex(dtID)
        %assign fxp_isSigned = curDT.IsSigned
        %assign fxp_wordLen = curDT.RequiredBits
        %assign fxp_slope = curDT.FracSlope
        %assign fxp_fixedExp = curDT.FixedExp
        %assign fxp_bias = curDT.Bias
        rtwAddFixedPointLeafNode(...
            %<dtID>, ...
            "%<sigName>", ...
            "%<interpMethod>", ...
            %<complexity>, ...
            (unsigned int*)dims,  ...
            %<nDims>, ...
            "%<datatypeName>", ...
            "%<sigUnits>", ...
            %<fxp_isSigned>, ...
            %<fxp_wordLen>, ...
            %<fxp_slope>, ...
            %<fxp_fixedExp>, ...
            %<fxp_bias>, ...
            "%<sampleTime>", ...
            %<discreteInterval>, ...
            %<stopTime>, ...
            %<treeVector>);

        %% enum parameters
    %elseif LibIsEnumDataType(dtID)
        %assign storageID = -1
        %if LibIsEnumTypeStoredAsInt(dtID)
            %assign storageID = 6 %% int32
        %else
            %assign storageID = LibGetEnumTypeStorageType(dtID)
        %endif
        %assign resolvedDatatypeName = SLibGetMLDataTypeFromId(storageID)
        %<addEnumLeafNode(...
            dtID, ...
            sigName, ...
            interpMethod, ...
            "(unsigned int*)dims",  ...
            nDims, ...
            datatypeName, ...
            sigUnits, ...
            resolvedDatatypeName, ...
            sampleTime, ...
            discreteInterval, ...
            stopTime, ...
            treeVector)>

        %% UNKNOWN types
    %else
        %assign warnTxt = "User-defined data types not supported for logging to mat-file."
        %<LibBlockReportWarning(block, warnTxt)>
    %endif
%endfunction %%addLeafNode

%function StartSlioSignalDef(block, system, pworkAddress) Output
    %assign intType = LibGetDataTypeNameFromId(::CompiledModel.tSS_INTEGER)
    %assign uintType = LibGetDataTypeNameFromId(::CompiledModel.tSS_UINTEGER)
    %% Port type
    %assign dsMetadataKey = STRING(ParamSettings.DatasetMetadataKey)
    %assign porttype = 3 %% Noport
    %assign clientType = 10 %% Undefined
    %assign portOrder = 0
    %if dsMetadataKey ==  "DATASET_SIGNAL_LOGGING"
        %assign porttype = 1 %% Outport
        %assign clientType = 1 %% Antenna
        %assign datasetName = "tmp_raccel_logsout"
    %endif
    %if dsMetadataKey ==  "DATASET_OUTPORT_LOGGING"
        %assign porttype = 2   %% Import
        %assign clientType = 3  %% Outport
        %assign datasetName = "tmp_raccel_yout"
        %assign portOrder = ParamSettings.ElementOrder[0]
        if (rtwLogRootOutport(rtwGetPointerFromUniquePtr(rt_slioCatalogue())))
    %endif
    {
        %assign elementName = STRING(ParamSettings.ElementNames[0])
        %assign isLinearInterp = ParamSettings.LinearInterpolation[0]

        %% Interpolation
        %assign interpMethod = ""
        %if isLinearInterp
            %assign interpMethod = "linear"
        %else
            %assign interpMethod = "zoh"
        %endif

        %% Signal Dimensions
        %assign dimsArrayPrefix = "signalDimensions"
        %if ParamSettings.NumDims > 0
            %assign nDims = ParamSettings.NumDims
            %assign dims = ParamSettings.Dims
        %else
            %assign nDims = LibBlockInputSignalNumDimensions(0)
            %assign dims = LibBlockInputSignalDimensions(0)
        %endif
        %% also creates the dimsarray
        %assign dimsArrayName = ...
            "%<CreateDimsArray(nDims, dims, dimsArrayPrefix, 0)>"

        %% Data is complex
        %assign complexity = LibBlockInputSignalIsComplex(0)

        %% Units
        %if dsMetadataKey ==  "DATASET_SIGNAL_LOGGING"
            %assign units = LibBlockInputSignalASCIIEscapedUnitExpr(0)
        %elseif block.ParamSettings.InheritSourceUnit == "yes"
            %assign units = getASCIIEscapedUnitsToLog(0)
        %else
            %assign units = block.ParamSettings.OutportUnits
        %endif

        %% Datatype Name
        %assign datatypeName = getDatatypeNameFromId(LibBlockInputSignalDataTypeId(0))

        %% Max points
        %assign maxpoints = ParamSettings.MaxDataPoints[0]

        %% Decimation
        %assign decimation = ParamSettings.Decimation[0]

        %% Port index
        %assign logPortIdx = ParamSettings.ConnectedPortIdx[0]

        %% Propagated name
        %assign propagatedName = STRING(ParamSettings.PropagatedName)

        %% Logged Name
        %assign loggedName = STRING(ParamSettings.ElementNames[0])
        %assign sigName = STRING(ParamSettings.SignalNames[0])

        %assign scalarTokens = LibGetScalarDataInitTokens()

        %% Block path
        %assign blockPath = STRING(ParamSettings.LogBlockPath)
        %if IsModelReferenceTarget()
            %assign mapInfo = RTMsGet(system, "DataMapInfo")
            char* pathToTopModel%<scalarTokens[0]>%<mapInfo>.mmi.InstanceMap.fullPath%<scalarTokens[1]>;
        %else
            char* pathToTopModel%<scalarTokens[0]>""%<scalarTokens[1]>;
        %endif

        %% number of inport ports
        %assign numberOfInputPorts = 1

        %% Sample Time
        %assign sampleTime = ParamSettings.SampleTimeLabels[0]
        %if IsModelReferenceSimTarget() && !MdlRefDisallowSampleTimeInheritance()
            %assign discreteInterval = 0
        %else
            %assign discreteInterval = ParamSettings.DiscreteInterval[0]
        %endif

        %assign dTypeId = LibBlockInputSignalDataTypeId(0)
        %assign nulldef = SLibGetNullDefinitionFromTfl()
        %assign treeVector = "treeVector"
        void * treeVector%<scalarTokens[0]>rtwGetTreeVector()%<scalarTokens[1]>;
        void * loggingInterval%<scalarTokens[0]>%<nulldef>%<scalarTokens[1]>;
        void * accessor%<scalarTokens[0]>%<nulldef>%<scalarTokens[1]>;

        %% ForEach dimensions
        %if 0 < block.NumForEachLevels
            %<uintType> numForEachLevels%<scalarTokens[0]>%<block.NumForEachLevels>%<scalarTokens[1]>;
            %<CreateDims(block.NumForEachLevels,block.ForEachDims,"forEachDims")>
            %assign foreachSubDims = "forEachDims, " + STRING(block.NumForEachLevels)
        %else
            %assign foreachSubDims = nulldef + ", 0"
        %endif
        %if IsModelReferenceSimTarget()
            %<intType> forEachMdlRefDimsArray[32];
            %<intType> forEachMdlRefDimsArraySize%<scalarTokens[0]>0%<scalarTokens[1]>;
            %% Get the dimensions of the foreach subsystem which contains the model block
            if(!slIsRapidAcceleratorSimulating()) {
                forEachMdlRefDimsArraySize = slSigLogGetForEachDimsForRefModel(...
                    %<RTMsGet(system, "MdlRefSfcnS")>, ...
                    forEachMdlRefDimsArray);
            }
            %assign foreachTopDims = "forEachMdlRefDimsArraySize ? (const %<uintType>*)forEachMdlRefDimsArray : " + nulldef + ", forEachMdlRefDimsArraySize"
        %else
            %assign foreachTopDims = nulldef + ", 0"
        %endif

        %if LibIsBuiltInDataType(dTypeId)
            rtwAddLeafNode(...
                %<dTypeId>, ...
                "%<sigName>", ...
                "%<interpMethod>", ...
                %<complexity>, ...
                %<dimsArrayName>, ...
                %<nDims>, ...
                "%<datatypeName>", ...
                "%<units>", ...
                "%<sampleTime>", ...
                %<discreteInterval>, ...
                %<RTMGet("TFinal")>, ...
                %<treeVector>);

        %elseif LibIsDataTypeFixpt(dTypeId)
            %assign curDT = FixPt_GetDataTypeFromIndex(dTypeId)
            %assign fxp_isSigned = curDT.IsSigned
            %assign fxp_wordLen = curDT.RequiredBits
            %assign fxp_slope = curDT.FracSlope
            %assign fxp_fixedExp = curDT.FixedExp
            %assign fxp_bias = curDT.Bias
            rtwAddFixedPointLeafNode(...
                %<dTypeId>, ...
                "%<elementName>", ...
                "%<interpMethod>", ...
                %<complexity>, ...
                %<dimsArrayName>, ...
                %<nDims>, ...
                "%<datatypeName>", ...
                "%<units>", ...
                %<fxp_isSigned>, ...
                %<fxp_wordLen>, ...
                %<fxp_slope>, ...
                %<fxp_fixedExp>, ...
                %<fxp_bias>, ...
                "%<sampleTime>", ...
                %<discreteInterval>, ...
                %<RTMGet("TFinal")>, ...
                %<treeVector>);

            %% enum parameters
        %elseif LibIsEnumDataType(dTypeId)
            %assign storageID = -1
            %if LibIsEnumTypeStoredAsInt(dTypeId)
                %assign storageID = 6 %% int32
            %else
                %assign storageID = LibGetEnumTypeStorageType(dTypeId)
            %endif
            %assign resolvedDatatypeName = SLibGetMLDataTypeFromId(storageID)
            %<addEnumLeafNode(...
                dTypeId, ...
                elementName, ...
                interpMethod, ...
                dimsArrayName, ...
                nDims, ...
                datatypeName, ...
                units, ...
                resolvedDatatypeName, ...
                sampleTime, ...
                discreteInterval, ...
                RTMGet("TFinal"), ...
                treeVector)>

            %% UNKNOWN types
        %else
            %assert TLC_FALSE
        %endif

        {
            const void * signalDescriptor%<scalarTokens[0]>...
                rtwGetSignalDescriptor (...
                treeVector, ...
                %<numberOfInputPorts>, ...
                %<porttype>,
            %<maxpoints>, ...
                %<decimation>, ...
                "%<loggedName>", ...
                "%<propagatedName>", ...
                pathToTopModel, ...
                "%<blockPath>", ...
                %<logPortIdx>,
            %<portOrder>, ...
                rtwGetPointerFromUniquePtr(rt_slioCatalogue()), ...
                %<foreachTopDims>, ...
                %<foreachSubDims>)%<scalarTokens[1]>;

            %if IsModelReferenceTarget()
                loggingInterval = ...
                    rtliGetLoggingInterval(%<RTMGet("MdlRefSfcnS")>->mdlInfo->rtwLogInfo);
            %else
                loggingInterval = ...
                    rtliGetLoggingInterval(%<RTMsGet(system, "RootSS")>->mdlInfo->rtwLogInfo);
            %endif
            %<pworkAddress> = accessor;
        }
    %%}
    %if dsMetadataKey ==  "DATASET_OUTPORT_LOGGING"
    } else {
        %<pworkAddress> = %<nulldef>;
    }
    %else
    }
    %endif

%endfunction

%% Function: get the datatype name form datatype id.
%function getDatatypeNameFromId(datatypeId)

    %if LibIsBuiltInDataType(datatypeId)
        %assign typeName = SLibGetMLDataTypeFromId(datatypeId)
        %if typeName == "boolean"
            %assign typeName = "logical"
        %endif
        %assign isFxp = TLC_FALSE
        %% fixpt parameters
    %elseif LibIsDataTypeFixpt(datatypeId)
        %assign curDT = FixPt_GetDataTypeFromIndex(datatypeId)
        %if fxpIsDataTypeFixPt(curDT)
            %assign typeName = "fixed-point"
            %assign isFxp    = TLC_TRUE
        %elseif fxpIsDataTypeScaledDouble(curDT)
            %assign typeName = "scaled-double"
            %assign isFxp    = TLC_TRUE
        %elseif FixPt_DataTypeIsDouble(curDT)
            %assign typeName = "double"
            %assign isFxp = TLC_FALSE
        %elseif FixPt_DatatTypeIsSingle(curDT)
            %assign typeName = "single"
            %assign isFxp = TLC_FALSE
        %elseif FixPt_DatatTypeIsBoolean(curDT)
            %assign typeName = "logical"
            %assign isFxp = TLC_FALSE
        %else
            %assert TLC_FALSE
        %endif
        %assign fxp_isSigned = curDT.IsSigned
        %assign fxp_wordLen = curDT.RequiredBits
        %assign fxp_slope = curDT.FracSlope
        %assign fxp_fixedExp = curDT.FixedExp
        %assign fxp_bias = curDT.Bias
        %% enum parameters
    %elseif LibIsEnumDataType(datatypeId)
        %assign typeName = LibGetDataTypeNameFromId(datatypeId)
        %assign isFxp = TLC_FALSE
        %% UNKNOWN types
    %else
        %assert TLC_FALSE
    %endif
    %return typeName
%endfunction


%% Function: StartSignalStreamingVirtualBus ========================================================
%% Abstract:
%%      Start callback using Signal Streamig infrastructure for virtual bus
%%      logging.
%function StartSignalStreamingVirtualBus(block, system)  Output
    %assign statementsBuffer = " "
    %assign nulldef = SLibGetNullDefinitionFromTfl()
    {
        %createrecord retValsLowerLevel ...
            %<CreateVirtualBusHierarchyAndSignalProbeCollection(block, system)>
        %assign pSignalProbeCollectionName = retValsLowerLevel.val
        %assign statementsBuffer = statementsBuffer + retValsLowerLevel.statements
        %undef retValsLowerLevel
        %openfile statements
        %if 0 == block.NumForEachLevels
            rtwSignalProbeCollectionFinalizeMetaData(%<pSignalProbeCollectionName>);
        %else
            rtwSignalProbeCollectionFinalizeMetaDataForeach(%<pSignalProbeCollectionName>, numForEachLevels, forEachDims);
        %endif
        %<LibBlockPWork(SignalProbe, "", "", 0)> = %<pSignalProbeCollectionName>;
        %closefile statements
        %assign statementsBuffer = statementsBuffer + statements
        %<statementsBuffer>
    }
%endfunction %% StartSignalStreamingVirtualBus

%function outputTranspose(block, system, matrixToTranspose) Output
    %assign ipRecord = FcnGetInputPortRecord(0)
    %assign dataRecord = SLibGetSourceRecord(ipRecord, 0)
    %assign freeStatement = ""
    %if !ISEMPTY(dataRecord) && ISFIELD(dataRecord, "PreprocessingFcnPtr")
        %assign cgTypeIdx = LibCGTypeFixedPointBaseType(dataRecord.CGTypeIdx)
        %assign baseName = SLibGetTypeNameFromCGType(cgTypeIdx)
        %assign isComplex = LibCGTypeIsComplex(dataRecord.CGTypeIdx)
        %assign complexMul = 1
        %if isComplex
            %assign complexMul = 2
        %endif
        %assign numEls = LibGetRecordSymbolicWidth(dataRecord)
        %assign preprocessingPtr = dataRecord.PreprocessingFcnPtr
        %assign scalarTokens = LibGetScalarDataInitTokens()
        {
            void* rt_curData%<scalarTokens[0]>malloc(sizeof(%<baseName>) * %<complexMul> * %<numEls>)%<scalarTokens[1]>;
            %<preprocessingPtr>(rt_curData, %<matrixToTranspose>);
            %assign freeStatement = "free( rt_curData );"
    %endif
    %return freeStatement
%endfunction

%% Function: Outputs ===============================================================================
%% Abstract:
%%      If we are using the standard .mat file logging and the to workspace
%%      block is not constant, then write out a call to log data. If the
%%      sample time of the to workspace is triggered, then we log whenever we
%%      are called, otherwise we log only in major time steps. Constant
%%      sample are handled in the Start function.
%%
%%      For dataset format in model reference in multitasking, OutputsForTID
%%      should be called instead of this to handle port-based sample times.
%%
%function Outputs(block, system) Output
    %if block.Type == "ToWorkspace" && EXISTS(ParamSettings) && ...
        (ParamSettings.SigLogRapidAccel == 1 || ParamSettings.SigLogRapidAccel == 2)
        %if ParamSettings.LogPowerDownEvent == "no"
            %<logSingletasking(block, system)>
        %endif
    %elseif  (MatFileLogging != 0) ...
        && (TargetType == "RT" || isRSim) ...
        && (CodeFormat != "S-Function") ...
        && (ParamSettings.VariableName != "")

        %assign arrayFormat = (ParamSettings.SaveFormat == "Array")
        %assign logVar = LibBlockPWork(LoggedData, "", "", 0)
        %assign sigDTypeId    = LibBlockInputSignalDataTypeId(0)
        %assign nulldef       = SLibGetNullDefinitionFromTfl()
        %%
        %if (LibIsDataTypeLogSupported(sigDTypeId, TLC_TRUE) == TLC_FALSE)
            %return
        %endif

        %assign scalarTokens = LibGetScalarDataInitTokens()

        %%
        %assign logDTypeId = SLibSigToLogDataType(sigDTypeId, tSS_DOUBLE)
        %if ParamSettings.InputContiguous == "yes" && ...
            LibIsDataTypeBuiltinOrFixpt(sigDTypeId)
            %assign inpPtr = "%<LibBlockInputSignalAddr(0, "", "", 0)>"
            %if arrayFormat
                %if ::isRSim
                    %if isRSimWithSolverModule
                        if (%<RTMGet("LogOutput")>) {
                    %else
                        if (%<RTMIs("MajorTimeStep")>) {
                    %endif
                %elseif (SLibIsERTCodeFormat()) && (NumContStates > 0)
                    if (%<RTMIs("MajorTimeStep")>) {
                %endif



                %% Array format logging supports fixed-size signal logging only
                %assign isVarDims = 0
                %if ::isRAccel
                    {
                        double locTime%<scalarTokens[0]>%<checkAndGetDESEngTimeSource(block)>%<scalarTokens[1]>;
                        %% Check interval-logging rapid-accel graphical-toWorkspace top-model.
                        %assign simS = RTMsGet(system, "RootSS")
                        %if !LibUseOldFilePackagingInfrastructure()
                            %% slSimTgtSigstreamRTW.h needs rtwtypes.h
                            %<SLibAddArrayToNonSharedIncludes(SLibCoderBasicTypesFilenames())>
                        %endif
                        %<SLibAddToNonSharedIncludes("simtarget/slSimTgtSigstreamRTW.h")>
                        %<SLibAddToNonSharedIncludes("simtarget/slSimTgtSlioCoreRTW.h")>
                        %<SLibAddToNonSharedIncludes("simtarget/slSimTgtSlioClientsRTW.h")>
                        %<SLibAddToNonSharedIncludes("simtarget/slSimTgtSlioSdiRTW.h")>
                        if (rtwTimeInLoggingInterval(
                        rtliGetLoggingInterval(%<simS>->mdlInfo->rtwLogInfo),
                        locTime))
                        {
                            %<SLibGenLogVarUpdate("(LogVar*) (%<logVar>)", inpPtr, isVarDims)>
                        }
                    }
                %else
                    %assign freeStatement = outputTranspose(block, system, inpPtr)
                    %if freeStatement != ""
                        %<SLibGenLogVarUpdate("(LogVar*) (%<logVar>)", "rt_curData", isVarDims)>
                        %<freeStatement>
                    }
                    %else
                        %<SLibGenLogVarUpdate("(LogVar*) (%<logVar>)", inpPtr, isVarDims)>
                    %endif
                %endif


                %if ::isRSim || ((SLibIsERTCodeFormat()) && (NumContStates > 0))
                }
                %endif
            %else
                %if ParamSettings.SaveFormat == "StructureWithTime"
                    {
                        double locTime%<scalarTokens[0]>%<checkAndGetDESEngTimeSource(block)>%<scalarTokens[1]>;
                        %assign timePtr = "&locTime"
                %else
                    %assign timePtr = nulldef
                %endif

                %if ::isRSim
                    %if isRSimWithSolverModule
                        if (%<RTMGet("LogOutput")>) {
                    %else
                        if (%<RTMIs("MajorTimeStep")>) {
                    %endif
                %elseif (SLibIsERTCodeFormat()) && (NumContStates > 0)
                    if (%<RTMIs("MajorTimeStep")>) {
                %endif

                %if ::isRAccel
                    {
                        %assign simS = RTMsGet(system, "RootSS")
                        %if ParamSettings.SaveFormat != "StructureWithTime"
                            double locTime%<scalarTokens[0]>%<checkAndGetDESEngTimeSource(block)>%<scalarTokens[1]>;
                        %endif
                        %% Check interval-logging rapid-accel graphical-toWorkspace top-model.
                        %if !LibUseOldFilePackagingInfrastructure()
                            %% slSimTgtSigstreamRTW.h needs rtwtypes.h
                            %<SLibAddArrayToNonSharedIncludes(SLibCoderBasicTypesFilenames())>
                        %endif
                        %<SLibAddToNonSharedIncludes("simtarget/slSimTgtSigstreamRTW.h")>
                        %<SLibAddToNonSharedIncludes("simtarget/slSimTgtSlioCoreRTW.h")>
                        %<SLibAddToNonSharedIncludes("simtarget/slSimTgtSlioClientsRTW.h")>
                        %<SLibAddToNonSharedIncludes("simtarget/slSimTgtSlioSdiRTW.h")>
                        if (rtwTimeInLoggingInterval(
                        rtliGetLoggingInterval(%<simS>->mdlInfo->rtwLogInfo),
                        locTime))
                        {
                            %<SLibGenStructLogVarUpdate(logVar, timePtr, inpPtr)>
                        }
                    }
                %else
                    %assign freeStatement = outputTranspose(block, system, inpPtr)
                    %if freeStatement != ""
                        %<SLibGenStructLogVarUpdate(logVar, timePtr, "rt_curData")>
                        %<freeStatement>
                    }
                    %else
                        %<SLibGenStructLogVarUpdate(logVar, timePtr, inpPtr)>
                    %endif
                %endif
                %if ::isRSim || ((SLibIsERTCodeFormat()) && (NumContStates > 0))
                }
                %endif
                %if ParamSettings.SaveFormat == "StructureWithTime"
                }
                %endif
            %endif
        %else %% input is not contiguous or datatype is not built-in/fixpt
            {
                %assign symWidth = LibBlockInputSignalSymbolicWidth(0)
                %assign isSymbolic = "%<LibBlockInputSignalWidth(0)>" == symWidth
                %assign cmplx = LibBlockInputSignalIsComplex(0)
                %if LibIsBuiltInDataType(sigDTypeId)
                    %assign dtype = LibBlockInputSignalDataTypeName(0,"")
                %else
                    %if !cmplx
                        %assign dtype = LibGetDataTypeNameFromId(logDTypeId)
                    %else
                        %assign dtype = LibGetDataTypeComplexNameFromId(logDTypeId)
                    %endif
                %endif
                %<dtype> u[%<symWidth>];

                %if !isSymbolic
                    %% use ROLL REGIONS if it has no symbolic.
                    %% TODO: can be improved in R2016a if TLC ROLL REGIONS support symbolic dims.
                    %assign rollVars = ["U"]
                    %roll idx = RollRegions, lcv = RollThreshold, block, "Roller", rollVars
                        %assign input = LibBlockInputSignal(0,"",lcv,idx)
                        %assign rhs = LibGetIndexedElement("u", %<symWidth>, lcv, idx)
                        %if LibIsBuiltInDataType(sigDTypeId)
                            %<rhs> = %<input>;
                        %else
                            %% investigate when this code will be covered.

                            %assign convertBetweenFcn = ...
                                LibConvertBetweenTLCFcnName(sigDTypeId)
                            %if LibConvertBetweenTLCFcnFile(sigDTypeId) != ""
                                %include "%<LibConvertBetweenTLCFcnFile(sigDTypeId)>"
                            %endif
                            %assign status = LibComplexConvertBetweenForSrcId(...
                                logDTypeId, sigDTypeId, cmplx, input, "", rhs)
                            %if status != 1
                                %%START_ASSERT
                                %assign errTxt = ...
                                    "Error: funcion %<convertBetweenFcn> doesn't support " ...
                                    "converting the input signal to type double."
                                %<LibBlockReportFatalError(block, errTxt)>
                                %%END_ASSERT
                            %endif
                        %endif
                    %endroll
                %else
                    %%
                    %% use for loop with symbolic upper bound.
                    %% this code doesn't work with discontiguous inputs.
                    %%
                    %if SIZE(LibRollRegions2StartEndMatrix(RollRegions), 1) > 1
                        %assign errMsg = "To workspace block taking symbolic matrix input cannot handle discontiguous inputs"
                        %<LibReportFatalError(errMsg)>
                    %endif

                    %assign loopCode = SLibEmitForLoopCounterCode(symWidth, "i")
                    {
                        %<loopCode[0]>
                        %<loopCode[1]> {
                            %assign input = LibBlockInputSignal(0, "i", "", 0)
                            %assign rhs = LibGetIndexedElement("u", INT32MAX, "i", 0)
                            %if LibIsBuiltInDataType(sigDTypeId)
                                %<rhs> = %<input>;
                            %else
                                %assign convertBetweenFcn = ...
                                    LibConvertBetweenTLCFcnName(sigDTypeId)
                                %if LibConvertBetweenTLCFcnFile(sigDTypeId) != ""
                                    %include "%<LibConvertBetweenTLCFcnFile(sigDTypeId)>"
                                %endif
                                %assign status = LibComplexConvertBetweenForSrcId(...
                                    logDTypeId, sigDTypeId, cmplx, input, "", rhs)
                                %if status != 1
                                    %%START_ASSERT
                                    %assign errTxt = ...
                                        "Error: funcion %<convertBetweenFcn> doesn't support " ...
                                        "converting the input signal to type double."
                                    %<LibBlockReportFatalError(block, errTxt)>
                                    %%END_ASSERT
                                %endif
                            %endif
                        }
                    }
                %endif

                %if arrayFormat
                    %if ::isRSim
                        %if isRSimWithSolverModule
                            if (%<RTMGet("LogOutput")>) {
                        %else
                            if (%<RTMIs("MajorTimeStep")>) {
                        %endif
                    %elseif (SLibIsERTCodeFormat()) && (NumContStates > 0)
                        if (%<RTMIs("MajorTimeStep")>) {
                    %endif

                    %% Array format logging supports fixed-size signal logging only
                    %assign isVarDims = 0
                    %<SLibGenLogVarUpdate("(LogVar*)%<logVar>", "u", isVarDims)>
                    %if ::isRSim || ((SLibIsERTCodeFormat()) && (NumContStates > 0))
                    }
                    %endif
                %else
                    %if ParamSettings.SaveFormat == "StructureWithTime"
                        {
                            double locTime%<scalarTokens[0]>%<checkAndGetDESEngTimeSource(block)>%<scalarTokens[1]>;
                            %assign timePtr = "&locTime"
                    %else
                        %assign timePtr = nulldef
                    %endif

                    %if ::isRSim
                        %if isRSimWithSolverModule
                            if (%<RTMGet("LogOutput")>) {
                        %else
                            if (%<RTMIs("MajorTimeStep")>) {
                        %endif
                    %elseif (SLibIsERTCodeFormat()) && (NumContStates > 0)
                        if (%<RTMIs("MajorTimeStep")>) {
                    %endif

                    %<SLibGenStructLogVarUpdate(logVar, timePtr, "u")>
                    %if ::isRSim || ((SLibIsERTCodeFormat()) && (NumContStates > 0))
                    }
                    %endif
                    %if ParamSettings.SaveFormat == "StructureWithTime"
                    }
                    %endif
                %endif
            }
        %endif
    %elseif Accelerator
        /* Call into Simulink for To Workspace */
        %<SLibCallBlockInSimulink(system, block, "SS_CALL_MDL_OUTPUTS")>

    %elseif (IsModelReferenceSimTarget() && ParamSettings.SaveFormat == "Dataset" )
        %% Model Reference - Dataset format. This is called for Singletasking
        %% or blocks with 1 sample time. For multitasking, port-based sample
        %% times, OutputsForTID will be called
        %<logSingletasking(block, system)>

    %endif

%endfunction %% Outputs

%% Function: OutputsForTID =========================================================================
%% Abstract:
%%      Update dataset format logged data for multitasking. In
%%      non-dataset formats, the block has single sample time and therefore we
%%      call the standard Outputs.
%%
%function OutputsForTID(block, system, tid) Output
    %if (EXISTS(ParamSettings) && ParamSettings.SaveFormat == "Dataset" )
        %<logMultitasking(block, system, tid)>
    %else
        %<Outputs(block, system)>
    %endif
%endfunction %% OutputsForTID

%% Function: OutputTypedVectorForDatasetVariable ===================================================
%% Abstract:
%%   Output the dimension vector for creating a dataset variable
%%
%function OutputTypedVectorForDatasetVariable(nValues, values, valueType, varname) Output
    %assign charType = LibGetDataTypeNameFromId(::CompiledModel.tSS_CHAR)
    %assign equalSign = LibGetDataInitEqualSign()
    %if nValues == 1
        %if valueType == "%<charType>*"
            %<valueType> %<varname>[1]%<equalSign>{"%<values[0]>"};
        %else
            %<valueType> %<varname>[1]%<equalSign>{%<values[0]>};
        %endif
    %else
        %assign valuesInit = "%<valueType> %<varname>[%<nValues>]%<equalSign>{"
        %foreach valuesIdx = nValues
            %if valueType == "%<charType>*"
                %assign valuesInit = valuesInit + "\"%<values[valuesIdx]>\""
            %else
                %assign valuesInit = valuesInit + "%<values[valuesIdx]>"
            %endif
            %if valuesIdx != nValues-1
                %assign valuesInit = valuesInit + ", "
            %endif
        %endforeach
        %assign valuesInit = valuesInit + "};"
        %<valuesInit>
    %endif
%endfunction %% OutputTypedVectorForDatasetVariable


%% Function: GetDataTypeStrForDatasetVariable ======================================================
%% Abstract:
%%   Get the datatype string for the given datatype for use in creating a
%%   dataset variable
%%
%function GetDataTypeStrForDatasetVariable(sigDTypeId, simS) Output
    %% ENUM data types
    %assign scalarTokens = LibGetScalarDataInitTokens()
    %if LibIsEnumDataType(sigDTypeId)
        %assign dtName = LibGetDataTypeNameFromId(sigDTypeId)
        DTypeId dtId%<scalarTokens[0]>ssGetDataTypeId(%<simS>, "%<dtName>")%<scalarTokens[1]>;
        if(dtId == INVALID_DTYPE_ID) return;
        %assign dtStr = "dtId"

        %% FIXED POINT data types
    %elseif LibIsDataTypeFixpt(sigDTypeId)
        %assign curDT = FixPt_GetDataTypeFromIndex(sigDTypeId)
        DTypeId dtId%<scalarTokens[0]>ssGetDataTypeId(%<simS>, "%<curDT.DataTypeName>")%<scalarTokens[1]>;
        if(dtId == INVALID_DTYPE_ID) return;
        %assign dtStr = "dtId"

        %% BUILT-IN data types
    %elseif LibIsBuiltInDataType(sigDTypeId)
        %assign dtStr = LibGetDataTypeEnumFromId(sigDTypeId)

        %% UNKNOWN types
    %else
        %assign errTxt = ...
            "User-defined data types not supported for model reference simulation logging."
        %<LibReportFatalError(errTxt)>
    %endif

    %return dtStr
%endfunction %% OutputDimsVectorForDatasetVariable

%% Function: GetInterpolationString ================================================================
%% Abstract:
%%   Get the string for linear interpolation
%%
%function GetInterpolationString(isLinearInterp)
    %assert(isLinearInterp == 0 || isLinearInterp == 1)
    %assign interpStr = "SS_LINEAR_INTERPOLATION"
    %if %<isLinearInterp> == 0
        %assign interpStr = "SS_ZOH_INTERPOLATION"
    %endif

    %return interpStr
%endfunction %% GetInterpolationString

%% Function: CallAddTimeseriesForDataset ===========================================================
%% Abstract:
%%   Generate a call to slSigLogAddTimeseriesDescription
%%
%function CallAddTimeseriesForDataset(simS, sigDTypeId, cmplx, nDims, dims,...
    isLinearInterp, sigName, units) Output
    %assign intType = LibGetDataTypeNameFromId(::CompiledModel.tSS_INTEGER)
    %assign interpStr = GetInterpolationString(isLinearInterp)

    {
        %% Dimensions vector
        %assign dimsVarName = "dimensions"
        %<OutputTypedVectorForDatasetVariable(nDims, dims, intType, dimsVarName)>

        %assign dtStr = GetDataTypeStrForDatasetVariable(sigDTypeId, simS)

        %% Construct the timeseries description
        slSigLogAddTimeseriesDescription(%<simS>,
        &pElementDesc,
        &pDatasetDesc,
        %<sigName>,
        %<nDims>,
        %<dimsVarName>,
        %<dtStr>,
        %<cmplx>,
        %<interpStr>,
        "%<units>");
    }
%endfunction %% CallAddTimeseriesForDataset

%% Function: CreateDatasetVariable =================================================================
%% Abstract:
%%   Create the necessary variables for dataset format logging for model
%%   reference simulation.
%%
%function CreateDatasetVariable(block, system) Output
    %assign intType = LibGetDataTypeNameFromId(::CompiledModel.tSS_INTEGER)
    %assign uintType = LibGetDataTypeNameFromId(::CompiledModel.tSS_UINTEGER)

    %% Settings common to all ports
    %assign simS          = RTMsGet(system, "MdlRefSfcnS")
    %assign blockPath     = STRING(ParamSettings.LogBlockPath)
    %assign maxDataPoints = ParamSettings.MaxDataPoints[0]
    %assign decimation    = ParamSettings.Decimation[0]
    %assign busHierIdx    = ParamSettings.HierInfoIndex[0]
    %assign dsMetadataKey = STRING(ParamSettings.DatasetMetadataKey)
    %assign nulldef       = SLibGetNullDefinitionFromTfl()

    { %% Open bracket for dataset creation
    %% Construct dataset description
    %assign mapInfo = RTMsGet(system, "DataMapInfo")
    void *pDatasetDesc;
    %if dsMetadataKey ==  "DATASET_SIGNAL_LOGGING" || ...
        dsMetadataKey ==  "DATASET_OUTPORT_LOGGING"
        %assign dsName = nulldef
    %else
        %assign dsName = "\"" + STRING(ParamSettings.VariableName) + "\""
    %endif
    %if 0 < block.NumForEachLevels
        %assign scalarTokens = LibGetScalarDataInitTokens()
        %<uintType> numForEachLevels%<scalarTokens[0]>%<block.NumForEachLevels>%<scalarTokens[1]>;
        %<CreateDims(block.NumForEachLevels,block.ForEachDims,"forEachDims")>
    %endif
    _ssLoggerCreateDatasetDescriptWithMMI(%<simS>,
    &%<mapInfo>.mmi,
    0,
    %<nulldef>,
    %<dsName>,
    &pDatasetDesc);

    %% Get the number of elements to add - buses are always logged as 1 element
    %if busHierIdx < 0
        %assign numElements = block.NumDataInputPorts
    %else
        %assign numElements = 1
    %endif

    %% Iterate over number of elements
    %assign portIdx = 0
    %assign busName = ""
    %assign propName = STRING(ParamSettings.PropagatedName)

    %foreach elementIdx = numElements
        {
            %% Element name
            %assign elName = STRING(ParamSettings.ElementNames[elementIdx])

            %% Logged port index
            %if ParamSettings.ConnectedPortIdx[0] == 0
                %assign logPortIdx = portIdx + 1
            %else
                %assign logPortIdx = ParamSettings.ConnectedPortIdx[0]
            %endif

            %assign sigDTypeId = LibGetDataTypeIdAliasedThruToForNonBusDtype(LibBlockInputSignalDataTypeId(portIdx))

            %if LibDataTypeIsBus(sigDTypeId)
                %assert (busName == "")
                %assert (numElements == 1)

                %assign busName = LibGetDataTypeSLNameFromId(sigDTypeId)

                %% Dimensions vector
                %assign nDims       = LibBlockInputSignalNumDimensions(portIdx)
                %assign dims        = LibBlockInputSignalDimensions(portIdx)
                %assign dimsVarName = "dimensions"
                %<OutputTypedVectorForDatasetVariable(nDims, dims, intType, dimsVarName)>

                %assign isLinearInterp = ParamSettings.LinearInterpolation[portIdx]
                %assign interpStr = GetInterpolationString(isLinearInterp)

                slSigLogAddElementDescriptionForBus(%<simS>,
                &pDatasetDesc,
                %<busHierIdx>,
                "%<busName>",
                "%<elName>",
                "%<propName>",
                "%<blockPath>",
                %<logPortIdx>,
                %<maxDataPoints>,
                %<decimation>,
                %<nDims>,
                %<dimsVarName>,
                %<interpStr>);

                %assign portIdx = portIdx + 1
            %else
                %assign blockPath_escaped = FEVAL("coder.internal.getEscapedString", blockPath)
                %% Construct the element description
                void *pValuesDesc;
                void *pElementDesc;
                ssLoggerCreateBusValuesDescription(%<simS>, %<busHierIdx>, &pValuesDesc);
                ssLoggerAddSignalDescriptionWithValuesDescription(%<simS>,
                &pDatasetDesc,
                "%<elName>",
                "%<propName>",
                "%<blockPath_escaped>",
                %<logPortIdx>,
                %<maxDataPoints>,
                %<decimation>,
                &pValuesDesc,
                &pElementDesc);

                %% Determine how many signals are in this element
                %if busHierIdx < 0
                    %assign numSignals = 1
                %else
                    %assign numSignals = block.NumDataInputPorts
                %endif

                %% Iterate over all signals
                %foreach signalIdx = numSignals
                    %assert ! LibDataTypeIsBus(sigDTypeId)

                    %assign cmplx          = LibBlockInputSignalIsComplex(portIdx)
                    %assign nDims          = LibBlockInputSignalNumDimensions(portIdx)
                    %assign dims           = LibBlockInputSignalDimensions(portIdx)
                    %assign isLinearInterp = ParamSettings.LinearInterpolation[portIdx]

                    %% Signal name for non-bus signals
                    %if busHierIdx < 0
                        %assign sigName = "\"" + STRING(ParamSettings.SignalNames[portIdx]) + "\""
                    %else
                        %assign sigName = nulldef
                    %endif

                    %% Get signal type of each port.
                    %assign sigDTypeId = LibGetDataTypeIdAliasedThruToForNonBusDtype(LibBlockInputSignalDataTypeId(portIdx))

                    %% Get Units for each port
                    %assign units = getASCIIEscapedUnitsToLog(portIdx)

                    %<CallAddTimeseriesForDataset(simS, sigDTypeId, cmplx, nDims, dims, isLinearInterp, sigName, units)>

                    %assign portIdx = portIdx + 1
                %endforeach %% signalIdx
            %endif
        }
    %endforeach %% elementIdx

    %% Store elements in Pwork vector. Note that ssDatasetCreateFromDescpt will
    %% set ALL elements in the pwork vector, not just index 0.
    %assign pwork = LibBlockPWork(LoggedData, "", "", 0)

    %if 0 < block.NumForEachLevels
        if (pDatasetDesc) {
            slmrSetForeachDimensions(pDatasetDesc, numForEachLevels, forEachDims);
        }
    %endif


    %% Construct dataset and elements from description
    %if busName == ""
        ssLoggerCreateElementFromDescription(%<simS>, &pDatasetDesc, &%<pwork>);
    %else
        ssLoggerCreateElementFromDescriptionForBus(%<simS>, &pDatasetDesc, "%<busName>", &%<pwork>, %<nulldef>, 0);
    %endif

} %% Close bracket for dataset creation

%endfunction %% CreateDatasetVariable

%% Function: Terminate =============================================================================
%% Abstract:
%%      Terminate callback is used only with Signal Streaming infrastructure.
%%
%function Terminate(block, system) Output
    %if block.Type == "ToWorkspace" && EXISTS(ParamSettings)
        %if ParamSettings.LogPowerDownEvent == "yes"
            %<logSingletasking(block, system)>
        %endif

        %if ParamSettings.SigLogRapidAccel == 1 || ...
            ParamSettings.SigLogRapidAccel == 2
            %if ParamSettings.SigLogRapidAccel == 1
                %return
            %elseif ParamSettings.SigLogRapidAccel == 2
                %<TerminateSignalStreaming(block, system)>
                %return
            %endif
        %endif

        %if IsModelReferenceSimTarget() && ...
            ParamSettings.SignalStreamingCapable == "on" && ...
            ParamSettings.SaveFormat == "Dataset"
            if (slIsRapidAcceleratorSimulating()) {
                %<TerminateSignalStreaming(block, system)>
            }
        %endif
    %endif
%endfunction %% Terminate

%% Function: TerminateSignalStreaming ==============================================================
%% Abstract:
%%      Terminate callback used with Signal Streaming infrastructure.
%%
%function TerminateSignalStreaming(block, system) Output
    %assign nulldef = SLibGetNullDefinitionFromTfl()
    if (rt_GetOSigstreamManager() != %<nulldef>) {
        %assign scalarTokens = LibGetScalarDataInitTokens()
        void *pSignalProbeCollection%<scalarTokens[0]>(void *)%<LibBlockPWork(SignalProbe,"","",0)>%<scalarTokens[1]>;
        rtwSignalProbeCollectionDestroyInstance(pSignalProbeCollection);
    }
%endfunction %% TerminateSignalStreamingAob

%% [EOF] towks.tlc
